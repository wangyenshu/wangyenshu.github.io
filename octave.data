encoding=utf-8
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acosd (@var{x})
## Compute the inverse cosine in degrees for each element of @var{x}.
## @seealso{cosd, acos}
## @end deftypefn

function y = acosd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = acos (x) .* 180 ./ pi;

endfunction


%!assert (acosd (0:0.1:1), 180/pi * acos (0:0.1:1), -10*eps)

%!error <Invalid call> acosd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acot (@var{x})
## Compute the inverse cotangent in radians for each element of @var{x}.
## @seealso{cot, acotd}
## @end deftypefn

function y = acot (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = atan (1 ./ x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! x = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
%! v = [pi/6, pi/4, pi/3, pi/2, -pi/3, -pi/4, -pi/6];
%! assert (acot (x), v, sqrt (eps));

%!error <Invalid call> acot ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acotd (@var{x})
## Compute the inverse cotangent in degrees for each element of @var{x}.
## @seealso{cotd, acot}
## @end deftypefn

function y = acotd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = atand (1 ./ x);

endfunction


%!assert (acotd (0:10:90), 180/pi * acot (0:10:90), -10*eps)

%!error <Invalid call> acotd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acoth (@var{x})
## Compute the inverse hyperbolic cotangent of each element of @var{x}.
## @seealso{coth}
## @end deftypefn

function y = acoth (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = atanh (1 ./ x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! v = -i*[pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6];
%! x = i*[rt3, 1, rt3/3, -rt3/3, -1, -rt3];
%! assert (acoth (x), v, sqrt (eps));

%!error <Invalid call> acoth ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acsc (@var{x})
## Compute the inverse cosecant in radians for each element of @var{x}.
## @seealso{csc, acscd}
## @end deftypefn

function y = acsc (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = asin (1 ./ x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! v = [pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6];
%! x = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
%! assert (acsc (x), v, sqrt (eps));

%!error <Invalid call> acsc ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acscd (@var{x})
## Compute the inverse cosecant in degrees for each element of @var{x}.
## @seealso{cscd, acsc}
## @end deftypefn

function y = acscd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = acsc (x) .* 180 ./ pi;

endfunction


%!assert (acscd (0:10:90), 180/pi * acsc (0:10:90), -10*eps)

%!error <Invalid call> acscd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} acsch (@var{x})
## Compute the inverse hyperbolic cosecant of each element of @var{x}.
## @seealso{csch}
## @end deftypefn

function y = acsch (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = asinh (1 ./ x);

endfunction


%!test
%! v = [pi/2*i, -pi/2*i];
%! x = [-i, i];
%! assert (acsch (x), v, sqrt (eps));

%!error <Invalid call> acsch ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} asec (@var{x})
## Compute the inverse secant in radians for each element of @var{x}.
## @seealso{sec, asecd}
## @end deftypefn

function y = asec (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = acos (1 ./ x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! v = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
%! x = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
%! assert (asec (x), v, sqrt (eps));

%!error <Invalid call> asec ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} asecd (@var{x})
## Compute the inverse secant in degrees for each element of @var{x}.
## @seealso{secd, asec}
## @end deftypefn

function y = asecd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = asec (x) .* 180 ./ pi;

endfunction


%!assert (asecd (0:10:90), 180/pi * asec (0:10:90), -10*eps)

%!error <Invalid call> asecd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} asech (@var{x})
## Compute the inverse hyperbolic secant of each element of @var{x}.
## @seealso{sech}
## @end deftypefn

function y = asech (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = acosh (1 ./ x);

endfunction


%!testif ; ! ismac ()
%! v = [0, pi*i];
%! x = [1, -1];
%! assert (asech (x), v, sqrt (eps));

%!test <*52627>
%! ## Same test code as above, but intended only for test statistics on Mac.
%! ## Mac trig/hyperbolic functions have huge tolerances.
%! if (! ismac ()), return; endif
%! v = [0, pi*i];
%! x = [1, -1];
%! assert (asech (x), v, sqrt (eps));

%!error <Invalid call> asech ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} asind (@var{x})
## Compute the inverse sine in degrees for each element of @var{x}.
## @seealso{sind, asin}
## @end deftypefn

function y = asind (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = asin (x) .* 180 ./ pi;

endfunction


%!assert (asind (0:0.1:1), 180/pi * asin (0:0.1:1), -10*eps)

%!error <Invalid call> asind ()
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} atan2d (@var{y}, @var{x})
## Compute atan (@var{y} / @var{x}) in degrees for corresponding elements
## from @var{y} and @var{x}.
## @seealso{tand, atan2}
## @end deftypefn

function retval = atan2d (y, x)

  if (nargin != 2)
    print_usage ();
  endif

  retval = 180 ./ pi .* atan2 (y, x);

endfunction


%!assert (atan2d (-1:.1:1, 1:-.1:-1),
%!        180/pi * atan2 (-1:.1:1, 1:-.1:-1), -10*eps)

%!error <Invalid call> atan2d ()
%!error <Invalid call> atan2d (1)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} atand (@var{x})
## Compute the inverse tangent in degrees for each element of @var{x}.
## @seealso{tand, atan}
## @end deftypefn

function y = atand (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 180 ./ pi .* atan (x);

endfunction


%!assert (atand (0:10:90), 180/pi * atan (0:10:90), -10*eps)

%!error <Invalid call> atand ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} cosd (@var{x})
## Compute the cosine for each element of @var{x} in degrees.
##
## The function is more accurate than @code{cos} for large values of @var{x}
## and for multiples of 90 degrees (@code{@var{x} = 90 + 180*n} with n an
## integer) where @code{cosd} returns 0 rather than a small value on the order
## of eps.
## @seealso{acosd, cos}
## @end deftypefn

function y = cosd (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    error ("cosd: X must be numeric");
  endif

  ## Advance phase by 90 degrees to transform sin to cos and use sind().
  y = sind (x + 90);

endfunction


%!assert (cosd (10:20:360), cos ([10:20:360] * pi/180), 5*eps)
%!assert (cosd ([-270, -90, 90, 270]) == 0)
%!assert (cosd ([-360, -180, 0, 180, 360]), [1, -1, 1, -1, 1])
%!assert (cosd ([-Inf, NaN, +Inf, 0]), [NaN, NaN, NaN, 1])
%!assert (cosd (+23) == cosd (-23))
%!assert (cosd (1e6), 0.17364817766693033, 5*eps)
%!assert (cosd (90 + 180i), -i*sinh (pi))
%!assert (cosd (1e6 + 180i), 2.01292156189451577 + 11.3732880565446539i, -eps)

%!error <Invalid call> cosd ()
%!error <X must be numeric> cosd ("abc")
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{y} =} cospi (@var{x})
## Compute cosine (@var{x} * pi) for each element of @var{x} accurately.
##
## The ordinary @code{cos} function uses IEEE floating point numbers and may
## produce results that are very close (within a few eps) of the correct
## value, but which are not exact.  The @code{cospi} function is more accurate
## and returns 0 exactly for half-integer values of @var{x} (e.g., @dots{},
## -3/2, -1/2, 1/2, 3/2, @dots{}), and +1/-1 for integer values.
##
## Example @*
## comparison of @code{cos} and @code{cospi} for half-integer values of @var{x}
##
## @example
## @group
## cos ([-3/2, -1/2, 1/2, 3/2] * pi)
## @result{}
##      -1.8370e-16   6.1232e-17   6.1232e-17  -1.8370e-16
##
## cospi ([-3/2, -1/2, 1/2, 3/2])
## @result{}
##        0   0   0   0
## @end group
## @end example
##
## @seealso{sinpi, cos}
## @end deftypefn

function y = cospi (x)

  if (nargin < 1)
    print_usage ();
  endif

  ## Advance phase by pi/2 so that algorithm from sinpi can be used.
  ## Wrap integer multiples so that new domain is [-1, 1).
  x = mod (x - 0.5, 2) - 1;

  ## Integer multiples of pi must be exactly zero.
  x(x == -1) = 0;

  y = sin (x * pi);

endfunction


%!assert (cospi ([-3/2, -1/2, 1/2, 3/2]) == 0)
%!assert (cospi ([-2, -1, 0, 1, 2]), [1, -1, 1, -1, 1])
%!assert (cospi (100 + [0.1:0.1:0.9]), cos ([0.1:0.1:0.9]*pi), 2*eps (100))

%!error <Invalid call> cospi ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} cot (@var{x})
## Compute the cotangent for each element of @var{x} in radians.
## @seealso{acot, cotd, coth}
## @end deftypefn

function y = cot (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ tan (x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
%! v = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
%! assert (cot (x), v, sqrt (eps));

%!error <Invalid call> cot ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} cotd (@var{x})
## Compute the cotangent for each element of @var{x} in degrees.
## @seealso{acotd, cot}
## @end deftypefn

function y = cotd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ tand (x);

endfunction


%!assert (cotd (10:10:80), cot (pi*[10:10:80]/180), -10*eps)
%!assert (cotd ([0, 180, 360]) == Inf)
%!assert (cotd ([90, 270]) == 0)

%!error <Invalid call> cotd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} coth (@var{x})
## Compute the hyperbolic cotangent of each element of @var{x}.
## @seealso{acoth}
## @end deftypefn

function y = coth (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ tanh (x);

endfunction


%!test
%! x = [pi/2*i, 3*pi/2*i];
%! v = [0, 0];
%! assert (coth (x), v, sqrt (eps));

%!error <Invalid call> coth ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} csc (@var{x})
## Compute the cosecant for each element of @var{x} in radians.
## @seealso{acsc, cscd, csch}
## @end deftypefn

function y = csc (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ sin (x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
%! v = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
%! assert (csc (x), v, sqrt (eps));

%!error <Invalid call> csc ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} cscd (@var{x})
## Compute the cosecant for each element of @var{x} in degrees.
## @seealso{acscd, csc}
## @end deftypefn

function y = cscd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ sind (x);

endfunction


%!assert (cscd (10:10:90), csc (pi*[10:10:90]/180), -10*eps)
%!assert (cscd ([0, 180, 360]) == Inf)
%!assert (cscd ([90, 270]) != Inf)

%!error <Invalid call> cscd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} csch (@var{x})
## Compute the hyperbolic cosecant of each element of @var{x}.
## @seealso{acsch}
## @end deftypefn

function y = csch (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ sinh (x);

endfunction


%!test
%! x = [pi/2*i, 3*pi/2*i];
%! v = [-i, i];
%! assert (csch (x), v, sqrt (eps));

%!error <Invalid call> csch ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} sec (@var{x})
## Compute the secant for each element of @var{x} in radians.
## @seealso{asec, secd, sech}
## @end deftypefn

function y = sec (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ cos (x);

endfunction


%!test
%! rt2 = sqrt (2);
%! rt3 = sqrt (3);
%! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
%! v = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
%! assert (sec (x), v, sqrt (eps));

%!error <Invalid call> sec ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} secd (@var{x})
## Compute the secant for each element of @var{x} in degrees.
## @seealso{asecd, sec}
## @end deftypefn

function y = secd (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ cosd (x);

endfunction


%!assert (secd (0:10:80), sec (pi*[0:10:80]/180), -10*eps)
%!assert (secd ([0, 180, 360]) != Inf)
%!assert (secd ([90, 270]) == Inf)

%!error <Invalid call> secd ()
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} sech (@var{x})
## Compute the hyperbolic secant of each element of @var{x}.
## @seealso{asech}
## @end deftypefn

function y = sech (x)

if (nargin < 1)
    print_usage ();
  endif

  y = 1 ./ cosh (x);

endfunction


%!test
%! x = [0, pi*i];
%! v = [1, -1];
%! assert (sech (x), v, sqrt (eps));

%!error <Invalid call> sech ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} sind (@var{x})
## Compute the sine for each element of @var{x} in degrees.
##
## The function is more accurate than @code{sin} for large values of @var{x}
## and for multiples of 180 degrees (@code{@var{x}/180} is an integer) where
## @code{sind} returns 0 rather than a small value on the order of eps.
## @seealso{asind, sin}
## @end deftypefn

function y = sind (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    error ("sind: X must be numeric");
  endif

  x_iscomplex = iscomplex (x);
  if (x_iscomplex)
    xi = imag (x);
  endif
  x = real (x);

  ## Wrap multiples so that new domain is [-180, 180)
  x = mod (x-180, 360) - 180;

  if (x_iscomplex)
    y = sin (complex (x, xi) / 180 * pi);
    ## Integer multiples of pi must be exactly zero
    y(x == -180) = complex (0, imag (y(x == -180)));
  else
    y = sin (x / 180 * pi);
    ## Integer multiples of pi must be exactly zero
    y(x == -180) = 0;
  endif

endfunction


%!assert (sind (10:20:360), sin ([10:20:360] * pi/180), 5*eps)
%!assert (sind ([-360, -180, 0, 180, 360]) == 0)
%!assert (sind ([-270, -90, 90, 270]), [1, -1, 1, -1])
%!assert (sind ([-Inf, NaN, +Inf, 0]), [NaN, NaN, NaN, 0])
%!assert (sind (+23) == -sind (-23))
%!assert (sind (1e6), -0.984807753012208, 5*eps)
%!assert (sind (180 + 180i), -i*sinh (pi))
%!assert (sind (1e6 + 180i), -11.415845458288851 + 2.0054175437381652i, 5*eps)

%!error <Invalid call> sind ()
%!error <X must be numeric> sind ("abc")
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{y} =} sinpi (@var{x})
## Compute sine (@var{x} * pi) for each element of @var{x} accurately.
##
## The ordinary @code{sin} function uses IEEE floating point numbers and may
## produce results that are very close (within a few eps) of the correct
## value, but which are not exact.  The @code{sinpi} function is more accurate
## and returns 0 exactly for integer values of @var{x} and +1/-1 for
## half-integer values (e.g., @dots{}, -3/2, -1/2, 1/2, 3/2, @dots{}).
##
## Example @*
## comparison of @code{sin} and @code{sinpi} for integer values of @var{x}
##
## @example
## @group
## sin ([0, 1, 2, 3] * pi)
## @result{}
##      0   1.2246e-16  -2.4493e-16   3.6739e-16
##
## sinpi ([0, 1, 2, 3])
## @result{}
##        0   0   0   0
## @end group
## @end example
##
## @seealso{cospi, sin}
## @end deftypefn

function y = sinpi (x)

  if (nargin < 1)
    print_usage ();
  endif

  ## Wrap integer multiples so that new domain is [-1, 1)
  x = mod (x-1, 2) - 1;

  ## Integer multiples of pi must be exactly zero
  x(x == -1) = 0;

  y = sin (x * pi);

endfunction


%!assert (sinpi ([-1, -2, 0, 1, 2]) == 0)
%!assert (sinpi ([-3/2, -1/2, 1/2, 3/2]), [1, -1, 1, -1])
%!assert (sinpi (100 + [0.1:0.1:0.9]), sin ([0.1:0.1:0.9]*pi), 2*eps (100))

%!error <Invalid call> sinpi ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} tand (@var{x})
## Compute the tangent for each element of @var{x} in degrees.
##
## Returns zero for elements where @code{@var{x}/180} is an integer and
## @code{Inf} for elements where @code{(@var{x}-90)/180} is an integer.
## @seealso{atand, tan}
## @end deftypefn

function y = tand (x)

  if (nargin < 1)
    print_usage ();
  endif

  I0 = x / 180;
  I90 = (x-90) / 180;
  y = tan (I0 .* pi);
  y(I0 == fix (I0) & isfinite (I0)) = 0;
  y(I90 == fix (I90) & isfinite (I90)) = Inf;

endfunction


%!assert (tand (10:10:80), tan (pi*[10:10:80]/180), -10*eps)
%!assert (tand ([0, 180, 360]) == 0)
%!assert (tand ([90, 270]) == Inf)

%!error <Invalid call> tand ()
encoding=utf-8
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} accumarray (@var{subs}, @var{vals}, @var{sz}, @var{func}, @var{fillval}, @var{issparse})
## @deftypefnx {} {} accumarray (@var{subs}, @var{vals}, @dots{})
##
## Create an array by accumulating the elements of a vector into the
## positions defined by their subscripts.
##
## The subscripts are defined by the rows of the matrix @var{subs} and the
## values by @var{vals}.  Each row of @var{subs} corresponds to one of the
## values in @var{vals}.  If @var{vals} is a scalar, it will be used for each
## of the row of @var{subs}.  If @var{subs} is a cell array of vectors, all
## vectors must be of the same length, and the subscripts in the @var{k}th
## vector must correspond to the @var{k}th dimension of the result.
##
## The size of the matrix will be determined by the subscripts
## themselves.  However, if @var{sz} is defined it determines the matrix
## size.  The length of @var{sz} must correspond to the number of columns
## in @var{subs}.  An exception is if @var{subs} has only one column, in
## which case @var{sz} may be the dimensions of a vector and the
## subscripts of @var{subs} are taken as the indices into it.
##
## The default action of @code{accumarray} is to sum the elements with
## the same subscripts.  This behavior can be modified by defining the
## @var{func} function.  This should be a function or function handle
## that accepts a column vector and returns a scalar.  The result of the
## function should not depend on the order of the subscripts.
##
## The elements of the returned array that have no subscripts associated
## with them are set to zero.  Defining @var{fillval} to some other value
## allows these values to be defined.  This behavior changes, however,
## for certain values of @var{func}.  If @var{func} is @code{@@min}
## (respectively, @code{@@max}) then the result will be filled with the
## minimum (respectively, maximum) integer if @var{vals} is of integral
## type, logical false (respectively, logical true) if @var{vals} is of
## logical type, zero if @var{fillval} is zero and all values are
## non-positive (respectively, non-negative), and NaN otherwise.
##
## By default @code{accumarray} returns a full matrix.  If
## @var{issparse} is logically true, then a sparse matrix is returned
## instead.
##
## The following @code{accumarray} example constructs a frequency table
## that in the first column counts how many occurrences each number in
## the second column has, taken from the vector @var{x}.  Note the usage
## of @code{unique}  for assigning to all repeated elements of @var{x}
## the same index (@pxref{XREFunique,,@code{unique}}).
##
## @example
## @group
## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
## [@var{u}, ~, @var{j}] = unique (@var{x});
## [accumarray(@var{j}', 1), @var{u}']
##   @result{}  2    89
##       3    90
##       2    91
##       2    92
##       3   100
## @end group
## @end example
##
## Another example, where the result is a multi-dimensional 3-D array and
## the default value (zero) appears in the output:
##
## @example
## @group
## accumarray ([1, 1, 1;
##              2, 1, 2;
##              2, 3, 2;
##              2, 1, 2;
##              2, 3, 2], 101:105)
## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
## @result{} ans(:,:,2) = [0, 0, 0; 206, 0, 208]
## @end group
## @end example
##
## The sparse option can be used as an alternative to the @code{sparse}
## constructor (@pxref{XREFsparse,,@code{sparse}}).  Thus
##
## @example
## sparse (@var{i}, @var{j}, @var{sv})
## @end example
##
## @noindent
## can be written with @code{accumarray} as
##
## @example
## accumarray ([@var{i}, @var{j}], @var{sv}', [], [], 0, true)
## @end example
##
## @noindent
## For repeated indices, @code{sparse} adds the corresponding value.  To
## take the minimum instead, use @code{min} as an accumulator function:
##
## @example
## accumarray ([@var{i}, @var{j}], @var{sv}', [], @@min, 0, true)
## @end example
##
## The complexity of accumarray in general for the non-sparse case is
## generally O(M+N), where N is the number of subscripts and M is the
## maximum subscript (linearized in multi-dimensional case).  If
## @var{func} is one of @code{@@sum} (default), @code{@@max},
## @code{@@min} or @code{@@(x) @{x@}}, an optimized code path is used.
## Note that for general reduction function the interpreter overhead can
## play a major part and it may be more efficient to do multiple
## accumarray calls and compute the results in a vectorized manner.
##
## @seealso{accumdim, unique, sparse}
## @end deftypefn

function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])

  if (nargin < 2)
    print_usage ();
  endif

  lenvals = length (vals);

  if (iscell (subs))
    subs = cellfun (@vec, subs, "uniformoutput", false);
    ndims = numel (subs);
    if (ndims == 1)
      subs = subs{1};
    endif

    lensubs = cellfun (@length, subs);

    if (any (lensubs != lensubs(1)) || (lenvals > 1 && lenvals != lensubs(1)))
      error ("accumarray: dimension mismatch");
    endif

  else
    ndims = columns (subs);
    if (lenvals > 1 && lenvals != rows (subs))
      error ("accumarray: dimension mismatch");
    endif
  endif

  if (isempty (func))
    func = @sum;
  elseif (! is_function_handle (func))
    error ("accumarray: FUNC must be a function handle");
  endif

  if (isempty (fillval))
    fillval = 0;
  endif

  if (isempty (issparse))
    issparse = false;
  endif

  if (issparse)

    ## Sparse case.
    ## Avoid linearizing the subscripts, because it could overflow.

    if (fillval != 0)
      error ("accumarray: FILLVAL must be zero in the sparse case");
    endif

    ## Ensure subscripts are a two-column matrix.
    if (iscell (subs))
      subs = [subs{:}];
    endif

    ## Validate dimensions.
    if (ndims == 1)
      subs(:,2) = 1;
    elseif (ndims != 2)
      error ("accumarray: in the sparse case, needs 1 or 2 subscripts");
    endif

    if (isnumeric (vals) || islogical (vals))
      vals = double (vals);
    else
      error ("accumarray: in the sparse case, values must be numeric or logical");
    endif

    if (func != @sum)

      ## Reduce values.  This is not needed if we're about to sum them,
      ## because "sparse" can do that.

      ## Sort indices.
      [subs, idx] = sortrows (subs);
      n = rows (subs);
      ## Identify runs.
      jdx = find (any (diff (subs, 1, 1), 2));
      jdx = [jdx; n];

      vals = cellfun (func, mat2cell (vals(:)(idx), diff ([0; jdx])));
      subs = subs(jdx, :);
      mode = "unique";
    else
      mode = "sum";
    endif

    ## Form the sparse matrix.
    if (isempty (sz))
      A = sparse (subs(:,1), subs(:,2), vals, mode);
    elseif (length (sz) == 2)

      ## Row vector case
      if (sz(1) == 1)
        [i, j] = deal (subs(:,2), subs(:,1));
      else
        [i, j] = deal (subs(:,1), subs(:,2));
      endif
      A = sparse (i, j, vals, sz(1), sz(2), mode);
    else
      error ("accumarray: dimensions mismatch");
    endif

  else

    ## Linearize subscripts.
    if (ndims > 1)
      if (isempty (sz))
        if (iscell (subs))
          sz = cellfun ("max", subs);
        else
          sz = max (subs, [], 1);
        endif
      elseif (ndims != length (sz))
        error ("accumarray: dimensions mismatch");
      endif

      ## Convert multidimensional subscripts.
      if (isnumeric (subs))
        subs = num2cell (subs, 1);
      endif
      subs = sub2ind (sz, subs{:}); # creates index cache
    elseif (! isempty (sz) && length (sz) < 2)
      error ("accumarray: needs at least 2 dimensions");
    elseif (! isindex (subs)) # creates index cache
      error ("accumarray: indices must be positive integers");
    endif


    ## Some built-in reductions handled efficiently.

    if (func == @sum)
      ## Fast summation.
      if (isempty (sz))
        A = __accumarray_sum__ (subs, vals);
      else
        A = __accumarray_sum__ (subs, vals, prod (sz));
        ## set proper shape.
        A = reshape (A, sz);
      endif

      ## we fill in nonzero fill value.
      if (fillval != 0)
        mask = true (size (A));
        mask(subs) = false;
        A(mask) = fillval;
      endif
    elseif (func == @max)
      ## Fast maximization.

      if (isinteger (vals))
        zero = intmin (vals);
      elseif (islogical (vals))
        zero = false;
      elseif (fillval == 0 && all (vals(:) >= 0))
        ## This is a common case - fillval is zero, all numbers
        ## nonegative.
        zero = 0;
      else
        zero = NaN; # Neutral value.
      endif

      if (isempty (sz))
        A = __accumarray_max__ (subs, vals, zero);
      else
        A = __accumarray_max__ (subs, vals, zero, prod (sz));
        A = reshape (A, sz);
      endif

      if (fillval != zero && ! (isnan (fillval) || isnan (zero)))
        mask = true (size (A));
        mask(subs) = false;
        A(mask) = fillval;
      endif
    elseif (func == @min)
      ## Fast minimization.

      if (isinteger (vals))
        zero = intmax (vals);
      elseif (islogical (vals))
        zero = true;
      elseif (fillval == 0 && all (vals(:) <= 0))
        ## This is a common case - fillval is zero, all numbers
        ## non-positive.
        zero = 0;
      else
        zero = NaN; # Neutral value.
      endif

      if (isempty (sz))
        A = __accumarray_min__ (subs, vals, zero);
      else
        A = __accumarray_min__ (subs, vals, zero, prod (sz));
        A = reshape (A, sz);
      endif

      if (fillval != zero && ! (isnan (fillval) || isnan (zero)))
        mask = true (size (A));
        mask(subs) = false;
        A(mask) = fillval;
      endif
    else

      ## The general case.  Reduce values.
      n = rows (subs);
      if (numel (vals) == 1)
        vals = vals(ones (1, n), 1);
      else
        vals = vals(:);
      endif

      ## Sort indices.
      [subs, idx] = sort (subs);
      ## Identify runs.
      jdx = find (subs(1:n-1) != subs(2:n));
      if (n != 0) # bug #47287
        jdx = [jdx; n];
      endif
      vals = mat2cell (vals(idx), diff ([0; jdx]));
      ## Optimize the case when function is @(x) {x}, i.e., we just want
      ## to collect the values to cells.
      persistent simple_cell_str = func2str (@(x) {x});
      if (! strcmp (func2str (func), simple_cell_str))
        vals = cellfun (func, vals);
      endif

      subs = subs(jdx);

      if (isempty (sz))
        sz = max (subs);
        ## If subs is empty, sz will be too, and length will be 0, hence "<= 1"
        if (length (sz) <= 1)
          sz(2) = 1;
        endif
      endif

      ## Construct matrix of fillvals.
      if (iscell (vals))
        A = cell (sz);
      elseif (fillval == 0)
        A = zeros (sz, class (vals));
      else
        A = repmat (fillval, sz);
      endif

      ## Set the reduced values.
      A(subs) = vals;
    endif
  endif

endfunction


%!assert (accumarray ([1; 2; 4; 2; 4], 101:105), [101; 206; 0; 208])
%!assert (accumarray ([1 1 1; 2 1 2; 2 3 2; 2 1 2; 2 3 2], 101:105),
%!                    cat (3, [101 0 0; 0 0 0], [0 0 0; 206 0 208]))

%!assert (accumarray ([1 1 1; 2 1 2; 2 3 2; 2 1 2; 2 3 2], 101:105, [], @(x) sin (sum (x))),
%!        sin (cat (3, [101,0,0;0,0,0],[0,0,0;206,0,208])))

%!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2], [3 4 2 1 4 3 4 2 2 4 3 4], [1 1 2 2 1 1 2 1 1 1 2 2]}, 101:112),
%!        cat (3, [0 0 207 0; 0 108 0 0; 0 109 0 317], [0 0 111 0; 104 0 0 219; 0 103 0 0]))

%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2 4], @max, NaN),
%!        [101 NaN NaN NaN; 104 NaN 105 NaN])

%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [], @prod),
%!        [101 0 0; 10608 0 10815])
%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2 4], @prod, 0, true),
%!        sparse ([1 2 2], [1 1 3], [101 10608 10815], 2, 4))
%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 1, [2 4]), [1 0 0 0; 2 0 2 0])
%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2 4], @(x) length (x) > 1),
%!        [false false false false; true false true false])

%!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
%!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
%!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
%!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))

%!test
%! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2,4], @(x) {x});
%! assert (A{2},[102; 104]);

%!test
%! subs = ceil (rand (2000, 3)*10);
%! vals = rand (2000, 1);
%! assert (accumarray (subs, vals, [], @max),
%!         accumarray (subs, vals, [], @(x) max (x)));

%!test
%! subs = ceil (rand (2000, 1)*100);
%! vals = rand (2000, 1);
%! assert (accumarray (subs, vals, [100, 1], @min, NaN),
%!         accumarray (subs, vals, [100, 1], @(x) min (x), NaN));

%!test
%! subs = ceil (rand (2000, 2)*30);
%! subsc = num2cell (subs, 1);
%! vals = rand (2000, 1);
%! assert (accumarray (subsc, vals, [], [], 0, true),
%!         accumarray (subs, vals, [], [], 0, true));

%!test
%! subs = ceil (rand (2000, 3)*10);
%! subsc = num2cell (subs, 1);
%! vals = rand (2000, 1);
%! assert (accumarray (subsc, vals, [], @max),
%!         accumarray (subs, vals, [], @max));

%!error accumarray (1:5)
%!error accumarray ([1,2,3],1:2)

## Handle empty arrays
%!test <*47287>
%! ## min, max, and sum are special cases within accumarray so test them.
%! funcs = {@(x) length (x) > 1, @min, @max, @sum};
%! for idx = 1:numel (funcs)
%!   assert (accumarray (zeros (0, 1), [], [0 1] , funcs{idx}), zeros (0, 1));
%!   assert (accumarray (zeros (0, 1), [], [1 0] , funcs{idx}), zeros (1, 0));
%!   assert (accumarray (zeros (0, 1), [], [] , funcs{idx}), zeros (0, 1));
%! endfor

## Matlab returns an array of doubles even though FUNC returns cells.  In
## Octave, we do not have that bug, at least for this case.
%!assert (accumarray (zeros (0, 1), [], [0 1] , @(x) {x}), cell (0, 1))

%!error <FUNC must be a function handle>
%! accumarray ([1; 2; 3], [1; 2; 3], [3 1], '@(x) {x}')
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} accumdim (@var{subs}, @var{vals}, @var{dim}, @var{n}, @var{func}, @var{fillval})
## Create an array by accumulating the slices of an array into the
## positions defined by their subscripts along a specified dimension.
##
## The subscripts are defined by the index vector @var{subs}.
## The dimension is specified by @var{dim}.  If not given, it defaults
## to the first non-singleton dimension.  The length of @var{subs} must
## be equal to @code{size (@var{vals}, @var{dim})}.
##
## The extent of the result matrix in the working dimension will be
## determined by the subscripts themselves.  However, if @var{n} is
## defined it determines this extent.
##
## The default action of @code{accumdim} is to sum the subarrays with the
## same subscripts.  This behavior can be modified by defining the
## @var{func} function.  This should be a function or function handle
## that accepts an array and a dimension, and reduces the array along
## this dimension.  As a special exception, the built-in @code{min} and
## @code{max} functions can be used directly, and @code{accumdim}
## accounts for the middle empty argument that is used in their calling.
##
## The slices of the returned array that have no subscripts associated
## with them are set to zero.  Defining @var{fillval} to some other
## value allows these values to be defined.
##
## An example of the use of @code{accumdim} is:
##
## @example
## @group
## accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
##                             -5, -12,   8;
##                            -12,   2,   8;
##                            -10,   9,  -3;
##                             -5,  -3, -13])
## @result{} [-10,-11,-1;-15,-3,5]
## @end group
## @end example
##
## @seealso{accumarray}
## @end deftypefn

function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)

  if (nargin < 2)
    print_usage ();
  endif

  if (isempty (fillval))
    fillval = 0;
  endif

  if (! isvector (subs))
    error ("accumdim: SUBS must be a subscript vector");
  elseif (! isindex (subs)) # creates index cache
    error ("accumdim: indices must be positive integers");
  else
    m = max (subs);
    if (n == 0 || isempty (n))
      n = m;
    elseif (n < m)
      error ("accumdim: N index out of range");
    endif
  endif

  sz = size (vals);

  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  elseif (! isindex (dim))
    error ("accumdim: DIM must be a valid dimension");
  elseif (dim > length (sz))
    sz(end+1:dim) = 1;
  endif
  sz(dim) = n;

  if (length (subs) != size (vals, dim))
    error ("accumdim: dimension mismatch");
  endif

  if (isempty (func) || func == @sum)
    ## Fast summation case.
    A = __accumdim_sum__ (subs, vals, dim, n);

    ## Fill in nonzero fill value
    if (fillval != 0)
      mask = true (n, 1);
      mask(subs) = false;
      subsc = {':'}(ones (1, length (sz)));
      subsc{dim} = mask;
      A(subsc{:}) = fillval;
    endif
    return;
  endif

  ## The general case.
  ns = length (subs);
  ## Sort indices.
  [subs, idx] = sort (subs(:));
  ## Identify runs.
  jdx = find (subs(1:ns-1) != subs(2:ns));
  jdx = [jdx; ns];
  ## Collect common slices.
  szc = num2cell (sz);
  szc{dim} = diff ([0; jdx]);
  subsc = {':'}(ones (1, length (sz)));
  subsc{dim} = idx;
  vals = mat2cell (vals(subsc{:}), szc{:});
  ## Apply reductions.  Special case min, max.
  if (func == @min || func == @max)
    vals = cellfun (func, vals, {[]}, {dim}, "uniformoutput", false);
  else
    vals = cellfun (func, vals, {dim}, "uniformoutput", false);
  endif
  subs = subs(jdx);

  ## Concatenate reduced slices.
  vals = cat (dim, vals{:});

  ## Construct matrix of fillvals.
  if (fillval == 0)
    A = zeros (sz, class (vals));
  else
    A = repmat (fillval, sz);
  endif

  ## Set the reduced values.
  subsc{dim} = subs;
  A(subsc{:}) = vals;

endfunction


## Test accumdim vs. accumarray
%!shared a
%! a = rand (5, 5, 5);

%!assert (accumdim ([1;3;1;3;3], a)(:,2,3), accumarray ([1;3;1;3;3], a(:,2,3)))
%!assert (accumdim ([2;3;2;2;2], a, 2, 4)(4,:,2),
%!        accumarray ([2;3;2;2;2], a(4,:,2), [1,4]))
%!assert (accumdim ([2;3;2;1;2], a, 3, 3, @min)(1,5,:),
%!        accumarray ([2;3;2;1;2], a(1,5,:), [1,1,3], @min))
%!assert (accumdim ([1;3;2;2;1], a, 2, 3, @median)(4,:,5),
%!        accumarray ([1;3;2;2;1], a(4,:,5), [1,3], @median))

## Test fillval
%!assert (accumdim ([1;3;1;3;3], a)(2,:,:), zeros (1,5,5))
%!assert (accumdim ([1;3;1;3;3], a, 1, 4)([2 4],:,:), zeros (2,5,5))
%!assert (accumdim ([1;3;1;3;3], a, 1, 4, [], pi)([2 4],:,:), pi (2,5,5))

## Test input validation
%!error <Invalid call> accumdim ()
%!error <Invalid call> accumdim (1)
%!error <SUBS must be a subscript vector> accumdim (ones (2,2), ones (2,2))
%!error <indices must be positive integers> accumdim ([-1 1], ones (2,2))
%!error <N index out of range> accumdim ([1 2], ones (2,2), 1, 1)
%!error <dimension mismatch> accumdim ([1], ones (2,2))
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} bincoeff (@var{n}, @var{k})
## Return the binomial coefficient of @var{n} and @var{k}.
##
## The binomial coefficient is defined as
## @tex
## $$
##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##  /   \
##  | n |    n (n-1) (n-2) @dots{} (n-k+1)
##  |   |  = -------------------------
##  | k |               k!
##  \   /
## @end group
## @end example
##
## @end ifnottex
## For example:
##
## @example
## @group
## bincoeff (5, 2)
##    @result{} 10
## @end group
## @end example
##
## In most cases, the @code{nchoosek} function is faster for small
## scalar integer arguments.  It also warns about loss of precision for
## big arguments.
##
## @seealso{nchoosek}
## @end deftypefn

function b = bincoeff (n, k)

  if (nargin != 2)
    print_usage ();
  endif

  [retval, n, k] = common_size (n, k);
  if (retval > 0)
    error ("bincoeff: N and K must be of common size or scalars");
  endif

  if (iscomplex (n) || iscomplex (k))
    error ("bincoeff: N and K must not be complex");
  endif

  b = zeros (size (n));

  ok = (k >= 0) & (k == fix (k)) & (! isnan (n));
  b(! ok) = NaN;

  n_int = (n == fix (n));
  idx = n_int & (n < 0) & ok;
  b(idx) = (-1) .^ k(idx) .* exp (gammaln (abs (n(idx)) + k(idx))
                                  - gammaln (k(idx) + 1)
                                  - gammaln (abs (n(idx))));

  idx = (n >= k) & ok;
  b(idx) = exp (gammaln (n(idx) + 1)
                - gammaln (k(idx) + 1)
                - gammaln (n(idx) - k(idx) + 1));

  idx = (! n_int) & (n < k) & ok;
  b(idx) = (1/pi) * exp (gammaln (n(idx) + 1)
                         - gammaln (k(idx) + 1)
                         + gammaln (k(idx) - n(idx))
                         + log (sin (pi * (n(idx) - k(idx) + 1))));

  ## Clean up rounding errors.
  b(n_int) = round (b(n_int));

  idx = ! n_int;
  b(idx) = real (b(idx));

endfunction


%!assert (bincoeff (4, 2), 6)
%!assert (bincoeff (2, 4), 0)
%!assert (bincoeff (-4, 2), 10)
%!assert (bincoeff (5, 2), 10)
%!assert (bincoeff (50, 6), 15890700)
%!assert (bincoeff (0.4, 2), -.12, 8*eps)

%!assert (bincoeff ([4 NaN 4], [-1, 2, 2.5]), NaN (1, 3))

## Test input validation
%!error <Invalid call> bincoeff ()
%!error <Invalid call> bincoeff (1)
%!error bincoeff (ones (3), ones (2))
%!error bincoeff (ones (2), ones (3))
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} bitcmp (@var{A}, @var{k})
## Return the @var{k}-bit complement of integers in @var{A}.
##
## If @var{k} is omitted @code{k = log2 (flintmax) + 1} is assumed.
##
## @example
## @group
## bitcmp (7,4)
##   @result{} 8
## dec2bin (11)
##   @result{} 1011
## dec2bin (bitcmp (11, 6))
##   @result{} 110100
## @end group
## @end example
##
## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, flintmax}
## @end deftypefn

## Liberally based on the version by Kai Habel from Octave Forge

function C = bitcmp (A, k)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 2 && (! isscalar (k) || (floor (k) != k)))
    error ("bitcmp: K must be a scalar integer");
  endif

  if (isa (A, "double"))
    bmax = flintmax - 1;
    amax = ceil (log2 (bmax));
  elseif (isa (A, "single"))
    bmax = flintmax ("single") - 1;
    amax = ceil (log2 (bmax));
  elseif (isinteger (A))
    amax = sizeof (ones (1, class (A))) * 8;
    bmax = bitpack (true (amax, 1), class (A));
  else
    error ("bitcmp: invalid class %s", class (A));
  endif

  if (nargin == 1 || k == amax)
    C = bitxor (A, bmax);
  else
    m = double (k);
    if (any (m < 1) || any (m > amax))
      error ("bitcmp: K must be in the range [1,%d]", amax);
    endif
    mask = bitshift (bmax, k - amax);
    C = bitxor (bitand (A, mask), mask);
  endif

endfunction


%!test
%! Amax = 53;
%! Bmax = flintmax - 1;
%! A = bitshift (Bmax,-2);
%! assert (bitcmp (A,Amax),bitor (bitshift (1,Amax-1), bitshift (1,Amax-2)));
%! assert (bitcmp (A,Amax-1), bitshift (1,Amax-2));
%! assert (bitcmp (A,Amax-2), 0);
%!test
%! Amax = 24;
%! Bmax = flintmax ("single") - 1;
%! A = bitshift (Bmax,-2);
%! assert (bitcmp (A,Amax),
%!         bitor (bitshift (single (1),Amax-1), bitshift (single (1),Amax-2)));
%! assert (bitcmp (A,Amax-1), bitshift (single (1),Amax-2));
%! assert (bitcmp (A,Amax-2), single (0));
%!test
%! Amax = 8;
%! Bmax = intmax ("uint8");
%! A = bitshift (Bmax,-2);
%! assert (bitcmp (A,Amax),
%!         bitor (bitshift (uint8 (1),Amax-1), bitshift (uint8 (1),Amax-2)));
%! assert (bitcmp (A,Amax-1), bitshift (uint8 (1),Amax-2));
%! assert (bitcmp (A,Amax-2), uint8 (0));
%!test
%! Amax = 16;
%! Bmax = intmax ("uint16");
%! A = bitshift (Bmax,-2);
%! assert (bitcmp (A,Amax),
%!         bitor (bitshift (uint16 (1),Amax-1), bitshift (uint16 (1),Amax-2)));
%! assert (bitcmp (A,Amax-1), bitshift (uint16 (1),Amax-2));
%! assert (bitcmp (A,Amax-2), uint16 (0));
%!test
%! Amax = 32;
%! Bmax = intmax ("uint32");
%! A = bitshift (Bmax,-2);
%! assert (bitcmp (A,Amax),
%!         bitor (bitshift (uint32 (1),Amax-1), bitshift (uint32 (1),Amax-2)));
%! assert (bitcmp (A,Amax-1), bitshift (uint32 (1),Amax-2));
%! assert (bitcmp (A,Amax-2), uint32 (0));
%!test
%! Amax = 64;
%! Bmax = intmax ("uint64");
%! A = bitshift (Bmax,-2);
%! assert (bitcmp (A,Amax),
%!         bitor (bitshift (uint64 (1),Amax-1), bitshift (uint64 (1),Amax-2)));
%! assert (bitcmp (A,Amax-1), bitshift (uint64 (1),Amax-2));
%! assert (bitcmp (A,Amax-2), uint64 (0));

## Do not forget signed integers
%!assert (bitcmp (int8 (127)), int8 (-128)) # [1 1 1 1 1 1 1 0]
%!assert (bitcmp (int8 (1)), int8 (-2))     # [1 0 0 0 0 0 0 0]
%!assert (bitcmp (int8 (0)), int8 (-1))     # [0 0 0 0 0 0 0 0]
%!assert (bitcmp (int8 (8)), int8 (-9))     # [0 0 0 1 0 0 0 0]
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{c} =} bitget (@var{A}, @var{n})
## Return the status of bit(s) @var{n} of the unsigned integers in @var{A}.
##
## The least significant bit is @var{n} = 1.
##
## @example
## @group
## bitget (100, 8:-1:1)
## @result{} 0  1  1  0  0  1  0  0
## @end group
## @end example
## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, intmax, flintmax}
## @end deftypefn

## Liberally based of the version by Kai Habel from Octave Forge

function C = bitget (A, n)

  if (nargin != 2)
    print_usage ();
  endif

  if (isa (A, "double"))
    Amax = ceil (log2 (flintmax));
    _conv = @double;
  elseif (isa (A, "single"))
    Amax = ceil (log2 (flintmax ("single")));
    _conv = @single;
  else
    if (isa (A, "uint8"))
      Amax = 8;
      _conv = @uint8;
    elseif (isa (A, "uint16"))
      Amax = 16;
      _conv = @uint16;
    elseif (isa (A, "uint32"))
      Amax = 32;
      _conv = @uint32;
    elseif (isa (A, "uint64"))
      Amax = 64;
      _conv = @uint64;
    elseif (isa (A, "int8"))
      Amax = 8;
      _conv = @int8;
    elseif (isa (A, "int16"))
      Amax = 16;
      _conv = @int16;
    elseif (isa (A, "int32"))
      Amax = 32;
      _conv = @int32;
    elseif (isa (A, "int64"))
      Amax = 64;
      _conv = @int64;
    else
      error ("bitget: invalid class %s", class (A));
    endif
  endif

  m = double (n(:));
  if (any (m < 1) || any (m > Amax))
    error ("bitget: N must be in the range [1,%d]", Amax);
  endif

  C = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);

endfunction


%!test
%! assert (bitget ([4, 14], [3, 3]), logical ([1, 1]));
%! assert (bitget (single ([4, 14]), [3, 3]), logical ([1, 1]));
%! pfx = {"", "u"};
%! for i = 1:2
%!   for prec = [8, 16, 32, 64]
%!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
%!     assert (bitget (fcn ([4, 14]), [3, 3]), logical ([1, 1]));
%!   endfor
%! endfor

## Test input validation
%!error <Invalid call> bitget ()
%!error <Invalid call> bitget (1)
%!error <invalid class> bitget ("char", 1)
%!error <N must be in the range \[1,53\]> bitget (0, 0)
%!error <N must be in the range \[1,53\]> bitget (0, 55)
%!error <N must be in the range \[1,24\]> bitget (single (0), 0)
%!error <N must be in the range \[1,24\]> bitget (single (0), 26)
%!error <N must be in the range \[1,8\]> bitget (int8 (0), 9)
%!error <N must be in the range \[1,8\]> bitget (uint8 (0), 9)
%!error <N must be in the range \[1,16\]> bitget (int16 (0), 17)
%!error <N must be in the range \[1,16\]> bitget (uint16 (0), 17)
%!error <N must be in the range \[1,32\]> bitget (int32 (0), 33)
%!error <N must be in the range \[1,32\]> bitget (uint32 (0), 33)
%!error <N must be in the range \[1,64\]> bitget (int64 (0), 65)
%!error <N must be in the range \[1,64\]> bitget (uint64 (0), 65)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{C} =} bitset (@var{A}, @var{n})
## @deftypefnx {} {@var{C} =} bitset (@var{A}, @var{n}, @var{val})
## Set or reset bit(s) @var{n} of the unsigned integers in @var{A}.
##
## The least significant bit is @var{n} = 1.  @w{@var{val} = 0} resets bits and
## @w{@var{val} = 1} sets bits.  If no @var{val} is specified it defaults to
## 1 (set bit).  All inputs must be the same size or scalars.
##
## Example 1: Set multiple bits
##
## @example
## @group
## x = bitset (1, 3:5)
##   @result{} x =
##
##    5    9   17
##
## dec2bin (x)
##   @result{}
##      00101
##      01001
##      10001
## @end group
## @end example
##
## Example 2: Reset and set bits
##
## @example
## @group
## x = bitset ([15 14], 1, [0 1])
##   @result{} x =
##
##    14    15
## @end group
## @end example
## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, intmax, flintmax}
## @end deftypefn

function C = bitset (A, n, val = true)

  if (nargin < 2)
    print_usage ();
  endif

  if (any (A(:) < 0))
    error ("bitset: A must be >= 0");
  endif

  [size_err, A, n, val] = common_size (A, n, val);
  if (size_err)
    error ("bitset: A, N, and VAL must be the same size or scalar");
  endif

  ## Special case of empty input
  if (isempty (A))
    C = [];
    return;
  endif

  sz = size (A);
  cl = class (A);

  if (isfloat (A) && isreal (A))
    Bmax = flintmax (cl);
    Amax = ceil (log2 (Bmax));
  elseif (isinteger (A))
    Bmax = intmax (cl);
    Amax = ceil (log2 (Bmax));
  else
    error ("bitset: invalid class %s", cl);
  endif

  if (any ((n < 1)(:)) || any ((n > Amax)(:)))
    error ("bitset: N must be in the range [1,%d]", Amax);
  endif

  mask = bitshift (cast (1, cl), uint8 (n) - uint8 (1));

  on = logical (val);
  off = ! on;

  if (isscalar (mask))
    onmask = mask;
    offmask = mask;
  else
    onmask = mask(on);
    offmask = mask(off);
  endif

  C = zeros (sz, cl);
  C(on) = bitor (A(on), onmask);
  C(off) = bitand (A(off), bitcmp (offmask));

endfunction


%!test
%! assert (bitset ([0, 10], [3, 3]), [4, 14]);
%! assert (bitset (single ([0, 10]), [3, 3]), single ([4, 14]));
%! pfx = {"", "u"};
%! for i = 1:2
%!   for prec = [8, 16, 32, 64]
%!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
%!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
%!   endfor
%! endfor

%!assert (bitset ([], 1), [])

%!assert <*36458> (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]),
%!                 uint8 ([0, 3; 2 5]))

%!assert (bitset (1:5, 1), [1, 3, 3, 5, 5])
%!assert (bitset (1:5, 1, [1, 1, 1, 1, 1]), [1, 3, 3, 5, 5])
%!assert <*54110> (bitset (1:5, 1, 1), [1, 3, 3, 5, 5])
%!assert (bitset (1:5, 1, [1, 1, 1, 1, 0]), [1, 3, 3, 5, 4])

## Test input validation
%!error <Invalid call> bitset ()
%!error <Invalid call> bitset (1)
%!error <A must be .= 0> bitset (-1, 2)
%!error <must be the same size or scalar> bitset (1, [1 2], [1 2 3])
%!error <must be the same size or scalar> bitset ([1 2], [1 2 3])
%!error <invalid class char> bitset ("1", 2)
%!error <N must be in the range \[1,53\]> bitset (0, 0)
%!error <N must be in the range \[1,53\]> bitset (0, 55)
%!error <N must be in the range \[1,24\]> bitset (single (0), 0)
%!error <N must be in the range \[1,24\]> bitset (single (0), 26)
%!error <N must be in the range \[1,8\]> bitset (uint8 (0), 0)
%!error <N must be in the range \[1,8\]> bitset (uint8 (0), 9)
%!error <N must be in the range \[1,7\]> bitset (int8 (0), 9)
%!error <N must be in the range \[1,15\]> bitset (int16 (0), 17)
%!error <N must be in the range \[1,16\]> bitset (uint16 (0), 17)
%!error <N must be in the range \[1,31\]> bitset (int32 (0), 33)
%!error <N must be in the range \[1,32\]> bitset (uint32 (0), 33)
%!error <N must be in the range \[1,63\]> bitset (int64 (0), 65)
%!error <N must be in the range \[1,64\]> bitset (uint64 (0), 65)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} blkdiag (@var{A}, @var{B}, @var{C}, @dots{})
## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}
##
## All arguments must be numeric and either two-dimensional matrices or
## scalars.  If any argument is of type sparse, the output will also be sparse.
## @seealso{diag, horzcat, vertcat, sparse}
## @end deftypefn

function retval = blkdiag (varargin)

  if (nargin < 1)
    print_usage ();
  endif

  if (! all (cellfun ("isnumeric", varargin)))
    error ("blkdiag: all arguments must be numeric");
  endif

  ## Note: trailing singletons are automatically (correctly) ignored.
  if (! all (cellfun ("ndims", varargin) == 2))
    error ("blkdiag: all arguments must be two-dimensional matrices");
  endif

  ## size is an option for cellfun, but it's a bit different from
  ## calling size directly.
  tmp = cell2mat (cellfun (@size, varargin', "uniformoutput", false));
  csz = cumsum ([0 0; tmp], 1);

  if (any (cellfun ("issparse", varargin)))
    retval = sparse (csz(end,1), csz(end,2));
  else
    retval = zeros (csz(end,:));
  endif

  for p = 1:nargin
    vp = varargin{p};
    if (! isempty (vp))
      retval((csz(p,1)+1):csz(p+1,1),(csz(p,2)+1):csz(p+1,2)) = vp;
    endif
  endfor

endfunction


## regular tests
%!assert (blkdiag (1,ones (2),1), [1,0,0,0;0,1,1,0;0,1,1,0;0,0,0,1])
%!assert (blkdiag ([1,2],[3,4],[5,6]), [1,2,0,0,0,0;0,0,3,4,0,0;0,0,0,0,5,6])
%!assert (blkdiag ([1,2],[3;4],[5,6]),
%!        [1,2,0,0,0;0,0,3,0,0;0,0,4,0,0;0,0,0,5,6])
%!assert (blkdiag ([1,2;3,4],[5,6,7]), [1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
## tests involving empty matrices
%!assert (blkdiag ([],[],[]), [])
%!assert (blkdiag ([],[1,2;3,4],[],5,[]), [1,2,0;3,4,0;0,0,5])
%!assert (blkdiag (zeros (1,0,1),[1,2,3],1,0,5,zeros (0,1,1)),
%!        [0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0])
## tests involving sparse matrices
%!assert (blkdiag (sparse ([1,2;3,4]),[5,6;7,8]),
%!        sparse ([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
%!assert (blkdiag (sparse ([1,2;3,4]),[5,6]),
%!        sparse ([1,2,0,0;3,4,0,0;0,0,5,6]))
## sanity checks
%!test
%! A = rand (round (rand (1, 2) * 10));
%! assert (blkdiag (A), A);
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{theta}, @var{r}] =} cart2pol (@var{x}, @var{y})
## @deftypefnx {} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{x}, @var{y}, @var{z})
## @deftypefnx {} {[@var{theta}, @var{r}] =} cart2pol (@var{C})
## @deftypefnx {} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{C})
##
## Transform Cartesian coordinates to polar or cylindrical coordinates.
##
## The inputs @var{x}, @var{y} (, and @var{z}) must be the same shape, or
## scalar.  If called with a single matrix argument then each row of @var{C}
## represents the Cartesian coordinate pair (@var{x}, @var{y}) or triplet
## (@var{x}, @var{y}, @var{z}).
##
## The outputs @var{theta}, @var{r} (, and @var{z}) match the shape of the
## inputs.  For a matrix input @var{C} the outputs will be column vectors with
## rows corresponding to the rows of the input matrix.
##
## @var{theta} describes the angle relative to the positive x-axis measured in
## the xy-plane.
##
## @var{r} is the distance to the z-axis @w{(0, 0, z)}.
##
## @var{z}, if present, is unchanged by the transformation.
##
## The coordinate transformation is computed using:
##
## @tex
## $$ \theta = \arctan \left ( {y \over x} \right ) $$
## $$ r = \sqrt{x^2 + y^2} $$
## $$ z = z $$
## @end tex
## @ifnottex
##
## @example
## @group
## @var{theta} = arctan (@var{y} / @var{x})
## @var{r} = sqrt (@var{x}^2 + @var{y}^2)
## @var{z} = @var{z}
## @end group
## @end example
##
## @end ifnottex
##
## @c FIXME: Remove this note in Octave 9.1 (two releases after 7.1).
## Note: For @sc{matlab} compatibility, this function no longer returns a full
## coordinate matrix when called with a single return argument.
## @seealso{pol2cart, cart2sph, sph2cart}
## @end deftypefn

function [theta, r, z] = cart2pol (x, y, z = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    if (! (isnumeric (x) && ismatrix (x)))
      error ("cart2pol: matrix input must be 2-D numeric array");
    endif
    if (isvector (x))
      n = numel (x);
      if (n != 2 && n != 3)
        error ("cart2pol: matrix input must be a 2- or 3-element vector or a 2- or 3-column array");
      endif
      if (n == 3)
        z = x(3);
      endif
      y = x(2);
      x = x(1);
    else
      ncols = columns (x);
      if (ncols != 2 && ncols != 3)
        error ("cart2pol: matrix input must be a 2- or 3-element vector or a 2- or 3-column array");
      endif

      if (ncols == 3)
        z = x(:,3);
      endif
      y = x(:,2);
      x = x(:,1);
    endif

  elseif (nargin == 2)
    if (! (isnumeric (x) && isnumeric (y)))
      error ("cart2pol: X, Y must be numeric arrays or scalars");
    endif
    [err, x, y] = common_size (x, y);
    if (err)
      error ("cart2pol: X, Y must be the same size or scalars");
    endif

  elseif (nargin == 3)
    if (! (isnumeric (x) && isnumeric (y) && isnumeric (z)))
      error ("cart2pol: X, Y, Z must be numeric arrays or scalars");
    endif
    [err, x, y, z] = common_size (x, y, z);
    if (err)
      error ("cart2pol: X, Y, Z must be the same size or scalars");
    endif
  endif

  theta = atan2 (y, x);
  r = sqrt (x .^ 2 + y .^ 2);

endfunction


%!test
%! x = [0, 1, 2];
%! y = 0;
%! [t, r] = cart2pol (x, y);
%! assert (t, [0, 0, 0]);
%! assert (r, x);

%!test
%! x = [0, 1, 2];
%! y = [0, 1, 2];
%! [t, r] = cart2pol (x, y);
%! assert (t, [0, pi/4, pi/4], eps);
%! assert (r, sqrt (2)*[0, 1, 2], eps);

%!test
%! x = [0, 1, 2]';
%! y = [0, 1, 2]';
%! [t, r] = cart2pol (x, y);
%! assert (t, [0; pi/4; pi/4], eps);
%! assert (r, sqrt (2)*[0; 1; 2], eps);

%!test
%! x = [0, 1, 2];
%! y = [0, 1, 2];
%! z = [0, 1, 2];
%! [t, r, z2] = cart2pol (x, y, z);
%! assert (t, [0, pi/4, pi/4], sqrt (eps));
%! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
%! assert (z2, z);

%!test
%! x = [0, 1, 2];
%! y = 0;
%! z = 0;
%! [t, r, z2] = cart2pol (x, y, z);
%! assert (t, [0, 0, 0], eps);
%! assert (r, x, eps);
%! assert (z2, [0, 0, 0]);

%!test
%! x = 0;
%! y = [0, 1, 2];
%! z = 0;
%! [t, r, z2] = cart2pol (x, y, z);
%! assert (t, [0, 1, 1]*pi/2, eps);
%! assert (r, y, eps);
%! assert (z2, [0, 0, 0]);

%!test
%! x = 0;
%! y = 0;
%! z = [0, 1, 2];
%! [t, r, z2] = cart2pol (x, y, z);
%! assert (t, [0, 0, 0]);
%! assert (r, [0, 0, 0]);
%! assert (z2, z);

%!test
%! C = [0, 0; 1, 1; 2, 2];
%! [t, r] = cart2pol (C);
%! assert (t, [0; 1; 1]*pi/4, eps);
%! assert (r, [0; 1; 2]*sqrt(2), eps);

%!test
%! C = [0, 0, 0; 1, 1, 1; 2, 2, 2];
%! [t, r, z] = cart2pol (C);
%! assert (t, [0; 1; 1]*pi/4, eps);
%! assert (r, [0; 1; 2]*sqrt(2), eps);
%! assert (z, [0; 1; 2]);

%!test
%! C = [0, 0, 0; 1, 1, 1; 2, 2, 2;1, 1, 1];
%! [t, r, z] = cart2pol (C);
%! assert (t, [0; 1; 1; 1]*pi/4, eps);
%! assert (r, [0; 1; 2; 1]*sqrt(2), eps);
%! assert (z, [0; 1; 2; 1]);

%!test
%! x = zeros (1, 1, 1, 2);
%! x(1, 1, 1, 2) = sqrt (2);
%! y = x;
%! [t, r] = cart2pol (x, y);
%! T = zeros (1, 1, 1, 2);
%! T(1, 1, 1, 2) = pi/4;
%! R = zeros (1, 1, 1, 2);
%! R(1, 1, 1, 2) = 2;
%! assert (t, T, eps);
%! assert (r, R, eps);

%!test
%! [x, y, Z] = meshgrid ([0, 1], [0, 1], [0, 1]);
%! [t, r, z] = cart2pol (x, y, Z);
%! T(:, :, 1) = [0, 0; pi/2, pi/4];
%! T(:, :, 2) = T(:, :, 1);
%! R = sqrt (x.^2 + y.^2);
%! assert (t, T, eps);
%! assert (r, R, eps);
%! assert (z, Z);

## Test input validation
%!error <Invalid call> cart2pol ()
%!error cart2pol (1,2,3,4)
%!error <matrix input must be 2-D numeric array> cart2pol ({1,2,3})
%!error <matrix input must be 2-D numeric array> cart2pol (ones (3,3,2))
%!error <matrix input must be a 2- or 3-element> cart2pol ([1])
%!error <matrix input must be a 2- or 3-element> cart2pol ([1,2,3,4])
%!error <must be numeric arrays or scalars> cart2pol ({1,2,3}, [1,2,3])
%!error <must be numeric arrays or scalars> cart2pol ([1,2,3], {1,2,3})
%!error <must be the same size or scalars> cart2pol (ones (3,3,3), ones (3,2,3))
%!error <must be the same size or scalars> cart2pol ([1; 1], [2, 2])
%!error <must be the same size or scalars> cart2pol ([1; 1], [2, 2], [3, 3])
%!error <must be numeric arrays or scalars> cart2pol ({1,2,3}, [1,2,3], [1,2,3])
%!error <must be numeric arrays or scalars> cart2pol ([1,2,3], {1,2,3}, [1,2,3])
%!error <must be numeric arrays or scalars> cart2pol ([1,2,3], [1,2,3], {1,2,3})
%!error <must be the same size or scalars> cart2pol (ones (3,3,3), 1, ones (3,2,3))
%!error <must be the same size or scalars> cart2pol (ones (3,3,3), ones (3,2,3), 1)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{x}, @var{y}, @var{z})
## @deftypefnx {} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{C})
## Transform Cartesian coordinates to spherical coordinates.
##
## The inputs @var{x}, @var{y}, and @var{z} must be the same shape, or scalar.
## If called with a single matrix argument then each row of @var{C} must
## represent a Cartesian coordinate triplet (@var{x}, @var{y}, @var{z}).
##
## The outputs @var{theta}, @var{phi}, @var{r} match the shape of the inputs.
## For a matrix input @var{C} the outputs will be column vectors with rows
## corresponding to the rows of the input matrix.
##
## @var{theta} describes the azimuth angle relative to the positive x-axis
## measured in the xy-plane.
##
## @var{phi} is the elevation angle measured relative to the xy-plane.
##
## @var{r} is the distance to the origin @w{(0, 0, 0)}.
##
## The coordinate transformation is computed using:
##
## @tex
## $$ \theta = \arctan \left ({y \over x} \right ) $$
## $$ \phi = \arctan \left ( {z \over {\sqrt{x^2+y^2}}} \right ) $$
## $$ r = \sqrt{x^2 + y^2 + z^2} $$
## @end tex
## @ifnottex
##
## @example
## @group
## @var{theta} = arctan (@var{y} / @var{x})
## @var{phi} = arctan (@var{z} / sqrt (@var{x}^2 + @var{y}^2))
## @var{r} = sqrt (@var{x}^2 + @var{y}^2 + @var{z}^2)
## @end group
## @end example
##
## @end ifnottex
##
## @c FIXME: Remove this note in Octave 9.1 (two releases after 7.1).
## Note: For @sc{matlab} compatibility, this function no longer returns a full
## coordinate matrix when called with a single return argument.
## @seealso{sph2cart, cart2pol, pol2cart}
## @end deftypefn

function [theta, phi, r] = cart2sph (x, y, z)

  if (nargin != 1 && nargin != 3)
    print_usage ();
  endif

  if (nargin == 1)
    if (! (isnumeric (x) && ismatrix (x)))
      error ("cart2sph: matrix input C must be a 2-D numeric array");
    elseif (columns (x) != 3 && numel (x) != 3)
      error ("cart2sph: matrix input C must be a 3-element vector or 3-column array");
    endif

    if (numel (x) == 3)
      z = x(3);
      y = x(2);
      x = x(1);
    else
      z = x(:,3);
      y = x(:,2);
      x = x(:,1);
    endif

  else
    if (! (isnumeric (x) && isnumeric (y) && isnumeric (z)))
      error ("cart2sph: X, Y, Z must be numeric arrays or scalars");
    endif
    [err, x, y, z] = common_size (x, y, z);
    if (err)
      error ("cart2sph: X, Y, Z must be the same size or scalars");
    endif
  endif

  theta = atan2 (y, x);
  phi = atan2 (z, sqrt (x .^ 2 + y .^ 2));
  r = sqrt (x .^ 2 + y .^ 2 + z .^ 2);

endfunction


%!test
%! x = [0, 1, 2];
%! y = [0, 1, 2];
%! z = [0, 1, 2];
%! [t, p, r] = cart2sph (x, y, z);
%! assert (t, [0, pi/4, pi/4], eps);
%! assert (p, [0, 1, 1]*atan (sqrt (0.5)), eps);
%! assert (r, [0, 1, 2]*sqrt (3), eps);

%!test
%! x = [0; 1; 2];
%! y = [0; 1; 2];
%! z = [0; 1; 2];
%! [t, p, r] = cart2sph (x, y, z);
%! assert (t, [0; pi/4; pi/4], eps);
%! assert (p, [0; 1; 1] * atan (sqrt (0.5)), eps);
%! assert (r, [0; 1; 2] * sqrt (3), eps);

%!test
%! x = 0;
%! y = [0, 1, 2];
%! z = [0, 1, 2];
%! [t, p, r] = cart2sph (x, y, z);
%! assert (t, [0, 1, 1] * pi/2, eps);
%! assert (p, [0, 1, 1] * pi/4, eps);
%! assert (r, [0, 1, 2] * sqrt (2), eps);

%!test
%! x = [0, 1, 2];
%! y = 0;
%! z = [0, 1, 2];
%! [t, p, r] = cart2sph (x, y, z);
%! assert (t, [0, 0, 0]);
%! assert (p, [0, 1, 1] * pi/4, eps);
%! assert (r, [0, 1, 2] * sqrt (2), eps);

%!test
%! x = [0, 1, 2];
%! y = [0, 1, 2];
%! z = 0;
%! [t, p, r] = cart2sph (x, y, z);
%! assert (t, [0, 1, 1] * pi/4, eps);
%! assert (p, [0, 0, 0]);
%! assert (r, [0, 1, 2] * sqrt (2), eps);

%!test
%! x = 0;
%! y = 0;
%! z = [0, 1, 2];
%! [t, p, r] = cart2sph (x, y, z);
%! assert (t, [0, 0, 0]);
%! assert (p, [0, 1, 1] * pi/2, eps);
%! assert (r, [0, 1, 2]);

%!test
%! C = [0, 0, 0; 1, 0, 1; 2, 0, 2];
%! [t, p, r] = cart2sph (C);
%! assert (t, [0; 0; 0]);
%! assert (p, [0; 1; 1] * pi/4, eps);
%! assert (r, [0; 1; 2] * sqrt (2), eps);

%!test
%! C = [0, 0, 0; 1, 0, 1; 2, 0, 2; 1, 0, 1];
%! [t, p, r] = cart2sph (C);
%! assert (t, [0; 0; 0; 0]);
%! assert (p, [0; 1; 1; 1] * pi/4, eps);
%! assert (r, [0; 1; 2; 1] * sqrt (2), eps);

%!test
%! [x, y, z] = meshgrid ([0, 1], [0, 1], [0, 1]);
%! [t, p, r] = cart2sph (x, y, z);
%! T(:, :, 1) = [0, 0; pi/2, pi/4];
%! T(:, :, 2) = T(:, :, 1);
%! P(:, :, 1) = zeros (2, 2);
%! P(:, :, 2) = [pi/2, pi/4; pi/4, acos(sqrt(2/3))];
%! R = sqrt (x .^ 2 + y .^ 2 + z .^ 2);
%! assert (t, T, eps);
%! assert (p, P, eps);
%! assert (r, R, eps);

## Test input validation
%!error <Invalid call> cart2sph ()
%!error <Invalid call> cart2sph (1,2)
%!error <matrix input C must be a 2-D numeric array> cart2sph ({1,2,3})
%!error <matrix input C must be a 2-D numeric array> cart2sph (ones (3,3,2))
%!error <matrix input C must be a 3-element> cart2sph ([1,2,3,4])
%!error <matrix input C must be a 3-element> cart2sph ([1,2,3,4; 1,2,3,4; 1,2,3,4])
%!error <must be numeric arrays or scalars> cart2sph ({1,2,3}, [1,2,3], [1,2,3])
%!error <must be numeric arrays or scalars> cart2sph ([1,2,3], {1,2,3}, [1,2,3])
%!error <must be numeric arrays or scalars> cart2sph ([1,2,3], [1,2,3], {1,2,3})
%!error <must be the same size or scalars> cart2sph ([1,2,3], [1,2,3], [1,2,3]')
%!error <must be the same size or scalars> cart2sph (ones (3,3,3), 1, ones (3,2,3))
%!error <must be the same size or scalars> cart2sph (ones (3,3,3), ones (3,2,3), 1)
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{m} =} cell2mat (@var{c})
## Convert the cell array @var{c} into a matrix by concatenating all
## elements of @var{c} into a hyperrectangle.
##
## Elements of @var{c} must be numeric, logical, or char matrices; or cell
## arrays; or structs; and @code{cat} must be able to concatenate them
## together.
## @seealso{mat2cell, num2cell}
## @end deftypefn

function m = cell2mat (c)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (c))
    m = zeros (size (c));
  else
    if (! iscell (c))
      error ("cell2mat: C must be a cell array");
    endif

    ## Check first for valid matrix types
    valid = cellfun ("isnumeric", c);
    valid = cellfun ("islogical", c(! valid));
    valid = cellfun ("isclass", c(! valid), "char");
    if (! all (valid(:)))
      valid = cellfun ("isclass", c, "cell");
      if (! all (valid(:)))
        valid = cellfun ("isclass", c, "struct");
        if (! all (valid(:)))
          error ("cell2mat: wrong type elements or mixed cells, structs, and matrices");
        endif
      endif
    endif

    sz = size (c);
    if (all (cellfun ("numel", c)(:) == 1))
      ## Special case of all scalars
      m = reshape (cat (1, c{:}), sz);
    else
      ## The goal is to minimize the total number of cat() calls.
      ## The dimensions can be concatenated along in arbitrary order.
      ## The numbers of concatenations are:
      ## n / d1
      ## n / (d1 * d2)
      ## n / (d1 * d2 * d3)
      ## etc.
      ## This is minimized if d1 >= d2 >= d3...

      nd = ndims (c);
      [~, isz] = sort (sz, "descend");
      for idim = isz
        if (sz(idim) == 1)
          continue;
        endif
        xdim = [1:idim-1, idim+1:nd];
        cc = num2cell (c, xdim);
        c = cellfun ("cat", {idim}, cc{:}, "uniformoutput", false);
      endfor
      m = c{1};

    endif
  endif

endfunction


%!demo
%! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
%! cell2mat (C)

%!assert (cell2mat ({}), [])
%!assert (cell2mat ([]), [])
%!assert (cell2mat (cell (2,0)), zeros (2,0))
%!test
%! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
%! D = C; D(:,:,2) = C;
%! E = [1 2 3 4; 5 6 7 8; 9 10 11 12];
%! F = E; F(:,:,2) = E;
%! assert (cell2mat (C), E);
%! assert (cell2mat (D), F);
%!test
%! m = rand (10) + i * rand (10);
%! c = mat2cell (m, [1 2 3 4], [4 3 2 1]);
%! assert (cell2mat (c), m);
%!test
%! m = int8 (256*rand (4, 5, 6, 7, 8));
%! c = mat2cell (m, [1 2 1], [1 2 2], [3 1 1 1], [4 1 2], [3 1 4]);
%! assert (cell2mat (c), m);
%!test
%! m = {1, 2, 3};
%! assert (cell2mat (mat2cell (m, 1, [1 1 1])), m);

## cell2mat from cell into another cell
%!assert (cell2mat ({{"foo", "bar", "qux"}}), {"foo", "bar", "qux"})
%!assert (cell2mat ({{"foo"}, {"bar", "qux"}}), {"foo", "bar", "qux"})
%!assert (cell2mat ({{"foo"}; {"bar"; "qux"}}), {"foo"; "bar"; "qux"})
%!assert (cell2mat ({{"foo", "lol"}; {"bar", "qux"}}),
%!        {"foo", "lol"; "bar", "qux"})

## cell2mat cell strings
%!assert (cell2mat ({"foo", "lol"; "bar", "qux"}),
%!        reshape ("fboaorlqoulx", [2 6]))

%!error <Invalid call> cell2mat ()
%!error <C must be a cell array> cell2mat ([1,2])
%!error <mixed cells, structs, and matrices> cell2mat ({[1], struct()})
%!error <mixed cells, structs, and matrices> cell2mat ({[1], {1}})
%!error <mixed cells, structs, and matrices> cell2mat ({struct(), {1}})
%!error <dimension mismatch> cell2mat ({{"foo"}; {"bar", "qux"}})
%!error <dimension mismatch> cell2mat ({"foox", "lol"; "bar", "qux"})
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} celldisp (@var{c})
## @deftypefnx {} {} celldisp (@var{c}, @var{name})
## Recursively display the contents of a cell array.
##
## By default the values are displayed with the name of the variable @var{c}.
## However, this name can be replaced with the variable @var{name}.  For
## example:
##
## @example
## @group
## c = @{1, 2, @{31, 32@}@};
## celldisp (c, "b")
##    @result{}
##       b@{1@} =
##        1
##       b@{2@} =
##        2
##       b@{3@}@{1@} =
##        31
##       b@{3@}@{2@} =
##        32
## @end group
## @end example
##
## @seealso{disp}
## @end deftypefn

## This is ugly, but seems to be what matlab does..

function celldisp (c, name)

  if (nargin < 1)
    print_usage ();
  endif

  if (! iscell (c))
    error ("celldisp: C must be a cell array");
  endif

  if (nargin == 1)
    name = inputname (1);
  endif

  for i = 1: numel (c)
    if (iscell (c{i}))
      celldisp (c{i}, sprintf ("%s{%s}", name, indices (size (c), i)));
    else
      disp (sprintf ("%s{%s} = \n", name, indices (size (c), i)));
      disp (c{i});
      disp ("");
    endif
  endfor

endfunction

function s = indices (dv, i)

  if (sum (dv != 1) > 1)
    c = cell (size (dv));
    [c{:}] = ind2sub (dv, i);
    s = sprintf ("%i,", c{:});
    s(end) = [];
  else
    s = sprintf ("%i", i);
  endif

endfunction


%!demo
%! c = {1, 2, {31, 32}};
%! celldisp (c, "b")

## Test input validation
%!error <Invalid call> celldisp ()
%!error celldisp ({}, "name", 1)
%!error <C must be a cell array> celldisp (1)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} circshift (@var{x}, @var{n})
## @deftypefnx {} {@var{y} =} circshift (@var{x}, @var{n}, @var{dim})
## Circularly shift the values of the array @var{x}.
##
## @var{n} must be a vector of integers no longer than the number of dimensions
## in @var{x}.  The values of @var{n} can be either positive or negative, which
## determines the direction in which the values of @var{x} are shifted.  If an
## element of @var{n} is zero, then the corresponding dimension of @var{x} will
## not be shifted.  If @var{n} is a scalar and no @var{dim} is specified then
## the shift is applied to the first non-singular dimension.
##
## If a scalar @var{dim} is given then operate along the specified dimension.
## In this case @var{n} must be a scalar as well.
##
## Examples:
##
## @example
## x = [1, 2, 3;
##      4, 5, 6;
##      7, 8, 9];
## ## positive shift on rows (1st non-singular dim)
## circshift (x, 1)
##   @result{}
##        7   8   9
##        1   2   3
##        4   5   6
## ## negative shift on rows (1st non-singular dim)
## circshift (x, -2)
##   @result{}
##        7   8   9
##        1   2   3
##        4   5   6
## ## no shift of rows, shift columns by 1 (2nd dimension)
## circshift (x, [0,1])
##   @result{}
##        3   1   2
##        6   4   5
##        9   7   8
## ## shift columns (2nd dimension)
## circshift (x, 1, 2)
##   @result{}
##        3   1   2
##        6   4   5
##        9   7   8
## @end example
## @seealso{permute, ipermute, shiftdim}
## @end deftypefn

function y = circshift (x, n, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (isempty (x))
    y = x;
    return;
  endif

  nd = ndims (x);
  sz = size (x);

  if (nargin == 2)
    if (isscalar (n))
      ## Find the first non-singleton dimension.
      (dim = find (sz > 1, 1)) || (dim = 1);
      n = [zeros(1, dim-1), n];
    endif
  elseif (nargin == 3)
    if ( ! isscalar (n))
      error ("circshift: N must be a scalar when DIM is also specified");
    endif
    n = [zeros(1, dim-1), n];
  endif

  if (! isvector (n) || length (n) > nd)
    error ("circshift: N must be a vector, no longer than the number of dimensions in X");
  elseif (any (n != fix (n)))
    error ("circshift: all values of N must be integers");
  endif

  idx = repmat ({':'}, 1, nd);
  for i = 1:length (n)
    b = n(i);
    d = sz(i);
    if (b > 0)
      b = rem (b, d);
      idx{i} = [d-b+1:d, 1:d-b];
    elseif (b < 0)
      b = rem (abs (b), d);
      idx{i} = [b+1:d, 1:b];
    endif
  endfor

  y = x(idx{:});

endfunction


%!shared x
%! x = [1, 2, 3; 4, 5, 6; 7, 8, 9];

%!assert (circshift (x, 1), [7, 8, 9; 1, 2, 3; 4, 5, 6])
%!assert (circshift (x, -2), [7, 8, 9; 1, 2, 3; 4, 5, 6])
%!assert (circshift (x, [0, 1]), [3, 1, 2; 6, 4, 5; 9, 7, 8])
%!assert (circshift ([], 1), [])

%!assert (circshift (eye (3), 1), circshift (eye (3), 1))
%!assert (circshift (eye (3), 1), [0,0,1;1,0,0;0,1,0])

%!assert (circshift (x, -2, 1), [7, 8, 9; 1, 2, 3; 4, 5, 6])
%!assert (circshift (x, 1, 2), [3, 1, 2; 6, 4, 5; 9, 7, 8])

%!test <*53178> assert (circshift (1:4, 1), [4 1 2 3])
%!test <*53178> assert (circshift (1:4, 1, 1), 1:4)

## Test input validation
%!error <Invalid call> circshift ()
%!error <Invalid call> circshift (1)
%!error <N must be a scalar> circshift (1, [2 3], 4)
%!error <N must be a vector> circshift (1, ones (2,2))
%!error <no longer than the number of dimensions in X> circshift (1, [1 2 3])
%!error <all values of N must be integers> circshift (1, 1.5)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{err}, @var{yi}, @dots{}] =} common_size (@var{xi}, @dots{})
## Determine if all input arguments are either scalar or of common size.
##
## If true, @var{err} is zero, and @var{yi} is a matrix of the common size
## with all entries equal to @var{xi} if this is a scalar or @var{xi}
## otherwise.  If the inputs cannot be brought to a common size, @var{err} is
## 1, and @var{yi} is @var{xi}.  For example:
##
## @example
## @group
## [err, a, b] = common_size ([1 2; 3 4], 5)
##      @result{} err = 0
##      @result{} a = [ 1, 2; 3, 4 ]
##      @result{} b = [ 5, 5; 5, 5 ]
## @end group
## @end example
##
## @noindent
## This is useful for implementing functions where arguments can either be
## scalars or of common size.
## @seealso{size, size_equal, numel, ndims}
## @end deftypefn

function [err, varargout] = common_size (varargin)

  if (nargin < 2)
    error ("common_size: only makes sense if nargin >= 2");
  endif

  ## Find array args
  array = cellfun ("numel", varargin) != 1;
  aridx = find (array, 1);

  if (isempty (aridx))
    ## All inputs are scalars
    err = 0;
    varargout = varargin;
  else
    sz_eq = cellfun ("size_equal", varargin, varargin(aridx));
    if (any (! sz_eq & array))
      err = 1;
      varargout = varargin;
    else
      err = 0;
      if (nargout > 1)
        varargout = varargin;
        if (any (array))
          scalar = ! array;
          dims = size (varargin{aridx});
          subs = arrayfun (@ones, 1, dims, "uniformoutput", false);
          varargout(scalar) = cellindexmat (varargin(scalar), subs{:});
        endif
      endif
    endif
  endif

endfunction


%!test
%! m = [1,2;3,4];
%! [err, a, b, c] = common_size (m, 3, 5);
%! assert (err, 0);
%! assert (a, m);
%! assert (b, [3,3;3,3]);
%! assert (c, [5,5;5,5]);

%!test
%! m = [1,2;3,4];
%! [err, a, b, c] = common_size (m, [], 5);
%! assert (err, 1);
%! assert (a, m);
%! assert (b, []);
%! assert (c, 5);

## Test input validation
%!error <only makes sense if nargin .= 2> common_size ()
%!error <only makes sense if nargin .= 2> common_size (1)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} cplxpair (@var{z})
## @deftypefnx {} {} cplxpair (@var{z}, @var{tol})
## @deftypefnx {} {} cplxpair (@var{z}, @var{tol}, @var{dim})
## Sort the numbers @var{z} into complex conjugate pairs ordered by increasing
## real part.
##
## The negative imaginary complex numbers are placed first within each pair.
## All real numbers (those with
## @code{abs (imag (@var{z})) / abs (@var{z}) < @var{tol}}) are placed after
## the complex pairs.
##
## @var{tol} is a weighting factor in the range [0, 1) which determines the
## tolerance of the matching.  The default value is @code{100 * eps} and the
## resulting tolerance for a given complex pair is
## @code{@var{tol} * abs (@var{z}(i)))}.
##
## By default the complex pairs are sorted along the first non-singleton
## dimension of @var{z}.  If @var{dim} is specified, then the complex pairs are
## sorted along this dimension.
##
## Signal an error if some complex numbers could not be paired.  Signal an
## error if all complex numbers are not exact conjugates (to within @var{tol}).
## Note that there is no defined order for pairs with identical real parts but
## differing imaginary parts.
## @c Set example in small font to prevent overfull line
##
## @smallexample
## cplxpair (exp (2i*pi*[0:4]'/5)) == exp (2i*pi*[3; 2; 4; 1; 0]/5)
## @end smallexample
## @end deftypefn

## 2006-05-12 David Bateman - Modified for NDArrays

function y = cplxpair (z, tol, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (z))
    y = zeros (size (z));
    return;
  endif

  cls = ifelse (isa (z, "single"), "single", "double");
  if (nargin < 2 || isempty (tol))
    tol = 100*eps (cls);
  elseif (! isscalar (tol) || tol < 0 || tol >= 1)
    error ("cplxpair: TOL must be a scalar number in the range 0 <= TOL < 1");
  endif

  nd = ndims (z);
  if (nargin < 3)
    ## Find the first singleton dimension.
    sz = size (z);
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    dim = floor (dim);
    if (dim < 1 || dim > nd)
      error ("cplxpair: invalid dimension DIM");
    endif
  endif

  ## Move dimension to analyze to first position, and convert to a 2-D matrix.
  perm = [dim:nd, 1:dim-1];
  z = permute (z, perm);
  sz = size (z);
  n = sz(1);
  m = prod (sz) / n;
  z = reshape (z, n, m);

  ## Sort the sequence in terms of increasing real values.
  [~, idx] = sort (real (z), 1);
  z = z(idx + n * ones (n, 1) * [0:m-1]);

  ## Put the purely real values at the end of the returned list.
  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin (cls)) <= tol);
  ## Force values detected to be real within tolerance to actually be real.
  z(idxi + n*(idxj-1)) = real (z(idxi + n*(idxj-1)));
  q = sparse (idxi, idxj, 1, n, m);
  nr = sum (q, 1);
  [~, idx] = sort (q, 1);
  midx = idx + rows (idx) * ones (rows (idx), 1) * [0:columns(idx)-1];
  z = z(midx);
  y = z;

  ## For each remaining z, place the value and its conjugate at the start of
  ## the returned list, and remove them from further consideration.
  for j = 1:m
    p = n - nr(j);
    for i = 1:2:p
      if (i+1 > p)
        error ("cplxpair: could not pair all complex numbers");
      endif
      [v, idx] = min (abs (z(i+1:p,j) - conj (z(i,j))));
      if (v >= tol * abs (z(i,j)))
        error ("cplxpair: could not pair all complex numbers");
      endif
      ## For pairs, select the one with positive imaginary part and use it and
      ## it's conjugate, but list the negative imaginary pair first.
      if (imag (z(i,j)) > 0)
        y([i, i+1],j) = [conj(z(i,j)), z(i,j)];
      else
        y([i, i+1],j) = [conj(z(idx+i,j)), z(idx+i,j)];
      endif
      z(idx+i,j) = z(i+1,j);
    endfor
  endfor

  ## Reshape the output matrix.
  y = ipermute (reshape (y, sz), perm);

endfunction


%!demo
%! [ cplxpair(exp(2i*pi*[0:4]'/5)), exp(2i*pi*[3; 2; 4; 1; 0]/5) ]

%!assert (isempty (cplxpair ([])))
%!assert (cplxpair (1), 1)
%!assert (cplxpair ([1+1i, 1-1i]), [1-1i, 1+1i])
%!assert (cplxpair ([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), ...
%!                  [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
%!assert (cplxpair ([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), ...
%!                  [1-1i; 1+1i; 1-1i; 1+1i; 1; 2])
%!assert (cplxpair ([0, 1, 2]), [0, 1, 2])

%!shared z,y
%! z = exp (2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
%! z(2) = conj (z(1));
%! z(4) = conj (z(3));
%! z(6) = conj (z(5));
%!assert (cplxpair (z(randperm (7))), z)
%!assert (cplxpair (z(randperm (7))), z)
%!assert (cplxpair (z(randperm (7))), z)
%!assert (cplxpair ([z(randperm (7)), z(randperm (7))]), [z,z])
%!assert (cplxpair ([z(randperm (7)), z(randperm (7))],[],1), [z,z])
%!assert (cplxpair ([z(randperm (7)).'; z(randperm (7)).'],[],2), [z.';z.'])
%! y = [ -1-1i; -1+1i;-3; -2; 1; 2; 3];
%!assert (cplxpair ([z(randperm (7)), y(randperm (7))]), [z,y])
%!assert (cplxpair ([z(randperm (7)), y(randperm (7)),z(randperm (7))]),
%!        [z,y,z])

## Test tolerance
%!assert (cplxpair ([2000 * (1+eps) + 4j; 2000 * (1-eps) - 4j]),
%!        [(2000 - 4j); (2000 + 4j)], 100*eps(200))
%!error <could not pair>
%! cplxpair ([2000 * (1+eps) + 4j; 2000 * (1-eps) - 4j], 0);
%!error <could not pair>
%! cplxpair ([2e6 + j; 2e6 - j; 1e-9 * (1 + j); 1e-9 * (1 - 2j)]);

## Test input validation
%!error <Invalid call> cplxpair ()
%!error <cplxpair: TOL must be .* scalar number> cplxpair (1, ones (2,2))
%!error <cplxpair: TOL must be .* in the range 0 <= TOL < 1> cplxpair (1, -1)
%!error <cplxpair: TOL must be .* in the range 0 <= TOL < 1> cplxpair (1, -1)
%!error <invalid dimension DIM> cplxpair (1, [], 3)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} cumtrapz (@var{y})
## @deftypefnx {} {@var{q} =} cumtrapz (@var{x}, @var{y})
## @deftypefnx {} {@var{q} =} cumtrapz (@dots{}, @var{dim})
## Cumulative numerical integration of points @var{y} using the trapezoidal
## method.
##
## @w{@code{cumtrapz (@var{y})}} computes the cumulative integral of @var{y}
## along the first non-singleton dimension.  Where @code{trapz} reports only
## the overall integral sum, @code{cumtrapz} reports the current partial sum
## value at each point of @var{y}.
##
## When the argument @var{x} is omitted an equally spaced @var{x} vector with
## unit spacing (1) is assumed.  @code{cumtrapz (@var{x}, @var{y})} evaluates
## the integral with respect to the spacing in @var{x} and the values in
## @var{y}.  This is useful if the points in @var{y} have been sampled
## unevenly.
##
## If the optional @var{dim} argument is given, operate along this dimension.
##
## Application Note: If @var{x} is not specified then unit spacing will be
## used.  To scale the integral to the correct value you must multiply by the
## actual spacing value (deltaX).
## @seealso{trapz, cumsum}
## @end deftypefn

function z = cumtrapz (x, y, dim)

  if (nargin < 1)
    print_usage ();
  endif

  have_xy = have_dim = false;

  if (nargin == 3)
    have_xy = true;
    have_dim = true;
  elseif (nargin == 2)
    if (isscalar (y) && ! isscalar (x))
      have_dim = true;
      dim = y;
    else
      have_xy = true;
    endif
  endif

  if (have_xy)
    nd = ndims (y);
    sz = size (y);
  else
    nd = ndims (x);
    sz = size (x);
  endif

  if (! have_dim)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("trapz: DIM must be an integer and a valid dimension");
    endif
  endif

  n = sz(dim);
  idx1 = idx2 = {':'}(ones (nd, 1));  # repmat ({':'}, [nd, 1]), but faster
  idx1{dim} = 2 : n;
  idx2{dim} = 1 : (n - 1);

  if (! have_xy)
    z = 0.5 * cumsum (x(idx1{:}) + x(idx2{:}), dim);
  elseif (isscalar (x))
    z = x * 0.5 * cumsum (y(idx1{:}) + y(idx2{:}), dim);
  elseif (isvector (x))
    if (length (x) != n)
      error ("cumtrapz: length of X and length of Y along DIM must match");
    endif
      ## Reshape vector to point along dimension DIM
      shape = ones (nd, 1);
      shape(dim) = n;
      x = reshape (x, shape);
      z = 0.5 * cumsum (diff (x) .* (y(idx1{:}) + y(idx2{:})), dim);
  else
    if (! size_equal (x, y))
      error ("cumtrapz: X and Y must have same shape");
    endif
    z = 0.5 * cumsum (diff (x, 1, dim) .* (y(idx1{:}) + y(idx2{:})), dim);
  endif

  sz(dim) = 1;
  z = cat (dim, zeros (sz), z);

endfunction


%!shared x1, x2, y
%! x1 = [1:5];
%! x2 = [2:2:10];
%! y = [1:5];
%!
%!assert (cumtrapz (y), [0, 1.5, 4, 7.5, 12])
%!assert (cumtrapz (y'), [0, 1.5, 4, 7.5, 12]')
%!assert (cumtrapz (1, y), [0, 1.5, 4, 7.5, 12])
%!assert (cumtrapz (2, y), [0, 3, 8, 15, 24])
%!assert (cumtrapz (x1, y),[0, 1.5, 4, 7.5, 12])
%!assert (cumtrapz (x2, y),[0, 3, 8, 15, 24])
%!assert (cumtrapz (2, y, 2), [0, 3, 8, 15, 24])
%!assert (cumtrapz (x2, y, 2), [0, 3, 8, 15, 24])
%!assert (cumtrapz (y, 1), [0, 0, 0, 0, 0])
%!assert (cumtrapz (2, y, 1), [0, 0, 0, 0, 0])
%!assert (cumtrapz (y', 2), [0, 0, 0, 0, 0]')

%!shared x1, x2, y
%! x1 = [0,0,0;2,2,2];
%! x2 = [0,2,4;0,2,4];
%! y = [1,2,3;4,5,6];
%!
%!assert (cumtrapz (y), [0,0,0;2.5,3.5,4.5])
%!assert (cumtrapz (x1, y), [0,0,0;5,7,9])
%!assert (cumtrapz (y, 1), [0,0,0;2.5,3.5,4.5])
%!assert (cumtrapz (x1, y, 1), [0,0,0;5,7,9])
%!assert (cumtrapz (y, 2), [0,1.5,4;0,4.5,10])
%!assert (cumtrapz (x2, y, 2), [0,3,8;0,9,20])

## Test ND-array implementation
%!shared x1,x2,y
%! x1 = 1:3;
%! x2 = reshape ([0,2,4;0,2,4], [1 2 3]);
%! y = reshape ([1,2,3;4,5,6], [1 2 3]);
%!
%!assert (cumtrapz (y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
%!assert (cumtrapz (x1,y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
%!assert (cumtrapz (x2,y,3), reshape ([0,3,8;0,9,20],[1 2 3]))

## Test input validation
%!error <Invalid call> cumtrapz ()
%!error <DIM must be an integer> cumtrapz (1, 2, [1 2])
%!error <DIM must be an integer> cumtrapz (1, 2, 1.5)
%!error <DIM must be .* a valid dimension> cumtrapz (1, 2, 0)
%!error <length of X and length of Y.*must match> cumtrapz ([1 2], [1 2 3])
%!error <X and Y must have same shape> cumtrapz (ones (2,3), ones (2,4))

########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{cx}, @var{cy}, @var{cz}, @var{v}] =} curl (@var{x}, @var{y}, @var{z}, @var{fx}, @var{fy}, @var{fz})
## @deftypefnx {} {[@var{cz}, @var{v}] =} curl (@var{x}, @var{y}, @var{fx}, @var{fy})
## @deftypefnx {} {[@dots{}] =} curl (@var{fx}, @var{fy}, @var{fz})
## @deftypefnx {} {[@dots{}] =} curl (@var{fx}, @var{fy})
## @deftypefnx {} {@var{v} =} curl (@dots{})
## Calculate curl of vector field given by the arrays @var{fx}, @var{fy}, and
## @var{fz} or @var{fx}, @var{fy} respectively.
## @tex
## $$ curl F(x,y,z) = \left( {\partial{d} \over \partial{y}} F_z - {\partial{d} \over \partial{z}} F_y, {\partial{d} \over \partial{z}} F_x - {\partial{d} \over \partial{x}} F_z, {\partial{d} \over \partial{x}} F_y - {\partial{d} \over \partial{y}} F_x \right)$$
## @end tex
## @ifnottex
##
## @example
## @group
##                   / d         d       d         d       d         d     \
## curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
##                   \ dy        dz      dz        dx      dx        dy    /
## @end group
## @end example
##
## @end ifnottex
## The coordinates of the vector field can be given by the arguments @var{x},
## @var{y}, @var{z} or @var{x}, @var{y} respectively.  @var{v} calculates the
## scalar component of the angular velocity vector in direction of the z-axis
## for two-dimensional input.  For three-dimensional input the scalar
## rotation is calculated at each grid point in direction of the vector field
## at that point.
## @seealso{divergence, gradient, del2, cross}
## @end deftypefn

function varargout = curl (varargin)

  fidx = 1;
  if (nargin == 2)
    sz = size (varargin{fidx});
    dx = (1:sz(2))(:);
    dy = (1:sz(1))(:);
  elseif (nargin == 3)
    sz = size (varargin{fidx});
    dx = (1:sz(2))(:);
    dy = (1:sz(1))(:);
    dz = (1:sz(3))(:);
  elseif (nargin == 4)
    fidx = 3;
    dx = varargin{1}(1,:);
    dy = varargin{2}(:,1);
  elseif (nargin == 6)
    fidx = 4;
    dx = varargin{1}(1,:,1)(:);
    dy = varargin{2}(:,1,1)(:);
    dz = varargin{3}(1,1,:)(:);
  else
    print_usage ();
  endif

  if (nargin == 4 || nargin == 2)
    if (! size_equal (varargin{fidx}, varargin{fidx + 1}))
      error ("curl: size of X and Y must match");
    elseif (ndims (varargin{fidx}) != 2)
      error ("curl: X and Y must be 2-D matrices");
    elseif ((length (dx) != columns (varargin{fidx}))
         || (length (dy) != rows (varargin{fidx})))
      error ("curl: size of dx and dy must match the respective dimension of X and Y");
    endif

    dFx_dy = gradient (varargin{fidx}.', dy, dx).';
    dFy_dx = gradient (varargin{fidx + 1}, dx, dy);
    rot_z = dFy_dx - dFx_dy;
    av = rot_z / 2;
    if (nargout == 0 || nargout == 1)
      varargout{1} = av;
    else
      varargout{1} = rot_z;
      varargout{2} = av;
    endif

  elseif (nargin == 6 || nargin == 3)
    if (! size_equal (varargin{fidx}, varargin{fidx + 1}, varargin{fidx + 2}))
      error ("curl: size of X, Y, and Z must match");
    elseif (ndims (varargin{fidx}) != 3)
      error ("curl: X, Y, and Z must be 2-D matrices");
    elseif ((length (dx) != size (varargin{fidx}, 2))
         || (length (dy) != size (varargin{fidx}, 1))
         || (length (dz) != size (varargin{fidx}, 3)))
      error ("curl: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
    endif

    [~, dFx_dy, dFx_dz] = gradient (varargin{fidx}, dx, dy, dz);
    [dFy_dx, ~, dFy_dz] = gradient (varargin{fidx + 1}, dx, dy, dz);
    [dFz_dx, dFz_dy] = gradient (varargin{fidx + 2}, dx, dy, dz);
    rot_x = dFz_dy - dFy_dz;
    rot_y = dFx_dz - dFz_dx;
    rot_z = dFy_dx - dFx_dy;
    l = sqrt(varargin{fidx}.^2 + varargin{fidx + 1}.^2 + varargin{fidx + 2}.^2);
    av = (rot_x .* varargin{fidx} +
          rot_y .* varargin{fidx + 1} +
          rot_z .* varargin{fidx + 2}) ./ (2 * l);

    if (nargout == 0 || nargout == 1)
      varargout{1} = av;
    else
      varargout{1} = rot_x;
      varargout{2} = rot_y;
      varargout{3} = rot_z;
      varargout{4} = av;
    endif
  endif

endfunction


%!test
%! [X,Y] = meshgrid (-20:20,-22:22);
%! av = curl (2*(X-Y), Y);
%! assert (all (av(:) == 1));
%! [cz,av] = curl (2*(X-Y), Y);
%! assert (all (cz(:) == 2));
%! assert (all (av(:) == 1));
%! [cz,av] = curl (X/2, Y/2, 2*(X-Y), Y);
%! assert (all (cz(:) == 4));
%! assert (all (av(:) == 2));
%! assert (size_equal (X,Y,cz,av));
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dblquad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb})
## @deftypefnx {} {} dblquad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{tol})
## @deftypefnx {} {} dblquad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{tol}, @var{quadf})
## @deftypefnx {} {} dblquad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{tol}, @var{quadf}, @dots{})
## Numerically evaluate the double integral of @var{f}.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must have the form
## @math{z = f(x,y)} where @var{x} is a vector and @var{y} is a scalar.  It
## should return a vector of the same length and orientation as @var{x}.
##
## @var{xa}, @var{ya} and @var{xb}, @var{yb} are the lower and upper limits of
## integration for x and y respectively.  The underlying integrator determines
## whether infinite bounds are accepted.
##
## The optional argument @var{tol} defines the absolute tolerance used to
## integrate each sub-integral.  The default value is 1e-6.
##
## The optional argument @var{quadf} specifies which underlying integrator
## function to use.  Any choice but @code{quad} is available and the default
## is @code{quadcc}.
##
## Additional arguments, are passed directly to @var{f}.  To use the default
## value for @var{tol} or @var{quadf} one may pass @qcode{':'} or an empty
## matrix ([]).
## @seealso{integral2, integral3, triplequad, quad, quadv, quadl, quadgk,
##          quadcc, trapz}
## @end deftypefn

function q = dblquad (f, xa, xb, ya, yb, tol = 1e-6, quadf = @quadcc, varargin)

  if (nargin < 5)
    print_usage ();
  endif
  if (isempty (tol))
    tol = 1e-6;
  endif
  if (isempty (quadf))
    quadf = @quadcc;
  endif

  inner = @__dblquad_inner__;
  if (ischar (f))
    f = @(x,y) feval (f, x, y, varargin{:});
    varargin = {};
  endif

  q = feval (quadf, @(y) inner (y, f, xa, xb, tol, quadf,
                                varargin{:}), ya, yb, tol);

endfunction

function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
  q = zeros (size (y));
  for i = 1 : length (y)
    q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
  endfor
endfunction


## Nasty integrand to show quadcc off
%!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log (2), 1e-6)

%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadgk),
%!        pi * erf (1).^2, 1e-6)
%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadl),
%!        pi * erf (1).^2, 1e-6)
%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadv),
%!        pi * erf (1).^2, 1e-6)
########################################################################
##
## Copyright (C) 1998-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{r1}, @var{r2}, @dots{}, @var{rn}] =} deal (@var{a})
## @deftypefnx {} {[@var{r1}, @var{r2}, @dots{}, @var{rn}] =} deal (@var{a1}, @var{a2}, @dots{}, @var{an})
##
## Copy the input parameters into the corresponding output parameters.
##
## If only a single input parameter is supplied, its value is copied to each
## of the outputs.
##
## For example,
##
## @example
## [a, b, c] = deal (x, y, z);
## @end example
##
## @noindent
## is equivalent to
##
## @example
## @group
## a = x;
## b = y;
## c = z;
## @end group
## @end example
##
## @noindent
## and
##
## @example
## [a, b, c] = deal (x);
## @end example
##
## @noindent
## is equivalent to
##
## @example
## a = b = c = x;
## @end example
##
## Programming Note: @code{deal} is often used with comma separated lists
## derived from cell arrays or structures.  This is unnecessary as the
## interpreter can perform the same action without the overhead of a function
## call.  For example:
##
## @example
## @group
## c = @{[1 2], "Three", 4@};
## [x, y, z] = c@{:@}
## @result{}
##    x =
##
##       1   2
##
##    y = Three
##    z =  4
## @end group
## @end example
## @seealso{cell2struct, struct2cell, repmat}
## @end deftypefn

function varargout = deal (varargin)

  if (nargin == 0)
    print_usage ();
  elseif (nargin == 1 || nargin == nargout)
    varargout(1:nargout) = varargin;
  else
    error ("deal: nargin > 1 and nargin != nargout");
  endif

endfunction


%!test
%! [a,b] = deal (1,2);
%! assert (a, 1);
%! assert (b, 2);
%!test
%! [a,b] = deal (1);
%! assert (a, 1);
%! assert (b, 1);

## Test input validation
%!error <Invalid call> deal ()
%!error <nargin . 1 and nargin != nargout> y = deal (1, 2)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{rad} =} deg2rad (@var{deg})
##
## Convert degrees to radians.
##
## The input @var{deg} must be a scalar, vector, or N-dimensional array of
## double or single floating point values.  @var{deg} may be complex in which
## case the real and imaginary components are converted separately.
##
## The output @var{rad} is the same size and shape as @var{deg} with degrees
## converted to radians using the conversion constant @code{pi/180}.
##
## Example:
##
## @example
## @group
## deg2rad ([0, 90, 180, 270, 360])
##   @result{}  0.00000   1.57080   3.14159   4.71239   6.28319
## @end group
## @end example
## @seealso{rad2deg}
## @end deftypefn

function rad = deg2rad (deg)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isfloat (deg))
    error ("deg2rad: DEG must be a floating point class (double or single)");
  endif

  rad = deg * (pi / 180);

endfunction


%!assert (deg2rad (0), 0)
%!assert (deg2rad (90), pi/2)
%!assert (deg2rad (180), pi)
%!assert (deg2rad ([0, 90, 180, 270, 360]), pi*[0, 1/2, 1, 3/2, 2])

## Test input validation
%!error <Invalid call> deg2rad ()
%!error <DEG must be a floating point class> deg2rad (uint8 (1))
%!error <DEG must be a floating point class> deg2rad ("A")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{L} =} del2 (@var{M})
## @deftypefnx {} {@var{L} =} del2 (@var{M}, @var{h})
## @deftypefnx {} {@var{L} =} del2 (@var{M}, @var{dx}, @var{dy}, @dots{})
##
## Calculate the discrete Laplace
## @tex
## operator $( \nabla^2 )$.
## @end tex
## @ifnottex
## operator.
## @end ifnottex
##
## For a 2-dimensional matrix @var{M} this is defined as
## @tex
## $$L = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$$
## @end tex
## @ifnottex
##
## @example
## @group
##       1    / d^2            d^2         \
## L  = --- * | ---  M(x,y) +  ---  M(x,y) |
##       4    \ dx^2           dy^2        /
## @end group
## @end example
##
## @end ifnottex
## For N-dimensional arrays the sum in parentheses is expanded to include
## second derivatives over the additional higher dimensions.
##
## The spacing between evaluation points may be defined by @var{h}, which is a
## scalar defining the equidistant spacing in all dimensions.  Alternatively,
## the spacing in each dimension may be defined separately by @var{dx},
## @var{dy}, etc.  A scalar spacing argument defines equidistant spacing,
## whereas a vector argument can be used to specify variable spacing.  The
## length of the spacing vectors must match the respective dimension of
## @var{M}.  The default spacing value is 1.
##
## Dimensions with fewer than 3 data points are skipped.  Boundary points are
## calculated from the linear extrapolation of interior points.
##
## Example: Second derivative of 2*x^3
##
## @example
## @group
## f = @@(x) 2*x.^3;
## dd = @@(x) 12*x;
## x = 1:6;
## L = 4*del2 (f(x));
## assert (L, dd (x));
## @end group
## @end example
##
## @seealso{gradient, diff}
## @end deftypefn

function L = del2 (M, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  nd = ndims (M);
  sz = size (M);
  dx = cell (1, nd);
  if (nargin == 1)
    for i = 1 : nd
      dx(i) = ones (sz(i), 1);
    endfor
  elseif (nargin == 2 && isscalar (varargin{1}))
    h = varargin{1};
    for i = 1 : nd
      dx(i) = h * ones (sz(i), 1);
    endfor
  elseif (numel (varargin) <= nd)
    ndx = numel (varargin);
    varargin(ndx+1:nd) = 1;   # Fill missing dims with 1.
    ## Reverse dx{1} and dx{2} as the X-dim is the 2nd dim of a meshgrid array
    varargin([1, 2]) = varargin([2, 1]);
    for i = 1 : nd
      arg = varargin{i};
      if (isscalar (arg))
        dx(i) = arg * ones (sz(i), 1);
      elseif (isvector (arg))
        if (length (arg) != sz(i))
          error ("del2: number of elements in spacing vector %d does not match dimension %d of M", i, i);
        endif
        dx(i) = diff (varargin{i})(:);
      else
        error ("del2: spacing element %d must be a scalar or vector", i);
      endif
    endfor
  else
    print_usage ();
  endif

  idx = cell (1, nd);
  idx(:) = ":";

  L = zeros (sz);
  for i = 1 : nd
    if (sz(i) >= 3)
      DD = zeros (sz);
      idx1 = idx2 = idx3 = idx;

      ## interior points
      idx1{i} = 1 : sz(i) - 2;
      idx2{i} = 2 : sz(i) - 1;
      idx3{i} = 3 : sz(i);
      szi = sz;
      szi(i) = 1;

      h1 = repmat (shiftdim (dx{i}(1 : sz(i) - 2), 1 - i), szi);
      h2 = repmat (shiftdim (dx{i}(2 : sz(i) - 1), 1 - i), szi);
      DD(idx2{:}) = ((M(idx1{:}) - M(idx2{:})) ./ h1 + ...
                     (M(idx3{:}) - M(idx2{:})) ./ h2) ./ (h1 + h2);

      ## left and right boundary
      if (sz(i) == 3)
        DD(idx1{:}) = DD(idx3{:}) = DD(idx2{:});
      else
        idx1{i} = 1;
        idx2{i} = 2;
        idx3{i} = 3;
        DD(idx1{:}) = (dx{i}(1) + dx{i}(2)) / dx{i}(2) * DD(idx2{:}) - ...
            dx{i}(1) / dx{i}(2) * DD(idx3{:});

        idx1{i} = sz(i);
        idx2{i} = sz(i) - 1;
        idx3{i} = sz(i) - 2;
        DD(idx1{:}) = (dx{i}(sz(i) - 1) + dx{i}(sz(i) - 2)) / ...
            dx{i}(sz(i) - 2) * DD(idx2{:}) - ...
            dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD(idx3{:});
      endif

      L += DD;
    endif
  endfor

  L ./= nd;

endfunction


## 3x3 constant test
%!test
%! a = ones (3,3);
%! b = del2 (a);
%! assert (b(:,1), [0.00;0.00;0.00]);
%! assert (b(:,2), [0.00;0.00;0.00]);
%! assert (b(:,3), [0.00;0.00;0.00]);

## 3x3 planar test
%!test
%! a = [1,2,3;2,3,4;3,4,5];
%! b = del2 (a);
%! assert (b(:,1), [0.00;0.00;0.00]);
%! assert (b(:,2), [0.00;0.00;0.00]);
%! assert (b(:,3), [0.00;0.00;0.00]);

## 3x3 corner test
%!test
%! a = zeros (3,3);
%! a(1,1) = 1.0;
%! b = 2*del2 (a);
%! assert (b(:,1), [1.00;0.50;0.50]);
%! assert (b(:,2), [0.50;0.00;0.00]);
%! assert (b(:,3), [0.50;0.00;0.00]);
%! assert (b, flipud (2*del2 (flipud (a))));
%! assert (b, fliplr (2*del2 (fliplr (a))));
%! assert (b, flipud (fliplr (2*del2 (fliplr (flipud (a))))));

## 3x3 boundary test
%!test
%! a = zeros (3,3);
%! a(2,1)=1.0;
%! b = 2*del2 (a);
%! assert (b(:,1), [-1.00;-0.50;-1.00]);
%! assert (b(:,2), [0.00;0.50;0.00]);
%! assert (b(:,3), [0.00;0.50;0.00]);
%! assert (b, flipud (2*del2 (flipud (a))));
%! assert (b, fliplr (2*del2 (fliplr (a))));
%! assert (b, flipud (fliplr (2*del2 (fliplr (flipud (a))))));

## 3x3 center test
%!test
%! a = zeros (3,3);
%! a(2,2) = 1.0;
%! b = del2 (a);
%! assert (b(:,1), [0.00;-0.50;0.00]);
%! assert (b(:,2), [-0.50;-1.00;-0.50]);
%! assert (b(:,3), [0.00;-0.50;0.00]);

## 4x4 constant test
%!test
%! a = ones (4,4);
%! b = del2 (a);
%! assert (b(:,1), [0.00;0.00;0.00;0.00]);
%! assert (b(:,2), [0.00;0.00;0.00;0.00]);
%! assert (b(:,3), [0.00;0.00;0.00;0.00]);
%! assert (b(:,4), [0.00;0.00;0.00;0.00]);

## 4x4 planar test
%!test
%! a = [1,2,3,4;2,3,4,5;3,4,5,6;4,5,6,7];
%! b = del2 (a);
%! assert (b(:,1), [0.00;0.00;0.00;0.00]);
%! assert (b(:,2), [0.00;0.00;0.00;0.00]);
%! assert (b(:,3), [0.00;0.00;0.00;0.00]);
%! assert (b(:,4), [0.00;0.00;0.00;0.00]);

## 4x4 corner test
%!test
%! a = zeros (4,4);
%! a(1,1) = 1.0;
%! b = 2*del2 (a);
%! assert (b(:,1), [2.00;0.50;0.00;-0.50]);
%! assert (b(:,2), [0.50;0.00;0.00;0.00]);
%! assert (b(:,3), [0.00;0.00;0.00;0.00]);
%! assert (b(:,4), [-0.50;0.00;0.00;0.00]);
%! assert (b, flipud (2*del2 (flipud (a))));
%! assert (b, fliplr (2*del2 (fliplr (a))));
%! assert (b, flipud (fliplr (2*del2 (fliplr (flipud (a))))));

## 9x9 center test
%!test
%! a = zeros (9,9);
%! a(5,5) = 1.0;
%! b = 2*del2 (a);
%! assert (b(:,1), [0.00;0.00;0.00;0.00;0.00;0.00;0.00;0.00;0.00]);
%! assert (b(:,2), [0.00;0.00;0.00;0.00;0.00;0.00;0.00;0.00;0.00]);
%! assert (b(:,3), [0.00;0.00;0.00;0.00;0.00;0.00;0.00;0.00;0.00]);
%! assert (b(:,4), [0.00;0.00;0.00;0.00;0.50;0.00;0.00;0.00;0.00]);
%! assert (b(:,5), [0.00;0.00;0.00;0.50;-2.00;0.50;0.00;0.00;0.00]);
%! assert (b(:,6), b(:,4));
%! assert (b(:,7), b(:,3));
%! assert (b(:,8), b(:,2));
%! assert (b(:,9), b(:,1));

## 9x9 boundary test
%!test
%! a = zeros (9,9);
%! a(1,5) = 1.0;
%! b = 2*del2 (a);
%! assert (b(1,:), [0.00,0.00,0.00,0.50,0.00,0.50,0.00,0.00,0.00]);
%! assert (b(2,:), [0.00,0.00,0.00,0.00,0.50,0.00,0.00,0.00,0.00]);
%! assert (b(3:9,:), zeros (7,9));
%! a(1,5) = 0.0;
%! a(5,1) = 1.0;
%! b = 2*del2 (a);
%! assert (b(:,1), [0.00;0.00;0.00;0.50;0.00;0.50;0.00;0.00;0.00]);
%! assert (b(:,2), [0.00;0.00;0.00;0.00;0.50;0.00;0.00;0.00;0.00]);
%! assert (b(:,3:9), zeros (9,7));

## 9x9 dh center test
%!test
%! a = zeros (9,9);
%! a(5,5) = 1.0;
%! b = 8*del2 (a,2);
%! assert (b(:,1:3), zeros (9,3));
%! assert (b(:,4), [0.00;0.00;0.00;0.00;0.50;0.00;0.00;0.00;0.00]);
%! assert (b(:,5), [0.00;0.00;0.00;0.50;-2.00;0.50;0.00;0.00;0.00]);
%! assert (b(:,6), b(:,4));
%! assert (b(:,7:9), zeros (9,3));

## 9x9 dx test
%!test
%! a = zeros (9,9);
%! a(5,5) = 1.0;
%! b = 4*del2 (a,2,1);
%! assert (b(1:3,:), zeros (3,9));
%! assert (b(4,:), [0.00;0.00;0.00;0.00;1.00;0.00;0.00;0.00;0.00]');
%! assert (b(5,:), [0.00;0.00;0.00;0.25;-2.5;0.25;0.00;0.00;0.00]');
%! assert (b(6,:), b(4,:));
%! assert (b(7:9,:), zeros (3,9));

## 9x9 dy test
%!test
%! a = zeros (9,9);
%! a(5,5) = 1.0;
%! b = 4*del2 (a,1,2);
%! assert (b(:,1:3), zeros (9,3));
%! assert (b(:,4), [0.00;0.00;0.00;0.00;1.00;0.00;0.00;0.00;0.00]);
%! assert (b(:,5), [0.00;0.00;0.00;0.25;-2.5;0.25;0.00;0.00;0.00]);
%! assert (b(:,6), b(:,4));
%! assert (b(:,7:9), zeros (9,3));

## 3D test
%!test
%! a = zeros (9,9,9);
%! a(5,5,5) = 1.0;
%! b = 8*3*del2 (a,2);
%! assert (b(:,:,1:3), zeros (9,9,3));
%! assert (b(:,1:3,:), zeros (9,3,9));
%! assert (b(1:3,:,:), zeros (3,9,9));
%! assert (b(4:5,4,4), [0.0,0.0]');
%! assert (b(5,5,4), 1.00);
%! assert (b(4,4,5), 0.00);
%! assert (b(5,4,5), 1.00);
%! assert (b(5,5,5),-6.00);
%! assert (b, flip (b,1));
%! assert (b, flip (b,2));
%! assert (b, flip (b,3));

%!test <*51728>
%! x = linspace (-2*pi, 2*pi);
%! U = cos (x);
%! L = 4*del2 (U, x);

## Test input validation
%!error <Invalid call> del2 ()
%!error <Invalid call> del2 (1, 1, 2, 3)
%!error <in spacing vector 1> del2 (1, 2, [1 1])
%!error <in spacing vector 2> del2 (1, [1 1], 2)
%!error <must be a scalar or vector> del2 (1, ones (2,2), 2)

########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{div} =} divergence (@var{x}, @var{y}, @var{z}, @var{fx}, @var{fy}, @var{fz})
## @deftypefnx {} {@var{div} =} divergence (@var{fx}, @var{fy}, @var{fz})
## @deftypefnx {} {@var{div} =} divergence (@var{x}, @var{y}, @var{fx}, @var{fy})
## @deftypefnx {} {@var{div} =} divergence (@var{fx}, @var{fy})
## Calculate divergence of a vector field given by the arrays @var{fx},
## @var{fy}, and @var{fz} or @var{fx}, @var{fy} respectively.
##
## @tex
## $$
## div F(x,y,z) = \partial_x{F} + \partial_y{F} + \partial_z{F}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                   d               d               d
## div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
##                   dx              dy              dz
## @end group
## @end example
##
## @end ifnottex
## The coordinates of the vector field can be given by the arguments @var{x},
## @var{y}, @var{z} or @var{x}, @var{y} respectively.
##
## @seealso{curl, gradient, del2, dot}
## @end deftypefn

function retval = divergence (varargin)

  fidx = 1;
  if (nargin == 2)
    sz = size (varargin{fidx});
    dx = (1:sz(2))(:);
    dy = (1:sz(1))(:);
  elseif (nargin == 3)
    sz = size (varargin{fidx});
    dx = 1:sz(2);
    dy = 1:sz(1);
    dz = 1:sz(3);
  elseif (nargin == 4)
    fidx = 3;
    dx = varargin{1}(1,:);
    dy = varargin{2}(:,1);
  elseif (nargin == 6)
    fidx = 4;
    dx = varargin{1}(1,:,1)(:);
    dy = varargin{2}(:,1,1)(:);
    dz = varargin{3}(1,1,:)(:);
  else
    print_usage ();
  endif

  if (nargin == 4 || nargin == 2)
    if (! size_equal (varargin{fidx},varargin{fidx + 1}))
      error ("divergence: size of X and Y must match");
    elseif (ndims (varargin{fidx}) != 2)
      error ("divergence: X and Y must be 2-D matrices");
    elseif (length (dx) != columns (varargin{fidx})
            || length (dy) != rows (varargin{fidx}))
      error ("divergence: size of dx and dy must match the respective dimension of X and Y");
    endif

    retval = gradient (varargin{fidx}, dx, dy);
    retval += gradient (varargin{fidx + 1}.', dy, dx).';

  elseif (nargin == 6 || nargin == 3)
    if (! size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
      error ("divergence: size of X, Y, and Z must match");
    elseif (ndims (varargin{fidx}) != 3)
      error ("divergence: X, Y, and Z must be 2-D matrices");
    elseif ((length (dx) != size (varargin{fidx}, 2))
         || (length (dy) != size (varargin{fidx}, 1))
         || (length (dz) != size (varargin{fidx}, 3)))
      error ("divergence: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
    endif

    ## x-direction
    retval = gradient (varargin{fidx}, dx, dy, dz);
    ## y-direction
    retval += shiftdim (gradient (shiftdim (varargin{fidx + 1}, 2), dy), 1);
    ## z-direction
    retval += shiftdim (gradient (shiftdim (varargin{fidx + 2}, 1), dz), 2);
  endif

endfunction


%!test
%! [X,Y] = meshgrid (-20:20,-22:22);
%! div = divergence (X-Y,Y);
%! assert (all (div(:) == 2));
%! assert (size_equal (X,Y,div));
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} flip (@var{x})
## @deftypefnx {} {} flip (@var{x}, @var{dim})
## Return a copy of array @var{x} flipped across dimension @var{dim}.
##
## If @var{dim} is unspecified it defaults to the first non-singleton
## dimension.
##
## Examples:
##
## @example
## ## row vector
## flip ([1  2  3  4])
##       @result{}  4  3  2  1
##
## ## column vector
## flip ([1; 2; 3; 4])
##       @result{}  4
##           3
##           2
##           1
##
## ## 2-D matrix along dimension 1
## flip ([1 2; 3 4])
##       @result{}  3  4
##           1  2
##
## ## 2-D matrix along dimension 2
## flip ([1 2; 3 4], 2)
##       @result{}  2  1
##           4  3
## @end example
##
## @seealso{fliplr, flipud, rot90, rotdim, permute, transpose}
## @end deftypefn

function y = flip (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin == 1)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  elseif (! (isscalar (dim) && isindex (dim)))
    error ("flip: DIM must be a positive integer");
  endif

  idx(1:max(nd, dim)) = {':'};
  idx{dim} = size (x, dim):-1:1;
  y = x(idx{:});

endfunction


%!assert (flip ([1 2; 3 4], 2), [2 1; 4 3])
%!assert (flip ([1 2; 3 4], 3), [1 2; 3 4])

## Test defaults
%!assert (flip ([1 2 3 4]), [4 3 2 1])
%!assert (flip ([1 2 3 4].'), [4 3 2 1].')
%!assert (flip ([1 2; 3 4]), flip ([1 2 ; 3 4], 1))

## Test NDArrays
%!test
%! a(1:2,1:2,1) = [1 2; 3 4];
%! a(1:2,1:2,2) = [5 6; 7 8];
%! b(1:2,1:2,1) = [5 6; 7 8];
%! b(1:2,1:2,2) = [1 2; 3 4];
%! assert (flip (a, 3), b);

%!test
%! a = b = zeros (2, 2, 1, 2);
%! a(1:2,1:2,:,1) = [1 2; 3 4];
%! a(1:2,1:2,:,2) = [5 6; 7 8];
%! b(1:2,1:2,:,1) = [5 6; 7 8];
%! b(1:2,1:2,:,2) = [1 2; 3 4];
%! assert (flip (a, 3), a);
%! assert (flip (a, 4), b);
%! assert (flip (a, 5), a);

%!error <Invalid call> flip ()
%!error <DIM must be a positive integer> flip (magic (3), -1)
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} fliplr (@var{x})
## Flip array left to right.
##
## Return a copy of @var{x} with the order of the columns reversed.  In other
## words, @var{x} is flipped left-to-right about a vertical axis.  For example:
##
## @example
## @group
## fliplr ([1, 2; 3, 4])
##      @result{}  2  1
##          4  3
## @end group
## @end example
##
## @seealso{flipud, flip, rot90, rotdim}
## @end deftypefn

function y = fliplr (x)

  if (nargin < 1)
    print_usage ();
  endif

  y = flip (x, 2);

endfunction


%!assert (fliplr ([1, 2; 3, 4]), [2, 1; 4, 3])
%!assert (fliplr ([1, 2; 3, 4; 5, 6]), [2, 1; 4, 3; 6, 5])
%!assert (fliplr ([1, 2, 3; 4, 5, 6]), [3, 2, 1; 6, 5, 4])
%!assert (fliplr ([1 2 3].'), [1 2 3].')

## Test NDArrays
%!test
%! a(:,:,1) = [ 1  2;  3  4;  5  6];
%! a(:,:,2) = [ 7  8;  9 10; 11 12];
%! b(:,:,1) = [ 2  1;  4  3;  6  5];
%! b(:,:,2) = [ 8  7; 10  9; 12 11];
%! assert (fliplr (a), b);

## Test NDArray with singleton dimensions
%!test
%! a(:,:,:,1) = [ 1  2;  3  4;  5  6];
%! a(:,:,:,2) = [ 7  8;  9 10; 11 12];
%! b(:,:,:,1) = [ 2  1;  4  3;  6  5];
%! b(:,:,:,2) = [ 8  7; 10  9; 12 11];
%! assert (fliplr (a), b);

## Test for 1 row, i.e., returns the same
%!test
%! a(:,1,:,1) = [ 1  2  3  4];
%! a(:,1,:,2) = [ 5  6  7  8];
%! assert (fliplr (a), a);

## Test input validation
%!error <Invalid call> fliplr ()
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} flipud (@var{x})
## Flip array upside down.
##
## Return a copy of @var{x} with the order of the rows reversed.  In other
## words, @var{x} is flipped upside-down about a horizontal axis.  For example:
##
## @example
## @group
## flipud ([1, 2; 3, 4])
##      @result{}  3  4
##          1  2
## @end group
## @end example
##
## @seealso{fliplr, flip, rot90, rotdim}
## @end deftypefn

function y = flipud (x)

  if (nargin < 1)
    print_usage ();
  endif
  y = flip (x, 1);

endfunction


%!assert (flipud ([1, 2; 3, 4]), [3, 4; 1, 2])
%!assert (flipud ([1, 2; 3, 4; 5, 6]), [5, 6; 3, 4; 1, 2])
%!assert (flipud ([1, 2, 3; 4, 5, 6]), [4, 5, 6; 1, 2, 3])
%!assert (flipud ([1 2 3]), [1 2 3])

## Test NDArrays
%!test
%! a(:,:,1) = [ 1  2  3;  4  5  6];
%! a(:,:,2) = [ 7  8  9; 10 11 12];
%! b(:,:,1) = [ 4  5  6;  1  2  3];
%! b(:,:,2) = [10 11 12;  7  8  9];
%! assert (flipud (a), b);

## Test NDArray with singleton dimensions
%!test
%! a(:,:,:,1) = [ 1  2  3;  4  5  6];
%! a(:,:,:,2) = [ 7  8  9; 10 11 12];
%! b(:,:,:,1) = [ 4  5  6;  1  2  3];
%! b(:,:,:,2) = [10 11 12;  7  8  9];
%! assert (flipud (a), b);

## Test for 1 row, i.e., returns the same
%!test
%! a(1,:,:,1) = [ 1  2  3  4];
%! a(1,:,:,2) = [ 5  6  7  8];
%! assert (flipud (a), a);

%!error <Invalid call> flipud ()
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{dx} =} gradient (@var{m})
## @deftypefnx {} {[@var{dx}, @var{dy}, @var{dz}, @dots{}] =} gradient (@var{m})
## @deftypefnx {} {[@dots{}] =} gradient (@var{m}, @var{s})
## @deftypefnx {} {[@dots{}] =} gradient (@var{m}, @var{x}, @var{y}, @var{z}, @dots{})
## @deftypefnx {} {[@dots{}] =} gradient (@var{f}, @var{x0})
## @deftypefnx {} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{s})
## @deftypefnx {} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{x}, @var{y}, @dots{})
##
## Calculate the gradient of sampled data or a function.
##
## If @var{m} is a vector, calculate the one-dimensional gradient of @var{m}.
## If @var{m} is a matrix the gradient is calculated for each dimension.
##
## @code{[@var{dx}, @var{dy}] = gradient (@var{m})} calculates the
## one-dimensional gradient for @var{x} and @var{y} direction if @var{m} is a
## matrix.  Additional return arguments can be use for multi-dimensional
## matrices.
##
## A constant spacing between two points can be provided by the @var{s}
## parameter.  If @var{s} is a scalar, it is assumed to be the spacing for all
## dimensions.  Otherwise, separate values of the spacing can be supplied by
## the @var{x}, @dots{} arguments.  Scalar values specify an equidistant
## spacing.  Vector values for the @var{x}, @dots{} arguments specify the
## coordinate for that dimension.  The length must match their respective
## dimension of @var{m}.
##
## At boundary points a linear extrapolation is applied.  Interior points
## are calculated with the first approximation of the numerical gradient
##
## @example
## y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).
## @end example
##
## If the first argument @var{f} is a function handle, the gradient of the
## function at the points in @var{x0} is approximated using central difference.
## For example, @code{gradient (@@cos, 0)} approximates the gradient of the
## cosine function in the point @math{x0 = 0}.  As with sampled data, the
## spacing values between the points from which the gradient is estimated can
## be set via the @var{s} or @var{dx}, @var{dy}, @dots{} arguments.  By default
## a spacing of 1 is used.
## @seealso{diff, del2}
## @end deftypefn

function varargout = gradient (m, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  nargout_with_ans = max (1,nargout);
  if (isnumeric (m))
    [varargout{1:nargout_with_ans}] = matrix_gradient (m, varargin{:});
  elseif (is_function_handle (m))
    [varargout{1:nargout_with_ans}] = handle_gradient (m, varargin{:});
  elseif (ischar (m))
    [varargout{1:nargout_with_ans}] = handle_gradient (str2func (m), ...
                                                       varargin{:});
  else
    error ("gradient: first input must be an array or a function");
  endif

endfunction

function varargout = matrix_gradient (m, varargin)

  transposed = false;
  if (isvector (m))
    ## make a row vector.
    transposed = (columns (m) == 1);
    m = m(:).';
  endif

  nd = ndims (m);
  sz = size (m);
  if (length (sz) > 1)
    tmp = sz(1); sz(1) = sz(2); sz(2) = tmp;
  endif

  if (nargin > 2 && nargin != nd + 1)
    print_usage ("gradient");
  endif

  ## cell d stores a spacing vector for each dimension
  d = cell (1, nd);
  if (nargin == 1)
    ## no spacing given - assume 1.0 for all dimensions
    for i = 1:nd
      d{i} = ones (sz(i) - 1, 1);
    endfor
  elseif (nargin == 2)
    if (isscalar (varargin{1}))
      ## single scalar value for all dimensions
      for i = 1:nd
        d{i} = varargin{1} * ones (sz(i) - 1, 1);
      endfor
    else
      ## vector for one-dimensional derivative
      d{1} = diff (varargin{1}(:));
    endif
  else
    ## have spacing value for each dimension
    if (length (varargin) != nd)
      error ("gradient: dimensions and number of spacing values do not match");
    endif
    for i = 1:nd
      if (isscalar (varargin{i}))
        d{i} = varargin{i} * ones (sz(i) - 1, 1);
      else
        d{i} = diff (varargin{i}(:));
      endif
    endfor
  endif

  m = shiftdim (m, 1);
  for i = 1:min (nd, nargout)
    mr = rows (m);
    mc = numel (m) / mr;
    Y = zeros (size (m), class (m));

    if (mr > 1)
      ## Top and bottom boundary.
      Y(1,:) = diff (m(1:2, :)) / d{i}(1);
      Y(mr,:) = diff (m(mr-1:mr, :) / d{i}(mr - 1));
    endif

    if (mr > 2)
      ## Interior points.
      Y(2:mr-1,:) = ((m(3:mr,:) - m(1:mr-2,:))
          ./ kron (d{i}(1:mr-2) + d{i}(2:mr-1), ones (1, mc)));
    endif

    ## turn multi-dimensional matrix in a way, that gradient
    ## along x-direction is calculated first then y, z, ...

    if (i == 1)
      varargout{i} = shiftdim (Y, nd - 1);
      m = shiftdim (m, nd - 1);
    elseif (i == 2)
      varargout{i} = Y;
      m = shiftdim (m, 2);
    else
      varargout{i} = shiftdim (Y, nd - i + 1);
      m = shiftdim (m, 1);
    endif
  endfor

  if (transposed)
    varargout{1} = varargout{1}.';
  endif

endfunction

function varargout = handle_gradient (f, p0, varargin)

  ## Input checking
  p0_size = size (p0);

  if (numel (p0_size) != 2)
    error ("gradient: the second input argument should either be a vector or a matrix");
  endif

  if (any (p0_size == 1))
    p0 = p0(:);
    dim = 1;
    num_points = numel (p0);
  else
    num_points = p0_size (1);
    dim = p0_size (2);
  endif

  if (length (varargin) == 0)
    delta = 1;
  elseif (length (varargin) == 1 || length (varargin) == dim)
    try
      delta = [varargin{:}];
    catch
      error ("gradient: spacing parameters must be scalars or a vector");
    end_try_catch
  else
    error ("gradient: incorrect number of spacing parameters");
  endif

  if (isscalar (delta))
    delta = repmat (delta, 1, dim);
  elseif (! isvector (delta))
    error ("gradient: spacing values must be scalars or a vector");
  endif

  ## Calculate the gradient
  p0 = mat2cell (p0, num_points, ones (1, dim));
  varargout = cell (1, dim);
  for d = 1:dim
    s = delta(d);
    df_dx = (f (p0{1:d-1}, p0{d}+s, p0{d+1:end})
           - f (p0{1:d-1}, p0{d}-s, p0{d+1:end})) ./ (2*s);
    if (dim == 1)
      varargout{d} = reshape (df_dx, p0_size);
    else
      varargout{d} = df_dx;
    endif
  endfor

endfunction


%!test
%! data = [1, 2, 4, 2];
%! dx = gradient (data);
%! dx2 = gradient (data, 0.25);
%! dx3 = gradient (data, [0.25, 0.5, 1, 3]);
%! assert (dx, [1, 3/2, 0, -2]);
%! assert (dx2, [4, 6, 0, -8]);
%! assert (dx3, [4, 4, 0, -1]);
%! assert (size_equal (data, dx));

%!test
%! [Y,X,Z,U] = ndgrid (2:2:8,1:5,4:4:12,3:5:30);
%! [dX,dY,dZ,dU] = gradient (X);
%! assert (all (dX(:) == 1));
%! assert (all (dY(:) == 0));
%! assert (all (dZ(:) == 0));
%! assert (all (dU(:) == 0));
%! [dX,dY,dZ,dU] = gradient (Y);
%! assert (all (dX(:) == 0));
%! assert (all (dY(:) == 2));
%! assert (all (dZ(:) == 0));
%! assert (all (dU(:) == 0));
%! [dX,dY,dZ,dU] = gradient (Z);
%! assert (all (dX(:) == 0));
%! assert (all (dY(:) == 0));
%! assert (all (dZ(:) == 4));
%! assert (all (dU(:) == 0));
%! [dX,dY,dZ,dU] = gradient (U);
%! assert (all (dX(:) == 0));
%! assert (all (dY(:) == 0));
%! assert (all (dZ(:) == 0));
%! assert (all (dU(:) == 5));
%! assert (size_equal (dX, dY, dZ, dU, X, Y, Z, U));
%! [dX,dY,dZ,dU] = gradient (U, 5.0);
%! assert (all (dU(:) == 1));
%! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
%! assert (all (dU(:) == 2));

%!test
%! [Y,X,Z,U] = ndgrid (2:2:8,1:5,4:4:12,3:5:30);
%! [dX,dY,dZ,dU] = gradient (X+j*X);
%! assert (all (dX(:) == 1+1j));
%! assert (all (dY(:) == 0));
%! assert (all (dZ(:) == 0));
%! assert (all (dU(:) == 0));
%! [dX,dY,dZ,dU] = gradient (Y-j*Y);
%! assert (all (dX(:) == 0));
%! assert (all (dY(:) == 2-j*2));
%! assert (all (dZ(:) == 0));
%! assert (all (dU(:) == 0));
%! [dX,dY,dZ,dU] = gradient (Z+j*1);
%! assert (all (dX(:) == 0));
%! assert (all (dY(:) == 0));
%! assert (all (dZ(:) == 4));
%! assert (all (dU(:) == 0));
%! [dX,dY,dZ,dU] = gradient (U-j*1);
%! assert (all (dX(:) == 0));
%! assert (all (dY(:) == 0));
%! assert (all (dZ(:) == 0));
%! assert (all (dU(:) == 5));
%! assert (size_equal (dX, dY, dZ, dU, X, Y, Z, U));
%! [dX,dY,dZ,dU] = gradient (U, 5.0);
%! assert (all (dU(:) == 1));
%! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
%! assert (all (dU(:) == 2));

%!test
%! x = 0:10;
%! f = @cos;
%! df_dx = @(x) -sin (x);
%! assert (gradient (f, x), df_dx (x), 0.2);
%! assert (gradient (f, x, 0.5), df_dx (x), 0.1);

%!test
%! xy = reshape (1:10, 5, 2);
%! f = @(x,y) sin (x) .* cos (y);
%! df_dx = @(x, y) cos (x) .* cos (y);
%! df_dy = @(x, y) -sin (x) .* sin (y);
%! [dx, dy] = gradient (f, xy);
%! assert (dx, df_dx (xy (:, 1), xy (:, 2)), 0.1);
%! assert (dy, df_dy (xy (:, 1), xy (:, 2)), 0.1);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} idivide (@var{x}, @var{y}, @var{op})
## Integer division with different rounding rules.
##
## The standard behavior of integer division such as @code{@var{a} ./ @var{b}}
## is to round the result to the nearest integer.  This is not always the
## desired behavior and @code{idivide} permits integer element-by-element
## division to be performed with different treatment for the fractional
## part of the division as determined by the @var{op} flag.  @var{op} is
## a string with one of the values:
##
## @table @asis
## @item @qcode{"fix"}
## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
## towards zero.
##
## @item @qcode{"round"}
## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
## towards the nearest integer.
##
## @item @qcode{"floor"}
## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
## towards negative infinity.
##
## @item @qcode{"ceil"}
## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
## towards positive infinity.
## @end table
##
## @noindent
## If @var{op} is not given it defaults to @qcode{"fix"}.
## An example demonstrating these rounding rules is
##
## @example
## @group
## idivide (int8 ([-3, 3]), int8 (4), "fix")
##   @result{}   0   0
## idivide (int8 ([-3, 3]), int8 (4), "round")
##   @result{}  -1   1
## idivide (int8 ([-3, 3]), int8 (4), "floor")
##   @result{}  -1   0
## idivide (int8 ([-3, 3]), int8 (4), "ceil")
##   @result{}   0   1
## @end group
## @end example
##
## @seealso{ldivide, rdivide}
## @end deftypefn

function z = idivide (x, y, op)

  if (nargin < 2)
    print_usage ();
  endif

  if (nargin == 2)
    op = "fix";
  else
    op = tolower (op);
  endif

  if (! isinteger (x) && ! isinteger (y))
    error ("idivide: at least one input (X or Y) must be an integer type");
  elseif (isinteger (x) && isinteger (y) && ! strcmp (class (x), class (y)))
    error ("idivide: integer type of X (%s) must match integer type of Y (%s)",
           class (x), class (y));
  endif

  z = x ./ y;
  if (strcmp (op, "fix"))
    ## The following is an optimized version of `z -= (z .* y > x) .* sign (y)`.
    if (isscalar (y))
      if (y > 0)
        z -= (z * y > x);
      else
        z += (z * y > x);
      endif
    else
      y_sel = (y > 0);
      if (isscalar (x))
        z(y_sel) -= (z(y_sel) .* y(y_sel) > x);
        y_sel = ! y_sel;
        z(y_sel) += (z(y_sel) .* y(y_sel) > x);
      else
        z(y_sel) -= (z(y_sel) .* y(y_sel) > x(y_sel));
        y_sel = ! y_sel;
        z(y_sel) += (z(y_sel) .* y(y_sel) > x(y_sel));
      endif
    endif
  elseif (strcmp (op, "round"))
    return;
  elseif (strcmp (op, "floor"))
    ## The following is an optimized version of `z -= (z .* abs (y) > sign (y) .* x)`.
    if (isscalar (y))
      if (y > 0)
        z -= (z * y > x);
      else
        z -= (z * y < x);
      endif
    else
      y_sel = (y > 0);
      if (isscalar (x))
        z(y_sel) -= (z(y_sel) .* y(y_sel) > x);
        y_sel = ! y_sel;
        z(y_sel) -= (z(y_sel) .* y(y_sel) < x);
      else
        z(y_sel) -= (z(y_sel) .* y(y_sel) > x(y_sel));
        y_sel = ! y_sel;
        z(y_sel) -= (z(y_sel) .* y(y_sel) < x(y_sel));
      endif
    endif
  elseif (strcmp (op, "ceil"))
    ## The following is an optimized version of `z += (z .* abs (y) < sign (y) .* x)`.
    if (isscalar (y))
      if (y > 0)
        z += (z * y < x);
      else
        z += (z * y > x);
      endif
    else
      y_sel = (y > 0);
      if (isscalar (x))
        z(y_sel) += (z(y_sel) .* y(y_sel) < x);
        y_sel = ! y_sel;
        z(y_sel) += (z(y_sel) .* y(y_sel) > x);
      else
        z(y_sel) += (z(y_sel) .* y(y_sel) < x(y_sel));
        y_sel = ! y_sel;
        z(y_sel) += (z(y_sel) .* y(y_sel) > x(y_sel));
      endif
    endif
  else
    error ('idivide: unrecognized rounding type "%s"', op);
  endif

endfunction


%!shared a, af, b, bf
%! a = int8 (3);
%! af = 3;
%! b = int8 ([-4, 4]);
%! bf = [-4, 4];

%!assert (idivide (a, b), int8 ([0, 0]))
%!assert (idivide (a, b, "floor"), int8 ([-1, 0]))
%!assert (idivide (a, b, "ceil"), int8 ([0, 1]))
%!assert (idivide (a, b, "round"), int8 ([-1, 1]))

%!assert (idivide (af, b), int8 ([0, 0]))
%!assert (idivide (af, b, "floor"), int8 ([-1, 0]))
%!assert (idivide (af, b, "ceil"), int8 ([0, 1]))
%!assert (idivide (af, b, "round"), int8 ([-1, 1]))

%!assert (idivide (a, bf), int8 ([0, 0]))
%!assert (idivide (a, bf, "floor"), int8 ([-1, 0]))
%!assert (idivide (a, bf, "ceil"), int8 ([0, 1]))
%!assert (idivide (a, bf, "round"), int8 ([-1, 1]))

%!shared c, d
%! c = int64 (4e16);
%! d = int64 ([-2e8, 2e8]);

%!assert <*61319> (idivide (c, d + int64 (1)), d + int64 ([-1, -1]))
%!assert <*61319> (idivide (c, d + int64 (1), "floor"), d + int64 ([-2, -1]))
%!assert <*61319> (idivide (c, d + int64 (1), "ceil"), d + int64 ([-1, 0]))
%!assert <*61319> (idivide (c, d + int64 (1), "round"), d + int64 ([-1, -1]))

%!assert <*61319> (idivide (c + int64 (1), d), d)
%!assert <*61319> (idivide (c + int64 (1), d, "floor"), d + int64 ([-1, 0]))
%!assert <*61319> (idivide (c + int64 (1), d, "ceil"), d + int64 ([0, 1]))
%!assert <*61319> (idivide (c + int64 (1), d, "round"), d)

## Test input validation
%!error idivide (uint8 (1))
%!error idivide (uint8 (1), 2, 3)
%!error <at least one input> idivide (1, 2)
%!error <at least one input> idivide ({1}, 2)
%!error <X \(int8\) must match.* Y \(uint8\)> idivide (int8 (1), uint8 (2))
%!error <unrecognized rounding type "foo"> idivide (int8 (1), 2, "foo")
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} int2str (@var{n})
## Convert an integer (or array of integers) to a string (or a character
## array).
##
## @example
## @group
## int2str (123)
##   @result{} 123
##
## s = int2str ([1, 2, 3; 4, 5, 6])
##   @result{} s =
##         1  2  3
##         4  5  6
##
## whos s
##   @result{} Variables in the current scope:
##         Attr Name        Size                     Bytes  Class
##         ==== ====        ====                     =====  =====
##              s           2x7                         14  char
##      Total is 14 elements using 14 bytes
## @end group
## @end example
##
## This function is not very flexible.  For better control over the
## results, use @code{sprintf} (@pxref{Formatted Output}).
##
## Programming Notes:
##
## Non-integers are rounded to integers before display.  Only the real part
## of complex numbers is displayed.
##
## @seealso{sprintf, num2str, mat2str}
## @end deftypefn

function retval = int2str (n)

  if (nargin < 1)
    print_usage ();
  elseif (! (isnumeric (n) || islogical (n) || ischar (n)))
    error ("int2str: N must be a numeric, logical, or character array");
  endif

  if (ischar (n))
    retval = n;
    return;
  elseif (isempty (n))
    retval = "";
    return;
  endif

  n = round (real (n));

  ## Set up a suitable format string while ignoring Inf/NaN entries
  nan_inf = ! isfinite (n(:));
  ndgt = floor (log10 (max (abs (n(! nan_inf)))));
  if (isempty (ndgt) || ndgt == -Inf)
    ndgt = 0;  # All Inf or all zero array
  endif

  ndgt += 3;
  if (any (nan_inf))
    ndgt = max (ndgt, 5);
  endif

  ## FIXME: Integers should be masked to show only 16 significant digits
  fmt = sprintf ("%%%d.0f", ndgt);

  nd = ndims (n);
  nc = columns (n) * (nd - 1);    # ND-arrays are expanded in columns
  n  = permute (n, [2, 3:nd, 1]);
  fmt = [repmat(fmt, 1, nc), "\n"];
  strtmp = sprintf (fmt, n);
  retval = strtrim (char (ostrsplit (strtmp, "\n", true)));

endfunction


%!assert (int2str (123), "123")
%!assert (int2str (-123), "-123")
%!assert (int2str (1.2), "1")
%!assert (int2str (1.6), "2")
%!assert (int2str ([1, 2, 3; 4, 5, 6]), ["1  2  3";"4  5  6"])
%!assert (int2str ([]), "")

%!error <Invalid call> int2str ()
%!error <N must be a numeric> int2str ({1})
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} integral (@var{f}, @var{a}, @var{b})
## @deftypefnx {} {@var{q} =} integral (@var{f}, @var{a}, @var{b}, @var{prop}, @var{val}, @dots{})
##
## Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using
## adaptive quadrature.
##
## @code{integral} is a wrapper for @code{quadcc} (general real-valued, scalar
## integrands and limits), @code{quadgk} (integrals with specified integration
## paths), and @code{quadv} (array-valued integrands) that is intended to
## provide @sc{matlab} compatibility.  More control of the numerical
## integration may be achievable by calling the various quadrature functions
## directly.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must be vectorized and
## return a vector of output values when given a vector of input values.
##
## @var{a} and @var{b} are the lower and upper limits of integration.  Either
## or both limits may be infinite or contain weak end singularities.  If either
## or both limits are complex, @code{integral} will perform a straight line
## path integral.  Alternatively, a complex domain path can be specified using
## the @qcode{"Waypoints"} option (see below).
##
## Additional optional parameters can be specified using
## @qcode{"@var{property}", @var{value}} pairs.  Valid properties are:
##
## @table @code
## @item Waypoints
## Specifies points to be used in defining subintervals of the quadrature
## algorithm, or if @var{a}, @var{b}, or @var{waypoints} are complex then
## the quadrature is calculated as a contour integral along a piecewise
## continuous path.  For more detail, @pxref{XREFquadgk,,@code{quadgk}}.
##
## @item ArrayValued
## @code{integral} expects @var{f} to return a scalar value unless
## @var{arrayvalued} is specified as true.  This option will cause
## @code{integral} to perform the integration over the entire array and return
## @var{q} with the same dimensions as returned by @var{f}.  For more detail
## @pxref{XREFquadv,,@code{quadv}}.
##
## @item AbsTol
## Define the absolute error tolerance for the quadrature.  The default
## absolute tolerance is 1e-10 (1e-5 for single).
##
## @item RelTol
## Define the relative error tolerance for the quadrature.  The default
## relative tolerance is 1e-6 (1e-4 for single).
## @end table
##
## Adaptive quadrature is used to minimize the estimate of error until the
## following is satisfied:
## @tex
## $$error \leq \max \left( AbsTol, RelTol\cdot\vert q\vert \right)$$
## @end tex
## @ifnottex
##
## @example
## @group
##   @var{error} <= max (@var{AbsTol}, @var{RelTol}*|@var{q}|).
## @end group
## @end example
##
## @end ifnottex
##
## Known @sc{matlab} incompatibilities:
##
## @enumerate
## @item
## If tolerances are left unspecified, and any integration limits or waypoints
## are of type @code{single}, then Octave's integral functions automatically
## reduce the default absolute and relative error tolerances as specified
## above.  If tighter tolerances are desired they must be specified.
## @sc{matlab} leaves the tighter tolerances appropriate for @code{double}
## inputs in place regardless of the class of the integration limits.
##
## @item
## As a consequence of using @code{quadcc}, @code{quadgk}, and @code{quadv},
## certain option combinations are not supported.  Currently,
## @qcode{"ArrayValued"} cannot be combined with @qcode{"RelTol"} or
## @qcode{"Waypoints"}.
## @end enumerate
##
## @seealso{integral2, integral3, quad, quadgk, quadv, quadl, quadcc, trapz,
##          dblquad, triplequad}
## @end deftypefn

function q = integral (f, a, b, varargin)

  if (nargin < 3 || (mod (nargin, 2) == 0))
    print_usage ();
  endif

  ## quadcc can't handle complex limits or integrands, but quadgk & quadv can.
  ## Check for simple cases of complex limits and integrand.
  f_is_complex = false;
  if (iscomplex (a) || iscomplex (b))
    f_is_complex = true;
  elseif (iscomplex (feval (f, a)) || iscomplex (feval (f, b)))
    f_is_complex = true;
  endif

  if (nargin == 3)
    ## Pass the simplest case directly to general integrator.
    ## Let quadcc function handle input checks on function and limits.
    if (! f_is_complex)
      try
        q = quadcc (f, a, b);
      catch quaderror
        if (strcmp (quaderror.message,
                    "quadcc: integrand F must return a single, real-valued vector"))
          q = quadgk (f, a, b);
        else
          error (quaderror.message);
        endif
      end_try_catch

    else
      ## Complex-valued integral
      q = quadgk (f, a, b);
    endif

  else
    ## Parse options to determine how to call integrator.
    abstol = [];
    reltol = [];
    waypoints = [];
    arrayvalued = false;

    idx = 1;
    while (idx < nargin - 3)
      prop = varargin{idx++};
      if (! ischar (prop))
        error ("integral: property PROP must be a string");
      endif

      switch (tolower (prop))
        case "reltol"
          reltol = varargin{idx++};
        case "abstol"
          abstol = varargin{idx++};
        case "waypoints"
          waypoints = varargin{idx++}(:);
        case "arrayvalued"
          arrayvalued = varargin{idx++};
        otherwise
          error ("integral: unknown property '%s'", prop);
      endswitch
    endwhile

    issingle = (isa (a, "single") || isa (b, "single")
                || isa (waypoints, "single"));

    if (arrayvalued)
      ## Pass vector-valued function to quadv, checking for conflicting params

      ## FIXME: Replace warning when have array compatible call with waypoints
      if (! isempty (waypoints))
        warning (["integral: array-valued quadrature routine currently ", ...
                 "unable to handle WayPoints.  WayPoints are ignored."]);
      endif

      ## FIXME: Remove warning once we have reltol compatible arrayval'd quadfn
      if (! isempty (reltol))
        warning (["integral: array-valued quadrature only accepts AbsTol.", ...
                 "  RelTol ignored."]);
      endif
      if (isempty (abstol))
        abstol = ifelse (issingle, 1e-5, 1e-10);
      endif

      q = quadv (f, a, b, abstol);

    else
      if (isempty (abstol))
        abstol = ifelse (issingle, 1e-5, 1e-10);
      endif
      if (isempty (reltol))
        reltol = ifelse (issingle, 1e-4, 1e-6);
      endif

      if (! isempty (waypoints))
        q = quadgk (f, a, b, "AbsTol", abstol, "RelTol", reltol,
                             "WayPoints", waypoints);
      else
        if (! f_is_complex)
          try
            q = quadcc (f, a, b, [abstol, reltol]);
          catch quaderror
            if (strcmp (quaderror.message,
                        "quadcc: integrand F must return a single, real-valued vector"))
              q = quadgk (f, a, b, "AbsTol", abstol, "RelTol", reltol);
            else
              error (quaderror.message);
            endif
          end_try_catch
        else
          ## Complex-valued integral
          q = quadgk (f, a, b, "AbsTol", abstol, "RelTol", reltol);
        endif
      endif
    endif
  endif

endfunction


## Matlab compatibility tests
%!test
%! f = @(x) exp (-x.^2) .* log (x).^2;
%! emgamma = 0.57721566490153286;
%! exact = (sqrt (pi)*(8*log (2)^2+8*emgamma*log (2)+pi^2+2*emgamma^2))/16;
%! assert (integral (f, 0, Inf), exact, -1e-6);
%! assert (integral (f, 0, Inf, "RelTol", 1e-12), exact, -1e-12);

%!test  # with parameter
%! f = @(x, c) 1 ./ (x.^3 - 2*x - c);
%! assert (integral (@(x) f(x,5), 0, 2), -0.4605015338467329, 1e-10);

%!test  # with tolerances
%! f = @(x) log (x);
%! assert (integral (@(x) f(x), 0, 1, "AbsTol", 1e-6), -1, 1e-6);

%!test  # waypoints
%! f = @(x) 1./(2.*x-1);
%! assert (integral (f, 0, 0, "Waypoints", [1+1i, 1-1i]), -pi*1i, 1e-10);

%!test  # an array-valued function
%! f = @(x) sin ((1:5)*x);
%! assert (integral (f, 0, 1, "ArrayValued", true), 1./[1:5]-cos(1:5)./[1:5],
%!         1e-10);

%!test  # test single input/output
%! assert (integral (@sin, 0, 1), cos (0)-cos (1), 1e-10);
%! assert (class (integral (@sin, single (0), 1)), "single");
%! assert (class (integral (@sin, 0, single (1))), "single");
%! assert (class (integral (@sin, single (0), single (1))), "single");
%! assert (integral (@sin, 0, 1, "Waypoints", 0.5), cos (0)-cos (1), 1e-10);
%! assert (class (integral (@sin, 0, 1, "Waypoints", single (0.5))), "single");
%! assert (class (integral (@sin, single (0), 1, "Waypoints", 0.5)), "single");
%! assert (class (integral (@sin, 0, single (1), "Waypoints", 0.5)), "single");

%!test  # test complex argument handling
%! f = @(x) round (exp (i*x));
%! assert (integral (f, 0, pi), quadgk (f, 0, pi), eps);
%! assert (integral (f, -1, 1), 2, 5*eps);
%! assert (integral (@sin, -i, i), 0, eps);
%! assert (1.5 * integral (@sqrt, -1, 0), i, eps);

%!test
%! f = @(x) x.^5 .* exp (-x) .* sin (x);
%! assert (integral (f, 0, inf, "RelTol", 1e-8, "AbsTol", 1e-12), -15, -1e-8);

## tests from quadcc
%!assert (integral (@sin, -pi, pi), 0, 1e-10)
%!assert (integral (inline ("sin"), -pi, pi), 0, 1e-10)
%!assert (integral ("sin", -pi, pi), 0, 1e-10)
%!assert (integral (@sin, -pi, 0), -2, 1e-10)
%!assert (integral (@sin, 0, pi), 2, 1e-10)
%!assert (integral (@(x) 1./(sqrt (x).*(x+1)), 0, Inf), pi, -1e-6)
%!assert (integral (@(x) 1./(sqrt (x).*(x+1)), 0, Inf,
%!                  "AbsTol", 0, "RelTol", 1e-8),
%!        pi, -1e-8)
%!assert (integral (@(x) exp (-x .^ 2), -Inf, Inf), sqrt (pi), 1e-10)
%!assert (integral (@(x) exp (-x .^ 2), -Inf, 0), sqrt (pi)/2, 1e-10)

## tests from quadgk
%!assert (integral (@sin,-pi,pi, "WayPoints",0, "AbsTol",1e-6, "RelTol",1e-3),
%!        0, 1e-6)
%!assert (integral (@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1), 2, 1e-10)
%!assert (integral (@(z) log (z),1+1i,1+1i, "WayPoints", [1-1i, -1,-1i, -1+1i]),
%!        complex (0, pi), 1e-10)

## tests from quadv
## Test vector-valued functions
%!assert (integral (@(x) [(sin (x)), (sin (2*x))], 0, pi, "ArrayValued", 1),
%!        [2, 0], 1e-10)

## Test matrix-valued functions
%!test
%! assert (integral (@(x) [x,x,x; x,exp(x),x; x,x,x], 0, 1, "ArrayValued", 1),
%!         [0.5,0.5,0.5; 0.5,(exp (1) - 1),0.5; 0.5,0.5,0.5], 1e-10);

## Test input validation
%!error integral (@sin)
%!error integral (@sin, 0)
%!error integral (@sin, 0, 1, 1e-6, true, 4)
%!error integral (@sin, 0, 1, "DummyArg")
%!error <property PROP must be a string> integral (@sin, 0, 1, 2, 3)
%!error <unknown property 'foo'> integral (@sin, 0, 1, "foo", 3)
%!error integral (@sin, 0, 1, "AbsTol", ones (2,2))
%!error integral (@sin, 0, 1, "AbsTol", -1)
%!error integral (@sin, 0, 1, "RelTol", ones (2,2))
%!error integral (@sin, 0, 1, "RelTol", -1)
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} integral2 (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb})
## @deftypefnx {} {@var{q} =} integral2 (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{prop}, @var{val}, @dots{})
## @deftypefnx {} {[@var{q}, @var{err}] =} integral2 (@dots{})
##
## Numerically evaluate the two-dimensional integral of @var{f} using adaptive
## quadrature over the two-dimensional domain defined by @var{xa}, @var{xb},
## @var{ya}, @var{yb} (scalars may be finite or infinite).  Additionally,
## @var{ya} and @var{yb} may be scalar functions of @var{x}, allowing for
## integration over non-rectangular domains.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must be of the form
## @math{z = f(x,y)} where @var{x} is a vector and @var{y} is a scalar.  It
## should return a vector of the same length and orientation as @var{x}.
##
## Additional optional parameters can be specified using
## @qcode{"@var{property}", @var{value}} pairs.  Valid properties are:
##
## @table @code
## @item AbsTol
## Define the absolute error tolerance for the quadrature.  The default
## value is 1e-10 (1e-5 for single).
##
## @item RelTol
## Define the relative error tolerance for the quadrature.  The default
## value is 1e-6 (1e-4 for single).
##
## @item Method
## Specify the two-dimensional integration method to be used, with valid
## options being @qcode{"auto"} (default), @qcode{"tiled"}, or
## @qcode{"iterated"}.  When using @qcode{"auto"}, Octave will choose the
## @qcode{"tiled"} method unless any of the integration limits are infinite.
##
## @item Vectorized
## Enable or disable vectorized integration.  A value of @code{false} forces
## Octave to use only scalar inputs when calling the integrand, which enables
## integrands @math{f(x,y)} that have not been vectorized and only accept
## @var{x} and @var{y} as scalars to be used.  The default value is
## @code{true}.
## @end table
##
## Adaptive quadrature is used to minimize the estimate of error until the
## following is satisfied:
## @tex
## $$error \leq \max \left( AbsTol, RelTol\cdot\vert q\vert \right)$$
## @end tex
## @ifnottex
##
## @example
## @group
##         @var{error} <= max (@var{AbsTol}, @var{RelTol}*|@var{q}|)
## @end group
## @end example
##
## @end ifnottex
##
## @var{err} is an approximate bound on the error in the integral
## @code{abs (@var{q} - @var{I})}, where @var{I} is the exact value of the
## integral.
##
## Example 1 : integrate a rectangular region in x-y plane
##
## @example
## @group
## @var{f} = @@(@var{x},@var{y}) 2*ones (size (@var{x}));
## @var{q} = integral2 (@var{f}, 0, 1, 0, 1)
##   @result{} @var{q} =  2
## @end group
## @end example
##
## The result is a volume, which for this constant-value integrand, is just
## @code{@var{Length} * @var{Width} * @var{Height}}.
##
## Example 2 : integrate a triangular region in x-y plane
##
## @example
## @group
## @var{f} = @@(@var{x},@var{y}) 2*ones (size (@var{x}));
## @var{ymax} = @@(@var{x}) 1 - @var{x};
## @var{q} = integral2 (@var{f}, 0, 1, 0, @var{ymax})
##   @result{} @var{q} =  1
## @end group
## @end example
##
## The result is a volume, which for this constant-value integrand, is the
## Triangle Area x Height or
## @code{1/2 * @var{Base} * @var{Width} * @var{Height}}.
##
## Programming Notes: If there are singularities within the integration region
## it is best to split the integral and place the singularities on the
## boundary.
##
## Known @sc{matlab} incompatibility: If tolerances are left unspecified, and
## any integration limits are of type @code{single}, then Octave's integral
## functions automatically reduce the default absolute and relative error
## tolerances as specified above.  If tighter tolerances are desired they
## must be specified.  @sc{matlab} leaves the tighter tolerances appropriate
## for @code{double} inputs in place regardless of the class of the
## integration limits.
##
## Reference: @nospell{L.F. Shampine},
## @cite{@sc{matlab} program for quadrature in 2D}, Applied Mathematics and
## Computation, pp.@: 266--274, Vol 1, 2008.
##
## @seealso{quad2d, dblquad, integral, quad, quadgk, quadv, quadl, quadcc,
##          trapz, integral3, triplequad}
## @end deftypefn

function [q, err] = integral2 (f, xa, xb, ya, yb, varargin)

  if (nargin < 5 || mod (nargin, 2) == 0)
    print_usage ();
  endif

  if (! is_function_handle (f))
    print_usage ();
  endif

  if (! (isreal (xa) && isscalar (xa) && isreal (xb) && isscalar (xb)))
    print_usage ();
  endif

  ## Check for single or double limits to set appropriate default tolerance.
  issingle = (isa ([xa, xb], "single")
              || (! is_function_handle (ya) && isa (ya, "single"))
              || (! is_function_handle (yb) && isa (yb, "single")));

  ## Set defaults, update with any specified parameters.
  if (issingle)
    abstol = 1e-5;
    reltol = 1e-4;
  else
    abstol = 1e-10;
    reltol = 1e-6;
  endif

  method = "auto";
  idx = 1;
  while (idx < nargin - 5)
    prop = varargin{idx++};
    if (! ischar (prop))
      error ("integral2: property PROP must be a string");
    endif

    switch (tolower (prop))
      case "abstol"
        abstol = varargin{idx++};
        if (! (isnumeric (abstol) && isscalar (abstol) && abstol >= 0))
          error ("integral2: AbsTol value must be a numeric scalar >= 0");
        endif

      case "reltol"
        reltol = varargin{idx++};
        if (! (isnumeric (reltol) && isscalar (reltol) && reltol >= 0))
          error ("integral2: RelTol value must be a numeric scalar >= 0");
        endif

      case "method"
        method = tolower (varargin{idx++});
        if (! any (strcmp (method, {"auto", "iterated", "tiled"})))
          error ("integral2 : unrecognized method '%s'", method);
        endif

      case "vectorized"
        vectorized = varargin{idx++};
        if (! (isscalar (vectorized) && isreal (vectorized)))
          error ('integral2: Vectorized must be a logical value');
        endif
        if (! vectorized)
          f = @(x, y) arrayfun (f, x, y);
        endif

      otherwise
        error ("integral2: unknown property '%s'", prop);

    endswitch
  endwhile

  if (strcmp (method, "auto"))
    if (isinf (xa) || isinf (xb)
        || (! is_function_handle (ya) && isinf (ya))
        || (! is_function_handle (yb) && isinf (yb)))
      method = "iterated";
    else
      method = "tiled";
    endif
  endif

  ## check upper and lower bounds of y
  if (! is_function_handle (ya))
    if (! (isreal (ya) && isscalar (ya)))
      error ("integral2: YA must be a real scalar or a function");
    endif
    ya = @(x) ya * ones (rows (x), columns (x));
  endif
  if (! is_function_handle (yb))
    if (! (isreal (yb) && isscalar (yb)))
      error ("integral2: YB must be a real scalar or a function");
    endif
    yb = @(x) yb * ones (rows (x), columns (x));
  endif

  if (strcmp (method, "iterated"))
    q = outer_iterated (f, xa, xb, ya, yb, abstol, reltol);

    if (nargout == 2)
      warning ('integral2: "iterated" method can not return estimated error');
      err = 0;
    endif
  else
    [q, err] = quad2d (f, xa, xb, ya, yb, "AbsTol", abstol, "RelTol", reltol);
  endif

endfunction

function q = outer_iterated (f, xa, xb, ya, yb, abstol, reltol)
  finner_iter = @(x) inner_iterated (x, f, ya, yb, abstol, reltol);
  q = quadcc (finner_iter, xa, xb, [abstol, reltol]);
endfunction

function q = inner_iterated (x, f, ya, yb, abstol, reltol)
  q = zeros (size (x));
  for i = 1 : length (x)
    q(i) = quadcc (@(y) f(x(i), y), ya(x(i)), yb(x(i)), [abstol, reltol]);
  endfor
endfunction


## method tests
%!shared f
%! f = @(x, y) x .* y;

%!assert (integral2 (f, 0, 1, 0, 1), 0.25, 1e-10)
%!assert (integral2 (f, 0, 1, 0, 1, "method", "tiled"), 0.25, 1e-10)
%!assert (integral2 (f, 0, 1, 0, 1, "method", "iterated"), 0.25, 1e-10)
%!assert (integral2 (f, 0, 1, 0, 1, "method", "auto"), 0.25, 1e-10)

## vectorized = false test
%!test
%! f = @(x, y) x * y;
%!assert (integral2 (f, 0, 1, 0, 1, "vectorized", false), 0.25, 1e-10)

## tolerance tests
%!test
%! f = @(x, y) 9 * x.^2 + 15 * y.^2;
%!assert (integral2 (f, 0, 5, -5, 0, "AbsTol", 1e-9), 5000, 1e-9)
%!assert (integral2 (f, 0, 5, -5, 0, "RelTol", 1e-5), 5000, -1e-5)
%!assert (integral2 (f, 0, 5, -5, 0, "RelTol", 1e-6, "AbsTol", 1e-9),
%!        5000, 1e-9)

## tests from dblquad
%!test
%! f = @(x, y) 1 ./ (x+y);
%!assert (integral2 (f, 0, 1, 0, 1, "AbsTol", 1e-7), 2*log (2), 1e-7)
%!assert (integral2 (f, 0, 1, 0, 1, "RelTol", 1e-5), 2*log (2), -1e-5)
%!assert (integral2 (f, 0, 1, 0, 1, "AbsTol", 1e-8, "RelTol", 1e-6),
%!        2*log (2), -1e-6)
%!assert (integral2 (f, 0, 1, 0, @(x) 1 - x), 1, -1e-6)

%!assert (integral2 (@(x, y) exp (-x.^2 - y.^2) , -1, 1, -1, 1),
%!        pi * erf (1).^2, 1e-10)

%!assert (integral2 (@plus, 1, 2, 3, 4), 5, 1e-10)

## tests from dblquad w/method specified
%!assert (integral2 (f, 0, 1, 0, 1, "AbsTol", 1e-7, "method", "iterated"),
%!        2*log (2), 1e-7)
%!assert (integral2 (f, 0, 1, 0, 1, "RelTol", 1e-5, "method", "iterated"),
%!        2*log (2), -1e-5)
%!assert (integral2 (f, 0, 1, 0, 1, "AbsTol", 1e-8, "RelTol", 1e-6,
%!                                  "Method", "iterated"),
%!        2*log (2), -1e-6)
%!assert (integral2 (f, 0, 1, 0, @(x) 1 - x, "Method", "iterated"), 1, -1e-6)
%!assert (integral2 (@(x, y) exp (-x.^2 - y.^2) , -1, 1, -1, 1,
%!                                                "Method", "iterated"),
%!        pi * erf (1).^2, 1e-10)

%!assert (integral2 (@plus, 1, 2, 3, 4, "method", "iterated"), 5, 1e-10)

## Test input validation
%!error <Invalid call> integral2 ()
%!error <Invalid call> integral2 (@plus)
%!error <Invalid call> integral2 (@plus, 1)
%!error <Invalid call> integral2 (@plus, 1, 2)
%!error <Invalid call> integral2 (@plus, 1, 2, 3)
%!error <Invalid call> integral2 (@plus, 1, 2, 3, 4, "foo")
%!error integral2 (0, 1, 2, 3, 4)          # f must be function handle
%!error integral2 (@plus, 1i, 2, 3, 4)     # real limits
%!error integral2 (@plus, 1, 2i, 3, 4)     # real limits
%!error integral2 (@plus, [1 1], 2, 3, 4)  # scalar limits
%!error integral2 (@plus, 1, [2 2], 3, 4)  # scalar limits
%!error <property PROP must be a string> integral2 (@plus,1,2,3,4,99, "bar")
%!error <AbsTol value must be a numeric>
%! integral2 (@plus,1,2,3,4, "AbsTol", "foo");
%!error <AbsTol value must be a .* scalar>
%! integral2 (@plus, 1, 2, 3, 4, "AbsTol", [1, 2]);
%!error <AbsTol value must be.* .= 0> integral2 (@plus,1,2,3,4, "AbsTol", -1)
%!error <RelTol value must be a numeric>
%! integral2 (@plus, 1, 2, 3, 4, "RelTol", "foo");
%!error <RelTol value must be a .* scalar>
%! integral2 (@plus, 1, 2, 3, 4, "RelTol", [1, 2]);
%!error <RelTol value must be.* .= 0> integral2 (@plus,1,2,3,4, "RelTol", -1)
%!error <unrecognized method 'foo'> integral2 (@plus,1,2,3,4, "method", "foo")
%!error <Vectorized must be a logical value>
%! integral2 (@plus,1,2,3,4, "Vectorized", [0 1]);
%!error <Vectorized must be a logical value>
%! integral2 (@plus,1,2,3,4, "Vectorized", {true});
%!error <unknown property 'foo'>  integral2 (@plus, 1, 2, 3, 4, "foo", "bar")
%!error <YA must be a real scalar> integral2 (@plus, 1, 2, 3i, 4)
%!error <YA must be a real scalar> integral2 (@plus, 1, 2, [3 3], 4)
%!error <YB must be a real scalar> integral2 (@plus, 1, 2, 3, 4i)
%!error <YB must be a real scalar> integral2 (@plus, 1, 2, 3, [4 4])
%!warning <"iterated" method can not return estimated error>
%! [q, err] = integral2 (@plus, 0, 0, 0, 0, "method", "iterated");
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} integral3 (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb})
## @deftypefnx {} {@var{q} =} integral3 (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb}, @var{prop}, @var{val}, @dots{})
##
## Numerically evaluate the three-dimensional integral of @var{f} using
## adaptive quadrature over the three-dimensional domain defined by
## @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb} (scalars may
## be finite or infinite).  Additionally, @var{ya} and @var{yb} may be
## scalar functions of @var{x} and @var{za}, and @var{zb} maybe be scalar
## functions of @var{x} and @var{y}, allowing for integration over
## non-rectangular domains.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must be of the form
## @math{z = f(x,y)} where @var{x} is a vector and @var{y} is a scalar.  It
## should return a vector of the same length and orientation as @var{x}.
##
## Additional optional parameters can be specified using
## @qcode{"@var{property}", @var{value}} pairs.  Valid properties are:
##
## @table @code
## @item AbsTol
## Define the absolute error tolerance for the quadrature.  The default
## value is 1e-10 (1e-5 for single).
##
## @item RelTol
## Define the relative error tolerance for the quadrature.  The default
## value is 1e-6 (1e-4 for single).
##
## @item Method
## Specify the two-dimensional integration method to be used, with valid
## options being @qcode{"auto"} (default), @qcode{"tiled"}, or
## @qcode{"iterated"}.  When using @qcode{"auto"}, Octave will choose the
## @qcode{"tiled"} method unless any of the integration limits are infinite.
##
## @item Vectorized
## Enable or disable vectorized integration.  A value of @code{false} forces
## Octave to use only scalar inputs when calling the integrand, which enables
## integrands @math{f(x,y)} that have not been vectorized and only accept
## @var{x} and @var{y} as scalars to be used.  The default value is
## @code{true}.
## @end table
##
## Adaptive quadrature is used to minimize the estimate of error until the
## following is satisfied:
## @tex
## $$error \leq \max \left( AbsTol, RelTol\cdot\vert q\vert \right)$$
## @end tex
## @ifnottex
##
## @example
## @group
##         @var{error} <= max (@var{AbsTol}, @var{RelTol}*|@var{q}|)
## @end group
## @end example
##
## @end ifnottex
##
## @var{err} is an approximate bound on the error in the integral
## @code{abs (@var{q} - @var{I})}, where @var{I} is the exact value of the
## integral.
##
## Example 1 : integrate over a rectangular volume
##
## @example
## @group
## @var{f} = @@(@var{x},@var{y},@var{z}) ones (size (@var{x}));
## @var{q} = integral3 (@var{f}, 0, 1, 0, 1, 0, 1)
##   @result{} @var{q} =  1.00000
## @end group
## @end example
##
## For this constant-value integrand, the result is a volume which is just
## @code{@var{Length} * @var{Width} * @var{Height}}.
##
## Example 2 : integrate over a spherical volume
##
## @example
## @group
## @var{f} = @@(@var{x},@var{y}) ones (size (@var{x}));
## @var{ymax} = @@(@var{x}) sqrt (1 - @var{x}.^2);
## @var{zmax} = @@(@var{x},@var{y}) sqrt (1 - @var{x}.^2 - @var{y}.^2);
## @var{q} = integral3 (@var{f}, 0, 1, 0, @var{ymax}, 0, @var{zmax})
##   @result{} @var{q} =  0.52360
## @end group
## @end example
##
## For this constant-value integrand, the result is a volume which is 1/8th
## of a unit sphere or @code{1/8 * 4/3 * pi}.
##
## Programming Notes: If there are singularities within the integration region
## it is best to split the integral and place the singularities on the
## boundary.
##
## Known @sc{matlab} incompatibility: If tolerances are left unspecified, and
## any integration limits are of type @code{single}, then Octave's integral
## functions automatically reduce the default absolute and relative error
## tolerances as specified above.  If tighter tolerances are desired they
## must be specified.  @sc{matlab} leaves the tighter tolerances appropriate
## for @code{double} inputs in place regardless of the class of the
## integration limits.
##
## Reference: @nospell{L.F. Shampine},
## @cite{@sc{matlab} program for quadrature in 2D}, Applied Mathematics and
## Computation, pp.@: 266--274, Vol 1, 2008.
##
## @seealso{triplequad, integral, quad, quadgk, quadv, quadl,
##          quadcc, trapz, integral2, quad2d, dblquad}
## @end deftypefn

function q = integral3 (f, xa, xb, ya, yb, za, zb, varargin)

  if (nargin < 7 || mod (nargin, 2) == 0)
    print_usage ();
  endif

  if (! is_function_handle (f))
    print_usage ();
  endif

  if (! (isreal (xa) && isscalar (xa) && isreal (xb) && isscalar (xb)))
    print_usage ();
  endif

  ## Check for single or double limits to set appropriate default tolerance.
  issingle = (isa ([xa, xb], "single")
              || (! is_function_handle (ya) && isa (ya, "single"))
              || (! is_function_handle (yb) && isa (yb, "single"))
              || (! is_function_handle (za) && isa (za, "single"))
              || (! is_function_handle (zb) && isa (zb, "single")));

  ## Communicate to downstream quadrature routines that at least one limit of
  ## integration was of single type by casting xa, xb to single.
  if (issingle)
    xa = single (xa);
    xb = single (xb);
  endif

  ## Set default tolerances, and then update with any specified parameters.
  if (issingle)
    abstol = 1e-5;
    reltol = 1e-4;
  else
    abstol = 1e-10;
    reltol = 1e-6;
  endif

  method = "auto";
  vectorized = true;
  idx = 1;
  while (idx < nargin - 7)
    prop = varargin{idx++};
    if (! ischar (prop))
      error ("integral3: property PROP must be a string");
    endif

    switch (tolower (prop))
      case "abstol"
        abstol = varargin{idx++};
        if (! (isnumeric (abstol) && isscalar (abstol) && abstol >= 0))
          error ("integral3: AbsTol value must be a numeric scalar >= 0");
        endif

      case "reltol"
        reltol = varargin{idx++};
        if (! (isnumeric (reltol) && isscalar (reltol) && reltol >= 0))
          error ("integral3: RelTol value must be a numeric scalar >= 0");
        endif

      case "method"
        method = tolower (varargin{idx++});
        if (! any (strcmp (method, {"auto", "iterated", "tiled"})))
          error ("integral3 : unrecognized method '%s'", method);
        endif

      case "vectorized"
        vectorized = varargin{idx++};
        if (! (isscalar (vectorized) && isreal (vectorized)))
          error ('integral3: Vectorized must be a logical value');
        endif

      otherwise
        error ("integral3: unknown property '%s'", prop);

    endswitch
  endwhile

  if (strcmp (method, "auto"))
    if (isinf (xa) || isinf (xb)
        || (! is_function_handle (ya) && isinf (ya))
        || (! is_function_handle (yb) && isinf (yb))
        || (! is_function_handle (za) && isinf (za))
        || (! is_function_handle (zb) && isinf (zb)))
      method = "iterated";
    else
      method = "tiled";
    endif
  endif

  ## check upper and lower bounds of y
  if (! is_function_handle (ya))
    if (! (isreal (ya) && isscalar (ya)))
      error ("integral3: YA must be a real scalar or a function");
    endif
    ya = @(x) ya * ones (size (x));
  endif
  if (! is_function_handle (yb))
    if (! (isreal (yb) && isscalar (yb)))
      error ("integral3: YB must be a real scalar or a function");
    endif
    yb = @(x) yb * ones (size (x));
  endif

  ## check upper and lower bounds of z
  if (! is_function_handle (za))
    if (! (isreal (za) && isscalar (za)))
      error ("integral3: ZA must be a real scalar or a function");
    endif
    za = @(x, y) za * ones (size (y));
  endif
  if (! is_function_handle (zb))
    if (! (isreal (zb) && isscalar (zb)))
      error ("integral3: ZB must be a real scalar or a function");
    endif
    zb = @(x, y) zb * ones (size (y));
  endif

  finner = @(x) inner (x, f, ya, yb, za, zb, vectorized, method, abstol, reltol);
  q = quadcc (finner, xa, xb, [abstol, reltol]);

endfunction

function q = inner (x, f, ya, yb, za, zb, vectorized, method, abstol, reltol)

  q = zeros (size (x));
  for i = 1 : length (x)
    za2 = @(y) za(x(i), y);
    zb2 = @(y) zb(x(i), y);
    f2 = @(y, z) f(x(i), y, z);
    if (! vectorized)
      f2 = @(y, z) arrayfun (f2, y, z);
    endif
    if (strcmp (method, "iterated"))
      finner_iter = @(y) inner_iterated (y, f2, za2, zb2, abstol, reltol);
      q(i) = quadcc (finner_iter, ya(x(i)), yb(x(i)), [abstol, reltol]);
    else
      q(i) = quad2d (f2, ya(x(i)), yb(x(i)), za2, zb2,
                     "AbsTol", abstol, "RelTol", reltol);
    endif
  endfor

endfunction

function q = inner_iterated (y, f2, za2, zb2, abstol, reltol)
  q = zeros (size (y));
  for i = 1 : length (y)
    q(i) = quadcc (@(z) f2(y(i), z), za2(y(i)), zb2(y(i)), [abstol, reltol]);
  endfor
endfunction


## method tests
%!shared f
%! f = @(x, y, z) x .* y .* z;

%!assert (integral3 (f, 0, 1, 0, 1, 0, 1), 0.125, 1e-10)
%!assert (integral3 (f, 0, 1, 0, 1, 0, 1, "method", "tiled"), 0.125, 1e-10)
%!assert (integral3 (f, 0, 1, 0, 1, 0, 1, "method", "iterated"), 0.125, 1e-10)
%!assert (integral3 (f, 0, 1, 0, 1, 0, 1, "method", "auto"), 0.125, 1e-10)

## vectorized = false test
%!test
%! f = @(x, y, z) x * y * z;
%! assert (integral3 (f, 0, 1, 0, 1, 0, 1, "vectorized", false), 0.125, 1e-10);

## tolerance tests
%!test
%! f = @(x, y, z) 2 * x.^2 + 3 * y.^2 + 4 * z.^2;
%!assert (integral3 (f, 0, 5, -5, 0, 0, 5, "AbsTol", 1e-9), 9375, 1e-9)
%!assert (integral3 (f, 0, 5, -5, 0, 0, 5, "RelTol", 1e-5), 9375, -1e-5)
%!assert (integral3 (f, 0, 5, -5, 0, 0, 5, "RelTol", 1e-6, "AbsTol", 1e-9),
%!        9375, 1e-9)

## non-rectangular region
## This test is too slow with "iterated" method
%!test
%! f = @(x,y,z) 1 ./ (x + y + z);
%! ymax = @(x) 1 - x;
%! zmax = @(x, y) 1 - x - y;
%! assert (integral3 (f, 0, 1, 0, ymax, 0, zmax, "method", "tiled"),
%!         0.25, 1e-6);

## Test input validation
%!error integral3
%!error integral3 (@plus)
%!error integral3 (@plus, 1)
%!error integral3 (@plus, 1, 2)
%!error integral3 (@plus, 1, 2, 3)
%!error integral3 (@plus, 1, 2, 3, 4)
%!error integral3 (@plus, 1, 2, 3, 4, 5)
%!error integral3 (@plus, 1, 2, 3, 4, 5, 6, "foo")
%!error integral3 (0, 1, 2, 3, 4, 5, 6)          # f must be a function handle
%!error integral3 (@plus, 1i, 2, 3, 4, 5, 6)     # real limits
%!error integral3 (@plus, 1, 2i, 3, 4, 5, 6)     # real limits
%!error integral3 (@plus, [1 1], 2, 3, 4, 5, 6)  # scalar limits
%!error integral3 (@plus, 1, [2 2], 3, 4, 5, 6)  # scalar limits
%!error <property PROP must be a string>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, 99, "bar");
%!error <AbsTol value must be a numeric>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, "AbsTol", "foo");
%!error <AbsTol value must be a .* scalar>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, "AbsTol", [1, 2]);
%!error <AbsTol value must be.* .= 0>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, "AbsTol", -1);
%!error <RelTol value must be a numeric>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, "RelTol", "foo");
%!error <RelTol value must be a .* scalar>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, "RelTol", [1, 2]);
%!error <RelTol value must be.* .= 0>
%! integral3 (@plus, 1, 2, 3, 4, 5, 6, "RelTol", -1);
%!error <unrecognized method 'foo'>
%! integral3 (@plus,1,2,3,4,5,6, "method", "foo");
%!error <Vectorized must be a logical value>
%! integral3 (@plus,1,2,3,4,5,6, "Vectorized", [0 1]);
%!error <Vectorized must be a logical value>
%! integral3 (@plus,1,2,3,4,5,6, "Vectorized", {true});
%!error <unknown property 'foo'>
%! integral3 (@plus, 1, 2, 3, 4, 6, 6, "foo", "bar");
%!error <YA must be a real scalar> integral3 (@plus, 1, 2, 3i, 4, 5, 6)
%!error <YA must be a real scalar> integral3 (@plus, 1, 2, [3 3], 4, 5, 6)
%!error <YB must be a real scalar> integral3 (@plus, 1, 2, 3, 4i, 5, 6)
%!error <YB must be a real scalar> integral3 (@plus, 1, 2, 3, [4 4], 5, 6)
%!error <ZA must be a real scalar> integral3 (@plus, 1, 2, 3, 4, 5i, 6)
%!error <ZA must be a real scalar> integral3 (@plus, 1, 2, 3, 4, [5 5], 6)
%!error <ZB must be a real scalar> integral3 (@plus, 1, 2, 3, 4, 5, 6i)
%!error <ZB must be a real scalar> integral3 (@plus, 1, 2, 3, 4, 5, [6 6])
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
## @deftypefnx {} {@var{yi} =} interp1 (@var{y}, @var{xi})
## @deftypefnx {} {@var{yi} =} interp1 (@dots{}, @var{method})
## @deftypefnx {} {@var{yi} =} interp1 (@dots{}, @var{extrap})
## @deftypefnx {} {@var{yi} =} interp1 (@dots{}, "left")
## @deftypefnx {} {@var{yi} =} interp1 (@dots{}, "right")
## @deftypefnx {} {@var{pp} =} interp1 (@dots{}, "pp")
##
## One-dimensional interpolation.
##
## Interpolate input data to determine the value of @var{yi} at the points
## @var{xi}.  If not specified, @var{x} is taken to be the indices of @var{y}
## (@code{1:length (@var{y})}).  If @var{y} is a matrix or an N-dimensional
## array, the interpolation is performed on each column of @var{y}.
##
## The interpolation @var{method} is one of:
##
## @table @asis
## @item @qcode{"nearest"}
## Return the nearest neighbor.
##
## @item @qcode{"previous"}
## Return the previous neighbor.
##
## @item @qcode{"next"}
## Return the next neighbor.
##
## @item @qcode{"linear"} (default)
## Linear interpolation from nearest neighbors.
##
## @item @qcode{"pchip"}
## Piecewise cubic Hermite interpolating polynomial---shape-preserving
## interpolation with smooth first derivative.
##
## @item @qcode{"cubic"}
## Cubic interpolation (same as @qcode{"pchip"}).
##
## @item @qcode{"spline"}
## Cubic spline interpolation---smooth first and second derivatives
## throughout the curve.
## @end table
##
## Adding '*' to the start of any method above forces @code{interp1}
## to assume that @var{x} is uniformly spaced, and only @code{@var{x}(1)}
## and @code{@var{x}(2)} are referenced.  This is usually faster,
## and is never slower.  The default method is @qcode{"linear"}.
##
## If @var{extrap} is the string @qcode{"extrap"}, then extrapolate values
## beyond the endpoints using the current @var{method}.  If @var{extrap} is a
## number, then replace values beyond the endpoints with that number.  When
## unspecified, @var{extrap} defaults to @code{NA}.
##
## If the string argument @qcode{"pp"} is specified, then @var{xi} should not
## be supplied and @code{interp1} returns a piecewise polynomial object.  This
## object can later be used with @code{ppval} to evaluate the interpolation.
## There is an equivalence, such that @code{ppval (interp1 (@var{x},
## @var{y}, @var{method}, @qcode{"pp"}), @var{xi}) == interp1 (@var{x},
## @var{y}, @var{xi}, @var{method}, @qcode{"extrap"})}.
##
## Duplicate points in @var{x} specify a discontinuous interpolant.  There
## may be at most 2 consecutive points with the same value.
## If @var{x} is increasing, the default discontinuous interpolant is
## right-continuous.  If @var{x} is decreasing, the default discontinuous
## interpolant is left-continuous.
## The continuity condition of the interpolant may be specified by using
## the options @qcode{"left"} or @qcode{"right"} to select a left-continuous
## or right-continuous interpolant, respectively.
## Discontinuous interpolation is only allowed for @qcode{"nearest"} and
## @qcode{"linear"} methods; in all other cases, the @var{x}-values must be
## unique.
##
## An example of the use of @code{interp1} is
##
## @example
## @group
## xf = [0:0.05:10];
## yf = sin (2*pi*xf/5);
## xp = [0:10];
## yp = sin (2*pi*xp/5);
## lin = interp1 (xp, yp, xf);
## near = interp1 (xp, yp, xf, "nearest");
## pch = interp1 (xp, yp, xf, "pchip");
## spl = interp1 (xp, yp, xf, "spline");
## plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xf,pch,"c", xf,spl,"m",
##       xp,yp,"r*");
## legend ("original", "nearest", "linear", "pchip", "spline");
## @end group
## @end example
##
## @seealso{pchip, spline, interpft, interp2, interp3, interpn}
## @end deftypefn

function yi = interp1 (x, y, varargin)

  if (nargin < 2 || nargin > 6)
    print_usage ();
  endif

  method = "linear";
  extrap = [];
  xi = [];
  ispp = false;
  have_xi = false;
  rightcontinuous = NaN;

  if (nargin > 2)
    for i_arg = 1:length (varargin)
      arg = varargin{i_arg};
      if (ischar (arg))
        arg = tolower (arg);
        switch (arg)
          case "extrap"
            extrap = "extrap";
          case "pp"
            ispp = true;
          case {"right", "-right"}
            rightcontinuous = true;
          case {"left", "-left"}
            rightcontinuous = false;
          otherwise
            method = arg;
        endswitch
      else
        if (i_arg == 1)
          xi = arg;
          have_xi = true;
        else
          extrap = arg;
        endif
      endif
    endfor
  endif

  if (! have_xi && ! ispp)
    xi = y;
    y = x;
    if (isvector (y))
      x = 1:numel (y);
    else
      x = 1:rows (y);
    endif
  endif

  if (isempty (extrap))
    if (iscomplex (y))
      extrap = NA + 1i*NA;
    else
      extrap = NA;
    endif
  endif

  ## reshape matrices for convenience
  x = x(:);
  nx = rows (x);
  szx = size (xi);
  if (isvector (y))
    y = y(:);
  endif

  szy = size (y);
  y = y(:,:);
  [ny, nc] = size (y);
  xi = xi(:);

  ## determine sizes
  if (nx < 2 || ny < 2)
    error ("interp1: minimum of 2 points required in each dimension");
  endif

  ## check whether x is sorted; sort if not.
  if (! issorted (x, "either"))
    [x, p] = sort (x);
    y = y(p,:);
  endif

  if (any (strcmp (method, {"previous", "*previous", "next", "*next"})))
    rightcontinuous = NaN; # needed for these methods to work
  endif

  if (isnan (rightcontinuous))
    ## If not specified, set the continuity condition
    if (x(end) < x(1))
      rightcontinuous = false;
    else
      rightcontinuous = true;
    endif
  elseif ((rightcontinuous && (x(end) < x(1)))
          || (! rightcontinuous && (x(end) > x(1))))
    ## Switch between left-continuous and right-continuous
    x = flipud (x);
    y = flipud (y);
  endif

  ## Because of the way mkpp works, it's easiest to implement "next"
  ## by running "previous" with vectors flipped.
  if (strcmp (method, "next"))
    x = flipud (x);
    y = flipud (y);
    method = "previous";
  elseif (strcmp (method, "*next"))
    x = flipud (x);
    y = flipud (y);
    method = "*previous";
  endif

  starmethod = method(1) == "*";

  if (starmethod)
    dx = x(2) - x(1);
  else
    jumps = x(1:end-1) == x(2:end);
    have_jumps = any (jumps);
    if (have_jumps)
      if (strcmp (method, "linear") || strcmp (method, ("nearest")))
        if (any (jumps(1:nx-2) & jumps(2:nx-1)))
          warning ("interp1: multiple discontinuities at the same X value");
        endif
      else
        error ("interp1: discontinuities not supported for METHOD '%s'",
                                                                   method);
      endif
    endif
  endif

  ## Proceed with interpolating by all methods.
  switch (method)

    case "nearest"
      pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)],
                 shiftdim (y, 1), szy(2:end));
      pp.orient = "first";

      if (ispp)
        yi = pp;
      else
        yi = ppval (pp, reshape (xi, szx));
      endif

    case "*nearest"
      pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)],
                 shiftdim (y, 1), szy(2:end));
      pp.orient = "first";

      if (ispp)
        yi = pp;
      else
        yi = ppval (pp, reshape (xi, szx));
      endif

    case "previous"
      pp = mkpp ([x(1:nx); 2*x(nx)-x(nx-1)],
                 shiftdim (y, 1), szy(2:end));
      pp.orient = "first";

      if (ispp)
        yi = pp;
      else
        yi = ppval (pp, reshape (xi, szx));
      endif

    case "*previous"
      pp = mkpp (x(1)+[0:nx]*dx,
                 shiftdim (y, 1), szy(2:end));
      pp.orient = "first";

      if (ispp)
        yi = pp;
      else
        yi = ppval (pp, reshape (xi, szx));
      endif

    case "linear"

      xx = x;
      nxx = nx;
      yy = y;
      dy = diff (yy);
      if (have_jumps)
        ## Omit zero-size intervals.
        xx(jumps) = [];
        nxx = rows (xx);
        yy(jumps, :) = [];
        dy(jumps, :) = [];
      endif

      dx = diff (xx);
      dx = repmat (dx, [1 size(dy)(2:end)]);

      coefs = [(dy./dx).', yy(1:nxx-1, :).'];

      pp = mkpp (xx, coefs, szy(2:end));
      pp.orient = "first";

      if (ispp)
        yi = pp;
      else
        yi = ppval (pp, reshape (xi, szx));
      endif

    case "*linear"
      dy = diff (y);
      coefs = [(dy/dx).'(:), y(1:nx-1, :).'(:)];
      pp = mkpp (x, coefs, szy(2:end));
      pp.orient = "first";

      if (ispp)
        yi = pp;
      else
        yi = ppval (pp, reshape (xi, szx));
      endif

    case {"pchip", "*pchip", "cubic", "*cubic"}
      if (nx == 2 || starmethod)
        x = linspace (x(1), x(nx), ny);
      endif

      if (ispp)
        y = shiftdim (reshape (y, szy), 1);
        yi = pchip (x, y);
        yi.orient = "first";
      else
        y = shiftdim (y, 1);
        yi = pchip (x, y, reshape (xi, szx));
        if (! isvector (y))
          yi = shiftdim (yi, 1);
        endif
      endif

    case {"spline", "*spline"}
      if (nx == 2 || starmethod)
        x = linspace (x(1), x(nx), ny);
      endif

      if (ispp)
        y = shiftdim (reshape (y, szy), 1);
        yi = spline (x, y);
        yi.orient = "first";
      else
        y = shiftdim (y, 1);
        yi = spline (x, y, reshape (xi, szx));
        if (! isvector (y))
          yi = shiftdim (yi, 1);
        endif
      endif

    otherwise
      error ("interp1: invalid METHOD '%s'", method);

  endswitch

  if (! ispp && isnumeric (extrap))
    ## determine which values are out of range and set them to extrap,
    ## unless extrap == "extrap".
    minx = min (x(1), x(nx));
    maxx = max (x(1), x(nx));

    xi = reshape (xi, szx);
    outliers = (xi < minx) | ! (xi <= maxx);  # this even catches NaNs
    if (size_equal (outliers, yi))
      yi(outliers) = extrap;
      yi = reshape (yi, szx);
    elseif (! isscalar (yi))
      yi(outliers, :) = extrap;
    else
      warning ("interp1: Unreachable state.  Please submit data that produced this warning to bugs.octave.org");
      yi(outliers.') = extrap;
    endif

  endif

endfunction


%!demo
%! clf;
%! xf = 0:0.05:10;  yf = sin (2*pi*xf/5);
%! xp = 0:10;       yp = sin (2*pi*xp/5);
%! lin = interp1 (xp,yp,xf, 'linear');
%! spl = interp1 (xp,yp,xf, 'spline');
%! pch = interp1 (xp,yp,xf, 'pchip');
%! near= interp1 (xp,yp,xf, 'nearest');
%! plot (xf,yf,'r',xf,near,'g',xf,lin,'b',xf,pch,'c',xf,spl,'m',xp,yp,'r*');
%! legend ('original', 'nearest', 'linear', 'pchip', 'spline');
%! title ('Interpolation of continuous function sin (x) w/various methods');
%! %--------------------------------------------------------
%! % confirm that interpolated function matches the original

%!demo
%! clf;
%! xf = 0:0.05:10;  yf = sin (2*pi*xf/5);
%! xp = 0:10;       yp = sin (2*pi*xp/5);
%! lin = interp1 (xp,yp,xf, '*linear');
%! spl = interp1 (xp,yp,xf, '*spline');
%! pch = interp1 (xp,yp,xf, '*pchip');
%! near= interp1 (xp,yp,xf, '*nearest');
%! plot (xf,yf,'r',xf,near,'g',xf,lin,'b',xf,pch,'c',xf,spl,'m',xp,yp,'r*');
%! legend ('*original', '*nearest', '*linear', '*pchip', '*spline');
%! title ('Interpolation of continuous function sin (x) w/various *methods');
%! %--------------------------------------------------------
%! % confirm that interpolated function matches the original

%!demo
%! clf;
%! fstep = @(x) x > 1;
%! xf = 0:0.05:2;  yf = fstep (xf);
%! xp = linspace (0,2,10);  yp = fstep (xp);
%! pch = interp1 (xp,yp,xf, 'pchip');
%! spl = interp1 (xp,yp,xf, 'spline');
%! plot (xf,yf,'r',xf,pch,'b',xf,spl,'m',xp,yp,'r*');
%! title ({'Interpolation of step function with discontinuity at x==1', ...
%!         'Note: "pchip" is shape-preserving, "spline" (continuous 1st, 2nd derivatives) is not'});
%! legend ('original', 'pchip', 'spline');

%!demo
%! clf;
%! t = 0 : 0.3 : pi; dt = t(2)-t(1);
%! n = length (t); k = 100; dti = dt*n/k;
%! ti = t(1) + [0 : k-1]*dti;
%! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
%! ddys = diff (diff (interp1 (t,y,ti, 'spline'))./dti)./dti;
%! ddyp = diff (diff (interp1 (t,y,ti, 'pchip')) ./dti)./dti;
%! ddyc = diff (diff (interp1 (t,y,ti, 'cubic')) ./dti)./dti;
%! plot (ti(2:end-1),ddys,'b*', ti(2:end-1),ddyp,'c^', ti(2:end-1),ddyc,'g+');
%! title ({'Second derivative of interpolated "sin (4*t + 0.3) .* cos (3*t - 0.1)"', ...
%!         'Note: "spline" has continuous 2nd derivative, others do not'});
%! legend ('spline', 'pchip', 'cubic');

%!demo
%! clf;
%! xf = 0:0.05:10;                yf = sin (2*pi*xf/5) - (xf >= 5);
%! xp = [0:.5:4.5,4.99,5:.5:10];  yp = sin (2*pi*xp/5) - (xp >= 5);
%! lin = interp1 (xp,yp,xf, 'linear');
%! near= interp1 (xp,yp,xf, 'nearest');
%! plot (xf,yf,'r', xf,near,'g', xf,lin,'b', xp,yp,'r*');
%! legend ('original', 'nearest', 'linear');
%! %--------------------------------------------------------
%! % confirm that interpolated function matches the original

%!demo
%! clf;
%! x = 0:0.5:3;
%! x1 = [3 2 2 1];
%! x2 = [1 2 2 3];
%! y1 = [1 1 0 0];
%! y2 = [0 0 1 1];
%! h = plot (x, interp1 (x1, y1, x), 'b', x1, y1, 'sb');
%! hold on
%! g = plot (x, interp1 (x2, y2, x), 'r', x2, y2, '*r');
%! axis ([0.5 3.5 -0.5 1.5]);
%! legend ([h(1), g(1)], {'left-continuous', 'right-continuous'}, ...
%!         'location', 'northwest')
%! legend boxoff
%! %--------------------------------------------------------
%! % red curve is left-continuous and blue is right-continuous at x = 2

##FIXME: add test for N-d arguments here

## For each type of interpolated test, confirm that the interpolated
## value at the knots match the values at the knots.  Points away
## from the knots are requested, but only "nearest" and "linear"
## confirm they are the correct values.

%!shared xp, yp, xi, style
%! xp = 0:2:10;
%! yp = sin (2*pi*xp/5);
%! xi = [-1, 0, 2.2, 4, 6.6, 10, 11];

## The following BLOCK/ENDBLOCK section is repeated for each style
##    nearest, previous, next, linear, cubic, spline, pchip
## The test for ppval of cubic has looser tolerance, but otherwise
## the tests are identical.
## Note that the block checks style and *style; if you add more tests
## be sure to add them to both sections of each block.  One test,
## style vs. *style, occurs only in the first section.
## There is an ENDBLOCKTEST after the final block

%!test style = "nearest";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ["*",style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!error interp1 (1,1,1, style)
## ENDBLOCK

%!test style = "previous";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
## This test is expected to fail, so commented out.
## "previous" and "next" options are not symmetric w.r.t to flipping xp,yp
#%!assert (interp1 (xp,yp,xi,style),...
#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ["*",style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
#%!assert (interp1 (xp,yp,xi,style),...
#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!error interp1 (1,1,1, style)
## ENDBLOCK

%!test style = "next";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
#%!assert (interp1 (xp,yp,xi,style),...
#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ["*",style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
#%!assert (interp1 (xp,yp,xi,style),...
#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!error interp1 (1,1,1, style)
## ENDBLOCK

%!test style = "linear";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ['*',style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!assert (interp1 ([1 2 2 3], [1 2 3 4], 2), 3)
%!assert (interp1 ([3 2 2 1], [4 3 2 1], 2), 2)
%!error interp1 (1,1,1, style)
## ENDBLOCK

%!test style = "cubic";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),100*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ["*",style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),100*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!error interp1 (1,1,1, style)
## ENDBLOCK

%!test style = "pchip";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ["*",style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!error interp1 (1,1,1, style)
## ENDBLOCK

%!test style = "spline";
## BLOCK
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!error interp1 (1,1,1, style)
%!assert (interp1 (xp,[yp',yp'],xi,style),
%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
%!test style = ["*",style];
%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
%!assert (isempty (interp1 (xp',yp',[],style)))
%!assert (isempty (interp1 (xp,yp,[],style)))
%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
%!assert <*61903> ...
%!  (interp1 (xp, yp + 1i * yp.^2, xi, style),...
%!   interp1 (xp,yp,xi,style) + 1i * interp1 (xp,yp.^2,xi,style))
%!assert (interp1 (xp,yp,xi,style),...
%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
%!assert (interp1 (yp, xi, style, 0), ...
%!        interp1 (1:numel (yp), yp, xi, style, 0), 10*eps)
%!error interp1 (1,1,1, style)
## ENDBLOCK
## ENDBLOCKTEST

## test extrapolation
%!assert (interp1 ([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps)
%!assert (interp1 ([1:5],[3:2:11],[0,6],"nearest","extrap"), [3, 11], eps)
%!assert (interp1 ([1:5],[3:2:11],[0,6],"previous","extrap"), [3, 11], eps)
%!assert (interp1 ([1:5],[3:2:11],[0,6],"next","extrap"), [3, 11], eps)
%!assert (interp1 (xp, yp, [-1, max(xp)+1],"linear",5), [5, 5])
%!assert (interp1 ([0,1],[1,0],[0.1,0.9;0.2,1.1]), [0.9 0.1; 0.8 NA], eps)
%!assert (interp1 ([0,1],[1,0],[0.1,0.9;0.2,1]), [0.9 0.1; 0.8 0], eps)

## Basic sanity checks
%!assert (interp1 (1:2,1:2,1.4,"nearest"), 1)
%!assert (interp1 (1:2,1:2,1.6,"previous"), 1)
%!assert (interp1 (1:2,1:2,1.4,"next"), 2)
%!assert (interp1 (1:2,1:2,1.4,"linear"), 1.4)
%!assert (interp1 (1:4,1:4,1.4,"cubic"), 1.4)
%!assert (interp1 (1:2,1:2,1.1,"spline"), 1.1)
%!assert (interp1 (1:3,1:3,1.4,"spline"), 1.4)

%!assert (interp1 (1:2:4,1:2:4,1.4,"*nearest"), 1)
%!assert (interp1 (1:2:4,1:2:4,2.2,"*previous"), 1)
%!assert (interp1 (1:2:4,1:2:4,1.4,"*next"), 3)
%!assert (interp1 (1:2:4,1:2:4,[0,1,1.4,3,4],"*linear"), [NA,1,1.4,3,NA])
%!assert (interp1 (1:2:8,1:2:8,1.4,"*cubic"), 1.4)
%!assert (interp1 (1:2,1:2,1.3, "*spline"), 1.3)
%!assert (interp1 (1:2:6,1:2:6,1.4,"*spline"), 1.4)

%!assert (interp1 ([3,2,1],[3,2,2],2.5), 2.5)

%!assert (interp1 ([4,4,3,2,0],[0,1,4,2,1],[1.5,4,4.5], "linear"), [1.75,1,NA])
%!assert (interp1 (0:4, 2.5), 1.5)

## Left and Right discontinuities
%!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap", "right"), [-2,0.5,4,3,1.5])
%!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap", "left"), [-2,0.5,1,3,1.5])

## Test input validation
%!error <Invalid call> interp1 ()
%!error <Invalid call> interp1 (1)
%!error <Invalid call> interp1 (1,2,3,4,5,6,7)
%!error <minimum of 2 points required> interp1 (1,1,1, "linear")
%!error <minimum of 2 points required> interp1 (1,1,1, "*nearest")
%!error <minimum of 2 points required> interp1 (1,1,1, "*linear")
%!error <minimum of 2 points required> interp1 (1,1,1, "previous")
%!error <minimum of 2 points required> interp1 (1,1,1, "*previous")
%!warning <multiple discontinuities> interp1 ([1 1 1 2], [1 2 3 4], 1);
%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "next")
%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "pchip")
%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "cubic")
%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "spline")
%!error <invalid METHOD 'invalid'> interp1 (1:2,1:2,1, "invalid")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{zi} =} interp2 (@var{x}, @var{y}, @var{z}, @var{xi}, @var{yi})
## @deftypefnx {} {@var{zi} =} interp2 (@var{z}, @var{xi}, @var{yi})
## @deftypefnx {} {@var{zi} =} interp2 (@var{z}, @var{n})
## @deftypefnx {} {@var{zi} =} interp2 (@var{z})
## @deftypefnx {} {@var{zi} =} interp2 (@dots{}, @var{method})
## @deftypefnx {} {@var{zi} =} interp2 (@dots{}, @var{method}, @var{extrap})
##
## Two-dimensional interpolation.
##
## Interpolate reference data @var{x}, @var{y}, @var{z} to determine @var{zi}
## at the coordinates @var{xi}, @var{yi}.  The reference data @var{x}, @var{y}
## can be matrices, as returned by @code{meshgrid}, in which case the sizes of
## @var{x}, @var{y}, and @var{z} must be equal.  If @var{x}, @var{y} are
## vectors describing a grid then @code{length (@var{x}) == columns (@var{z})}
## and @code{length (@var{y}) == rows (@var{z})}.  In either case the input
## data must be strictly monotonic.
##
## If called without @var{x}, @var{y}, and just a single reference data matrix
## @var{z}, the 2-D region
## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})} is assumed.
## This saves memory if the grid is regular and the distance between points is
## not important.
##
## If called with a single reference data matrix @var{z} and a refinement
## value @var{n}, then perform interpolation over a grid where each original
## interval has been recursively subdivided @var{n} times.  This results in
## @code{2^@var{n}-1} additional points for every interval in the original
## grid.  If @var{n} is omitted a value of 1 is used.  As an example, the
## interval [0,1] with @code{@var{n}==2} results in a refined interval with
## points at [0, 1/4, 1/2, 3/4, 1].
##
## The interpolation @var{method} is one of:
##
## @table @asis
## @item @qcode{"nearest"}
## Return the nearest neighbor.
##
## @item @qcode{"linear"} (default)
## Linear interpolation from nearest neighbors.
##
## @item @qcode{"pchip"}
## Piecewise cubic Hermite interpolating polynomial---shape-preserving
## interpolation with smooth first derivative.
##
## @item @qcode{"cubic"}
## Cubic interpolation (same as @qcode{"pchip"}).
##
## @item @qcode{"spline"}
## Cubic spline interpolation---smooth first and second derivatives
## throughout the curve.
## @end table
##
## @var{extrap} is a scalar number.  It replaces values beyond the endpoints
## with @var{extrap}.  Note that if @var{extrap} is used, @var{method} must
## be specified as well.  If @var{extrap} is omitted and the @var{method} is
## @qcode{"spline"}, then the extrapolated values of the @qcode{"spline"} are
## used.  Otherwise the default @var{extrap} value for any other @var{method}
## is @qcode{"NA"}.
## @seealso{interp1, interp3, interpn, meshgrid}
## @end deftypefn

function ZI = interp2 (varargin)

  narginchk (1, 7);
  nargs = nargin;

  Z = X = Y = XI = YI = n = [];
  method = "linear";
  extrap = [];

  ## Check for method and extrap
  if (nargs > 1 && ischar (varargin{end-1}))
    if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
      error ("interp2: EXTRAP must be a numeric scalar");
    endif
    extrap = varargin{end};
    method = varargin{end-1};
    nargs -= 2;
  elseif (ischar (varargin{end}))
    method = varargin{end};
    nargs -= 1;
  endif
  if (method(1) == "*")
    warning ("interp2: ignoring unsupported '*' flag to METHOD");
    method(1) = [];
  endif
  method = validatestring (method, ...
                           {"nearest", "linear", "pchip", "cubic", "spline"});

  ## Read numeric input
  switch (nargs)
    case 1
      Z = varargin{1};
      n = 1;
    case 2
      [Z, n] = deal (varargin{1:nargs});
    case 3
      [Z, XI, YI] = deal (varargin{1:nargs});
    case 5
      [X, Y, Z, XI, YI] = deal (varargin{1:nargs});
    otherwise
      print_usage ();
  endswitch

  ## Type checking
  if (! isnumeric (Z) || isscalar (Z) || ! ismatrix (Z))
    error ("interp2: Z must be a 2-D matrix");
  endif
  if (! isempty (n) && ! (isscalar (n) && n >= 0 && n == fix (n)))
    error ("interp2: N must be an integer >= 0");
  endif

  ## Define X, Y, XI, YI if needed
  [zr, zc] = size (Z);
  if (isempty (X))
    X = 1:zc;
    Y = 1:zr;
  endif
  if (! isnumeric (X) || ! isnumeric (Y))
    error ("interp2: X, Y must be numeric matrices");
  endif
  if (! isempty (n))
    ## Calculate the interleaved input vectors.
    p = 2^n;
    XI = (p:p*zc)/p;
    YI = (p:p*zr)'/p;
  endif
  if (! isnumeric (XI) || ! isnumeric (YI))
    error ("interp2: XI, YI must be numeric");
  endif

  if (isvector (X) && isvector (Y))
    X = X(:);  Y = Y(:);
  elseif (size_equal (X, Y))
    X = X(1,:).';  Y = Y(:,1);
  else
    error ("interp2: X and Y must be matrices of equal size");
  endif
  if (columns (Z) != length (X) || rows (Z) != length (Y))
    error ("interp2: X and Y size must match the dimensions of Z");
  endif
  dx = diff (X);
  if (all (dx < 0))
    X = flipud (X);
    Z = fliplr (Z);
  elseif (any (dx <= 0))
    error ("interp2: X must be strictly monotonic");
  endif
  dy = diff (Y);
  if (all (dy < 0))
    Y = flipud (Y);
    Z = flipud (Z);
  elseif (any (dy <= 0))
    error ("interp2: Y must be strictly monotonic");
  endif

  if (any (strcmp (method, {"nearest", "linear", "pchip", "cubic"})))

    ## If Xi and Yi are vectors of different orientation build a grid
    if ((isrow (XI) && iscolumn (YI)) || (iscolumn (XI) && isrow (YI)))
      [XI, YI] = meshgrid (XI, YI);
    elseif (! size_equal (XI, YI))
      error ("interp2: XI and YI must be matrices of equal size");
    endif

    ## if XI, YI are vectors, X and Y should share their orientation.
    if (isrow (XI))
      if (rows (X) != 1)
        X = X.';
      endif
      if (rows (Y) != 1)
        Y = Y.';
      endif
    elseif (iscolumn (XI))
      if (columns (X) != 1)
        X = X.';
      endif
      if (columns (Y) != 1)
        Y = Y.';
      endif
    endif

    xidx = lookup (X, XI, "lr");
    yidx = lookup (Y, YI, "lr");

    if (strcmp (method, "linear"))
      ## each quad satisfies the equation z(x,y)=a+b*x+c*y+d*xy
      ##
      ## a-b
      ## | |
      ## c-d
      a = Z(1:(zr - 1), 1:(zc - 1));
      b = Z(1:(zr - 1), 2:zc) - a;
      c = Z(2:zr, 1:(zc - 1)) - a;
      d = Z(2:zr, 2:zc) - a - b - c;

      ## scale XI, YI values to a 1-spaced grid
      Xsc = (XI - X(xidx)) ./ (diff (X)(xidx));
      Ysc = (YI - Y(yidx)) ./ (diff (Y)(yidx));

      ## Get 2D index.
      idx = sub2ind (size (a), yidx, xidx);
      ## Dispose of the 1D indices at this point to save memory.
      clear xidx yidx;

      ## Apply plane equation
      ## Handle case where idx and coefficients are both vectors and resulting
      ## coeff(idx) follows orientation of coeff, rather than that of idx.
      forient = @(x) reshape (x, size (idx));
      ZI =   forient (a(idx))        ...
           + forient (b(idx)) .* Xsc ...
           + forient (c(idx)) .* Ysc ...
           + forient (d(idx)) .* Xsc.*Ysc;

    elseif (strcmp (method, "nearest"))
      ii = (XI - X(xidx) >= X(xidx + 1) - XI);
      jj = (YI - Y(yidx) >= Y(yidx + 1) - YI);
      idx = sub2ind (size (Z), yidx+jj, xidx+ii);
      ZI = Z(idx);

    elseif (strcmp (method, "pchip") || strcmp (method, "cubic"))

      if (length (X) < 2 || length (Y) < 2)
        error ("interp2: %s requires at least 2 points in each dimension",
               method);
      endif

      ## first order derivatives
      DX = __pchip_deriv__ (X, Z, 2);
      DY = __pchip_deriv__ (Y, Z, 1);
      ## Compute mixed derivatives row-wise and column-wise.  Use the average.
      DXY = (__pchip_deriv__ (X, DY, 2) + __pchip_deriv__ (Y, DX, 1))/2;

      if (iscomplex (Z))
        ## __pchip_deriv__ works only on real part.  Do it again for imag part.
        ## FIXME: Adapt __pchip_deriv__ to correctly handle complex input.

        ## first order derivatives
        DX += 1i * __pchip_deriv__ (X, imag (Z), 2);
        DY += 1i * __pchip_deriv__ (Y, imag (Z), 1);
        ## Compute mixed derivatives row-wise and column-wise.  Use the average.
        DXY += 1i * (__pchip_deriv__ (X, imag (DY), 2)
                     + __pchip_deriv__ (Y, imag (DX), 1))/2;
      endif

      ## do the bicubic interpolation
      hx = diff (X); hx = hx(xidx);
      hy = diff (Y); hy = hy(yidx);

      tx = (XI - X(xidx)) ./ hx;
      ty = (YI - Y(yidx)) ./ hy;

      ## construct the cubic hermite base functions in x, y

      ## formulas:
      ## b{1,1} =    ( 2*t.^3 - 3*t.^2     + 1);
      ## b{2,1} = h.*(   t.^3 - 2*t.^2 + t    );
      ## b{1,2} =    (-2*t.^3 + 3*t.^2        );
      ## b{2,2} = h.*(   t.^3 -   t.^2        );

      ## optimized equivalents of the above:
      t1 = tx.^2;
      t2 = tx.*t1 - t1;
      xb{2,2} = hx.*t2;
      t1 = t2 - t1;
      xb{2,1} = hx.*(t1 + tx);
      t2 += t1;
      xb{1,2} = -t2;
      xb{1,1} = t2 + 1;

      t1 = ty.^2;
      t2 = ty.*t1 - t1;
      yb{2,2} = hy.*t2;
      t1 = t2 - t1;
      yb{2,1} = hy.*(t1 + ty);
      t2 += t1;
      yb{1,2} = -t2;
      yb{1,1} = t2 + 1;

      ZI = zeros (size (XI));
      for i = 1:2
        for j = 1:2
          zidx = sub2ind (size (Z), yidx+(j-1), xidx+(i-1));
          ZI += xb{1,i} .* yb{1,j} .*   Z(zidx);
          ZI += xb{2,i} .* yb{1,j} .*  DX(zidx);
          ZI += xb{1,i} .* yb{2,j} .*  DY(zidx);
          ZI += xb{2,i} .* yb{2,j} .* DXY(zidx);
        endfor
      endfor

    endif

  else

    ## Check dimensions of XI and YI
    if (isvector (XI) && isvector (YI) && ! size_equal (XI, YI))
      XI = XI(:).';  YI = YI(:);
    elseif (! size_equal (XI, YI))
      error ("interp2: XI and YI must be matrices of equal size");
    endif

    if (strcmp (method, "spline"))
      if (isgriddata (XI) && isgriddata (YI'))
        ZI = __splinen__ ({Y, X}, Z, {YI(:,1), XI(1,:)}, extrap, "spline");
      else
        error ("interp2: XI, YI must have uniform spacing ('meshgrid' format)");
      endif
    endif

    return; # spline doesn't need NA extrapolation value (MATLAB compatibility)

  endif

  ## extrapolation 'extrap'
  if (isempty (extrap))
    if (iscomplex (Z))
      extrap = complex (NA, NA);
    else
      extrap = NA;
    endif
  endif

  if (X(1) < X(end))
    if (Y(1) < Y(end))
      ZI(XI < X(1,1) | XI > X(end) | YI < Y(1,1) | YI > Y(end)) = extrap;
    else
      ZI(XI < X(1) | XI > X(end) | YI < Y(end) | YI > Y(1)) = extrap;
    endif
  else
    if (Y(1) < Y(end))
      ZI(XI < X(end) | XI > X(1) | YI < Y(1) | YI > Y(end)) = extrap;
    else
      ZI(XI < X(1,end) | XI > X(1) | YI < Y(end) | YI > Y(1)) = extrap;
    endif
  endif

endfunction

function b = isgriddata (X)
  d1 = diff (X, 1, 1);
  b = ! any (d1(:) != 0);
endfunction


%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,4];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! [x,y,A] = peaks (10);
%! x = x(1,:)';  y = y(:,1);
%! xi = linspace (min (x), max (x), 41);
%! yi = linspace (min (y), max (y), 41)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,4];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! [x,y,A] = peaks (10);
%! x = x(1,:)';  y = y(:,1);
%! xi = linspace (min (x), max (x), 41);
%! yi = linspace (min (y), max (y), 41)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

## 'pchip' commented out since it is the same as 'cubic'
%!#demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,2];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

## 'pchip' commented out since it is the same as 'cubic'
%!#demo
%! clf;
%! colormap ("default");
%! [x,y,A] = peaks (10);
%! x = x(1,:)';  y = y(:,1);
%! xi = linspace (min (x), max (x), 41);
%! yi = linspace (min (y), max (y), 41)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,2];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! [x,y,A] = peaks (10);
%! x = x(1,:)';  y = y(:,1);
%! xi = linspace (min (x), max (x), 41);
%! yi = linspace (min (y), max (y), 41)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,2];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! [x,y,A] = peaks (10);
%! x = x(1,:)';  y = y(:,1);
%! xi = linspace (min (x), max (x), 41);
%! yi = linspace (min (y), max (y), 41)';
%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x,y,A,"b*"); hold off;

%!test  # simple test
%! x = [1,2,3];
%! y = [4,5,6,7];
%! [X, Y] = meshgrid (x, y);
%! orig = X.^2 + Y.^3;
%! xi = [1.2,2, 1.5];
%! yi = [6.2, 4.0, 5.0]';
%!
%! expected = ...
%!   [243,   245.4,  243.9;
%!     65.6,  68,     66.5;
%!    126.6, 129,    127.5];
%! result = interp2 (x,y,orig, xi, yi);
%!
%! assert (result, expected, 1000*eps);

## Test that interpolating a complex matrix is equivalent to interpolating its
## real and imaginary parts separately.
%!test <61863>
%! xi = [2.5, 3.5];
%! yi = [0.5, 1.5]';
%! orig = rand (2, 3) + 1i * rand (2, 3);
%! for method = {"nearest", "linear", "pchip", "spline"}
%!   interp_complex = interp2 (orig, xi, yi, method{1});
%!   interp_real = interp2 (real (orig), xi, yi, method{1});
%!   interp_imag = interp2 (imag (orig), xi, yi, method{1});
%!   assert (real (interp_complex), interp_real)
%!   assert (imag (interp_complex), interp_imag)
%! endfor

%!test  # 2^n refinement form
%! x = [1,2,3];
%! y = [4,5,6,7];
%! [X, Y] = meshgrid (x, y);
%! orig = X.^2 + Y.^3;
%! xi = [1:0.25:3];  yi = [4:0.25:7]';
%! expected = interp2 (x,y,orig, xi, yi);
%! result = interp2 (orig, 2);
%!
%! assert (result, expected, 10*eps);

%!test  # matrix slice
%! A = eye (4);
%! assert (interp2 (A,[1:4],[1:4]), [1,1,1,1]);

%!test  # non-gridded XI,YI
%! A = eye (4);
%! assert (interp2 (A,[1,2;3,4],[1,3;2,4]), [1,0;0,1]);

%!test  # for values outside of boundaries
%! x = [1,2,3];
%! y = [4,5,6,7];
%! [X, Y] = meshgrid (x,y);
%! orig = X.^2 + Y.^3;
%! xi = [0,4];
%! yi = [3,8]';
%! assert (interp2 (x,y,orig, xi, yi), [NA,NA;NA,NA]);
%! assert (interp2 (x,y,orig, xi, yi,"linear", 0), [0,0;0,0]);
%! assert (interp2 (x,y,orig, xi, yi,"linear", 2), [2,2;2,2]);
%! assert (interp2 (x,y,orig, xi, yi,"spline", 2), [2,2;2,2]);
%! assert (interp2 (x,y,orig, xi, yi,"linear", 0+1i), [0+1i,0+1i;0+1i,0+1i]);
%! assert (interp2 (x,y,orig, xi, yi,"spline"), [27,43;512,528]);

%!test  # for values at boundaries
%! A = [1,2;3,4];
%! x = [0,1];
%! y = [2,3]';
%! assert (interp2 (x,y,A,x,y,"linear"), A);
%! assert (interp2 (x,y,A,x,y,"nearest"), A);

%!test  # for Matlab-compatible rounding for 'nearest'
%! X = meshgrid (1:4);
%! assert (interp2 (X, 2.5, 2.5, "nearest"), 3);

## re-order monotonically decreasing
%!assert <*41838> (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
%!assert <*41838> (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)

## Linear interpretation with vector XI doesn't lead to matrix output
%!assert <*49506> (interp2 ([2 3], [2 3 4], [1 2; 3 4; 5 6], [2 3], 3, "linear"), [3 4])

%!shared z, zout, tol
%! z = [1 3 5; 3 5 7; 5 7 9];
%! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
%! tol = 2 * eps;
%!
%!assert (interp2 (z), zout, tol)
%!assert (interp2 (z, "linear"), zout, tol)
%!assert (interp2 (z, "pchip"), zout, tol)
%!assert (interp2 (z, "cubic"), zout, 10 * tol)
%!assert (interp2 (z, "spline"), zout, tol)
%!assert (interp2 (z, [2 3 1], [2 2 2]', "linear"),
%!        repmat ([5, 7, 3], [3, 1]), tol)
%!assert (interp2 (z, [2 3 1], [2 2 2]', "pchip"),
%!        repmat ([5, 7, 3], [3, 1]), tol)
%!assert (interp2 (z, [2 3 1], [2 2 2]', "cubic"),
%!        repmat ([5, 7, 3], [3, 1]), 10 * tol)
%!assert (interp2 (z, [2 3 1], [2 2 2]', "spline"),
%!        repmat ([5, 7, 3], [3, 1]), tol)
%!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol)
%!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol)
%!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol)
%!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol)

## Test input validation
%!error interp2 (1, 1, 1, 1, 1, 2)    # only 5 numeric inputs
%!error interp2 (1, 1, 1, 1, 1, 2, 2) # only 5 numeric inputs
%!error <Z must be a 2-D matrix> interp2 ({1})
%!error <Z must be a 2-D matrix> interp2 (1,1,1)
%!error <Z must be a 2-D matrix> interp2 (ones (2,2,2))
%!error <N must be an integer .= 0> interp2 (ones (2), ones (2))
%!error <N must be an integer .= 0> interp2 (ones (2), -1)
%!error <N must be an integer .= 0> interp2 (ones (2), 1.5)
%!warning <ignoring unsupported '\*' flag> interp2 (rand (3,3), 1, "*linear");
%!error <EXTRAP must be a numeric scalar> interp2 (1, 1, 1, 1, 1, 'linear', {1})
%!error <EXTRAP must be a numeric scalar> interp2 (1, 1, 1, 1, 1, 'linear', ones (2,2))
%!error <EXTRAP must be a numeric scalar> interp2 (1, 1, 1, 1, 1, 'linear', "abc")
%!error <EXTRAP must be a numeric scalar> interp2 (1, 1, 1, 1, 1, 'linear', "extrap")
%!error <X, Y must be numeric matrices> interp2 ({1}, 1, ones (2), 1, 1)
%!error <X, Y must be numeric matrices> interp2 (1, {1}, ones (2), 1, 1)
%!error <XI, YI must be numeric> interp2 (1, 1, ones (2), {1}, 1)
%!error <XI, YI must be numeric> interp2 (1, 1, ones (2), 1, {1})
%!error <X and Y must be matrices of equal size> interp2 (ones (2,2), 1, ones (2), 1, 1)
%!error <X and Y must be matrices of equal size> interp2 (ones (2,2), ones (2,3), ones (2), 1, 1)
%!error <X and Y size must match the dimensions of Z> interp2 (1:3, 1:3, ones (3,2), 1, 1)
%!error <X and Y size must match the dimensions of Z> interp2 (1:2, 1:2, ones (3,2), 1, 1)
%!error <X must be strictly monotonic> interp2 ([1 0 2], 1:3, ones (3,3), 1, 1)
%!error <Y must be strictly monotonic> interp2 (1:3, [1 0 2], ones (3,3), 1, 1)
%!error <XI and YI must be matrices of equal size> interp2 (1:2, 1:2, ones (2), ones (2,2), 1)
%!error <XI and YI must be matrices of equal size> interp2 (1:2, 1:2, ones (2), 1, ones (2,2))
%!error <XI, YI must have uniform spacing> interp2 (1:2, 1:2, ones (2), [1 2 4], [1 2 3], "spline")
%!error <XI, YI must have uniform spacing> interp2 (1:2, 1:2, ones (2), [1 2 3], [1 2 4], "spline")
%!error interp2 (1, 1, 1, 1, 1, "foobar")
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{vi} =} interp3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
## @deftypefnx {} {@var{vi} =} interp3 (@var{v}, @var{xi}, @var{yi}, @var{zi})
## @deftypefnx {} {@var{vi} =} interp3 (@var{v}, @var{n})
## @deftypefnx {} {@var{vi} =} interp3 (@var{v})
## @deftypefnx {} {@var{vi} =} interp3 (@dots{}, @var{method})
## @deftypefnx {} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
##
## Three-dimensional interpolation.
##
## Interpolate reference data @var{x}, @var{y}, @var{z}, @var{v} to determine
## @var{vi} at the coordinates @var{xi}, @var{yi}, @var{zi}.  The reference
## data @var{x}, @var{y}, @var{z} can be matrices, as returned by
## @code{meshgrid}, in which case the sizes of @var{x}, @var{y}, @var{z}, and
## @var{v} must be equal.  If @var{x}, @var{y}, @var{z} are vectors describing
## a cubic grid then @code{length (@var{x}) == columns (@var{v})},
## @code{length (@var{y}) == rows (@var{v})}, and
## @code{length (@var{z}) == size (@var{v}, 3)}.  In either case the input
## data must be strictly monotonic.
##
## If called without @var{x}, @var{y}, @var{z}, and just a single reference
## data matrix @var{v}, the 3-D region
## @code{@var{x} = 1:columns (@var{v}), @var{y} = 1:rows (@var{v}),
## @var{z} = 1:size (@var{v}, 3)} is assumed.
## This saves memory if the grid is regular and the distance between points is
## not important.
##
## If called with a single reference data matrix @var{v} and a refinement
## value @var{n}, then perform interpolation over a 3-D grid where each
## original interval has been recursively subdivided @var{n} times.  This
## results in @code{2^@var{n}-1} additional points for every interval in the
## original grid.  If @var{n} is omitted a value of 1 is used.  As an
## example, the interval [0,1] with @code{@var{n}==2} results in a refined
## interval with points at [0, 1/4, 1/2, 3/4, 1].
##
## The interpolation @var{method} is one of:
##
## @table @asis
## @item @qcode{"nearest"}
## Return the nearest neighbor.
##
## @item @qcode{"linear"} (default)
## Linear interpolation from nearest neighbors.
##
## @item @qcode{"cubic"}
## Piecewise cubic Hermite interpolating polynomial---shape-preserving
## interpolation with smooth first derivative (not implemented yet).
##
## @item @qcode{"spline"}
## Cubic spline interpolation---smooth first and second derivatives
## throughout the curve.
## @end table
##
## @var{extrapval} is a scalar number.  It replaces values beyond the endpoints
## with @var{extrapval}.  Note that if @var{extrapval} is used, @var{method}
## must be specified as well.  If @var{extrapval} is omitted and the
## @var{method} is @qcode{"spline"}, then the extrapolated values of the
## @qcode{"spline"} are used.  Otherwise the default @var{extrapval} value for
## any other @var{method} is @qcode{"NA"}.
## @seealso{interp1, interp2, interpn, meshgrid}
## @end deftypefn

## FIXME: Need to add support for 'cubic' method (maybe change interpn).

function vi = interp3 (varargin)

  narginchk (1,9);

  method = "linear";
  extrapval = [];
  nargs = nargin;

  if (! isnumeric (varargin{1}))
    print_usage ();
  endif

  if (nargs > 1 && ischar (varargin{end-1}))
    if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
      error ("interp3: EXTRAPVAL must be a numeric scalar");
    endif
    extrapval = varargin{end};
    method = varargin{end-1};
    nargs -= 2;
  elseif (ischar (varargin{end}))
    method = varargin{end};
    nargs -= 1;
  endif

  if (method(1) == "*")
    warning ("interp3: ignoring unsupported '*' flag to METHOD");
    method(1) = [];
  endif
  method = validatestring (method, {"nearest", "linear", "cubic", "spline"});

  if (nargs < 3)
    ## Calling form interp3 (v) OR interp3 (v, n)
    v = varargin{1};
    if (ndims (v) != 3)
      error ("interp3: V must be a 3-D array of values");
    endif
    n = varargin(2:nargs);
    v = permute (v, [2, 1, 3]);
    if (isempty (extrapval))
      vi = interpn (v, n{:}, method);
    else
      vi = interpn (v, n{:}, method, extrapval);
    endif

  elseif (nargs == 4 && ! isvector (varargin{1}))
    ## Calling form interp3 (v, xi, yi, zi)
    v = varargin{1};
    if (ndims (v) != 3)
      error ("interp3: V must be a 3-D array of values");
    endif
    xi = varargin(2:4);
    if (any (! cellfun (@isvector, xi)))
      ## Meshgridded values rather than vectors
      if (! size_equal (xi{:}))
        error ("interp3: XI, YI, and ZI dimensions must be equal");
      endif
      for i = 1 : 3
        xi{i} = permute (xi{i}, [2, 1, 3]);
      endfor
    endif
    v = permute (v, [2, 1, 3]);
    if (isempty (extrapval))
      vi = interpn (v, xi{:}, method);
    else
      vi = interpn (v, xi{:}, method, extrapval);
    endif

  elseif (nargs == 7)
    ## Calling form interp3 (x, y, z, v, xi, yi, zi)
    v = varargin{4};
    if (ndims (v) != 3)
      error ("interp3: V must be a 3-D array of values");
    endif
    x = varargin(1:3);
    if (any (! cellfun (@isvector, x)))
      ## Meshgridded values rather than vectors
      if (! size_equal (x{:}, v))
        error ("interp3: X, Y, Z, and V dimensions must be equal");
      endif
      for i = 1 : 3
        x{i} = permute (x{i}, [2, 1, 3]);
      endfor
    endif
    xi = varargin(5:7);
    if (any (! cellfun (@isvector, xi)))
      ## Meshgridded values rather than vectors
      if (! size_equal (xi{:}))
        error ("interp3: XI, YI, and ZI dimensions must be equal");
      endif
      for i = 1 : 3
        xi{i} = permute (xi{i}, [2, 1, 3]);
      endfor
    endif
    v = permute (v, [2, 1, 3]);
    if (isempty (extrapval))
      vi = interpn (x{:}, v, xi{:}, method);
    else
      vi = interpn (x{:}, v, xi{:}, method, extrapval);
    endif

  else
    error ("interp3: wrong number or incorrectly formatted input arguments");
  endif

  if (! isvector (vi))
    vi = ipermute (vi, [2, 1, 3]);
  endif

endfunction


## FIXME: Need some demo blocks here to show off the function like interp2.m.

%!test  # basic test
%! x = y = z = -1:1;  y = y + 2;
%! f = @(x,y,z) x.^2 - y - z.^2;
%! [xx, yy, zz] = meshgrid (x, y, z);
%! v = f (xx,yy,zz);
%! xi = yi = zi = -1:0.5:1;  yi = yi + 2.1;
%! [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
%! vi = interp3 (x, y, z, v, xxi, yyi, zzi);
%! [xxi, yyi, zzi] = ndgrid (yi, xi, zi);
%! vi2 = interpn (y, x, z, v, xxi, yyi, zzi);
%! assert (vi, vi2, 10*eps);

%!test  # meshgridded xi, yi, zi
%! x = z = 1:2;  y = 1:3;
%! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
%! xi = zi = .6:1.6;  yi = 1;
%! [xxi3, yyi3, zzi3] = meshgrid (xi, yi, zi);
%! [xxi, yyi, zzi] = ndgrid (yi, xi, zi);
%! vi = interp3 (x, y, z, v, xxi3, yyi3, zzi3, "nearest");
%! vi2 = interpn (y, x, z, v, xxi, yyi, zzi, "nearest");
%! assert (vi, vi2);

%!test  # vector xi, yi, zi
%! x = z = 1:2;  y = 1:3;
%! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
%! xi = zi = .6:1.6;  yi = 1;
%! vi = interp3 (x, y, z, v, xi, yi, zi, "nearest");
%! vi2 = interpn (y, x, z, v, yi, xi, zi, "nearest");
%! assert (vi, vi2);

%!test  # vector xi+1 with extrap value
%! x = z = 1:2;  y = 1:3;
%! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
%! xi = zi = .6:1.6;  yi = 1;
%! vi = interp3 (x, y, z, v, xi+1, yi, zi, "nearest", 3);
%! vi2 = interpn (y, x, z, v, yi, xi+1, zi, "nearest", 3);
%! assert (vi, vi2);

%!test  # input value matrix--no x,y,z
%! x = z = 1:2;  y = 1:3;
%! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
%! xi = zi = .6:1.6;  yi = 1;
%! vi = interp3 (v, xi, yi, zi, "nearest");
%! vi2 = interpn (v, yi, xi, zi, "nearest");
%! assert (vi, vi2);

%!test  # input value matrix--no x,y,z, with extrap value
%! x = z = 1:2;  y = 1:3;
%! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
%! xi = zi = .6:1.6;  yi = 1;
%! vi = interp3 (v, xi, yi, zi, "nearest", 3);
%! vi2 = interpn (v, yi, xi, zi, "nearest", 3);
%! assert (vi, vi2);

%!test  # extrapolation
%! X = [0,0.5,1];  Y=X;  Z=X;
%! V = zeros (3,3,3);
%! V(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
%! V(:,:,2) = V(:,:,1) + 2;
%! V(:,:,3) = V(:,:,2) + 2;
%! tol = 10 * eps;
%! x = y = z = [-0.1,0,0.1];
%! assert (interp3 (X,Y,Z,V,x,y,z,"spline"), [-0.2, 1.0, 2.2], tol);
%! assert (interp3 (X,Y,Z,V,x,y,z,"linear"), [NA, 1.0, 2.2], tol);
%! assert (interp3 (X,Y,Z,V,x,y,z,"spline", 0), [0, 1.0, 2.2], tol);
%! assert (interp3 (X,Y,Z,V,x,y,z,"linear", 0), [0, 1.0, 2.2], tol);

%!shared z, zout, tol
%! z = zeros (3, 3, 3);
%! zout = zeros (5, 5, 5);
%! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
%! z(:,:,2) = z(:,:,1) + 2;
%! z(:,:,3) = z(:,:,2) + 2;
%! for n = 1:5
%!   zout(:,:,n) = [1 2 3 4 5;
%!                  2 3 4 5 6;
%!                  3 4 5 6 7;
%!                  4 5 6 7 8;
%!                  5 6 7 8 9] + (n-1);
%! endfor
%! tol = 10 * eps;
%!
%!assert (interp3 (z), zout, tol)
%!assert (interp3 (z, "linear"), zout, tol)
%!assert (interp3 (z, "spline"), zout, tol)

%!test <*57450>
%! [x, y, z] = meshgrid (1:10);
%! v = x;
%! xi = yi = zi = linspace (1, 10, 20).';
%! vi = interp3 (x, y, z, v, xi, yi, zi);
%! assert (size (vi), [20, 1]);

## Test input validation
%!error <not enough input arguments> interp3 ()
%!error <Invalid call> interp3 ({1})
%!error <EXTRAPVAL must be a numeric scalar> interp3 (1,2,3,4,1,2,3,"linear", {1})
%!error <EXTRAPVAL must be a numeric scalar> interp3 (1,2,3,4,1,2,3,"linear", ones (2,2))
%!warning <ignoring unsupported '\*' flag> interp3 (rand (3,3,3), 1, "*linear");
%!error <V must be a 3-D array> interp3 (ones (2,2))
%!error <V must be a 3-D array> interp3 (ones (2,2), 1,1,1)
%!error <XI, YI, and ZI dimensions must be equal> interp3 (ones (2,2,2), 1,1, ones (2,2))
%!error <V must be a 3-D array> interp3 (1:2, 1:2, 1:2, ones (2,2), 1,1,1)
%!error <X, Y, Z, and V dimensions must be equal> interp3 (ones (1,2,2), ones (2,2,2), ones (2,2,2), ones (2,2,2), 1,1,1)
%!error <XI, YI, and ZI dimensions must be equal> interp3 (1:2, 1:2, 1:2, rand (2,2,2), 1,1, ones (2,2))
%!error <wrong number .* input arguments> interp3 (1:2, 1:2, 1:2)
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} interpft (@var{x}, @var{n})
## @deftypefnx {} {} interpft (@var{x}, @var{n}, @var{dim})
##
## Fourier interpolation.
##
## If @var{x} is a vector then @var{x} is resampled with @var{n} points.  The
## data in @var{x} is assumed to be equispaced.  If @var{x} is a matrix or an
## N-dimensional array, the interpolation is performed on each column of
## @var{x}.
##
## If @var{dim} is specified, then interpolate along the dimension @var{dim}.
##
## @code{interpft} assumes that the interpolated function is periodic, and so
## assumptions are made about the endpoints of the interpolation.
## @seealso{interp1}
## @end deftypefn

function z = interpft (x, n, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (! (isscalar (n) && n == fix (n)))
    error ("interpft: N must be a scalar integer");
  endif

  if (nargin == 2)
    if (isrow (x))
      dim = 2;
    else
      dim = 1;
    endif
  endif

  nd = ndims (x);

  if (dim < 1 || dim > nd)
    error ("interpft: invalid dimension DIM");
  endif

  perm = [dim:nd, 1:(dim-1)];
  x = permute (x, perm);
  m = rows (x);

  inc = ceil (m/n);
  y = fft (x) / m;
  k = ceil (m / 2);
  sz = size (x);
  sz(1) = n * inc - m;

  idx = repmat ({':'}, nd, 1);
  idx{1} = 1:k;
  z = cat (1, y(idx{:}), zeros (sz));
  idx{1} = k+1:m;
  z = cat (1, z, y(idx{:}));

  ## When m is an even number of rows, the FFT has a single Nyquist bin.
  ## If zero-padded above, distribute the value of the Nyquist bin evenly
  ## between the new corresponding positive and negative frequency bins.
  if (sz(1) > 0 && k == m/2)
    idx{1} = n * inc - k + 1;
    tmp = z(idx{:}) / 2;
    z(idx{:}) = tmp;
    idx{1} = k + 1;
    z(idx{:}) = tmp;
  endif

  z = n * ifft (z);

  if (inc != 1)
    sz(1) = n;
    z = inc * reshape (z(1:inc:end), sz);
  endif

  z = ipermute (z, perm);

endfunction


%!demo
%! clf;
%! t = 0 : 0.3 : pi;  dt = t(2)-t(1);
%! n = length (t);  k = 100;
%! ti = t(1) + [0 : k-1]*dt*n/k;
%! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
%! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
%! plot (ti, yp, 'g', ti, interp1 (t, y, ti, "spline"), 'b', ...
%!       ti, interpft (y, k), 'c', t, y, "r+");
%! legend ("sin (4t+0.3)cos (3t-0.1)", "spline", "interpft", "data");

%!shared n,y
%! x = [0:10]';  y = sin(x);  n = length (x);
%!testif HAVE_FFTW
%! assert (interpft (y, n), y, 20*eps);
%!testif HAVE_FFTW
%! assert (interpft (y', n), y', 20*eps);
%!testif HAVE_FFTW
%! assert (interpft ([y,y],n), [y,y], 20*eps);

## Test case with complex input
%!testif HAVE_FFTW <*39566>
%! x = (1 + j) * [1:4]';
%! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
%! assert (interpft (x, 6), y, 10*eps);

## Test for correct spectral symmetry with even/odd lengths
%!testif HAVE_FFTW
%! assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps);
%!testif HAVE_FFTW
%! assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps);
%!testif HAVE_FFTW
%! assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps);
%!testif HAVE_FFTW
%! assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps);

## Test input validation
%!error <Invalid call> interpft ()
%!error <Invalid call> interpft (1)
%!error <N must be a scalar integer> interpft (1,[2,2])
%!error <N must be a scalar integer> interpft (1,2.1)
%!error <invalid dimension DIM> interpft (1,2,0)
%!error <invalid dimension DIM> interpft (1,2,3)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{vi} =} interpn (@var{x1}, @var{x2}, @dots{}, @var{v}, @var{y1}, @var{y2}, @dots{})
## @deftypefnx {} {@var{vi} =} interpn (@var{v}, @var{y1}, @var{y2}, @dots{})
## @deftypefnx {} {@var{vi} =} interpn (@var{v}, @var{m})
## @deftypefnx {} {@var{vi} =} interpn (@var{v})
## @deftypefnx {} {@var{vi} =} interpn (@dots{}, @var{method})
## @deftypefnx {} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
##
## Perform @var{n}-dimensional interpolation, where @var{n} is at least two.
##
## Each element of the @var{n}-dimensional array @var{v} represents a value
## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}.
## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either
## @var{n}-dimensional arrays of the same size as the array @var{v} in
## the @qcode{"ndgrid"} format or vectors.
##
## The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} represent the points at
## which the array @var{vi} is interpolated.  They can be vectors of the same
## length and orientation in which case they are interpreted as coordinates of
## scattered points.  If they are vectors of differing orientation or length,
## they are used to form a grid in @qcode{"ndgrid"} format.  They can also be
## @var{n}-dimensional arrays of equal size.
##
## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be
## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
## the interpolation adds a point half way between each of the interpolation
## points.  This process is performed @var{m} times.  If only @var{v} is
## specified, then @var{m} is assumed to be @code{1}.
##
## The interpolation @var{method} is one of:
##
## @table @asis
## @item @qcode{"nearest"}
## Return the nearest neighbor.
##
## @item @qcode{"linear"} (default)
## Linear interpolation from nearest neighbors.
##
## @item @qcode{"pchip"}
## Piecewise cubic Hermite interpolating polynomial---shape-preserving
## interpolation with smooth first derivative (not implemented yet).
##
## @item @qcode{"cubic"}
## Cubic interpolation (same as @qcode{"pchip"} [not implemented yet]).
##
## @item @qcode{"spline"}
## Cubic spline interpolation---smooth first and second derivatives
## throughout the curve.
## @end table
##
## The default method is @qcode{"linear"}.
##
## @var{extrapval} is a scalar number.  It replaces values beyond the endpoints
## with @var{extrapval}.  Note that if @var{extrapval} is used, @var{method}
## must be specified as well.  If @var{extrapval} is omitted and the
## @var{method} is @qcode{"spline"}, then the extrapolated values of the
## @qcode{"spline"} are used.  Otherwise the default @var{extrapval} value for
## any other @var{method} is @code{NA}.
## @seealso{interp1, interp2, interp3, spline, ndgrid}
## @end deftypefn

function vi = interpn (varargin)

  if (nargin < 1 || ! isnumeric (varargin{1}))
    print_usage ();
  endif

  method = "linear";
  extrapval = [];
  nargs = nargin;

  ## Find and validate EXTRAPVAL and/or METHOD inputs
  if (nargs > 1 && ischar (varargin{end-1}))
    if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
      error ("interpn: EXTRAPVAL must be a numeric scalar");
    endif
    extrapval = varargin{end};
    method = varargin{end-1};
    nargs -= 2;
  elseif (ischar (varargin{end}))
    method = varargin{end};
    nargs -= 1;
  endif

  if (method(1) == "*")
    warning ("interpn: ignoring unsupported '*' flag to METHOD");
    method(1) = [];
  endif
  method = validatestring (method,
                           {"nearest", "linear", "pchip", "cubic", "spline"},
                           "interpn");

  if (nargs <= 2)
    ## Calling form interpn (V, ...)
    v = varargin{1};
    m = 1;
    if (nargs == 2)
      m = varargin{2};
      if (! (isnumeric (m) && isscalar (m) && m == fix (m)))
        print_usage ();
      endif
    endif
    sz = size (v);
    nd = ndims (v);
    x = cell (1, nd);
    y = cell (1, nd);
    for i = 1 : nd
      x{i} = 1 : sz(i);
      y{i} = 1 : (1 / (2 ^ m)) : sz(i);
    endfor
    y{1} = y{1}.';
    [y{:}] = ndgrid (y{:});
  elseif (! isvector (varargin{1}) && nargs == (ndims (varargin{1}) + 1))
    ## Calling form interpn (V, Y1, Y2, ...)
    v = varargin{1};
    sz = size (v);
    nd = ndims (v);
    x = cell (1, nd);
    y = varargin(2 : nargs);
    for i = 1 : nd
      x{i} = 1 : sz(i);
    endfor
  elseif (rem (nargs, 2) == 1
          && nargs == (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
    ## Calling form interpn (X1, X2, ..., V, Y1, Y2, ...)
    nv = ceil (nargs / 2);
    v = varargin{nv};
    sz = size (v);
    nd = ndims (v);
    x = varargin(1 : (nv - 1));
    y = varargin((nv + 1) : nargs);
  else
    error ("interpn: wrong number or incorrectly formatted input arguments");
  endif

  if (any (! cellfun ("isvector", x)))
    for i = 1 : nd
      if (! size_equal (x{i}, v))
        error ("interpn: incorrect dimensions for input X%d", i);
      endif
      idx(1 : nd) = {1};
      idx(i) = ":";
      x{i} = x{i}(idx{:})(:);
    endfor
  endif

  all_vectors = all (cellfun ("isvector", y));
  same_size = size_equal (y{:});
  if (all_vectors && ! same_size)
    [y{:}] = ndgrid (y{:});
  endif

  if (! strcmp (method, "spline") && isempty (extrapval))
    if (iscomplex (v))
      extrapval = NA + 1i*NA;
    else
      extrapval = NA;
    endif
  endif

  if (strcmp (method, "linear"))
    vi = __lin_interpn__ (x{:}, v, y{:});
    if (iscomplex (v))
      ## __lin_interpn__ ignores imaginary part. Do it again for imag part.
      ## FIXME: Adapt __lin_interpn__ to correctly handle complex input.
      vi += 1i * __lin_interpn__ (x{:}, imag (v), y{:});
    endif
    vi(isna (vi)) = extrapval;
  elseif (strcmp (method, "nearest"))
    ## FIXME: This seems overly complicated.  Is there a way to simplify
    ## all the code after the call to lookup (which should be fast)?
    ## Could Qhull be used for quick nearest neighbor calculation?
    yshape = size (y{1});
    yidx = cell (1, nd);
    ## Find rough nearest index using lookup function [O(log2 (N)].
    for i = 1 : nd
      y{i} = y{i}(:);
      yidx{i} = lookup (x{i}, y{i}, "lr");
    endfor
    ## Single comparison to next largest index to see which is closer.
    idx = cell (1,nd);
    for i = 1 : nd
      idx{i} = yidx{i} ...
               + (y{i} - x{i}(yidx{i})(:) >= x{i}(yidx{i} + 1)(:) - y{i});
    endfor
    vi = v(sub2ind (sz, idx{:}));
    ## Apply EXTRAPVAL to points outside original volume.
    idx = false (prod (yshape), 1);
    for i = 1 : nd
      idx |= y{i} < min (x{i}(:)) | y{i} > max (x{i}(:));
    endfor
    vi(idx) = extrapval;
    vi = reshape (vi, yshape);
  elseif (strcmp (method, "spline"))
    if (any (! cellfun ("isvector", y)))
      ysz = size (y{1});
      for i = 1 : nd
        if (any (size (y{i}) != ysz))
          error ("interpn: incorrect dimensions for input Y%d", i);
        endif
        idx(1 : nd) = {1};
        idx(i) = ":";
        y{i} = y{i}(idx{:});
      endfor
    endif

    vi = __splinen__ (x, v, y, extrapval, "interpn");

    if (size_equal (y{:}))
      ly = length (y{1});
      idx = cell (1, ly);
      q = cell (1, nd);
      for i = 1 : ly
        q(:) = i;
        idx{i} = q;
      endfor
      vi = vi(cellfun (@(x) sub2ind (size (vi), x{:}), idx));
      vi = reshape (vi, size (y{1}));
    endif
  elseif (strcmp (method, "pchip"))
    error ("interpn: pchip interpolation not yet implemented");
  elseif (strcmp (method, "cubic"))
    error ("interpn: cubic interpolation not yet implemented");
  endif

endfunction


%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,4];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "linear").');
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,4];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "nearest").');
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;

%!#demo  # FIXME: Uncomment when support for "cubic" has been added
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,2];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "cubic").');
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! A = [13,-1,12;5,4,3;1,6,2];
%! x = [0,1,2];  y = [10,11,12];
%! xi = linspace (min (x), max (x), 17);
%! yi = linspace (min (y), max (y), 26)';
%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "spline").');
%! [x,y] = meshgrid (x,y);
%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;

%!demo
%! clf;
%! colormap ("default");
%! x = y = z = -1:1;
%! f = @(x,y,z) x.^2 - y - z.^2;
%! [xx, yy, zz] = meshgrid (x, y, z);
%! v = f (xx,yy,zz);
%! xi = yi = zi = -1:0.1:1;
%! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
%! vi = interpn (x, y, z, v, xxi, yyi, zzi, "spline");
%! mesh (yi, zi, squeeze (vi(1,:,:)));

%!test
%! [x,y,z] = ndgrid (0:2);
%! f = x + y + z;
%! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5]);
%! assert (interpn (x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],"nearest"),
%!         [3, 6]);
%! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],"spline"), [1.5, 4.5]);
%! assert (interpn (x,y,z,f,x,y,z), f);
%! assert (interpn (x,y,z,f,x,y,z,"nearest"), f);
%! assert (interpn (x,y,z,f,x,y,z,"spline"), f);

%!test
%! [x, y, z] = ndgrid (0:2, 1:4, 2:6);
%! f = x + y + z;
%! xi = [0.5 1.0 1.5];  yi = [1.5 2.0 2.5 3.5];  zi = [2.5 3.5 4.0 5.0 5.5];
%! fi = interpn (x, y, z, f, xi, yi, zi);
%! [xi, yi, zi] = ndgrid (xi, yi, zi);
%! assert (fi, xi + yi + zi);

%!test
%! xi = 0:2;  yi = 1:4;  zi = 2:6;
%! [x, y, z] = ndgrid (xi, yi, zi);
%! f = x + y + z;
%! fi = interpn (x, y, z, f, xi, yi, zi, "nearest");
%! assert (fi, x + y + z);

%!test
%! [x,y,z] = ndgrid (0:2);
%! f = x.^2 + y.^2 + z.^2;
%! assert (interpn (x,y,-z,f,1.5,1.5,-1.5), 7.5);

%!test  # for Matlab-compatible rounding for "nearest"
%! x = meshgrid (1:4);
%! assert (interpn (x, 2.5, 2.5, "nearest"), 3);

%!test
%! z = zeros (3, 3, 3);
%! zout = zeros (5, 5, 5);
%! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
%! z(:,:,2) = z(:,:,1) + 2;
%! z(:,:,3) = z(:,:,2) + 2;
%! for n = 1:5
%!   zout(:,:,n) = [1 2 3 4 5;
%!                  2 3 4 5 6;
%!                  3 4 5 6 7;
%!                  4 5 6 7 8;
%!                  5 6 7 8 9] + (n-1);
%! endfor
%! tol = 10*eps;
%! assert (interpn (z), zout, tol);
%! assert (interpn (z, "linear"), zout, tol);
%! assert (interpn (z, "spline"), zout, tol);

## Test that interpolating a complex matrix is equivalent to interpolating its
## real and imaginary parts separately.
%!test <*61907>
%! yi = [0.5, 1.5]';
%! xi = [2.5, 3.5];
%! zi = [2.25, 4.75];
%! v = rand (4, 3, 5) + 1i * rand (4, 3, 5);
%! for method = {"nearest", "linear", "spline"}
%!   vi_complex = interpn (v, yi, xi, zi, method{1});
%!   vi_real = interpn (real (v), yi, xi, zi, method{1});
%!   vi_imag = interpn (imag (v), yi, xi, zi, method{1});
%!   assert (real (vi_complex), vi_real)
%!   assert (imag (vi_complex), vi_imag)
%! endfor

## Test input validation
%!error <Invalid call> interpn ()
%!error <Invalid call> interpn ("foobar")
%!error <EXTRAPVAL must be a numeric scalar> interpn (1, "linear", {1})
%!error <EXTRAPVAL must be a numeric scalar> interpn (1, "linear", [1, 2])
%!warning <ignoring unsupported '\*' flag> interpn (rand (3,3), 1, "*linear");
%!error <'foobar' does not match any of> interpn (1, "foobar")
%!error <wrong number or incorrectly formatted input arguments>
%! interpn (1, 2, 3, 4);
%!error <incorrect dimensions for input X1>
%! interpn ([1,2], ones (2,2), magic (3), [1,2], [1,2])
%!error <incorrect dimensions for input X2>
%! interpn (ones (3,3), ones (2,2), magic (3), [1,2], [1,2])
%!error <incorrect dimensions for input Y2>
%! interpn ([1,2], [1,2], magic (3), [1,2], ones (2,2), "spline")
%!error <pchip interpolation not yet implemented> interpn ([1,2], "pchip")
%!error <cubic interpolation not yet implemented> interpn ([1,2], "cubic")

########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isequal (@var{x1}, @var{x2}, @dots{})
## Return true if all of @var{x1}, @var{x2}, @dots{} are equal.
## @seealso{isequaln}
## @end deftypefn

## Algorithm:
##
## 1. Verify the class of x.
##    a. All objects are of the same class
##    b. All objects are of a generic "numeric" class which includes
##       numeric, logical, and character arrays
## 2. Verify size of all objects match.
## 3. Convert objects to struct, and then compare as stated below.
## 4. For each argument after x, compare it for equality with x:
##    a. char       compare each member with strcmp
##    b. numeric    compare each member with '==' with sparsity regarded
##    c. struct     compare number of fieldnames, value of fieldnames,
##                  and then each field with isequal (recursive)
##    d. cellstr    compare each cellstr member with strcmp
##    e. cell       compare each member with isequal (recursive)
##    f. fcn_handle compare using overloaded "eq" operator

function t = isequal (x, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  nvarargin = nargin - 1;
  two_args = (nvarargin == 1);  # Optimization for base case of just 2 args

  if (two_args)
    y = varargin{1};  # alias y to second input for comparison
  endif

  ############################################################
  ## Generic tests for equality

  ## All arguments must either be of the same class,
  ##  or they must be "numeric" values.
  if (two_args)
    t = (strcmp (class (x), class (y))
         || ((isreal (x) || iscomplex (x)) && (isreal (y) || iscomplex (y))));
  else
    t = (all (cellfun ("isclass", varargin, class (x)))
         || ((isreal (x) || iscomplex (x))
             && all (cellfun ("isreal", varargin)
                     | cellfun ("isnumeric", varargin))));
  endif

  ## Test that everything is the same size (which also tests dimensions)
  if (t)
    t = size_equal (x, varargin{:});
  endif

  ## From here on, compare any objects as if they were structures.
  if (t && isobject (x))
    ## Locally suppress class-to-struct warning.  We know what we are doing.
    warning ("off", "Octave:classdef-to-struct", "local");
    x = builtin ("struct", x);
    if (two_args)
      clear y;  # break link to existing variable
      varargin(1) = builtin ("struct", varargin{1});
      y = varargin{1};  # re-alias y to second input
    else
      for i = 1:nvarargin
        varargin(i) = builtin ("struct", varargin{i});
      endfor
    endif
  endif

  ############################################################
  ## Check individual classes.

  if (t)
    if (two_args)

      if (ischar (x) && ischar (y))
        ## char type.  Optimization, strcmp is ~35% faster than '==' operator.
        t = strcmp (x, y);

      elseif (isreal (x) || iscomplex (x))
        if (issparse (x))
          ## sparse types.
          [xi, xj, xv] = find (x);
          [yi, yj, yv] = find (y);
          t = (length (xi) == length (yi)) && all (xi == yi) ...
              && all (xj == yj) && all (xv == yv);
        else
          ## general "numeric" type.  Use '==' operator.
          m = (x == y);
          t = all (m(:));
        endif

      elseif (isstruct (x))
        ## struct type.  Compare # of fields, fieldnames, then field values.

        ## Test number of fields are equal.
        t = (numfields (x) == numfields (y));

        ## Test that all the field names are equal.
        if (t)
          s_fnm_x = sort (fieldnames (x));
          t = all (strcmp (s_fnm_x, sort (fieldnames (y))));
        endif

        ## Test that all field values are equal.  Slow because of recursion.
        if (t)
          if (isscalar (x))
            for fldnm = s_fnm_x.'
              t = isequal (x.(fldnm{1}), y.(fldnm{1}));
              if (! t)
                break;
              endif
            endfor
          else
            ## struct arrays have to have the contents of each field wrapped
            ## in a cell since it expands to a collection of values.
            for fldnm = s_fnm_x.'
              t = isequal ({x.(fldnm{1})}, {y.(fldnm{1})});
              if (! t)
                break;
              endif
            endfor
          endif
        endif

      elseif (iscellstr (x) && iscellstr (y))
        ## cellstr type.  Optimization over cell type by using strcmp.
        ## FIXME: It would be faster to use strcmp on whole cellstr arrays,
        ## but bug #51412 needs to be fixed.  Instead, time/space trade-off.
        ## Convert to char (space) for faster processing with strcmp (time).
        t = strcmp (char (x), char (y));

      elseif (iscell (x))
        ## cell type.  Check that each element of a cell is equal.  Slow.
        n = numel (x);
        idx = 1;
        while (t && idx <= n)
          t = isequal (x{idx}, y{idx});
          idx += 1;
        endwhile

      elseif (is_function_handle (x))
        ## function type.  Use '==' operator which is overloaded.
        t = (x == y);

      else
        error ("isequal: Impossible to reach code.  File a bug report.");

      endif

    else  # More than two args.  This is going to be slower in general.

      if (ischar (x) && all (cellfun ("isclass", varargin, "char")))
        ## char type.  Optimization, strcmp is ~35% faster than '==' operator.
        idx = 1;
        while (t && idx <= nvarargin)
          t = strcmp (x, varargin{idx});
          idx += 1;
        endwhile

      elseif (isreal (x) || iscomplex (x))

        if (issparse (x))
          ## sparse types.

          idx = 1;
          [xi, xj, xv] = find (x);
          while (t && idx <= nvarargin)
            y = varargin{idx};
            [yi, yj, yv] = find (y);
            t = (length (xi) == length (yi)) && all (xi == yi) ...
                && all (xj == yj) && all (xv == yv);

            idx += 1;
          endwhile

        else
          ## general "numeric" type.  Use '==' operator.

          idx = 1;
          while (t && idx <= nvarargin)
            y = varargin{idx};
            m = (x == y);
            t = all (m(:));

            idx += 1;
          endwhile

        endif

      elseif (isstruct (x))
        ## struct type.  Compare # of fields, fieldnames, then field values.

        ## Test number of fields are equal.
        fnm_x = fieldnames (x);
        n = numel (fnm_x);
        fnm_v = cellfun ("fieldnames", varargin, "uniformoutput", false);
        t = all (n == cellfun ("numel", fnm_v));

        ## Test that all the field names are equal.
        if (t)
          fnm_x = sort (fnm_x);
          idx = 1;
          while (t && idx <= nvarargin)
            ## Allow the fieldnames to be in a different order.
            t = all (strcmp (fnm_x, sort (fnm_v{idx})));
            idx += 1;
          endwhile
        endif

        ## Test that all field values are equal.  Slow because of recursion.
        if (t)
          args = cell (1, 1 + nvarargin);
          if (isscalar (x))
            for fldnm = fnm_x.'
              args{1} = x.(fldnm{1});
              for argn = 1:nvarargin
                args{argn+1} = varargin{argn}.(fldnm{1});
              endfor

              t = isequal (args{:});

              if (! t)
                break;
              endif
            endfor
          else
            ## struct arrays have to have the contents of each field wrapped
            ## in a cell since it expands to a collection of values.
            for fldnm = fnm_x.'
              args{1} = { x.(fldnm{1}) };
              for argn = 1:nvarargin
                args{argn+1} = { varargin{argn}.(fldnm{1}) };
              endfor

              t = isequal (args{:});

              if (! t)
                break;
              endif
            endfor
          endif
        endif

      elseif (iscellstr (x) && all (cellfun (@iscellstr, varargin)))
        ## cellstr type.  Optimization over cell type by using strcmp.
        ## FIXME: It would be faster to use strcmp on whole cellstr arrays,
        ## but bug #51412 needs to be fixed.  Instead, time/space trade-off.
        ## Convert to char (space) for faster processing with strcmp (time).
        idx = 1;
        x = char (x);
        while (t && idx <= nvarargin)
          t = strcmp (x, char (varargin{idx}));
          idx += 1;
        endwhile

      elseif (iscell (x))
        ## cell type.  Check that each element of a cell is equal.  Slow.
        n = numel (x);
        args = cell (1, 1 + nvarargin);
        idx = 1;
        while (t && idx <= n)
          args(1) = x{idx};
          args(2:end) = [cellindexmat(varargin, idx){:}];

          t = isequal (args{:});

          idx += 1;
        endwhile

      elseif (is_function_handle (x))
        ## function type.  Use '==' operator which is overloaded.
        t = all (cellfun ("eq", {x}, varargin));

      else
        error ("isequal: Impossible to reach code.  File a bug report.");

      endif

    endif
  endif

  t = full (t);  # Always return full logical value for Matlab compatibility.

endfunction


## test empty input
%!assert (isequal ([], []), true)
%!assert (isequal ([], 1), false)
%!assert (isequal ([], [], 1), false)
%!assert (isequal ([], 1, []), false)
%!assert (isequal (1, [], []), false)

## test size and shape
%!assert (isequal ([1,2,3,4], [1,2,3,4]), true)
%!assert (isequal ([1;2;3;4], [1;2;3;4]), true)
%!assert (isequal ([1,2,3,4], [1;2;3;4]), false)
%!assert (isequal ([1,2,3,4], [1,2;3,4]), false)
%!assert (isequal ([1,2,3,4], [1,3;2,4]), false)
%!assert (isequal ([1,2,3,4], [1,2,3,4], [1,2,3,4]), true)
%!assert (isequal ([1;2;3;4], [1;2;3;4], [1;2;3;4]), true)
%!assert (isequal ([1,2,3,4], [1,2,3,4], [1;2;3;4]), false)
%!assert (isequal ([1,2,3,4], [1,2,3,4], [1,2;3,4]), false)
%!assert (isequal ([1,2,3,4], [1,2,3,4], [1,3;2,4]), false)

## General tests
%!test
%! A = 1:8;
%! B = reshape (A, 2, 2, 2);
%! assert (isequal (A, B), false);
%! assert (isequal (A, A, B), false);
%!test
%! A = reshape (1:8, 2, 2, 2);
%! B = A;
%! assert (isequal (A, B), true);
%! assert (isequal (A, A, B), true);
%!test
%! A = reshape (1:8, 2, 4);
%! B = reshape (A, 2, 2, 2);
%! assert (isequal (A, B), false);
%! assert (isequal (A, A, B), false);

## test characters and strings
%!assert (isequal ('a', "a"), true)
%!assert (isequal ('a', 'a', "a"), true)
%!assert (isequal ("abab", ["a", "b", "a", "b"]), true)
%!assert (isequal ("abab", "abab", ["a", "b", "a", "b"]), true)
%!assert (isequal (["a","b","c","d"], ["a","b","c","d"]), true)
%!assert (isequal (["a","b","c","d"], ["a","b","c","d"], ["a","b","c","d"]),
%!        true)
%!assert (isequal (["test   ";"strings"], ["test   ";"strings"]), true)
%!assert (isequal (["test   ";"strings"], ["test   ";"strings"],
%!                 ["test   ";"strings"]), true)
%!assert (isequal (["a","b","c","d"], ["a";"b";"c";"d"]), false)
%!assert (isequal (["a","b","c","d"], ["a","b","c","d"], ["a";"b";"c";"d"]),
%!        false)

## test all numeric built-in primitives
%!assert (isequal (false, 0))
%!assert (isequal (char (0), 0))
%!assert (isequal (false, logical (0), char (0),
%!                 int8 (0), int16 (0), int32 (0), int64 (0),
%!                 uint8 (0), uint16 (0), uint32 (0), uint64 (0),
%!                 double (0), single (0),
%!                 double (complex (0,0)), single (complex (0,0)),
%!                 sparse (false), sparse (logical (0)),
%!                 sparse (double (0)), sparse (single (0)),
%!                 sparse (double (complex (0,0))),
%!                 sparse (single (complex (0,0)))),
%!        true)
%!assert (isequal (true, logical (1), char (1),
%!                 int8 (1), int16 (1), int32 (1), int64 (1),
%!                 uint8 (1), uint16 (1), uint32 (1), uint64 (1),
%!                 double (1), single (1),
%!                 double (complex (1,0)), single (complex (1,0)),
%!                 sparse (true), sparse (logical (1)),
%!                 sparse (double (1)), sparse (single (1)),
%!                 sparse (double (complex (1,0))),
%!                 sparse (single (complex (1,0)))),
%!        true)

## test structures
%!assert (isequal (struct ([]), struct ([])), true)
%!assert (isequal (struct ([]), struct ([]), struct ([])), true)
%!assert (isequal (struct ("a",1), struct ("a",1)), true)
%!assert (isequal (struct ("a",1), struct ("a",1), struct ("a",1)), true)
%!assert (isequal (struct ("a",1), struct ("a",2)), false)
%!assert (isequal (struct ("a",1), struct ("a",1), struct ("a",2)), false)
%!assert (isequal (struct ("a",1), struct ("a",1,"b",2)), false)
%!assert (isequal (struct ("a",1), struct ("a",1),struct ("a",1,"b",2)), false)
%!assert (isequal (struct ("a",1), struct ("b",1)), false)
%!assert (isequal (struct ("a",1), struct ("a",1), struct ("b",1)), false)
%!assert (isequal (struct ("a",1,"b",2), struct ("a",1,"b",2)), true)
%!assert (isequal (struct ("a",1,"b",2), struct ("a",1,"b",2),
%!                 struct ("a",1,"b",2)), true)
%!assert (isequal (struct ("a",1,"b",2), struct ("b",2,"a",1)), true)
%!assert (isequal (struct ("a",1,"b",2), struct ("a",1,"b",2),
%!                 struct ("b",2,"a",1)), true)
%!assert (isequal (struct ("a","abc","b",2), struct ("a","abc","b",2)), true)
%!assert (isequal (struct ("a","abc","b",2), struct ("a","abc","b",2),
%!                 struct ("a","abc","b",2)), true)

## recursive structure
%!test
%! x.a = "a1";
%! x.b.a = "ba1";
%! x.b.b = "bb1";
%! assert (isequal (x, x), true);
%! assert (isequal (x, x, x), true);
%! y = x;
%! y.b.b = "bb2";
%! assert (isequal (x, y), false);
%! assert (isequal (x, x, y), false);
%! y = x;
%! y.b = rmfield (y.b, "b");
%! y.b.b.a = "bba1";
%! assert (isequal (x, y), false);
%! assert (isequal (x, x, y), false);

## struct array
%!test
%! x(1).a = 'A';
%! x(2).a = magic (3);
%! assert (isequal (x, x), true);
%! assert (isequal (x, x, x), true);
%! y = x;
%! y(2).a = { magic(3) };
%! assert (isequal (x, y), false);
%! assert (isequal (x, x, y), false);

## test cellstr
%!assert (isequal (cell (1,1), cell (1,1)), true)
%!assert (isequal (cell (1,1), cell (1,2)), false)
%!assert (isequal ({"a","b";"c","d"}, {"a","b";"c","d"}), true)
%!assert (isequal ({"a","b";"c","d"}, {"a","b";"c","d"}, {"a","b";"c","d"}),
%!                 true)
%!assert (isequal ({"a","b","c","d"}, {"a";"b";"c";"d"}), false)
%!assert (isequal ({"a","b","c","d"}, {"a","b","c","d"}, {"a";"b";"c";"d"}),
%!        false)
%!assert (isequal (["a","b","c","d"], {"a","b","c","d"}), false)
%!assert (isequal (["a","b","c","d"], ["a","b","c","d"], {"a","b","c","d"}),
%!        false)
%!test
%! x = { ["ab"; "cd"] ; ["ef"; "gh"] };
%! assert (isequal (x, x), true);
%! assert (isequal (x, x, x), true);
%! y = x;
%! y(2) = ["ef"; "gH"];
%! assert (isequal (x, y), false);
%! assert (isequal (x, x, y), false);

## test cells
%!assert (isequal (cell (1,1), cell (1,1)), true)
%!assert (isequal (cell (1,1), cell (1,1), cell (1,1)), true)
%!assert (isequal (cell (1,1), cell (1,2)), false)
%!assert (isequal (cell (1,1), cell (1,1), cell (1,2)), false)
%!assert (isequal ({"a",1}, {"a",1}), true)
%!assert (isequal ({"a",1}, {"a",1}, {"a",1}), true)
%!assert (isequal ({"a",1}, {"a",2}), false)
%!assert (isequal ({"a",1}, {"a",1}, {"a",2}), false)
%!assert (isequal ({"a",1}, {"b",1}), false)
%!assert (isequal ({"a",1}, {"a",1}, {"b",1}), false)
%!assert (isequal ({"a",1,"b",2}, {"a",1,"b",2}), true)
%!assert (isequal ({"a",1,"b",2}, {"a",1,"b",2}, {"a",1,"b",2}), true)
%!assert (isequal ({"a",1,"b",2}, {"b",2,"a",1}), false)
%!assert (isequal ({"a",1,"b",2}, {"a",1,"b",2}, {"b",2,"a",1}), false)
%!assert (isequal ({"a","abc","b",2}, {"a","abc","b",2}), true)
%!assert (isequal ({"a","abc","b",2}, {"a","abc","b",2}, {"a","abc","b",2}),
%!                 true)

## recursive cell
%!test
%! x = cell (1,3);
%! x{1} = {[1], [1 2]};
%! x{2} = true;
%! x{3} = {{"hello"}, {"world"}};
%! assert (isequal (x, x));
%! y = x;
%! y{3}{1}{1} = "goodbye";
%! assert (isequal (x, y), false);

## test function_handle
%!test
%! fcn = @(x) x.^2;
%! assert (isequal (fcn, fcn), true);
%! assert (isequal (fcn, fcn, fcn), true);
%! assert (isequal (fcn, @(x) x.^2), false);
%! assert (isequal (fcn, fcn, @(x) x.^2), false);
%! assert (isequal (@(x) x.^2, fcn), false);
%! assert (isequal (@(x) x.^2, @(x) x.^2, fcn), false);

## test for sparse matrices
%!shared A, Z
%!  A = sprand (2^31, 1000, 2^(-31));
%!  Z = sparse (2^31, 1000);
%!assert (isequal (sparse ([]), []), true)
%!assert (isequal (sparse ([]), sparse ([]), []), true)
%!assert (isequal ([], sparse ([])), true)
%!assert (isequal ([], [], sparse ([])), true)
%!assert (isequal (sparse (0,1), sparse (0,1)), true)
%!assert (isequal (sparse (0,1), sparse (0,1), sparse (0,1)), true)
%!assert (isequal (sparse (0,1), zeros (0,1)), true)
%!assert (isequal (sparse (0,1), sparse (0,1), zeros (0,1)), true)
%!assert (isequal (sparse (2,2), sparse (2,2)), true)
%!assert (isequal (sparse (2,2), sparse (2,2), sparse (2,2)), true)
%!assert (isequal (zeros (2,2), sparse (2,2)), true)
%!assert (isequal (zeros (2,2), zeros (2,2), sparse (2,2)), true)
%!assert (isequal (speye (1), eye (1)), true)
%!assert (isequal (speye (1), speye (1), eye (1)), true)
%!assert (isequal (eye (300), speye (300)), true)
%!assert (isequal (eye (300), eye (300), speye (300)), true)
%!assert (isequal (sparse (0,1), sparse (1,0)), false)
%!assert (isequal (sparse (0,1), sparse (0,1), sparse (1,0)), false)
%!assert (isequal (Z, Z), true)
%!assert (isequal (A, A), true)
%!assert (isequal (A, Z), false)
%!assert (isequal (Z, Z, Z), true)
%!assert (isequal (A, A, A), true)
%!assert (isequal (A, Z, A), false)

## test NaN
%!assert (isequal (NaN, NaN), false)
%!assert (isequal (NaN, NaN, NaN), false)
%!assert (isequal (NaN, Inf), false)
%!assert (isequal (NaN, Inf, Inf), false)
%!assert (isequal (NaN, 1.0), false)
%!assert (isequal (NaN, 1.0, 1.0), false)
%!assert (isequal ([1,2,NaN,4], [1,2,NaN,4]), false)
%!assert (isequal ([1,2,NaN,4], [1,2,NaN,4], [1,2,NaN,4]), false)
%!assert (isequal (struct ("a",NaN,"b",2), struct ("a",NaN,"b",2)), false)
%!assert (isequal (struct ("a",NaN,"b",2), struct ("a",NaN,"b",2),
%!                 struct ("a",NaN,"b",2)), false)

## Matlab compatibility
%!assert (isequal (sparse (1), sparse (1)), true)
%!assert (isequal (sparse (1), sparse (1)), sparse (1), true)

## test input validation
%!error <Invalid call> isequal ()
%!error <Invalid call> isequal (1)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isequaln (@var{x1}, @var{x2}, @dots{})
## Return true if all of @var{x1}, @var{x2}, @dots{} are equal under the
## additional assumption that NaN == NaN (no comparison of NaN placeholders
## in dataset).
## @seealso{isequal}
## @end deftypefn

## Algorithm:
##
## 1. Verify the class of x.
##    a. All objects are of the same class
##    b. All objects are of a generic "numeric" class which includes
##       numeric, logical, and character arrays
## 2. Verify size of all objects match.
## 3. Convert objects to struct, and then compare as stated below.
## 4. For each argument after x, compare it for equality with x:
##    a. char       compare each member with strcmp
##    b. numeric    compare each member with '==', and assume NaN == NaN
##    c. struct     compare number of fieldnames, value of fieldnames,
##                  and then each field with isequaln (recursive)
##    d. cellstr    compare each cellstr member with strcmp
##    e. cell       compare each member with isequaln (recursive)
##    f. fcn_handle compare using overloaded "eq" operator

function t = isequaln (x, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  nvarargin = nargin - 1;
  two_args = (nvarargin == 1);  # Optimization for base case of just 2 args

  if (two_args)
    y = varargin{1};  # alias y to second input for comparison
  endif

  ############################################################
  ## Generic tests for equality

  ## All arguments must either be of the same class,
  ##  or they must be "numeric" values.
  if (two_args)
    t = (strcmp (class (x), class (y))
         || ((isreal (x) || iscomplex (x)) && (isreal (y) || iscomplex (y))));
  else
    t = (all (cellfun ("isclass", varargin, class (x)))
         || ((isreal (x) || iscomplex (x))
             && all (cellfun ("isreal", varargin)
                     | cellfun ("isnumeric", varargin))));
  endif

  ## Test that everything is the same size (which also tests dimensions)
  if (t)
    t = size_equal (x, varargin{:});
  endif

  ## From here on, compare any objects as if they were structures.
  if (t && isobject (x))
    ## Locally suppress class-to-struct warning.  We know what we are doing.
    warning ("off", "Octave:classdef-to-struct", "local");
    x = builtin ("struct", x);
    if (two_args)
      clear y;  # break link to existing variable
      varargin(1) = builtin ("struct", varargin{1});
      y = varargin{1};  # re-alias y to second input
    else
      for i = 1:nvarargin
        varargin(i) = builtin ("struct", varargin{i});
      endfor
    endif
  endif

  ############################################################
  ## Check individual classes.

  if (t)
    if (two_args)

      if (ischar (x) && ischar (y))
        ## char type.  Optimization, strcmp is ~35% faster than '==' operator.
        t = strcmp (x, y);

      elseif (isreal (x) || iscomplex (x))
        ## general "numeric" type.  Use '==' operator.
        m = (x == y);
        t = all (m(:));

        if (! t && isfloat (x) && isfloat (y))
          t = isnan (x(! m)) && isnan (y(! m));
        endif

      elseif (isstruct (x))
        ## struct type.  Compare # of fields, fieldnames, then field values.

        ## Test number of fields are equal.
        t = (numfields (x) == numfields (y));

        ## Test that all the field names are equal.
        if (t)
          s_fnm_x = sort (fieldnames (x));
          t = all (strcmp (s_fnm_x, sort (fieldnames (y))));
        endif

        ## Test that all field values are equal.  Slow because of recursion.
        if (t)
          if (isscalar (x))
            for fldnm = s_fnm_x.'
              t = isequaln (x.(fldnm{1}), y.(fldnm{1}));
              if (! t)
                break;
              endif
            endfor
          else
            ## struct arrays have to have the contents of each field wrapped
            ## in a cell since it expands to a collection of values.
            for fldnm = s_fnm_x.'
              t = isequaln ({x.(fldnm{1})}, {y.(fldnm{1})});
              if (! t)
                break;
              endif
            endfor
          endif
        endif

      elseif (iscellstr (x) && iscellstr (y))
        ## cellstr type.  Optimization over cell type by using strcmp.
        ## FIXME: It would be faster to use strcmp on whole cellstr arrays,
        ## but bug #51412 needs to be fixed.  Instead, time/space trade-off.
        ## Convert to char (space) for faster processing with strcmp (time).
        t = strcmp (char (x), char (y));

      elseif (iscell (x))
        ## cell type.  Check that each element of a cell is equal.  Slow.
        n = numel (x);
        idx = 1;
        while (t && idx <= n)
          t = isequaln (x{idx}, y{idx});
          idx += 1;
        endwhile

      elseif (is_function_handle (x))
        ## function type.  Use '==' operator which is overloaded.
        t = (x == y);

      else
        error ("isequaln: Impossible to reach code.  File a bug report.");

      endif

    else  # More than two args.  This is going to be slower in general.

      if (ischar (x) && all (cellfun ("isclass", varargin, "char")))
        ## char type.  Optimization, strcmp is ~35% faster than '==' operator.
        idx = 1;
        while (t && idx <= nvarargin)
          t = strcmp (x, varargin{idx});
          idx += 1;
        endwhile

      elseif (isreal (x) || iscomplex (x))
        ## general "numeric" type.  Use '==' operator.

        idx = 1;
        while (t && idx <= nvarargin)
          y = varargin{idx};
          m = (x == y);
          t = all (m(:));

          if (! t && isfloat (x) && isfloat (y))
            t = isnan (x(! m)) && isnan (y(! m));
          endif

          idx += 1;
        endwhile

      elseif (isstruct (x))
        ## struct type.  Compare # of fields, fieldnames, then field values.

        ## Test number of fields are equal.
        fnm_x = fieldnames (x);
        n = numel (fnm_x);
        fnm_v = cellfun ("fieldnames", varargin, "uniformoutput", false);
        t = all (n == cellfun ("numel", fnm_v));

        ## Test that all the field names are equal.
        if (t)
          fnm_x = sort (fnm_x);
          idx = 1;
          while (t && idx <= nvarargin)
            ## Allow the fieldnames to be in a different order.
            t = all (strcmp (fnm_x, sort (fnm_v{idx})));
            idx += 1;
          endwhile
        endif

        ## Test that all field values are equal.  Slow because of recursion.
        if (t)
          args = cell (1, 1 + nvarargin);
          if (isscalar (x))
            for fldnm = fnm_x.'
              args{1} = x.(fldnm{1});
              for argn = 1:nvarargin
                args{argn+1} = varargin{argn}.(fldnm{1});
              endfor

              t = isequaln (args{:});

              if (! t)
                break;
              endif
            endfor
          else
            ## struct arrays have to have the contents of each field wrapped
            ## in a cell since it expands to a collection of values.
            for fldnm = fnm_x.'
              args{1} = { x.(fldnm{1}) };
              for argn = 1:nvarargin
                args{argn+1} = { varargin{argn}.(fldnm{1}) };
              endfor

              t = isequaln (args{:});

              if (! t)
                break;
              endif
            endfor
          endif
        endif

      elseif (iscellstr (x) && all (cellfun (@iscellstr, varargin)))
        ## cellstr type.  Optimization over cell type by using strcmp.
        ## FIXME: It would be faster to use strcmp on whole cellstr arrays,
        ## but bug #51412 needs to be fixed.  Instead, time/space trade-off.
        ## Convert to char (space) for faster processing with strcmp (time).
        idx = 1;
        x = char (x);
        while (t && idx <= nvarargin)
          t = strcmp (x, char (varargin{idx}));
          idx += 1;
        endwhile

      elseif (iscell (x))
        ## cell type.  Check that each element of a cell is equal.  Slow.
        n = numel (x);
        args = cell (1, 1 + nvarargin);
        idx = 1;
        while (t && idx <= n)
          args(1) = x{idx};
          args(2:end) = [cellindexmat(varargin, idx){:}];

          t = isequaln (args{:});

          idx += 1;
        endwhile

      elseif (is_function_handle (x))
        ## function type.  Use '==' operator which is overloaded.
        t = all (cellfun ("eq", {x}, varargin));

      else
        error ("isequaln: Impossible to reach code.  File a bug report.");

      endif

    endif
  endif

  t = full (t);  # Always return full logical value for Matlab compatibility.

endfunction


## test for equality
%!assert (isequaln (1,1), true)
%!assert (isequaln (1,1,1), true)
%!assert (isequaln ({1,2,NaN,4}, {1,2,NaN,4}), true)
%!assert (isequaln ({1,2,NaN,4}, {1,2,NaN,4}, {1,2,NaN,4}), true)
%!assert (isequaln ([1,2,NaN,4], [1,2,NaN,4]), true)
%!assert (isequaln ([1,2,NaN,4], [1,2,NaN,4], [1,2,NaN,4]), true)
## test for inequality
%!assert (isequaln (1,2), false)
%!assert (isequaln (1,1,2), false)
%!assert (isequaln ([1,2,NaN,4], [1,NaN,3,4]), false)
%!assert (isequaln ([1,2,NaN,4], [1,2,NaN,4], [1,NaN,3,4]), false)
%!assert (isequaln ([1,2,NaN,4], [1,2,3,4]), false)
%!assert (isequaln ([1,2,NaN,4], [1,2,NaN,4], [1,2,3,4]), false)
## test for equality (struct)
%!shared st
%! st = struct ("a",NaN,"b",2);
%!assert (isequaln (st, st), true)
%!assert (isequaln (st, st, st), true)

## Input validation
%!error <Invalid call> isequaln ()
%!error <Invalid call> isequaln (1)
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} logspace (@var{a}, @var{b})
## @deftypefnx {} {} logspace (@var{a}, @var{b}, @var{n})
## @deftypefnx {} {} logspace (@var{a}, pi, @var{n})
## Return a row vector with @var{n} elements logarithmically spaced from
## @tex
## $10^{a}$ to $10^{b}$.
## @end tex
## @ifnottex
## 10^@var{a} to 10^@var{b}.
## @end ifnottex
##
## If @var{n} is unspecified it defaults to 50.
##
## If @var{b} is equal to
## @tex
## $\pi$,
## @end tex
## @ifnottex
## pi,
## @end ifnottex
## the points are between
## @tex
## $10^{a}$ and $\pi$,
## @end tex
## @ifnottex
## 10^@var{a} and pi,
## @end ifnottex
## @emph{not}
## @tex
## $10^{a}$ and $10^{\pi}$,
## @end tex
## @ifnottex
## 10^@var{a} and 10^pi,
## @end ifnottex
## in order to be compatible with the corresponding @sc{matlab} function.
##
## Also for compatibility with @sc{matlab}, return the right-hand side of
## the range
## @tex
## ($10^{b}$)
## @end tex
## @ifnottex
## (10^@var{b})
## @end ifnottex
## when just a single value is requested.
## @seealso{linspace}
## @end deftypefn

function retval = logspace (a, b, n = 50)

  if (nargin < 2)
    print_usage ();
  endif

  if (! (isscalar (a) && isscalar (b) && isscalar (n)))
    error ("logspace: arguments A, B, and N must be scalars");
  endif

  npoints = fix (n);

  if (b == pi)
    b = log10 (pi);
  endif

  retval = 10 .^ (linspace (a, b, npoints));

endfunction


%!test
%! x1 = logspace (1, 2);
%! x2 = logspace (1, 2, 10.1);
%! x3 = logspace (1, -2, 10);
%! x4 = logspace (1, pi, 10);
%! assert (size (x1) == [1, 50]);
%! assert (abs (x1(1) - 10) < eps);
%! assert (abs (x1(50) - 100) < eps);
%! assert (size (x2) == [1, 10]);
%! assert (abs (x2(1) - 10) < eps);
%! assert (abs (x2(10) - 100) < eps);
%! assert (size (x3) == [1, 10]);
%! assert (abs (x3(1) - 10) < eps);
%! assert (abs (x3(10) - 0.01) < eps);
%! assert (size (x4) == [1, 10]);
%! assert (abs (x4(1) - 10) < eps);
%! assert (abs (x4(10) - pi) < sqrt (eps));

## Edge cases
%!assert (logspace (Inf, Inf, 3), [Inf, Inf, Inf])
%!assert (logspace (-Inf, Inf, 3), [0, 1, Inf])
%!testif ; ! ismac ()
%! assert (logspace (Inf + 1i, Inf + 1i, 3),
%!         repmat (complex (-Inf,Inf), [1, 3]))
%!testif ; ismac () <55538>
%! assert (logspace (Inf + 1i, Inf + 1i, 3),
%!         repmat (complex (-Inf,Inf), [1, 3]))
%!testif ; ! ismac ()
%! assert (logspace (-Inf + 1i, Inf + 1i, 3),
%!         [0, NaN + NaN * 1i, complex(-Inf, Inf)])
%!testif ; ismac () <55538>
%! assert (logspace (-Inf + 1i, Inf + 1i, 3),
%!         [0, NaN + NaN * 1i, complex(-Inf, Inf)])
%!assert (logspace (0, Inf, 3), [1, Inf, Inf])
%!assert (logspace (0, -Inf, 3), [1, 0, 0])
%!assert (logspace (Inf, -Inf, 3), [Inf, 1, 0])

## FIXME: These are bizarre corner cases for Matlab compatibility.  See
## bug #56933.  This is marked as "Won't Fix", but if linspace is updated at
## some point then these tests can be re-instated.
##%!assert (logspace (-Inf, 0, 3), [0, NaN, 1])
##%!assert (logspace (Inf, 0, 3), [Inf, NaN, 1])

## Test input validation
%!error <Invalid call> logspace ()
%!error logspace ([1, 2; 3, 4], 5, 6)
%!error logspace (1, [1, 2; 3, 4], 6)
%!error logspace (1, 2, [1, 2; 3, 4])
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{n} =} nextpow2 (@var{x})
## Compute the exponent for the smallest power of two larger than the input.
##
## For each element in the input array @var{x}, return the first integer
## @var{n} such that
## @tex
## $2^n \ge |x|$.
## @end tex
## @ifnottex
## 2^n @geq{} abs (x).
## @end ifnottex
##
## @seealso{pow2, log2}
## @end deftypefn

function n = nextpow2 (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    error ("nextpow2: X must be numeric");
  endif

  [f, n] = log2 (abs (x));
  idx = (n == 0);   # Find any failures of log2 function (n == 0)
  n(idx) = f(idx);  # and copy over value.
  n(f == 0.5)--;

endfunction


%!assert (nextpow2 (16), 4)
%!assert (nextpow2 (17), 5)
%!assert (nextpow2 (31), 5)
%!assert (nextpow2 (-16), 4)
%!assert (nextpow2 (-17), 5)
%!assert (nextpow2 (-31), 5)
%!assert (nextpow2 (1:17), [0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5])
## Special cases
%!assert (nextpow2 (0), 0)
%!assert (nextpow2 (1), 0)
%!assert (nextpow2 (Inf), Inf)
%!assert (nextpow2 (-Inf), Inf)
%!assert (nextpow2 (NaN), NaN)
%!assert (nextpow2 ([1, Inf, 3, -Inf, 9, NaN]), [0, Inf, 2, Inf, 4, NaN])

## Test input validation
%!error <Invalid call> nextpow2 ()
%!error <X must be numeric> nextpow2 ("t")
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} num2str (@var{x})
## @deftypefnx {} {} num2str (@var{x}, @var{precision})
## @deftypefnx {} {} num2str (@var{x}, @var{format})
## Convert a number (or array) to a string (or a character array).
##
## The optional second argument may either give the number of significant
## digits (@var{precision}) to be used in the output or a format template
## string (@var{format}) as in @code{sprintf} (@pxref{Formatted Output}).
## @code{num2str} can also process complex numbers.
##
## Examples:
##
## @example
## num2str (123.456)
##   @result{} 123.456
##
## num2str (123.456, 4)
##   @result{} 123.5
##
## s = num2str ([1, 1.34; 3, 3.56], "%5.1f")
##   @result{} s =
##        1.0  1.3
##        3.0  3.6
## whos s
##   @result{} Variables in the current scope:
##         Attr Name        Size                     Bytes  Class
##         ==== ====        ====                     =====  =====
##              s           2x8                         16  char
##      Total is 16 elements using 16 bytes
##
## num2str (1.234 + 27.3i)
##   @result{} 1.234+27.3i
## @end example
##
## The @code{num2str} function is not very flexible.  For better control
## over the results, use @code{sprintf} (@pxref{Formatted Output}).
##
## Programming Notes:
##
## For @sc{matlab} compatibility, leading spaces are stripped before returning
## the string.
##
## Integers larger than @code{flintmax} may not be displayed correctly.
##
## For complex @var{x}, the format string may only contain one output
## conversion specification and nothing else.  Otherwise, results will be
## unpredictable.
##
## Any optional @var{format} specified by the programmer is used without
## modification.  This is in contrast to @sc{matlab} which tampers with the
## @var{format} based on internal heuristics.
## @seealso{sprintf, int2str, mat2str}
## @end deftypefn

function retval = num2str (x, arg)

  if (nargin < 1)
    print_usage ();
  elseif (! (isnumeric (x) || islogical (x) || ischar (x)))
    error ("num2str: X must be a numeric, logical, or character array");
  endif

  if (ischar (x))
    retval = x;
  elseif (isempty (x))
    retval = "";
  elseif (isreal (x))
    if (nargin == 2)
      if (ischar (arg))
        fmt = arg;
      elseif (isnumeric (arg) && isscalar (arg) && arg >= 0 && arg == fix (arg))
        if (isfloat (x))
          fmt = sprintf ("%%%d.%dg", arg+7, arg);
        else
          fmt = sprintf ("%%%dd", arg);
        endif
      else
        error ("num2str: PRECISION must be a scalar integer >= 0");
      endif
    else
      if (isnumeric (x))
        ## Set up a suitable format string while ignoring Inf/NaN entries
        valid = isfinite (x(:));
        ndgt = floor (log10 (max (abs (x(valid)))));
        if (isempty (ndgt) || ndgt == -Inf)
          ndgt = 0;  # All Inf or all zero array
        endif

        if (ndgt > 15 || any (x(valid) != fix (x(valid))))
          ## Floating point input
          ndgt = max (ndgt + 5, 5);   # Keep at least 5 significant digits
          ndgt = min (ndgt, 16);      # Cap significant digits at 16
          fmt = sprintf ("%%%d.%dg", ndgt+7, ndgt);
        else
          ## Integer input
          ndgt += 3;
          if (any (! valid))
            ndgt = max (ndgt, 5);     # Allow space for Inf/NaN
          endif
          if (isfloat (x))
            fmt = sprintf ("%%%d.0f", ndgt);
          else
            fmt = sprintf ("%%%dd", ndgt);
          endif
        endif
      else
        ## Logical input
        fmt = "%3d";
      endif
    endif
    fmt = do_string_escapes (fmt);  # required now that '\n' is interpreted.
    nd = ndims (x);
    nc = columns (x) * (nd - 1);    # ND-arrays are expanded in columns
    x  = permute (x, [2, 3:nd, 1]);
    if (! (sum (strrep (fmt, "%%", "") == "%") > 1
           || any (strcmp (fmt, {"%s", "%c"}))))
      fmt = [deblank(repmat (fmt, 1, nc)), "\n"];
    endif
    strtmp = sprintf (fmt, x);
    retval = strtrim (char (ostrsplit (strtmp, "\n", true)));
  else   # Complex matrix input
    if (nargin == 2)
      if (ischar (arg))
        fmt = [deblank(arg) "%-+" arg(2:end) "i"];
      elseif (isnumeric (arg) && isscalar (arg) && arg >= 0 && arg == fix (arg))
        fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
      else
        error ("num2str: PRECISION must be a scalar integer >= 0");
      endif
    else
      ## Set up a suitable format string while ignoring Inf/NaN entries
      valid_real = isfinite (real (x(:)));
      valid_imag = isfinite (imag (x(:)));
      ndgt = floor (log10 (max (max (abs (real (x(valid_real)))),
                                max (abs (imag (x(valid_imag)))))));
      if (isempty (ndgt) || ndgt == -Inf)
        ndgt = 0;  # All Inf or all zero array
      endif

      if (any (x(valid_real & valid_imag) != fix (x(valid_real & valid_imag))))
        ## Floating point input
        ndgt = max (ndgt + 5, 5);   # Keep at least 5 significant digits
        ndgt = min (ndgt, 16);      # Cap significant digits at 16
        fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", ndgt+7, ndgt, ndgt+7, ndgt);
      else
        ## Integer input
        ndgt += 3;
        ## FIXME: Integers must be masked to show only 16 significant digits
        ##        See test case for bug #36133 below
        fmt = sprintf ("%%%d.0f%%-+%d.0fi", ndgt, ndgt);
      endif
    endif

    ## Manipulate the complex value to have real values in the odd
    ## columns and imaginary values in the even columns.
    nd = ndims (x);
    nc = columns (x);
    idx = repmat ({':'}, nd, 1);
    perm(1:2:2*nc) = 1:nc;
    perm(2:2:2*nc) = nc + (1:nc);
    idx{2} = perm;
    x = horzcat (real (x), imag (x));
    x = x(idx{:});

    fmt = [deblank(repmat(fmt, 1, nc * (nd - 1))), "\n"];
    tmp = sprintf (fmt, permute (x, [2, 3:nd, 1]));

    ## Put the "i"'s where they are supposed to be.
    tmp = regexprep (tmp, " +i\n", "i\n");
    tmp = regexprep (tmp, "( +)i", "i$1");

    retval = strtrim (char (ostrsplit (tmp(1:end-1), "\n")));
  endif

endfunction


## Basic tests
%!assert (num2str (123), "123")
%!assert (num2str (1.23), "1.23")
%!assert (num2str (123.456, 4), "123.5")
%!assert (num2str ([1, 1.34; 3, 3.56], "%5.1f"), ["1.0  1.3"; "3.0  3.6"])
%!assert (num2str (1.234 + 27.3i), "1.234+27.3i")
%!assert (num2str ([true false true]), "1  0  1")

## Exceptional values
%!assert (num2str (19440606), "19440606")
%!assert (num2str (2^33), "8589934592")
%!assert (num2str (-2^33), "-8589934592")
%!assert (num2str (2^33+1i), "8589934592+1i")
%!assert (num2str (-2^33+1i), "-8589934592+1i")
%!assert (num2str ([0 0 0]), "0  0  0")
%!assert (num2str (inf), "Inf")
%!assert (num2str ([inf -inf]), "Inf -Inf")
%!assert (num2str ([inf NaN -inf]), "Inf  NaN -Inf")
%!assert (num2str ([complex(Inf,0), complex(0,-Inf)]), "Inf+0i   0-Infi")
%!assert (num2str (complex (Inf,1)), "Inf+1i")
%!assert (num2str (complex (1,Inf)), "1+Infi")
%!assert (num2str (nan), "NaN")
%!assert (num2str (complex (NaN, 1)), "NaN+1i")
%!assert (num2str (complex (1, NaN)), "1+NaNi")
%!assert (num2str (NA), "NA")
%!assert (num2str (complex (NA, 1)), "NA+1i")
%!assert (num2str (complex (1, NA)), "1+NAi")
%!assert (num2str (int64 (-flintmax ()) - 1), "-9007199254740993")
%!assert (num2str (int64 (-flintmax ()) - 1, 18), "-9007199254740993")

## ND-arrays are concatenated in columns
%!shared m, x
%! m = magic (3);
%! x = cat (3, m, -m);

## real case
%!test <*46770>
%! y = num2str (x);
%! assert (rows (y) == 3);
%! assert (y, ["8  1  6 -8 -1 -6"
%!             "3  5  7 -3 -5 -7"
%!             "4  9  2 -4 -9 -2"]);

## complex case
%!test <*46770>
%! x(1,1,2) = -8+2i;
%! y = num2str (x);
%! assert (rows (y) == 3);
%! assert (y, ["8+0i   1+0i   6+0i  -8+2i  -1+0i  -6+0i"
%!             "3+0i   5+0i   7+0i  -3+0i  -5+0i  -7+0i"
%!             "4+0i   9+0i   2+0i  -4+0i  -9+0i  -2+0i"]);

## Clear shared variables
%!shared

## Integers greater than 1e15 should switch to exponential notation
%!assert <*36133> (num2str (1e15), "1000000000000000")
%!assert <*36133> (num2str (1e16), "1e+16")
## Even exact integers in IEEE notation should use exponential notation
%!assert <*36133> (num2str (2^512), "1.34078079299426e+154")
## Mixed integer/floating point arrays
%!assert <*36133> (num2str ([2.1, 1e23, pi]),
%!                 "2.1  9.999999999999999e+22      3.141592653589793")

## Large integers should not switch sign when printed due to overflow
%!assert <*36121> (num2str (2.4e9, 15), "2400000000")

## Test for extra rows generated from newlines in format
%!assert <*44864> (rows (num2str (magic (3), "%3d %3d %3d\n")), 3)

## Test that string conversion of numeric objects results in characters
## if the numbers are within range for ASCII.
%!assert <*45174> (num2str ([65 66 67], "%s"), "ABC")

## Test input validation
%!error <Invalid call> num2str ()
%!error <X must be a numeric> num2str ({1})
%!error <PRECISION must be a scalar integer .= 0> num2str (1, {1})
%!error <PRECISION must be a scalar integer .= 0> num2str (1, ones (2))
%!error <PRECISION must be a scalar integer .= 0> num2str (1, -1)
%!error <PRECISION must be a scalar integer .= 0> num2str (1, 1.5)
%!error <PRECISION must be a scalar integer .= 0> num2str (1+1i, {1})
%!error <PRECISION must be a scalar integer .= 0> num2str (1+1i, ones (2))
%!error <PRECISION must be a scalar integer .= 0> num2str (1+1i, -1)
%!error <PRECISION must be a scalar integer .= 0> num2str (1+1i, 1.5)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{x}, @var{y}] =} pol2cart (@var{theta}, @var{r})
## @deftypefnx {} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{theta}, @var{r}, @var{z})
## @deftypefnx {} {[@var{x}, @var{y}] =} pol2cart (@var{P})
## @deftypefnx {} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{P})
## Transform polar or cylindrical coordinates to Cartesian coordinates.
##
## The inputs @var{theta}, @var{r}, (and @var{z}) must be the same shape, or
## scalar.  If called with a single matrix argument then each row of @var{P}
## represents the polar coordinate pair (@var{theta}, @var{r}) or the
## cylindrical triplet (@var{theta}, @var{r}, @var{z}).
##
## The outputs @var{x}, @var{y} (, and @var{z}) match the shape of the inputs.
## For a matrix input @var{P} the outputs will be column vectors with rows
## corresponding to the rows of the input matrix.
##
## @var{theta} describes the angle relative to the positive x-axis measured in
## the xy-plane.
##
## @var{r} is the distance to the z-axis @w{(0, 0, z)}.
##
## @var{z}, if present, is unchanged by the transformation.
##
## The coordinate transformation is computed using:
##
## @tex
## $$ x = r \cos \theta $$
## $$ y = r \sin \theta $$
## $$ z = z $$
## @end tex
## @ifnottex
##
## @example
## @group
## @var{x} = @var{r} * cos (@var{theta})
## @var{y} = @var{r} * sin (@var{theta})
## @var{z} = @var{z}
## @end group
## @end example
##
## @end ifnottex
## @c FIXME: Remove this note in Octave 9.1 (two releases after 7.1).
## Note: For @sc{matlab} compatibility, this function no longer returns a full
## coordinate matrix when called with a single return argument.
## @seealso{cart2pol, sph2cart, cart2sph}
## @end deftypefn

function [x, y, z] = pol2cart (theta, r, z = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    if (! (isnumeric (theta) && ismatrix (theta)))
      error ("cart2pol: matrix input P must be 2-D numeric array");
    endif
    if (isvector (theta))
      n = numel (theta);
      if (n != 2 && n != 3)
        error ("cart2pol: matrix input must be a 2- or 3-element vector or a 2- or 3-column array");
      endif
      if (n == 3)
        z = theta(3);
      endif
      r = theta(2);
      theta = theta(1);

    else
      ncols = columns (theta);
      if (ncols != 2 && ncols != 3)
        error ("cart2pol: matrix input must be a 2- or 3-element vector or a 2- or 3-column array");
      endif

      if (ncols == 3)
        z = theta(:,3);
      endif
      r = theta(:,2);
      theta = theta(:,1);
    endif

  elseif (nargin == 2)
    if (! (isnumeric (theta) && isnumeric (r)))
      error ("pol2cart: THETA, R must be numeric arrays or scalars");
    endif
    [err, theta, r] = common_size (theta, r);
    if (err)
      error ("pol2cart: THETA, R must be the same size or scalars");
    endif

  elseif (nargin == 3)
    if (! (isnumeric (theta) && isnumeric (r) && isnumeric (z)))
      error ("pol2cart: THETA, R, Z must be numeric arrays or scalars");
    endif
    [err, theta, r, z] = common_size (theta, r, z);
    if (err)
      error ("pol2cart: THETA, R, Z must be the same size or scalars");
    endif
  endif

  x = r .* cos (theta);
  y = r .* sin (theta);

endfunction


%!test
%! t = [0, 0.5, 1] * pi;
%! r = 1;
%! [x, y] = pol2cart (t, r);
%! assert (x, [1, 0, -1], eps);
%! assert (y, [0, 1,  0], eps);

%!test
%! t = [0, 1, 1] * pi/4;
%! r = sqrt (2) * [0, 1, 2];
%! [x, y] = pol2cart (t, r);
%! assert (x, [0, 1, 2], 2*eps);
%! assert (y, [0, 1, 2], 2*eps);

%!test
%! t = [0, 1, 1] * pi/4;
%! r = sqrt (2) * [0, 1, 2];
%! z = [0, 1, 2];
%! [x, y, z2] = pol2cart (t, r, z);
%! assert (x, [0, 1, 2], 2*eps);
%! assert (y, [0, 1, 2], 2*eps);
%! assert (z2, z);

%!test
%! t = [0; 1; 1] * pi/4;
%! r = sqrt (2) * [0; 1; 2];
%! z = [0; 1; 2];
%! [x, y, z2] = pol2cart (t, r, z);
%! assert (x, [0; 1; 2], 2*eps);
%! assert (y, [0; 1; 2], 2*eps);
%! assert (z2, z);


%!test
%! t = 0;
%! r = [0, 1, 2];
%! z = [0, 1, 2];
%! [x, y, z2] = pol2cart (t, r, z);
%! assert (x, [0, 1, 2], eps);
%! assert (y, [0, 0, 0], eps);
%! assert (z2, z);

%!test
%! t = [1, 1, 1]*pi/4;
%! r = 1;
%! z = [0, 1, 2];
%! [x, y, z2] = pol2cart (t, r, z);
%! assert (x, [1, 1, 1] / sqrt (2), eps);
%! assert (y, [1, 1, 1] / sqrt (2), eps);
%! assert (z2, z);

%!test
%! t = 0;
%! r = [1, 2, 3];
%! z = 1;
%! [x, y, z2] = pol2cart (t, r, z);
%! assert (x, [1, 2, 3], eps);
%! assert (y, [0, 0, 0] / sqrt (2), eps);
%! assert (z2, [1, 1, 1]);

%!test
%! P = [0, 0; pi/4, sqrt(2); pi/4, 2*sqrt(2)];
%! [x, y] = pol2cart(P);
%! assert (x, [0; 1; 2], 2*eps);
%! assert (y, [0; 1; 2], 2*eps);

%!test
%! P = [0, 0, 0; pi/4, sqrt(2), 1; pi/4, 2*sqrt(2), 2];
%! [x, y, z] = pol2cart(P);
%! assert (x, [0; 1; 2], 2*eps);
%! assert (y, [0; 1; 2], 2*eps);
%! assert (z, P(:,3), 2*eps);

%!test
%! P = [0, 0, 0; pi/4, sqrt(2), 1; pi/4, 2*sqrt(2), 2; 0, 0, 0];
%! [x, y, z] = pol2cart(P);
%! assert (x, [0; 1; 2; 0], 2*eps);
%! assert (y, [0; 1; 2; 0], 2*eps);
%! assert (z, P(:,3), 2*eps);

%!test
%! r = ones (1, 1, 1, 2);
%! r(1, 1, 1, 2) = 2;
%! t = pi/2 * r;
%! [x, y] = pol2cart (t, r);
%! X = zeros (1, 1, 1, 2);
%! X(1, 1, 1, 2) = -2;
%! Y = zeros (1, 1, 1, 2);
%! Y(1, 1, 1, 1) = 1;
%! assert (x, X, 2*eps);
%! assert (y, Y, 2*eps);

%!test
%! [t, r, Z] = meshgrid ([0, pi/2], [1, 2], [0, 1]);
%! [x, y, z] = pol2cart (t, r, Z);
%! X = zeros (2, 2, 2);
%! X(:, 1, 1) = [1; 2];
%! X(:, 1, 2) = [1; 2];
%! Y = zeros (2, 2, 2);
%! Y(:, 2, 1) = [1; 2];
%! Y(:, 2, 2) = [1; 2];
%! assert (x, X, eps);
%! assert (y, Y, eps);
%! assert (z, Z);

## Test input validation
%!error <Invalid call> pol2cart ()
%!error <matrix input P must be 2-D numeric array> pol2cart ({1,2,3})
%!error <matrix input P must be 2-D numeric array> pol2cart (ones (3,3,2))
%!error <matrix input must be a 2- or 3-element> pol2cart ([1])
%!error <matrix input must be a 2- or 3-element> pol2cart ([1,2,3,4])
%!error <must be numeric arrays or scalars> pol2cart ({1,2,3}, [1,2,3])
%!error <must be numeric arrays or scalars> pol2cart ([1,2,3], {1,2,3})
%!error <must be the same size or scalars> pol2cart (ones (3,3,3), ones (3,2,3))
%!error <must be the same size or scalars> pol2cart ([1; 1], [2, 2])
%!error <must be the same size or scalars> pol2cart ([1; 1], [2, 2], [3, 3])
%!error <must be numeric arrays or scalars> pol2cart ({1,2,3}, [1,2,3], [1,2,3])
%!error <must be numeric arrays or scalars> pol2cart ([1,2,3], {1,2,3}, [1,2,3])
%!error <must be numeric arrays or scalars> pol2cart ([1,2,3], [1,2,3], {1,2,3})
%!error <must be the same size or scalars> pol2cart (ones (3,3,3), 1, ones (3,2,3))
%!error <must be the same size or scalars> pol2cart (ones (3,3,3), ones (3,2,3), 1)
########################################################################
##
## Copyright (C) 1999-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} polyarea (@var{x}, @var{y})
## @deftypefnx {} {} polyarea (@var{x}, @var{y}, @var{dim})
##
## Determine area of a polygon by triangle method.
##
## The variables @var{x} and @var{y} define the vertex pairs, and must
## therefore have the same shape.  They can be either vectors or arrays.  If
## they are arrays then the columns of @var{x} and @var{y} are treated
## separately and an area returned for each.
##
## If the optional @var{dim} argument is given, then @code{polyarea} works
## along this dimension of the arrays @var{x} and @var{y}.
##
## @end deftypefn

## FIXME: Add moments for centroid, etc.
##
## Bugs and limitations:
##        Probably ought to be an optional check to make sure that
##        traversing the vertices doesn't make any sides cross
##        (Is simple closed curve the technical definition of this?).

function a = polyarea (x, y, dim)

  if (nargin < 2)
    print_usage ();
  elseif (! size_equal (x, y))
    error ("polyarea: X and Y must have the same shape");
  endif

  if (nargin == 2)
    a = abs (sum (x .* (shift (y, -1) - shift (y, 1)))) / 2;
  else
    a = abs (sum (x .* (shift (y, -1, dim) - shift (y, 1, dim)), dim)) / 2;
  endif

endfunction


%!shared x, y
%! x = [1;1;3;3;1];
%! y = [1;3;3;1;1];
%!assert (polyarea (x,y), 4, eps)
%!assert (polyarea ([x,x],[y,y]), [4,4], eps)
%!assert (polyarea ([x,x],[y,y],1), [4,4], eps)
%!assert (polyarea ([x,x]',[y,y]',2), [4;4], eps)
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} postpad (@var{x}, @var{l})
## @deftypefnx {} {} postpad (@var{x}, @var{l}, @var{c})
## @deftypefnx {} {} postpad (@var{x}, @var{l}, @var{c}, @var{dim})
## Append the scalar value @var{c} to the vector @var{x} until it is of length
## @var{l}.  If @var{c} is not given, a value of 0 is used.
##
## If @code{length (@var{x}) > @var{l}}, elements from the end of @var{x} are
## removed until a vector of length @var{l} is obtained.
##
## If @var{x} is a matrix, elements are appended or removed from each row.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## If @var{dim} is larger than the dimensions of @var{x}, the result will have
## @var{dim} dimensions.
## @seealso{prepad, cat, resize}
## @end deftypefn

function y = postpad (x, l, c, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (nargin < 3 || isempty (c))
    c = 0;
  else
    if (! isscalar (c))
      error ("postpad: third argument must be empty or a scalar");
    endif
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 4)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim) && dim >= 1))
      error ("postpad: DIM must be an integer and a valid dimension");
    endif
  endif

  if (! isscalar (l) || l < 0)
    error ("postpad: second argument must be a positive scaler");
  endif

  if (dim > nd)
    sz(nd+1:dim) = 1;
  endif

  d = sz(dim);

  if (d == l)
    ## This optimization makes sense because the function is used to match
    ## the length between two vectors not knowing a priori is larger, and
    ## allow for:
    ##    ml = max (numel (v1), numel (v2));
    ##    v1 = postpad (v1, ml);
    ##    v2 = postpad (v2, ml);
    y = x;
  elseif (d >= l)
    idx = repmat ({':'}, nd, 1);
    idx{dim} = 1:l;
    y = x(idx{:});
  else
    sz(dim) = l - d;
    y = cat (dim, x, c(ones (sz)));
  endif

endfunction


%!assert (postpad ([1,2], 4), [1,2,0,0])
%!assert (postpad ([1;2], 4), [1;2;0;0])
%!assert (postpad ([1,2], 4, 2), [1,2,2,2])
%!assert (postpad ([1;2], 4, 2), [1;2;2;2])
%!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2])
%!assert (postpad ([1;2], 2, 2, 3), reshape ([1;2;2;2], 2, 1, 2))
%!assert (postpad ([1,2], 2, 2, 3), reshape ([1,2,2,2], 1, 2, 2))

%!assert (postpad ([1 2], 2), [1 2])
%!assert (postpad ([1; 2], 2), [1; 2])
%!assert (postpad ([1; 2], 2, 3, 2), [1 3; 2 3])

%! ## Test with string concatenation
%!assert <*44162> (postpad ("Octave", 16, "x"), "Octavexxxxxxxxxx")
%!assert (postpad ("Octave", 4), "Octa")

%!error <Invalid call> postpad ()
%!error <Invalid call> postpad (1)
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} prepad (@var{x}, @var{l})
## @deftypefnx {} {} prepad (@var{x}, @var{l}, @var{c})
## @deftypefnx {} {} prepad (@var{x}, @var{l}, @var{c}, @var{dim})
## Prepend the scalar value @var{c} to the vector @var{x} until it is of length
## @var{l}.  If @var{c} is not given, a value of 0 is used.
##
## If @code{length (@var{x}) > @var{l}}, elements from the beginning of @var{x}
## are removed until a vector of length @var{l} is obtained.
##
## If @var{x} is a matrix, elements are prepended or removed from each row.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## If @var{dim} is larger than the dimensions of @var{x}, the result will have
## @var{dim} dimensions.
## @seealso{postpad, cat, resize}
## @end deftypefn

function y = prepad (x, l, c, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (nargin < 3 || isempty (c))
    c = 0;
  else
    if (! isscalar (c))
      error ("prepad: pad value C must be empty or a scalar");
    endif
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 4)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim) && dim >= 1))
      error ("prepad: DIM must be an integer and a valid dimension");
    endif
  endif

  if (! isscalar (l) || l < 0)
    error ("prepad: length L must be a positive scalar");
  endif

  if (dim > nd)
    sz(nd+1:dim) = 1;
  endif

  d = sz(dim);

  if (d == l)
    ## This optimization makes sense because the function is used to match
    ## the length between two vectors not knowing a priori is larger, and
    ## allow for:
    ##    ml = max (numel (v1), numel (v2));
    ##    v1 = prepad (v1, ml);
    ##    v2 = prepad (v2, ml);
    y = x;
  elseif (d >= l)
    idx = repmat ({':'}, nd, 1);
    idx{dim} = d-l+1:d;
    y = x(idx{:});
  else
    sz(dim) = l - d;
    y = cat (dim, c(ones (sz)), x);
  endif

endfunction


%!assert (prepad ([1,2], 4), [0,0,1,2])
%!assert (prepad ([1;2], 4), [0;0;1;2])

%!assert (prepad ([1,2], 4, 2), [2,2,1,2])
%!assert (prepad ([1;2], 4, 2), [2;2;1;2])

%!assert (prepad ([1 2], 2), [1 2])
%!assert (prepad ([1; 2], 2), [1; 2])
%!assert (prepad ([1; 2], 2, 3, 2), [3 1; 3 2])

%!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2])

%!assert (prepad ([1,2], 2, 2, 3), reshape ([2,2,1,2], 1, 2, 2))
%!assert (prepad ([1;2], 2, 2, 3), reshape ([2;2;1;2], 2, 1, 2))

%! ## Test with string concatenation
%!assert <*44162> (prepad ("Octave", 16, "x"), "xxxxxxxxxxOctave")
%!assert (prepad ("Octave", 4), "tave")

## FIXME: We need tests for multidimensional arrays.

%!error <Invalid call> prepad ()
%!error <Invalid call> prepad (1)
%!error <C must be empty or a scalar> prepad ([1,2], 2, ones (2))
%!error <DIM must be an integer> prepad ([1,2], 2, 2, ones (3))
%!error <DIM must be an integer> prepad ([1,2], 2, 2, 1.1)
%!error <L must be a positive scalar> prepad ([1,2], ones (2))
%!error <L must be a positive scalar> prepad ([1,2], -1)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{yi} =} __splinen__ (@var{x}, @var{y}, @var{xi}, @var{extrapval}, @var{f})
## Undocumented internal function.
## @end deftypefn

## FIXME: Allow arbitrary grids.

function yi = __splinen__ (x, y, xi, extrapval, f)

  ## ND function to check whether any object in cell array is *not* a vector.
  isnotvec = @(x) cellfun ("numel", x) != cellfun ("length", x);
  if (! iscell (x) || length (x) < ndims (y) || any (isnotvec (x))
      || ! iscell (xi) || length (xi) < ndims (y) || any (isnotvec (xi)))
    error ("__splinen__: %s: non-gridded data or dimensions inconsistent", f);
  endif

  yi = y;
  for i = length (x):-1:1
    yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
  endfor

  if (! isempty (extrapval))
    [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "uniformoutput", false){:});
    idx = false (size (xi{1}));
    for i = 1 : length (x)
      idx |= xi{i} < min (x{i}(:)) | xi{i} > max (x{i}(:));
    endfor
    yi(idx) = extrapval;
  endif

endfunction
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} quad2d (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb})
## @deftypefnx {} {@var{q} =} quad2d (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{prop}, @var{val}, @dots{})
## @deftypefnx {} {[@var{q}, @var{err}, @var{iter}] =} quad2d (@dots{})
##
## Numerically evaluate the two-dimensional integral of @var{f} using adaptive
## quadrature over the two-dimensional domain defined by @var{xa}, @var{xb},
## @var{ya}, @var{yb} using tiled integration.  Additionally, @var{ya} and
## @var{yb} may be scalar functions of @var{x}, allowing for the integration
## over non-rectangular domains.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must be of the form
## @math{z = f(x,y)} where @var{x} is a vector and @var{y} is a scalar.  It
## should return a vector of the same length and orientation as @var{x}.
##
## Additional optional parameters can be specified using
## @qcode{"@var{property}", @var{value}} pairs.  Valid properties are:
##
## @table @code
## @item AbsTol
## Define the absolute error tolerance for the quadrature.  The default
## value is 1e-10 (1e-5 for single).
##
## @item RelTol
## Define the relative error tolerance for the quadrature.  The default
## value is 1e-6 (1e-4 for single).
##
## @item MaxFunEvals
## The maximum number of function calls to the vectorized function @var{f}.
## The default value is 5000.
##
## @item Singular
## Enable/disable transforms to weaken singularities on the edge of the
## integration domain.  The default value is @var{true}.
##
## @item Vectorized
## Option to disable vectorized integration, forcing Octave to use only scalar
## inputs when calling the integrand.  The default value is @var{false}.
##
## @item FailurePlot
## If @code{quad2d} fails to converge to the desired error tolerance before
## MaxFunEvals is reached, a plot of the areas that still need refinement
## is created.  The default value is @var{false}.
## @end table
##
## Adaptive quadrature is used to minimize the estimate of error until the
## following is satisfied:
## @tex
## $$error \leq \max \left( AbsTol, RelTol\cdot\vert q\vert \right)$$
## @end tex
## @ifnottex
##
## @example
## @group
##         @var{error} <= max (@var{AbsTol}, @var{RelTol}*|@var{q}|)
## @end group
## @end example
##
## @end ifnottex
##
## The optional output @var{err} is an approximate bound on the error in the
## integral @code{abs (@var{q} - @var{I})}, where @var{I} is the exact value
## of the integral.  The optional output @var{iter} is the number of vectorized
## function calls to the function @var{f} that were used.
##
## Example 1 : integrate a rectangular region in x-y plane
##
## @example
## @group
## @var{f} = @@(@var{x},@var{y}) 2*ones (size (@var{x}));
## @var{q} = quad2d (@var{f}, 0, 1, 0, 1)
##   @result{} @var{q} =  2
## @end group
## @end example
##
## The result is a volume, which for this constant-value integrand, is just
## @code{@var{Length} * @var{Width} * @var{Height}}.
##
## Example 2 : integrate a triangular region in x-y plane
##
## @example
## @group
## @var{f} = @@(@var{x},@var{y}) 2*ones (size (@var{x}));
## @var{ymax} = @@(@var{x}) 1 - @var{x};
## @var{q} = quad2d (@var{f}, 0, 1, 0, @var{ymax})
##   @result{} @var{q} =  1
## @end group
## @end example
##
## The result is a volume, which for this constant-value integrand, is the
## Triangle Area x Height or
## @code{1/2 * @var{Base} * @var{Width} * @var{Height}}.
##
## Programming Notes: If there are singularities within the integration region
## it is best to split the integral and place the singularities on the
## boundary.
##
## Known @sc{matlab} incompatibility: If tolerances are left unspecified, and
## any integration limits are of type @code{single}, then Octave's integral
## functions automatically reduce the default absolute and relative error
## tolerances as specified above.  If tighter tolerances are desired they
## must be specified.  @sc{matlab} leaves the tighter tolerances appropriate
## for @code{double} inputs in place regardless of the class of the
## integration limits.
##
## Reference: @nospell{L.F. Shampine},
## @cite{@sc{matlab} program for quadrature in 2D}, Applied Mathematics and
## Computation, pp.@: 266--274, Vol 1, 2008.
##
## @seealso{integral2, dblquad, integral, quad, quadgk, quadv, quadl, quadcc,
##          trapz, integral3, triplequad}
## @end deftypefn

function [q, err, iter] = quad2d (f, xa, xb, ya, yb, varargin)

  if (nargin < 5 || mod (nargin, 2) == 0)
    print_usage ();
  endif

  if (ischar (f))
    ## Convert function given as a string to a function handle
    f = @(x) feval (f, x);
  elseif (! is_function_handle (f))
    print_usage ();
  endif

  if (! (isreal (xa) && isscalar (xa) && isreal (xb) && isscalar (xb)))
    print_usage ();
  endif

  ## Check for single or double limits to set appropriate default tolerance.
  issingle = (isa ([xa, xb], "single")
              || (! is_function_handle (ya) && isa (ya, "single"))
              || (! is_function_handle (yb) && isa (yb, "single")));

  ## Set defaults, update with any specified parameters.
  if (issingle)
    abstol = 1e-5;
    reltol = 1e-4;
  else
    abstol = 1e-10;
    reltol = 1e-6;
  endif

  vectorized = true;
  singular = true;
  idx = 1;
  maxiter = 5000;
  failureplot = false;

  while (idx < nargin - 5)
    prop = varargin{idx++};
    if (! ischar (prop))
      error ("quad2d: property PROP must be a string");
    endif

    switch (tolower (prop))
      case "abstol"
        abstol = varargin{idx++};
        if (! (isnumeric (abstol) && isscalar (abstol) && abstol >= 0))
          error ("quad2d: AbsTol value must be a numeric scalar >= 0");
        endif

      case "reltol"
        reltol = varargin{idx++};
        if (! (isnumeric (reltol) && isscalar (reltol) && reltol >= 0))
          error ("quad2d: RelTol value must be a numeric scalar >= 0");
        endif

      case "maxfunevals"
        maxiter = varargin{idx++};
        if (! (isnumeric (maxiter) && isscalar (maxiter)
               && fix (maxiter) == maxiter && maxiter >= 1))
          error ("quad2d: MaxFunEvals value must be a scalar integer >= 1");
        endif

      case "singular"
        singular = varargin{idx++};
        if (! (isscalar (singular) && isreal (singular)))
          error ("quad2d: Singular must be a logical value");
        endif

      case "vectorized"
        vectorized = varargin{idx++};
        if (! (isscalar (vectorized) && isreal (vectorized)))
          error ("quad2d: Vectorized must be a logical value");
        endif

      case "failureplot"
        failureplot = varargin{idx++};
        if (! (isscalar (failureplot) && isreal (failureplot)))
          error ("quad2d: FailurePlot must be a logical value");
        endif

      otherwise
        error ("quad2d: unknown property '%s'", prop);

    endswitch
  endwhile

  if (! vectorized)
    f = @(x, y) arrayfun (f, x, y);
  endif

  ## check upper and lower bounds of y
  if (! is_function_handle (ya))
    if (! (isreal (ya) && isscalar (ya)))
      error ("quad2d: YA must be a real scalar or a function");
    endif
    ya = @(x) ya * ones (rows (x), columns (x));
  endif
  if (! is_function_handle (yb))
    if (! (isreal (yb) && isscalar (yb)))
      error ("quad2d: YB must be a real scalar or a function");
    endif
    yb = @(x) yb * ones (rows (x), columns (x));
  endif

  iter = 0;
  qaccept = 0;
  qerraccept = 0;

  if (singular)
    ## Shampine suggests using the singularity weakening transform
    ## suggested by Havie.
    ##   \int_a^b f(x) dx = \int_0^pi f (g(t)) (dx / dt) dt
    ## where
    ##   g(t) = ((a - b) * cos(t) + (a + b)) / 2
    ##   dx = - (a - b) * sin(t) / 2 dt
    ## Now our integral is
    ##   \int_a^b \int_0^1 f(x,y) dydx
    ## as we already substitute for "y", so
    ##   gx(tx) = ((a - b) * cos(tx) + (a + b)) / 2
    ##   gy(ty) = (1 - cos(ty)) / 2
    ##   dydx = (b - a) * sin(tx) * sin(ty) / 4 dtydtx

    xtrans = @(tx) ((xa - xb) .* cos (tx) + (xa + xb)) ./ 2;
    ytrans = @(ty) (1 - cos (ty)) ./ 2;
    ztrans = @(tx, ty) (xb - xa) .* sin (tx) .* sin (ty) ./ 4;
    area = pi ^ 2;

    ## Initialize tile list
    tilelist(1) = struct ("xa", 0, "xb", pi, "ya", 0, "yb", pi, ...
                          "q", 0, "qerr", Inf);
  else
    xtrans = @(tx) tx;
    ytrans = @(ty) ty;
    ztrans = @(tx, ty)  1;
    area = (xb - xa);

    ## Initialize tile list
    tilelist(1) = struct ("xa", xa, "xb", xb, "ya", 0, "yb", 1, ...
                          "q", 0, "qerr", Inf);
  endif

  while (length (tilelist) > 0 && iter < maxiter)
    ## Get tile with the largest error
    [~, idx] = max ([tilelist.qerr]);
    tile = tilelist(idx);
    tilelist(idx) = [];

    ## Subdivide the tile into 4 subtiles
    iter += 4;
    tiles(4) = struct ("xa", tile.xa, "xb", tile.xa + (tile.xb - tile.xa) / 2,
                       "ya", tile.ya, "yb", tile.ya + (tile.yb - tile.ya) / 2,
                       "q", 0, "qerr", 0);
    tiles(3) = struct ("xa", tile.xa, "xb", tile.xa + (tile.xb - tile.xa) / 2,
                       "ya", tile.ya + (tile.yb - tile.ya) / 2, "yb", tile.yb,
                       "q", 0, "qerr", 0);
    tiles(2) = struct ("xa", tile.xa + (tile.xb - tile.xa) / 2, "xb", tile.xb,
                       "ya", tile.ya, "yb", tile.ya + (tile.yb - tile.ya) / 2,
                       "q", 0, "qerr", 0);
    tiles(1) = struct ("xa", tile.xa + (tile.xb - tile.xa) / 2, "xb", tile.xb,
                       "ya", tile.ya + (tile.yb - tile.ya) / 2, "yb", tile.yb,
                       "q", 0, "qerr", 0);

    ## Perform the quadrature of 4 subtiles
    for i = 1:4
      [tiles(i).q, tiles(i).qerr] = ...
        tensorproduct (f, ya, yb, tiles(i), xtrans, ytrans, ztrans, singular);
    endfor

    q = qaccept + sum ([[tilelist.q], tiles.q]);
    err = qerraccept + sum ([[tilelist.qerr], tiles.qerr]);
    tol = max (abstol, reltol .* abs (q));

    ## Shampine suggests taking a margin of a factor of 8 for
    ## the local tolerance.  That, and the fact that we are subdividing
    ## into 4 tiles, means we divide by 32 at this point.
    localtol = tol * ([tile.xb] - [tile.xa]) * ([tile.yb] - [tile.ya]) ...
               / area / 32;

    ## If global tolerance is met, return.
    if (err < tol)
      break;
    endif

    ## Accept the tiles meeting the tolerance, and add the others back to
    ## the list of tiles to treat.
    idx = find ([tiles.qerr] < localtol);
    qaccept += sum ([tiles(idx).q]);
    qerraccept += sum ([tiles(idx).qerr]);
    tiles(idx) = [];
    tilelist = [tilelist, tiles];
  endwhile

  ## Verify convergence
  if (iter >= maxiter)
    if (err > max (abstol, reltol .* abs (q)))
      warning (["quad2d: " ...
                "Maximum number of sub-tiles reached without convergence"]);
    else
      warning (["quad2d: " ...
                "Maximum number of sub-tiles reached, accuracy may be low"]);
    endif
    if (failureplot)
      newplot ();
      title ("quad2d : Areas needing refinement");
      for tile = tilelist
        xaa = xtrans(tile.xa);
        xbb = xtrans(tile.xb);
        y1 = ya(xaa) + ytrans(tile.ya) * (yb(xaa) - ya(xaa));
        y2 = ya(xaa) + ytrans(tile.yb) * (yb(xaa) - ya(xaa));
        y3 = ya(xbb) + ytrans(tile.yb) * (yb(xbb) - ya(xbb));
        y4 = ya(xbb) + ytrans(tile.ya) * (yb(xbb) - ya(xbb));
        patch ([xaa, xaa, xbb, xbb, xaa], [y1, y2, y3, y4, y1], "b");
      endfor
    endif
  endif

endfunction

function [q, qerr] = tensorproduct (f, ya, yb, tile, xtrans, ytrans, ztrans, singular)

  ## The Shampine TwoD paper proposes using a G3,K7 rule in a tensor product.
  ## I couldn't find a tabulated abscissas and weights of a G3,K7 rule publicly
  ## available, so use a G7,K15 rule from Octave's implementation of quadgk.

  persistent abscissa = [-0.9914553711208126e+00, -0.9491079123427585e+00, ...
                         -0.8648644233597691e+00, -0.7415311855993944e+00, ...
                         -0.5860872354676911e+00, -0.4058451513773972e+00, ...
                         -0.2077849550078985e+00,  0.0000000000000000e+00, ...
                          0.2077849550078985e+00,  0.4058451513773972e+00, ...
                          0.5860872354676911e+00,  0.7415311855993944e+00, ...
                          0.8648644233597691e+00,  0.9491079123427585e+00, ...
                          0.9914553711208126e+00];

  persistent weights15 = [0.2293532201052922e-01,  0.6309209262997855e-01, ...
                          0.1047900103222502e+00,  0.1406532597155259e+00, ...
                          0.1690047266392679e+00,  0.1903505780647854e+00, ...
                          0.2044329400752989e+00,  0.2094821410847278e+00, ...
                          0.2044329400752989e+00,  0.1903505780647854e+00, ...
                          0.1690047266392679e+00,  0.1406532597155259e+00, ...
                          0.1047900103222502e+00,  0.6309209262997855e-01, ...
                          0.2293532201052922e-01];

  persistent weights7  = [0.0, ...
                          0.1294849661688697e+00, 0.0, ...
                          0.2797053914892767e+00, 0.0, ...
                          0.3818300505051889e+00, 0.0, ...
                          0.4179591836734694e+00, 0.0, ...
                          0.3818300505051889e+00, 0.0, ...
                          0.2797053914892767e+00, 0.0, ...
                          0.1294849661688697e+00, 0.0];

  xaa = tile.xa;
  xbb = tile.xb;
  yaa = tile.ya;
  ybb = tile.yb;

  tx = ((xbb - xaa) * abscissa + xaa + xbb) / 2;
  x = xtrans(tx);
  ty = (abscissa' * (ybb - yaa)  + yaa + ybb) / 2;
  y = ones (15, 1) * ya(x) + ytrans(ty) * (yb(x) - ya(x));

  xhalfwidth = (xbb - xaa ) / 2;
  yhalfwidth = ones (15, 1) * (yb(x) - ya(x)) .* (ybb - yaa) ./ 2;

  x = ones (15, 1) * x;
  tx = ones (15,1) * tx;
  ty = ty * ones (1, 15);

  z = yhalfwidth .* f (x, y) .* ztrans(tx, ty) .* xhalfwidth;
  q = weights15 * (weights15 * z)';
  qerr = abs (weights7 * (weights7 * z)' - q);

endfunction


%!shared f
%! f = @(x, y) x .* y;
%!assert (quad2d (f, 0, 1, 0, 1), 0.25, 1e-10)

%!test
%! f = @(x, y) 9 * x.^2 + 15 * y.^2;
%!assert (quad2d (f, 0, 5, -5, 0, "AbsTol", 1e-9), 5000, 1e-9)
%!assert (quad2d (f, 0, 5, -5, 0, "RelTol", 1e-6), 5000, -1e-6)
%!assert (quad2d (f, 0, 5, -5, 0, "RelTol", 1e-6, "AbsTol", 1e-9), 5000, 1e-9)

## tests from dblquad
%!test
%! f = @(x, y) 1 ./ (x+y);
%!assert (quad2d (f, 0, 1, 0, 1, "AbsTol", 1e-7), 2*log (2), 1e-7)
%!assert (quad2d (f, 0, 1, 0, 1, "RelTol", 1e-5), 2*log (2), -1e-5)
%!assert (quad2d (f, 0, 1, 0, 1, "AbsTol", 1e-8, "RelTol", 1e-6),
%!        2*log (2), -1e-6)
%!assert (quad2d (f, 0, 1, 0, @(x) 1 - x), 1, -1e-6)
%!assert (quad2d (f, 0, 1, 0, @(x) 1 - x, "Singular", true), 1, -1e-6)

%!assert (quad2d (@(x, y) exp (-x.^2 - y.^2) , -1, 1, -1, 1),
%!        pi * erf (1).^2, 1e-10)

%!assert (quad2d (@plus, 1, 2, 3, 4), 5, 1e-10)

## Test input validation
%!error <Invalid call> quad2d ()
%!error <Invalid call> quad2d (@plus)
%!error <Invalid call> quad2d (@plus, 1)
%!error <Invalid call> quad2d (@plus, 1, 2)
%!error <Invalid call> quad2d (@plus, 1, 2, 3)
%!error <Invalid call> quad2d (@plus, 1, 2, 3, 4, "foo")
%!error quad2d (0, 1, 2, 3, 4)          # f must be function handle
%!error quad2d (@plus, 1i, 2, 3, 4)     # real limits
%!error quad2d (@plus, 1, 2i, 3, 4)     # real limits
%!error quad2d (@plus, [1 1], 2, 3, 4)  # scalar limits
%!error quad2d (@plus, 1, [2 2], 3, 4)  # scalar limits
%!error <property PROP must be a string> quad2d (@plus, 1, 2, 3, 4, 99, "bar")
%!error <AbsTol value must be a numeric> quad2d (@plus, 1, 2, 3, 4, "AbsTol", "foo")
%!error <AbsTol value must be a .* scalar> quad2d (@plus, 1, 2, 3, 4, "AbsTol", [1, 2])
%!error <AbsTol value must be.* .= 0> quad2d (@plus, 1, 2, 3, 4, "AbsTol", -1)
%!error <RelTol value must be a numeric> quad2d (@plus, 1, 2, 3, 4, "RelTol", "foo")
%!error <RelTol value must be a .* scalar> quad2d (@plus, 1, 2, 3, 4, "RelTol", [1, 2])
%!error <RelTol value must be.* .= 0> quad2d (@plus, 1, 2, 3, 4, "RelTol", -1)
%!error <MaxFunEvals value must be a scalar integer>
%! quad2d (@plus,1,2,3,4, "MaxFunEvals", {1});
%!error <MaxFunEvals value must be a scalar integer>
%! quad2d (@plus,1,2,3,4, "MaxFunEvals", [1 1]);
%!error <MaxFunEvals value must be a scalar integer>
%! quad2d (@plus,1,2,3,4, "MaxFunEvals", 1.5);
%!error <MaxFunEvals value must be a scalar integer .= 1>
%! quad2d (@plus,1,2,3,4, "MaxFunEvals", -1);
%!error <Singular must be a logical value>
%! quad2d (@plus,1,2,3,4, "Singular", [0 1]);
%!error <Singular must be a logical value>
%! quad2d (@plus,1,2,3,4, "Singular", {true});
%!error <Vectorized must be a logical value>
%! quad2d (@plus,1,2,3,4, "Vectorized", [0 1]);
%!error <Vectorized must be a logical value>
%! quad2d (@plus,1,2,3,4, "Vectorized", {true});
%!error <FailurePlot must be a logical value>
%! quad2d (@plus,1,2,3,4, "FailurePlot", [0 1]);
%!error <FailurePlot must be a logical value>
%! quad2d (@plus,1,2,3,4, "FailurePlot", {true});
%!error <unknown property 'foo'>  quad2d (@plus, 1, 2, 3, 4, "foo", "bar")
%!error <YA must be a real scalar> quad2d (@plus, 1, 2, 3i, 4)
%!error <YA must be a real scalar> quad2d (@plus, 1, 2, [3 3], 4)
%!error <YB must be a real scalar> quad2d (@plus, 1, 2, 3, 4i)
%!error <YB must be a real scalar> quad2d (@plus, 1, 2, 3, [4 4])
%!warning <Maximum number of> quad2d (@plus, 1, 2, 3, 4, "MaxFunEvals", 1);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} quadgk (@var{f}, @var{a}, @var{b})
## @deftypefnx {} {@var{q} =} quadgk (@var{f}, @var{a}, @var{b}, @var{abstol})
## @deftypefnx {} {@var{q} =} quadgk (@var{f}, @var{a}, @var{b}, @var{abstol}, @var{trace})
## @deftypefnx {} {@var{q} =} quadgk (@var{f}, @var{a}, @var{b}, @var{prop}, @var{val}, @dots{})
## @deftypefnx {} {[@var{q}, @var{err}] =} quadgk (@dots{})
##
## Numerically evaluate the integral of @var{f} from @var{a} to @var{b}
## using adaptive @nospell{Gauss-Kronrod} quadrature.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must be vectorized and
## return a vector of output values when given a vector of input values.
##
## @var{a} and @var{b} are the lower and upper limits of integration.  Either
## or both limits may be infinite or contain weak end singularities.  Variable
## transformation will be used to treat any infinite intervals and weaken the
## singularities.  For example:
##
## @example
## quadgk (@@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)
## @end example
##
## @noindent
## Note that the formulation of the integrand uses the element-by-element
## operator @code{./} and all user functions to @code{quadgk} should do the
## same.
##
## The optional argument @var{tol} defines the absolute tolerance used to stop
## the integration procedure.  The default value is 1e-10 (1e-5 for single).
##
## The algorithm used by @code{quadgk} involves subdividing the integration
## interval and evaluating each subinterval.  If @var{trace} is true then after
## computing each of these partial integrals display: (1) the number of
## subintervals at this step, (2) the current estimate of the error @var{err},
## (3) the current estimate for the integral @var{q}.
##
## The behavior of the algorithm can be configured by passing arguments
## to @code{quadgk} as pairs @qcode{"@var{prop}", @var{val}}.  Valid properties
## are
##
## @table @code
## @item AbsTol
## Define the absolute error tolerance for the quadrature.  The default
## absolute tolerance is 1e-10 (1e-5 for single).
##
## @item RelTol
## Define the relative error tolerance for the quadrature.  The default
## relative tolerance is 1e-6 (1e-4 for single).
##
## @item MaxIntervalCount
## @code{quadgk} initially subdivides the interval on which to perform the
## quadrature into 10 intervals.  Subintervals that have an unacceptable error
## are subdivided and re-evaluated.  If the number of subintervals exceeds 650
## subintervals at any point then a poor convergence is signaled and the
## current estimate of the integral is returned.  The property
## @qcode{"MaxIntervalCount"} can be used to alter the number of subintervals
## that can exist before exiting.
##
## @item WayPoints
## Discontinuities in the first derivative of the function to integrate can be
## flagged with the @qcode{"WayPoints"} property.  This forces the ends of a
## subinterval to fall on the breakpoints of the function and can result in
## significantly improved estimation of the error in the integral, faster
## computation, or both.  For example,
##
## @example
## quadgk (@@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)
## @end example
##
## @noindent
## signals the breakpoint in the integrand at @code{@var{x} = 1}.
##
## @item Trace
## If logically true @code{quadgk} prints information on the convergence of the
## quadrature at each iteration.
## @end table
##
## If any of @var{a}, @var{b}, or @var{waypoints} is complex then the
## quadrature is treated as a contour integral along a piecewise continuous
## path defined by
## @code{[@var{a}, @var{waypoints}(1), @var{waypoints}(2), @dots{}, @var{b}]}.
## In this case the integral is assumed to have no edge singularities.  For
## example,
##
## @example
## @group
## quadgk (@@(z) log (z), 1+1i, 1+1i, "WayPoints",
##         [-1+1i, -1-1i, +1-1i])
## @end group
## @end example
##
## @noindent
## integrates @code{log (z)} along the square defined by
## @code{[1+1i, -1+1i, -1-1i, +1-1i]}.
##
## The result of the integration is returned in @var{q}.
##
## @var{err} is an approximate bound on the error in the integral
## @w{@code{abs (@var{q} - @var{I})}}, where @var{I} is the exact value of the
## integral.
##
## Reference: @nospell{L.F. Shampine},
## @cite{"Vectorized adaptive quadrature in @sc{matlab}"}, Journal of
## Computational and Applied Mathematics, pp.@: 131--140, Vol 211, Issue 2,
## Feb 2008.
##
## @seealso{quad, quadv, quadl, quadcc, trapz, dblquad, triplequad, integral,
##           integral2, integral3}
## @end deftypefn

function [q, err] = quadgk (f, a, b, varargin)

  if (nargin < 3)
    print_usage ();
  endif

  if (b < a)
    ## Reverse integration
    [q, err] = quadgk (f, b, a, varargin{:});
    q = -q;
    return;
  endif

  abstol = [];
  reltol = [];
  waypoints = [];
  maxint = 650;
  trace = false;

  ## Parse options if present.
  if (nargin > 3)
    if (! ischar (varargin{1}))
      if (! isempty (varargin{1}))
        abstol = varargin{1};
        reltol = 0;
      endif
      if (nargin > 4)
        trace = varargin{2};
      endif
      if (nargin > 5)
        error ("quadgk: can not pass additional arguments to user function");
      endif
    else
      if (mod (nargin - 3, 2) != 0)
        error ("quadgk: property/value options must occur in pairs");
      endif

      idx = 1;
      while (idx < nargin - 3)
        if (! ischar (varargin{idx}))
          error ("quadgk: property PROP must be a string");
        endif
        str = varargin{idx++};
        switch (tolower (str))
          case "reltol"
            reltol = varargin{idx++};
          case "abstol"
            abstol = varargin{idx++};
          case "waypoints"
            waypoints = varargin{idx++}(:);
            if (isreal (waypoints))
              waypoints(waypoints < a | waypoints > b) = [];
            endif
          case "maxintervalcount"
            maxint = varargin{idx++};
          case "trace"
            trace = varargin{idx++};
          otherwise
            error ("quadgk: unknown property '%s'", str);
        endswitch
      endwhile
    endif
  endif

  issingle = (isa (a, "single") || isa (b, "single")
              || isa (waypoints, "single"));

  if (isempty (abstol))
    abstol = ifelse (issingle, 1e-5, 1e-10);
  elseif (! isscalar (abstol) || abstol < 0)
    error ("quadgk: ABSTOL must be a scalar >=0");
  endif

  if (isempty (reltol))
    reltol = ifelse (issingle, 1e-4, 1e-6);
  elseif (! isscalar (reltol) || reltol < 0)
    error ("quadgk: RELTOL must be a scalar >=0");
  endif

  ## Convert function given as a string to a function handle
  if (ischar (f))
    f = @(x) feval (f, x);
  endif

  ## Use variable substitution to weaken endpoint singularities and
  ## to perform integration with endpoints at infinity.
  ## No transform for contour integrals.
  if (iscomplex (a) || iscomplex (b) || iscomplex (waypoints))
    ## contour integral, no transform
    subs = [a; waypoints; b];
    h = sum (abs (diff (subs)));
    h0 = h;
    trans = @(t) t;
  elseif (isinf (a) && isinf (b))
    ## Standard infinite to finite integral transformation.
    ##   \int_{-\infinity_^\infinity f(x) dx = \int_-1^1 f (g(t)) g'(t) dt
    ## where
    ##   g(t)  = t / (1 - t^2)
    ##   g'(t) =  (1 + t^2) / (1 - t^2) ^ 2
    ## waypoint transform is then
    ##   t =  (2 * g(t)) ./ (1 + sqrt(1 + 4 * g(t) .^ 2))
    if (! isempty (waypoints))
      trans = @(x) (2 * x) ./ (1 + sqrt (1 + 4 * x .^ 2));
      subs = [-1; trans(waypoints); 1];
    else
      subs = linspace (-1, 1, 11)';
    endif
    h = 2;
    h0 = b - a;
    trans = @(t) t ./ (1 - t.^2);
    f = @(t) f (t ./ (1 - t .^ 2)) .* (1 + t .^ 2) ./ ((1 - t .^ 2) .^ 2);
  elseif (isinf (a))
    ## Formula defined in Shampine paper as two separate steps.
    ## One to weaken singularity at finite end, then a second to transform to
    ## a finite interval.  The singularity weakening transform is
    ##   \int_{-\infinity}^b f(x) dx =
    ##               - \int_{-\infinity}^0 f (b - t^2) 2 t dt
    ## (note minus sign) and the finite interval transform is
    ##   \int_{-\infinity}^0 f(b - t^2)  2 t dt =
    ##                  \int_{-1}^0 f (b - g(s) ^ 2) 2 g(s) g'(s) ds
    ## where
    ##   g(s)  = s / (1 + s)
    ##   g'(s) = 1 / (1 + s) ^ 2
    ## waypoint transform is then
    ##   t = sqrt (b - x)
    ##   s =  - t / (t + 1)
    if (! isempty (waypoints))
      tmp = sqrt (b - waypoints);
      trans = @(x) - x ./ (x + 1);
      subs = [-1; trans(tmp); 0];
    else
      subs = linspace (-1, 0, 11)';
    endif
    h = 1;
    h0 = b - a;
    trans = @(t) b - (t ./ (1 + t)).^2;
    f = @(s) - 2 * s .* f (b -  (s ./ (1 + s)) .^ 2) ./ ((1 + s) .^ 3);
  elseif (isinf (b))
    ## Formula defined in Shampine paper as two separate steps.
    ## One to weaken singularity at finite end, then a second to transform to
    ## a finite interval.  The singularity weakening transform is
    ##   \int_a^\infinity f(x) dx = \int_0^\infinity f (a + t^2) 2 t dt
    ## and the finite interval transform is
    ##  \int_0^\infinity f(a + t^2)  2 t dt =
    ##           \int_0^1 f (a + g(s) ^ 2) 2 g(s) g'(s) ds
    ## where
    ##   g(s)  = s / (1 - s)
    ##   g'(s) = 1 / (1 - s) ^ 2
    ## waypoint transform is then
    ##   t = sqrt (x - a)
    ##   s = t / (t + 1)
    if (! isempty (waypoints))
      tmp = sqrt (waypoints - a);
      trans = @(x) x ./ (x + 1);
      subs = [0; trans(tmp); 1];
    else
      subs = linspace (0, 1, 11)';
    endif
    h = 1;
    h0 = b - a;
    trans = @(t) a + (t ./ (1 - t)).^2;
    f = @(s) 2 * s .* f (a +  (s ./ (1 - s)) .^ 2) ./ ((1 - s) .^ 3);
  else
    ## Davis, Rabinowitz, "Methods of Numerical Integration" p441 2ed.
    ## Presented in section 5 of the Shampine paper as
    ##   g(t) = ((b - a) / 2) * (t / 2 * (3 - t^2)) + (b + a) / 2
    ##   g'(t) = ((b-a)/4) * (3 - 3t^2);
    ## waypoint transform can then be found by solving for t with
    ## Maxima (solve (c + 3*t -  3^3, t);).  This gives 3 roots, two of
    ## which are complex for values between a and b and so can be ignored.
    ## The third is
    ##  c = (-4*x + 2*(b+a)) / (b-a);
    ##  k = ((sqrt(c^2 - 4) + c)/2)^(1/3);
    ##  t = (sqrt(3)* 1i * (1 - k^2) - (1 + k^2)) / 2 / k;
    if (! isempty (waypoints))
      trans = @__quadgk_finite_waypoint__;
      subs = [-1; trans(waypoints, a, b); 1];
    else
      subs = linspace (-1, 1, 11)';
    endif
    h = 2;
    h0 = b - a;
    trans = @(t) ((b - a) ./ 4) * t .* (3 - t.^2) + (b + a) ./ 2;
    f = @(t) f((b - a) ./ 4 .* t .* (3 - t.^2) + (b + a) ./ 2) .* ...
         3 .* (b - a) ./ 4 .* (1 - t.^2);
  endif

  ## Split interval into at least 10 subinterval with a 15 point
  ## Gauss-Kronrod rule giving a minimum of 150 function evaluations.
  while (length (subs) < 11)
    subs = [subs.' ; subs(1:end-1).' + diff(subs.') ./ 2, NaN](:)(1 : end - 1);
  endwhile
  subs = [subs(1:end-1), subs(2:end)];

  warn_id = "Octave:quadgk:warning-termination";

  if (issingle)
    eps1 = eps ("single");
  else
    eps1 = eps ("double");
  endif

  ## Initial evaluation of the integrand on the subintervals
  [q_subs, q_errs] = __quadgk_eval__ (f, subs, eps1, trans);
  q0 = sum (q_subs);
  err0 = sum (q_errs);

  first = true;
  while (true)
    ## Quit if any evaluations are not finite (Inf or NaN).
    if (any (! isfinite (q_subs)))
      warning (warn_id, "quadgk: non-finite integrand encountered");
      q = q0;
      err = err0;
      break;
    endif

    tol = max (abstol, reltol .* abs (q0));

    ## If the global error estimate is met then exit
    if (err0 < tol)
      q = q0;
      err = err0;
      break;
    endif

    ## Accept the subintervals that meet the convergence criteria.
    idx = find (abs (q_errs) < tol .* abs (diff (subs, [], 2)) ./ h);
    if (first)
      q = sum (q_subs(idx));
      err = sum (q_errs(idx));
      first = false;
    else
      q0 = q + sum (q_subs);
      err0 = err + sum (q_errs);
      q += sum (q_subs(idx));
      err += sum (q_errs(idx));
    endif
    subs(idx,:) = [];

    ## If no remaining subintervals exit
    if (rows (subs) == 0)
      break;
    endif

    if (trace)
      disp ([rows(subs), err, q0]);
    endif

    ## Split remaining subintervals in two
    mid = (subs(:,2) + subs(:,1)) ./ 2;
    subs = [subs(:,1), mid; mid, subs(:,2)];

    ## If the maximum subinterval count is met accept remaining subinterval
    ## and exit
    if (rows (subs) > maxint)
      warning (warn_id, "quadgk: maximum interval count (%d) exceeded", maxint);
      q += sum (q_subs);
      err += sum (q_errs);
      break;
    endif

    ## Evaluation of the integrand on the remaining subintervals
    [q_subs, q_errs] = __quadgk_eval__ (f, subs, eps1, trans);
  endwhile

  if (err > max (abstol, reltol * abs (q)))
    warning (warn_id,
             "quadgk: Error tolerance not met.  Estimated error %g", err);
  endif

endfunction

## FIXME: too_close output is never used in function that calls this one.
function [q, err, too_close] = __quadgk_eval__ (f, subs, eps1, trans)

  ## A (15,7) point pair of Gauss-Kronrod quadrature rules.
  ## The abscissa and weights are copied directly from dqk15w.f from quadpack.

  persistent abscissa = [-0.9914553711208126e+00, -0.9491079123427585e+00, ...
                         -0.8648644233597691e+00, -0.7415311855993944e+00, ...
                         -0.5860872354676911e+00, -0.4058451513773972e+00, ...
                         -0.2077849550078985e+00,  0.0000000000000000e+00, ...
                          0.2077849550078985e+00,  0.4058451513773972e+00, ...
                          0.5860872354676911e+00,  0.7415311855993944e+00, ...
                          0.8648644233597691e+00,  0.9491079123427585e+00, ...
                          0.9914553711208126e+00];

  persistent weights15 = ...
      diag ([0.2293532201052922e-01,  0.6309209262997855e-01, ...
             0.1047900103222502e+00,  0.1406532597155259e+00, ...
             0.1690047266392679e+00,  0.1903505780647854e+00, ...
             0.2044329400752989e+00,  0.2094821410847278e+00, ...
             0.2044329400752989e+00,  0.1903505780647854e+00, ...
             0.1690047266392679e+00,  0.1406532597155259e+00, ...
             0.1047900103222502e+00,  0.6309209262997855e-01, ...
             0.2293532201052922e-01]);

  persistent weights7 = ...
      diag ([0.1294849661688697e+00,  0.2797053914892767e+00, ...
             0.3818300505051889e+00,  0.4179591836734694e+00, ...
             0.3818300505051889e+00,  0.2797053914892767e+00, ...
             0.1294849661688697e+00]);

  halfwidth = diff (subs, [], 2) ./ 2;
  center = sum (subs, 2) ./ 2;
  t = (halfwidth * abscissa) + center;
  x = trans ([t(:,1), t(:,end)]);

  ## Shampine suggests 100 * eps1, beginning of section 6.
  if (any (abs (diff (x, [], 2) ./ max (abs (x), [], 2))) < 100 * eps1)
    too_close = true;
    q = 0;
    err = 0;
    return;
  endif

  too_close = false;
  y = reshape (f (t(:)), size (t));

  ## This is faster than using bsxfun as the * operator can use a
  ## single BLAS call, rather than rows (sub) calls to the @times function.
  q = sum (y * weights15, 2) .* halfwidth;
  err = abs (sum (y(:,2:2:end) * weights7, 2) .* halfwidth - q);

endfunction

function t = __quadgk_finite_waypoint__ (x, a, b)
  c = (-4 .* x + 2.* (b + a)) ./ (b - a);
  k = ((sqrt (c .^ 2 - 4) + c) ./ 2) .^ (1/3);
  t = real ((sqrt (3) .* 1i * (1 - k .^ 2) - (1 + k .^ 2)) ./ 2 ./ k);
endfunction


%!assert (quadgk (@sin,-pi,pi), 0, 1e-10)
%!assert (quadgk (inline ("sin"),-pi,pi), 0, 1e-10)
%!assert (quadgk ("sin",-pi,pi), 0, 1e-10)
%!assert (quadgk (@sin,-pi,pi, "WayPoints", 0, "MaxIntervalCount", 100,
%!                "RelTol", 1e-3, "AbsTol", 1e-6, "trace", false), 0, 1e-6)
%!assert (quadgk (@sin,-pi,pi, 1e-6, false), 0, 1e-6)
%!assert <*51867> (quadgk (@(x) x, 0, 0), 0, 0)

%!assert (quadgk (@sin,-pi,0), -2, 1e-10)
%!assert (quadgk (@sin,0,pi), 2, 1e-10)
%!assert (quadgk (@(x) 1./sqrt (x),0,1), 2, 1e-10)
%!assert (quadgk (@(x) abs (1 - x.^2),0,2, "Waypoints", 1), 2, 1e-10)
%!assert (quadgk (@(x) 1./(sqrt (x) .* (x+1)),0,Inf), pi, 1e-10)
%!assert <*57614> (quadgk (@(z) exp (z)./z, 1, 1,
%!                        "Waypoints", [1+i, -1+i, -1-i, 1-i]),
%!                 complex (0, 2*pi), 1e-10)
%!assert <*57614> (quadgk (@(z) exp (z)./z, 1, 1,
%!                        "Waypoints", [1-i, -1-i, -1+i, 1+i]),
%!                 complex (0, -2*pi), 1e-10)
%!assert (quadgk (@(z) log (z),1+1i,1+1i, "WayPoints", [1-1i, -1,-1i, -1+1i]),
%!        complex (0, pi), 1e-10)
%!assert (quadgk (@(x) exp (-x .^ 2),-Inf,Inf), sqrt (pi), -1e-6)
%!assert (quadgk (@(x) exp (-x .^ 2),-Inf,0), sqrt (pi)/2, -1e-6)
%!test
%! f = @(x) x .^ 5 .* exp (-x) .* sin (x);
%! assert (quadgk (f, 0, Inf, "RelTol", 1e-8, "AbsTol", 1e-12), -15, -1e-8);

## Test input validation
%!error quadgk (@sin)
%!error quadgk (@sin, 0)
%!error <can not pass additional arguments> quadgk (@sin, 0, 1, 1e-6, true, 4)
%!error <options must occur in pairs> quadgk (@sin, 0, 1, "DummyArg")
%!error <PROP must be a string> quadgk (@sin, 0, 1, "AbsTol", 1e-6, 2, 3)
%!error <unknown property 'foo'> quadgk (@sin, 0, 1, "foo", 3)
%!error <ABSTOL must be a scalar> quadgk (@sin, 0, 1, ones (2,2))
%!error <ABSTOL must be a scalar .=0> quadgk (@sin, 0, 1, -1)
%!error <RELTOL must be a scalar> quadgk (@sin, 0, 1, "RelTol", ones (2,2))
%!error <RELTOL must be a scalar> quadgk (@sin, 0, 1, "RelTol", -1)
########################################################################
##
## Copyright (C) 1998-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} quadl (@var{f}, @var{a}, @var{b})
## @deftypefnx {} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol})
## @deftypefnx {} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace})
## @deftypefnx {} {@var{q} =} quadl (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace}, @var{p1}, @var{p2}, @dots{})
## @deftypefnx {} {[@var{q}, @var{nfun}] =} quadl (@dots{})
##
## Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using
## an adaptive @nospell{Lobatto} rule.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must be vectorized and
## return a vector of output values when given a vector of input values.
##
## @var{a} and @var{b} are the lower and upper limits of integration.  Both
## limits must be finite.
##
## The optional argument @var{tol} defines the absolute tolerance with which
## to perform the integration.  The default value is 1e-6.
##
## The algorithm used by @code{quadl} involves recursively subdividing the
## integration interval.  If @var{trace} is defined then for each subinterval
## display: (1) the total number of function evaluations, (2) the left end of
## the subinterval, (3) the length of the subinterval, (4) the approximation of
## the integral over the subinterval.
##
## Additional arguments @var{p1}, etc., are passed directly to the function
## @var{f}.  To use default values for @var{tol} and @var{trace}, one may pass
## empty matrices ([]).
##
## The result of the integration is returned in @var{q}.
##
## The optional output @var{nfun} indicates the total number of function
## evaluations performed.
##
## Reference: @nospell{W. Gander and W. Gautschi}, @cite{Adaptive Quadrature -
## Revisited}, BIT Vol.@: 40, No.@: 1, March 2000, pp.@: 84--101.
## @url{https://www.inf.ethz.ch/personal/gander/}
## @seealso{quad, quadv, quadgk, quadcc, trapz, dblquad, triplequad, integral,
##          integral2, integral3}
## @end deftypefn

## Original Author: Walter Gautschi
## Date: 08/03/98
## Reference: Gander, Computermathematik, Birkhaeuser, 1992.

## 2003-08-05 Shai Ayal
##   * permission from author to release as GPL

function [q, nfun] = quadl (f, a, b, tol = [], trace = false, varargin)

  if (nargin < 3)
    print_usage ();
  endif

  if (isa (a, "single") || isa (b, "single"))
    eps = eps ("single");
  else
    eps = eps ("double");
  endif
  if (isempty (tol))
    tol = 1e-6;
  elseif (! isscalar (tol) || tol < 0)
    error ("quadl: TOL must be a scalar >=0");
  elseif (tol < eps)
    warning ("quadl: TOL specified is smaller than machine precision, using %g",
                                                                           tol);
    tol = eps;
  endif
  if (isempty (trace))
    trace = false;
  endif

  y = feval (f, [a, b], varargin{:});
  nfun = 1;

  fa = y(1);
  fb = y(2);

  h = b - a;

  [q, nfun, hmin] = adaptlobstp (f, a, b, fa, fb, Inf, nfun, abs (h),
                                 tol, trace, varargin{:});

  if (nfun > 10_000)
    warning ("quadl: maximum iteration count reached -- possible singular integral");
  elseif (any (! isfinite (q(:))))
    warning ("quadl: infinite or NaN function evaluations were returned");
  elseif (hmin < (b - a) * eps)
    warning ("quadl: minimum step size reached -- possible singular integral");
  endif

endfunction

function [q, nfun, hmin] = adaptlobstp (f, a, b, fa, fb, q0, nfun, hmin,
                                        tol, trace, varargin)

  persistent alpha = sqrt (2/3);
  persistent beta = 1 / sqrt (5);

  if (nfun > 10_000)
    q = q0;
    return;
  endif

  h = (b - a) / 2;
  m = (a + b) / 2;
  mll = m - alpha*h;
  ml  = m - beta*h;
  mr  = m + beta*h;
  mrr = m + alpha*h;
  x = [mll, ml, m, mr, mrr];
  y = feval (f, x, varargin{:});
  nfun += 1;
  fmll = y(1);
  fml  = y(2);
  fm   = y(3);
  fmr  = y(4);
  fmrr = y(5);
  i2 = (h/6)*(fa + fb + 5*(fml+fmr));
  i1 = (h/1470)*(77*(fa+fb) + 432*(fmll+fmrr) + 625*(fml+fmr) + 672*fm);

  if (abs (b - a) < hmin)
    hmin = abs (b - a);
  endif

  if (trace)
    disp ([nfun, a, b-a, i1]);
  endif

  ## Force at least one adaptive step (nfun > 2 test).
  if ((abs (i1-i2) < tol || mll <= a || b <= mrr) && nfun > 2)
    q = i1;
  else
    q = zeros (6, 1, class (x));
    [q(1), nfun, hmin] = adaptlobstp (f, a  , mll, fa  , fmll, q0/6, nfun, hmin,
                                      tol, trace, varargin{:});
    [q(2), nfun, hmin] = adaptlobstp (f, mll, ml , fmll, fml , q0/6, nfun, hmin,
                                      tol, trace, varargin{:});
    [q(3), nfun, hmin] = adaptlobstp (f, ml , m  , fml , fm  , q0/6, nfun, hmin,
                                      tol, trace, varargin{:});
    [q(4), nfun, hmin] = adaptlobstp (f, m  , mr , fm  , fmr , q0/6, nfun, hmin,
                                      tol, trace, varargin{:});
    [q(5), nfun, hmin] = adaptlobstp (f, mr , mrr, fmr , fmrr, q0/6, nfun, hmin,
                                      tol, trace, varargin{:});
    [q(6), nfun, hmin] = adaptlobstp (f, mrr, b  , fmrr, fb  , q0/6, nfun, hmin,
                                      tol, trace, varargin{:});
    q = sum (q);
  endif

endfunction


## basic functionality
%!assert (quadl (@(x) sin (x), 0, pi), 2, 1e-6)

## the values here are very high so it may be unavoidable that this fails
%!assert (quadl (@(x) sin (3*x).*cosh (x).*sinh (x),10,15, 1e-3),
%!        2.588424538641647e+10, 1e-3)

## extra parameters
%!assert (quadl (@(x,a,b) sin (a + b*x), 0, 1, [], [], 2, 3),
%!        cos (2)/3 - cos (5)/3, 1e-6)

## test different tolerances.
%!test
%! [q, nfun1] = quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.5, []);
%! assert (q, (60 + sin (4) - sin (64))/12, 0.5);
%! [q, nfun2] = quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.1, []);
%! assert (q, (60 + sin (4) - sin (64))/12, 0.1);
%! assert (nfun2 > nfun1);

%!test  # test single input/output
%! assert (class (quadl (@sin, 0, 1)), "double");
%! assert (class (quadl (@sin, single (0), 1)), "single");
%! assert (class (quadl (@sin, 0, single (1))), "single");

## Test input validation
%!error <Invalid call> quadl ()
%!error <Invalid call> quadl (@sin)
%!error <Invalid call> quadl (@sin,1)
%!error <TOL must be a scalar> quadl (@sin,0,1, ones (2,2))
%!error <TOL must be .* .=0> quadl (@sin,0,1, -1)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} quadv (@var{f}, @var{a}, @var{b})
## @deftypefnx {} {@var{q} =} quadv (@var{f}, @var{a}, @var{b}, @var{tol})
## @deftypefnx {} {@var{q} =} quadv (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace})
## @deftypefnx {} {@var{q} =} quadv (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace}, @var{p1}, @var{p2}, @dots{})
## @deftypefnx {} {[@var{q}, @var{nfun}] =} quadv (@dots{})
##
## Numerically evaluate the integral of @var{f} from @var{a} to @var{b}
## using an adaptive Simpson's rule.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  @code{quadv} is a vectorized version of
## @code{quad} and the function defined by @var{f} must accept a scalar or
## vector as input and return a scalar, vector, or array as output.
##
## @var{a} and @var{b} are the lower and upper limits of integration.  Both
## limits must be finite.
##
## The optional argument @var{tol} defines the absolute tolerance used to stop
## the adaptation procedure.  The default value is 1e-6.
##
## The algorithm used by @code{quadv} involves recursively subdividing the
## integration interval and applying Simpson's rule on each subinterval.
## If @var{trace} is true then after computing each of these partial
## integrals display: (1) the total number of function evaluations,
## (2) the left end of the subinterval, (3) the length of the subinterval,
## (4) the approximation of the integral over the subinterval.
##
## Additional arguments @var{p1}, etc., are passed directly to the function
## @var{f}.  To use default values for @var{tol} and @var{trace}, one may pass
## empty matrices ([]).
##
## The result of the integration is returned in @var{q}.
##
## The optional output @var{nfun} indicates the total number of function
## evaluations performed.
##
## Note: @code{quadv} is written in Octave's scripting language and can be
## used recursively in @code{dblquad} and @code{triplequad}, unlike the
## @code{quad} function.
## @seealso{quad, quadl, quadgk, quadcc, trapz, dblquad, triplequad, integral,
##          integral2, integral3}
## @end deftypefn

## Algorithm: See https://en.wikipedia.org/wiki/Adaptive_Simpson%27s_method
## for basic explanation.  See NOTEs and FIXME for Octave modifications.

function [q, nfun] = quadv (f, a, b, tol = [], trace = false, varargin)

  if (nargin < 3)
    print_usage ();
  endif

  if (isa (a, "single") || isa (b, "single"))
    eps = eps ("single");
  else
    eps = eps ("double");
  endif
  if (isempty (tol))
    tol = 1e-6;
  elseif (! isscalar (tol) || tol < 0)
    error ("quadv: TOL must be a scalar >=0");
  endif

  if (trace)
    ## Print column headers once above trace display.
    printf ("  nfun          a            (b - a)         q_interval\n");
  endif

  ## NOTE: Split the interval into 3 parts which avoids problems with periodic
  ## functions when a, b, and (a + b)/2 fall on boundaries such as 0, 2*pi.
  ## For compatibility with Matlab, split in to two equal size regions on the
  ## left and right, and one larger central region.
  alpha = 0.27158;   # factor for region 1 & region 3 size (~27%)
  b1 = a + alpha * (b - a);
  b2 = b - alpha * (b - a);
  c1 = (a + b1) / 2;
  c2 = (a + b)  / 2;
  c3 = (b2 + b) / 2;

  fa  = feval (f, a,  varargin{:});
  fc1 = feval (f, c1, varargin{:});
  fb1 = feval (f, b1, varargin{:});
  fc2 = feval (f, c2, varargin{:});
  fb2 = feval (f, b2, varargin{:});
  fc3 = feval (f, c3, varargin{:});
  fb  = feval (f, b,  varargin{:});
  nfun = 7;

  ## NOTE: If there are edge singularities, move edge point by eps*(b-a) as
  ## discussed in Shampine paper used to implement quadgk.
  if (any (isinf (fa(:))))
    fa = feval (f, a + eps * (b-a), varargin{:});
    nfun++;
  endif
  if (any (isinf (fb(:))))
    fb = feval (f, b - eps * (b-a), varargin{:});
    nfun++;
  endif

  ## Region 1
  h = (b1 - a);
  q1 = h / 6 * (fa + 4*fc1 + fb1);

  [q1, nfun, hmin1] = simpsonstp (f, a, b1, c1, fa, fb1, fc1, q1, tol,
                                  nfun, abs (h), trace, varargin{:});

  ## Region 2
  h = (b2 - b1);
  q2 = h / 6 * (fb1 + 4*fc2 + fb2);

  [q2, nfun, hmin2] = simpsonstp (f, b1, b2, c2, fb1, fb2, fc2, q2, tol,
                                  nfun, abs (h), trace, varargin{:});

  ## Region 3
  h = (b - b2);
  q3 = h / 6 * (fb2 + 4*fc3 + fb);

  [q3, nfun, hmin3] = simpsonstp (f, b2, b, c3, fb2, fb, fc3, q3, tol,
                                  nfun, abs (h), trace, varargin{:});

  ## Total integral over all 3 regions and verify results
  q = q1 + q2 + q3;

  hmin = min ([hmin1, hmin2, hmin3]);

  if (nfun > 10_000)
    warning ("quadv: maximum iteration count reached -- possible singular integral");
  elseif (any (! isfinite (q(:))))
    warning ("quadv: infinite or NaN function evaluations were returned");
  elseif (hmin < (b - a) * eps)
    warning ("quadv: minimum step size reached -- possible singular integral");
  endif

endfunction

function [q, nfun, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0, tol,
                                       nfun, hmin, trace, varargin)

  if (nfun > 10_000)   # stop endless recursion
    q = q0;
    return;
  endif

  d = (a + c) / 2;
  e = (c + b) / 2;
  fd = feval (f, d, varargin{:});
  fe = feval (f, e, varargin{:});
  nfun += 2;
  q1 = (c - a) / 6 * (fa + 4*fd + fc);
  q2 = (b - c) / 6 * (fc + 4*fe + fb);
  q = q1 + q2;

  if (abs (a - c) < hmin)
    hmin = abs (a - c);
  endif

  delta = q - q0;   # error term between new estimate and old estimate

  if (trace)
    printf ("%5d   %#14.11g   %16.10e   %-16.11g\n",
            nfun,  a,         b-a,      q + delta/15);
  endif

  ## NOTE: Not vectorizing q-q0 in the norm provides a more rigid criterion
  ##       for matrix-valued functions.
  if (norm (delta, Inf) > 15*tol)
    ## FIXME: To keep sum of sub-interval integrands within overall tolerance
    ## each bisection interval should use tol/2.  However, Matlab does not
    ## do this, and it would also profoundly increase the number of function
    ## evaluations required.
    [q1, nfun, hmin] = simpsonstp (f, a, c, d, fa, fc, fd, q1, tol,
                                   nfun, hmin, trace, varargin{:});
    [q2, nfun, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, q2, tol,
                                   nfun, hmin, trace, varargin{:});
    q = q1 + q2;
  else
    q += delta / 15;   # NOTE: Richardson extrapolation correction
  endif

endfunction


%!assert (quadv (@sin, 0, 2*pi), 0, 1e-6)
%!assert (quadv (@sin, 0, pi), 2, 1e-6)

## Test weak singularities at the edge
%!assert (quadv (@(x) 1 ./ sqrt (x), 0, 1), 2, 15*1e-6)

## Test vector-valued functions
%!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-6)

## Test matrix-valued functions
%!assert (quadv (@(x) [ x,x,x; x,1./sqrt(x),x; x,x,x ], 0, 1),
%!        [0.5,0.5,0.5; 0.5,2,0.5; 0.5,0.5,0.5], 15*1e-6);

## Test periodic function
%!assert <*57603> (quadv (@(t) sin (t) .^ 2, 0, 8*pi), 4*pi, 1e-6)

## Test input validation
%!error <Invalid call> quadv ()
%!error <Invalid call> quadv (@sin)
%!error <Invalid call> quadv (@sin,1)
%!error <TOL must be a scalar> quadv (@sin,0,1, ones (2,2))
%!error <TOL must be .* .=0> quadv (@sin,0,1, -1)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{deg} =} rad2deg (@var{rad})
##
## Convert radians to degrees.
##
## The input @var{rad} must be a scalar, vector, or N-dimensional array of
## double or single floating point values.  @var{rad} may be complex in which
## case the real and imaginary components are converted separately.
##
## The output @var{deg} is the same size and shape as @var{rad} with radians
## converted to degrees using the conversion constant @code{180/pi}.
##
## Example:
##
## @example
## @group
## rad2deg ([0, pi/2, pi, 3/2*pi, 2*pi])
##   @result{}  0    90   180   270   360
## @end group
## @end example
## @seealso{deg2rad}
## @end deftypefn

function deg = rad2deg (rad)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isfloat (rad))
    error ("rad2deg: RAD must be a floating point class (double or single)");
  endif

  deg = rad * (180/pi);

endfunction


%!assert (rad2deg (0), 0)
%!assert (rad2deg (pi/2), 90)
%!assert (rad2deg (pi), 180)
%!assert (rad2deg (pi*[0, 1/2, 1, 3/2, 2]), [0, 90, 180, 270, 360])

## Test input validation
%!error <Invalid call> rad2deg ()
%!error <RAD must be a floating point class> rad2deg (uint8 (1))
%!error <RAD must be a floating point class> rad2deg ("A")
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} randi (@var{imax})
## @deftypefnx {} {} randi (@var{imax}, @var{n})
## @deftypefnx {} {} randi (@var{imax}, @var{m}, @var{n}, @dots{})
## @deftypefnx {} {} randi ([@var{imin} @var{imax}], @dots{})
## @deftypefnx {} {} randi (@dots{}, "@var{class}")
## Return random integers in the range 1:@var{imax}.
##
## Additional arguments determine the shape of the return matrix.  When no
## arguments are specified a single random integer is returned.  If one
## argument @var{n} is specified then a square matrix @w{(@var{n} x @var{n})}
## is returned.  Two or more arguments will return a multi-dimensional matrix
## @w{(@var{m} x @var{n} x @dots{})}.
##
## The integer range may optionally be described by a two element matrix with a
## lower and upper bound in which case the returned integers will be on the
## interval @w{[@var{imin}, @var{imax}]}.
##
## The optional argument @var{class} will return a matrix of the requested
## type.  The default is @qcode{"double"}.
##
## The following example returns 150 integers in the range 1--10.
##
## @example
## ri = randi (10, 150, 1)
## @end example
##
## Implementation Note: @code{randi} relies internally on @code{rand} which
## uses class @qcode{"double"} to represent numbers.  This limits the maximum
## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
## returned by the @code{flintmax} function.  For IEEE floating point numbers
## this value is @w{@math{2^{53} - 1}}.
##
## @seealso{rand}
## @end deftypefn

function ri = randi (bounds, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (bounds) && all (bounds == fix (bounds))))
    error ("randi: IMIN and IMAX must be integer bounds");
  endif

  bounds = real (double (bounds));
  if (isscalar (bounds))
    imin = 1;
    imax = bounds;
    if (imax < 1)
      error ("randi: require IMAX >= 1");
    endif
  else
    imin = bounds(1);
    imax = bounds(2);
    if (imax < imin)
      error ("randi: require IMIN <= IMAX");
    endif
  endif

  ## Limit set by use of class double in rand(): Any consecutive integer in the
  ## range [-flintmax(), flintmax()] can be represented by a double.
  if ((abs (imax) >= flintmax ()) || (abs (imin) >= flintmax ()))
    error ("randi: IMIN and IMAX must be smaller than flintmax()");
  endif
  if ((imax - imin) >= (flintmax () - 1))
    error ("randi: integer range must be smaller than flintmax()-1");
  endif

  if (nargin > 1 && ischar (varargin{end}))
    rclass = varargin{end};
    varargin(end) = [];
    nargin = nargin - 1;
  else
    rclass = "double";
  endif

  ## Expand dimension argument to at least 2-D for reshape
  if (nargin == 1)
    varargin = {1, 1};
  elseif (nargin == 2 && isscalar (varargin{1}))
    varargin(2) = varargin(1);
  endif

  ## Rejection Algorithm to guarantee unbiased results.  See bug #54619.
  rng = (imax - imin) + 1;              # requested range
  N = prod ([varargin{:}]);             # number of requested elements
  K = floor ((flintmax () + 1) / rng);  # number of primary integers ...
                                        # mapped to single output
  p = (K*rng) / (flintmax () + 1);      # expected proportion of used primaries

  do
    M = ceil (N/p + 10*sqrt (N/p - N)); # number of requested primary integers
    r_prim = floor (rand (M,1) * (flintmax () + 1));
    r_prim = r_prim(r_prim < K*rng);
  until (numel (r_prim) >= N)           # should practically always be true

  ri = imin + floor (reshape (r_prim(1:N), varargin{:}) / K);

  if (! strcmp (rclass, "double"))
    if (strfind (rclass, "int"))
      maxval = double (intmax (rclass));
      minval = double (intmin (rclass));
    elseif (strcmp (rclass, "single"))
      maxval = double (flintmax (rclass));
      minval = -maxval;
    else
      error ("randi: unknown requested output CLASS '%s'", rclass);
    endif
    if (imax > maxval)
      warning (["randi: integer IMAX exceeds requested type.  ", ...
                "Values might be truncated to requested type."]);
    elseif (imin < minval)
      warning (["randi: integer IMIN exceeds requested type.  ", ...
                " Values might be truncated to requested type."]);
    endif

    ri = cast (ri, rclass);
  endif

endfunction


%!test
%! ri = randi (10, 1000, 1);
%! assert (ri, fix (ri));
%! assert (min (ri), 1);
%! assert (max (ri), 10);
%! assert (rows (ri), 1000);
%! assert (columns (ri), 1);
%! assert (class (ri), "double");
## FIXME: Does Octave guarantee support for int64 even when underlying hardware
##        is 32-bit?
%!test
%! ri = randi (int64 (100), 1, 1000);
%! assert (ri, fix (ri));
%! assert (min (ri), 1);
%! assert (max (ri), 100);
%! assert (rows (ri), 1);
%! assert (columns (ri), 1000);
%! assert (class (ri), "double");
%!test
%! ri = randi ([-5, 10], 1000, 1, "int8");
%! assert (ri, fix (ri));
%! assert (min (ri), int8 (-5));
%! assert (max (ri), int8 (10));
%! assert (class (ri), "int8");
%!test
%! ri = randi ([-5; 10], 1000, 1, "single");
%! assert (ri, fix (ri));
%! assert (min (ri), single (-5));
%! assert (max (ri), single (10));
%! assert (class (ri), "single");

%!assert (size (randi (10, 3, 1, 2)), [3, 1, 2])

%!shared max_int8, min_int8, max_uint8, min_uint8, max_single
%! max_int8 = double (intmax ("int8"));
%! min_int8 = double (intmin ("int8"));
%! max_uint8 = double (intmax ("uint8"));
%! min_uint8 = double (intmin ("uint8"));
%! max_single = double (flintmax ("single"));

## Test that no warning thrown if IMAX is exactly on the limits of the range
%!function test_no_warning (func, varargin)
%!  lastwarn ("");
%!  func (varargin{:});
%!  assert (lastwarn (), "");
%!endfunction
%!test test_no_warning (@randi, max_int8, "int8");
%!test test_no_warning (@randi, max_uint8, "uint8");
%!test test_no_warning (@randi, max_single, "single");
%!test test_no_warning (@randi, [min_int8, max_int8], "int8");
%!test test_no_warning (@randi, [min_uint8, max_uint8], "uint8");
%!test test_no_warning (@randi, [-max_single, max_single], "single");

## Test exceeding range
%!warning <exceeds requested type>
%! randi ([min_int8-1, max_int8], "int8");
%!warning <exceeds requested type>
%! randi ([min_uint8-1, max_uint8], "uint8");
%!warning <exceeds requested type>
%! randi ([min_int8, max_int8 + 1], "int8");
%!warning <exceeds requested type>
%! randi ([min_uint8, max_uint8 + 1], "uint8");
%!warning <exceeds requested type>
%! randi ([0, max_single + 1], "single");
%!warning <exceeds requested type>
%! ri = randi ([-5, 10], 1000, 1, "uint8");
%! assert (ri, fix (ri));
%! assert (min (ri), uint8 (-5));
%! assert (max (ri), uint8 (10));
%! assert (class (ri), "uint8");


## Test input validation
%!error <Invalid call> randi ()
%!error <must be integer bounds> randi ("test")
%!error <must be integer bounds> randi (struct ("a", 1))
%!error <must be integer bounds> randi (1.5)
%!error <must be integer bounds> randi ([1.5, 2.5])
%!error <must be integer bounds> randi ([1, 2.5])
%!error <must be integer bounds> randi ([1.5, 2])
%!error <require IMAX .= 1> randi (0)
%!error <require IMIN <= IMAX> randi ([10, 1])
%!error <IMIN and IMAX must be smaller than flintmax\(\)> randi (flintmax ())
%!error <range must be smaller than flintmax\(\)-1> randi ([-1, flintmax() - 1])
%!error <unknown requested output CLASS 'foo'> randi (10, "foo")
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{s} =} rat (@var{x})
## @deftypefnx {} {@var{s} =} rat (@var{x}, @var{tol})
## @deftypefnx {} {[@var{n}, @var{d}] =} rat (@dots{})
##
## Find a rational approximation of @var{x} to within the tolerance defined by
## @var{tol}.
##
## If unspecified, the default tolerance is @code{1e-6 * norm (@var{x}(:), 1)}.
##
## When called with one output argument, return a string containing a
## continued fraction expansion (multiple terms).
##
## When called with two output arguments, return numeric matrices for the
## numerator and denominator of a fractional representation of @var{x} such
## that @code{@var{x} = @var{n} ./ @var{d}}.
##
## For example:
##
## @example
## @group
## s = rat (pi)
## @result{} s = 3 + 1/(7 + 1/16)
##
## [n, d] = rat (pi)
## @result{} n =  355
## @result{} d =  113
##
## n / d - pi
## @result{} 0.00000026676
## @end group
## @end example
##
## Programming Note: With one output @code{rat} produces a string which is a
## continued fraction expansion.  To produce a string which is a simple
## fraction (one numerator, one denominator) use @code{rats}.
##
## @seealso{rats, format}
## @end deftypefn

function [n, d] = rat (x, tol)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isfloat (x))
    error ("rat: X must be a single or double array");
  endif

  ## FIXME: This test should be removed when complex support is added.
  ##        See bug #55198.
  if (iscomplex (x))
    error ("rat: X must be a real, not complex, array");
  endif

  y = x(:);

  ## Replace Inf with 0 while calculating ratios.
  inf_idx = isinf (x);
  y(inf_idx(:)) = 0;

  if (nargin == 1)
    ## default norm
    tol = 1e-6 * norm (y, 1);
  else
    if (! (isscalar (tol) && isnumeric (tol) && tol > 0))
      error ("rat: TOL must be a numeric scalar > 0");
    endif
  endif

  ## First step in the approximation is the integer portion

  ## First element in the continued fraction.
  n = round (y);
  d = ones (size (y));
  frac = y - n;
  lastn = ones (size (y));
  lastd = zeros (size (y));

  nsz = numel (y);
  steps = zeros ([nsz, 0]);

  ## Grab new factors until all continued fractions converge.
  while (1)
    ## Determine which fractions have not yet converged.
    idx = find (y != 0 & abs (y - n./d) >= tol);
    if (isempty (idx))
      if (isempty (steps))
        steps = NaN (nsz, 1);
      endif
      break;
    endif

    ## Grab the next step in the continued fraction.
    flip = 1 ./ frac(idx);
    ## Next element in the continued fraction.
    step = round (flip);

    if (nargout < 2)
      tsteps = NaN (nsz, 1);
      tsteps(idx) = step;
      steps = [steps, tsteps];
    endif

    frac(idx) = flip - step;

    ## Update the numerator/denominator.
    savedn = n;
    savedd = d;
    n(idx) = n(idx).*step + lastn(idx);
    d(idx) = d(idx).*step + lastd(idx);
    lastn = savedn;
    lastd = savedd;
  endwhile

  if (nargout <= 1)
    ## string output
    n = "";
    nsteps = columns (steps);
    ## Loop over all values in array
    for i = 1:nsz

      if (inf_idx(i))
        s = ifelse (x(i) > 0, "Inf", "-Inf");
      elseif (y(i) == 0)
        s = "0";
      else
        ## Create partial fraction expansion of one value
        s = [int2str(y(i)), " "];
        j = 1;

        while (true)
          step = steps(i, j++);
          if (isnan (step))
            break;
          endif
          if (j > nsteps || isnan (steps(i, j)))
            if (step < 0)
              s = [s(1:end-1), " + 1/(", int2str(step), ")"];
            else
              s = [s(1:end-1), " + 1/", int2str(step)];
            endif
            break;
          else
            s = [s(1:end-1), " + 1/(", int2str(step), ")"];
          endif
        endwhile
        s = [s, repmat(")", 1, j-2)];
      endif

      ## Append result to output
      n_nc = columns (n);
      s_nc = columns (s);
      if (n_nc > s_nc)
        s(:, s_nc+1:n_nc) = " ";
      elseif (s_nc > n_nc && n_nc != 0)
        n(:, n_nc+1:s_nc) = " ";
      endif
      n = cat (1, n, s);
    endfor
  else
    ## numerator, denominator output

    ## Move the minus sign to the numerator.
    n .*= sign (d);
    d = abs (d);

    ## Return the same shape as the input.
    n = reshape (n, size (x));
    d = reshape (d, size (x));

    ## Use 1/0 for Inf.
    n(inf_idx) = sign (x(inf_idx));
    d(inf_idx) = 0;
  endif

endfunction


%!assert (rat (pi), "3 + 1/(7 + 1/16)")
%!assert (rat (pi, 1e-2), "3 + 1/7")
## Test exceptional values
%!assert (rat (0), "0")
%!assert (rat (Inf), "Inf")
%!assert (rat (-Inf), "-Inf")

%!test
%! [n, d] = rat ([0.5, 0.3, 1/3]);
%! assert (n, [1, 3, 1]);
%! assert (d, [2, 10, 3]);
## Test exceptional values
%!test
%! [n, d] = rat ([Inf, 0, -Inf]);
%! assert (n, [1, 0, -1]);
%! assert (d, [0, 1, 0]);

%!assert <*43374> (eval (rat (0.75)), [0.75])

## Test input validation
%!error <Invalid call> rat ()
%!error <X must be a single or double array> rat (int8 (3))
%!error <X must be a real, not complex, array> rat (1+1i)
%!error <TOL must be a numeric scalar> rat (1, "a")
%!error <TOL must be a numeric scalar> rat (1, [1 2])
%!error <TOL must be a numeric scalar . 0> rat (1, -1)
########################################################################
##
## Copyright (C) 2015-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{xxx} =} repelem (@var{x}, @var{R})
## @deftypefnx {} {@var{xxx} =} repelem (@var{x}, @var{R_1}, @dots{}, @var{R_n})
## Construct an array of repeated elements from @var{x} and repeat
## instructions @var{R_1}, @dots{}.
##
## @var{x} must be a scalar, vector, or N-dimensional array.
##
## A repeat instruction @var{R_j} must either be a scalar or a vector.  If the
## instruction is a scalar then each component of @var{x} in dimension @var{j}
## is repeated @var{R_j} times.  If the instruction is a vector then it must
## have the same number of elements as the corresponding dimension @var{j} of
## @var{x}.  In this case, the @var{k}th component of dimension @var{j} is
## repeated @code{@var{R_j}(@var{k})} times.
##
## If @var{x} is a scalar or vector then @code{repelem} may be called with just
## a single repeat instruction @var{R} and @code{repelem} will return a vector
## with the same orientation as the input.
##
## If @var{x} is a matrix then at least two @var{R_j}s must be specified.
##
## Note: Using @code{repelem} with a vector @var{x} and a vector for @var{R_j}
## is equivalent to Run Length Decoding.
##
## Examples:
##
## @example
## @group
## A = [1 2 3 4 5];
## B = [2 1 0 1 2];
## repelem (A, B)
##   @result{}   1   1   2   4   5   5
## @end group
## @end example
##
## @example
## @group
## A = magic (3)
##   @result{} A =
##        8   1   6
##        3   5   7
##        4   9   2
## B1 = [1 2 3];
## B2 = 2;
## repelem (A, B1, B2)
##   @result{}     8   8   1   1   6   6
##          3   3   5   5   7   7
##          3   3   5   5   7   7
##          4   4   9   9   2   2
##          4   4   9   9   2   2
##          4   4   9   9   2   2
## @end group
## @end example
##
## More @var{R_j} may be specified than the number of dimensions of @var{x}.
## Any excess @var{R_j} must be scalars (because @var{x}'s size in those
## dimensions is only 1), and @var{x} will be replicated in those dimensions
## accordingly.
##
## @example
## @group
## A = [1 2 3 4 5];
## B1 = 2;
## B2 = [2 1 3 0 2];
## B3 = 3;
## repelem (A, B1, B2, B3)
##   @result{}    ans(:,:,1) =
##            1   1   2   3   3   3   5   5
##            1   1   2   3   3   3   5   5
##
##         ans(:,:,2) =
##
##            1   1   2   3   3   3   5   5
##            1   1   2   3   3   3   5   5
##
##         ans(:,:,3) =
##            1   1   2   3   3   3   5   5
##            1   1   2   3   3   3   5   5
## @end group
## @end example
##
## @var{R_j} must be specified in order.  A placeholder of 1 may be used for
## dimensions which do not need replication.
##
## @example
## @group
## repelem ([-1, 0; 0, 1], 1, 2, 1, 2)
##   @result{}  ans(:,:,1,1) =
##         -1  -1   0   0
##          0   0   1   1
##
##       ans(:,:,1,2) =
##         -1  -1   0   0
##          0   0   1   1
## @end group
## @end example
##
## If fewer @var{R_j} are given than the number of dimensions in @var{x},
## @code{repelem} will assume @var{R_j} is 1 for those dimensions.
##
## @example
## A = cat (3, [-1 0; 0 1], [-1 0; 0 1])
##   @result{}  ans(:,:,1) =
##         -1   0
##          0   1
##
##       ans(:,:,2) =
##         -1   0
##          0   1
##
## repelem (A,2,3)
##   @result{}  ans(:,:,1) =
##         -1  -1  -1   0   0   0
##         -1  -1  -1   0   0   0
##          0   0   0   1   1   1
##          0   0   0   1   1   1
##
##       ans(:,:,2) =
##         -1  -1  -1   0   0   0
##         -1  -1  -1   0   0   0
##          0   0   0   1   1   1
##          0   0   0   1   1   1
## @end example
##
## @code{repelem} preserves the class of @var{x}, and works with strings,
## cell arrays, NA, and NAN inputs.  If any @var{R_j} is 0 the output will
## be an empty array.
##
## @example
## @group
## repelem ("Octave", 2, 3)
##   @result{}    OOOccctttaaavvveee
##         OOOccctttaaavvveee
##
## repelem ([1 2 3; 1 2 3], 2, 0)
##   @result{}    [](4x0)
## @end group
## @end example
##
## @seealso{cat, kron, repmat}
## @end deftypefn

## Author: Markus Bergholz <markuman@gmail.com>
## Author: Nicholas R. Jankowski <jankowskin@asme.org>

## As a U.S. government employee, Nicholas R. Jankowski makes no claim
## of copyright.

## The prepareIdx routine is Copyright (C) 2015 Peter John Acklam
## <pjacklam@gmail.com>, used with permission.

function retval = repelem (x, varargin)

  if (nargin < 2)
    print_usage ();

  elseif (nargin == 2)

    R = varargin{1};

    if (isscalar (R))

      if (! isvector (x))
        error (["repelem: %dD Array requires %d or more input " ...
                "arguments, but only %d given"], ...
               ndims (x), ndims (x) + 1, nargin);
      endif

      if (isrow (x))
        ## element values repeated R times in a scalar or row vector
        retval = x(ones (R, 1), :)(:).';
      else
        ## element values repeated R times in a col vector
        retval = x.'(ones (R, 1), :)(:);
      endif

    elseif (isvector (x) && isvector (R))

      ## vector x with vector repeat.
      if (numel (R) != numel (x))
        error (["repelem: R1 must either be scalar or have the same " ...
                "number of elements as the vector to be replicated"]);
      endif

      ## Basic run-length decoding in function prepareIdx returns
      ## idx2 as a row vector of element indices in the right positions.
      idx2 = prepareIdx (R);
      ## Fill with element values, direction matches element.
      retval = x(idx2);

    else # catch any arrays passed to x or varargin with nargin==2
      error (["repelem: when called with only two inputs they must be " ...
              "either scalars or vectors, not %s and %s."],
             typeinfo (x), typeinfo (R));
    endif

  elseif (nargin == 3)  # special optimized case for 2-D (matrices)

    ## Input Validation
    xsz = size (x);
    vector_r = ! (cellfun (@numel, varargin) == 1);

    ## 1. Check that all varargin are either scalars or vectors, not arrays.
    ##    isvector returns true for scalars so one test captures both inputs.
    if (! (isvector (varargin{1}) && (isvector (varargin{2}))))
      error ("repelem: R1 and R2 must be scalars or vectors");

    ## 2. check that any repeat vectors have the right length.
    elseif (any (cellfun (@numel, varargin(vector_r)) != xsz(vector_r)))
      error (["repelem: R_j vectors must have the same number of elements " ...
              "as the size of dimension j of X"]);
    endif

    ## Create index arrays to pass to element.
    ## (It is no slower to call prepareIdx than to check and do scalars
    ## directly.)
    idx1 = prepareIdx (varargin{1}, xsz(1));
    idx2 = prepareIdx (varargin{2}, xsz(2));

    if (issparse (x))
      retval = x(idx1, idx2);
    else
      ## The ":" at the end takes care of any x dimensions > 2.
      retval = x(idx1, idx2, :);
    endif

  else  # (nargin > 3)

    ## Input Validation
    xsz = size (x);
    n_xdims = numel (xsz);
    vector_r = ! (cellfun (@numel, varargin) == 1);

    ## 1. Check that all repeats are scalars or vectors
    ##    (isvector gives true for scalars);
    if (! all (cellfun (@isvector, varargin(vector_r))))
      error ("repelem: R_j must all be scalars or vectors");

    ## 2. Catch any vectors thrown at trailing singletons,
    ##    which should only have scalars;
    elseif (find (vector_r, 1, "last") > n_xdims)
      error ("repelem: R_j for trailing singleton dimensions must be scalar");

    ## 3. Check that the ones that are vectors have the right length.
    elseif (any (cellfun (@numel, varargin(vector_r)) != xsz(vector_r)))
      error (["repelem: R_j vectors must have the same number of elements " ...
              "as the size of dimension j of X"]);

    endif

    n_rpts = nargin - 1;
    dims_with_vectors_and_scalars = min (n_xdims, n_rpts);

    ## Preallocate idx which will contain index array to be put into element.
    idx = cell (1, n_rpts);

    ## Use prepareIdx() to fill indices for dimensions that could be
    ## a scalar or a vector.
    for i = 1 : dims_with_vectors_and_scalars
      idx(i) = prepareIdx (varargin{i}, xsz(i));
    endfor

    ## If there are more varargin inputs than x dimensions, then input tests
    ## have verified that they are just scalars, so add [1 1 1 1 1 ... 1] to
    ## those dims to perform concatenation along those dims.
    if (n_rpts > n_xdims)
      for i = n_xdims + (1 : (n_rpts - n_xdims))
        idx(i) = ones (1, varargin{i});
      endfor
    endif

    ## Use completed idx to specify repetition of x values in all dimensions.
    ## The trailing ":" will take care of cases where n_xdims > n_rpts.
    retval = x(idx{:}, :);

  endif

endfunction

## Return a row vector of indices prepared for replicating.
function idx = prepareIdx (v, n)

  if (isscalar (v))
    ## will always return row vector
    idx = [1:n](ones (v, 1), :)(:).';

  else
    ## This works for a row or column vector.

    ## Get ending position for each element item.
    idx_temp = cumsum (v);

    ## Set starting position of each element to 1.
    idx(idx_temp + 1) = 1;

    ## Set starting position of each element to 1.
    idx(1) = 1;

    ## Row vector with proper length for output
    idx = idx(1:idx_temp(end));

    ## with prepared index
    idx = (find (v != 0))(cumsum (idx));

  endif

endfunction


## tests for help examples
%!assert (repelem ([1 2 3 4 5], [2 1 0 1 2]), [1 1 2 4 5 5])
%!assert (repelem (magic(3), [1 2 3],2), ...
%!  [8 8 1 1 6 6;3 3 5 5 7 7;3 3 5 5 7 7;4 4 9 9 2 2;4 4 9 9 2 2;4 4 9 9 2 2])
%!assert (repelem ([1 2 3 4 5],2,[2 1 3 0 2],3),repmat([1 1 2 3 3 3 5 5],2,1,3))
%!assert (repelem ([-1 0;0 1],1,2,1,2), repmat([-1 -1 0 0; 0 0 1 1],1,1,1,2))
%!assert (repelem (cat(3,[-1 0 ; 0 1],[-1 0 ; 0 1]),2,3), ...
%!  repmat([-1 -1 -1 0 0 0;-1 -1 -1 0 0 0;0 0 0 1 1 1;0 0 0 1 1 1],1,1,2))
%!assert (repelem ("Octave", 2,3), ["OOOccctttaaavvveee";"OOOccctttaaavvveee"])

## test complex vectors are not Hermitian conjugated
%!assert (repelem ([i, -i], 2), [i, i, -i, -i])
%!assert (repelem ([i; -i], 2), [i; i; -i; -i])

## nargin == 2 tests
%!assert (repelem (2, 6), [2 2 2 2 2 2])
%!assert (repelem ([-1 0 1], 2), [-1 -1 0 0 1 1])
%!assert (repelem ([-1 0 1]', 2), [-1; -1; 0; 0; 1; 1])
%!assert (repelem ([-1 0 1], [1 2 1]), [-1 0 0 1])
%!assert (repelem ([-1 0 1]', [1 2 1]), [-1; 0; 0; 1])
%!assert (repelem ([1 2 3 4 5]', [2 1 0 1 2]), [1 1 2 4 5 5]')

## nargin == 3 tests
%!assert (repelem ([1 0;0 -1], 2, 3),
%!       [1 1 1 0 0 0;1 1 1 0 0 0;0 0 0 -1 -1 -1;0 0 0 -1 -1 -1])
%!assert (repelem ([1 0; 0 -1], 1,[3 2]), [1 1 1 0 0;0 0 0 -1 -1])
%!assert (repelem ([1 0; 0 -1], 2,[3 2]),
%!        [1 1 1 0 0;1 1 1 0 0;0 0 0 -1 -1;0 0 0 -1 -1])
%!assert (repelem (cat(3,[1 0; 0 -1],[1 0;0 -1]), 1,[3 2]),
%!        repmat([1 1 1 0 0 ; 0 0 0 -1 -1],1,1,2))
%!assert (repelem ([1 0; 0 -1], [3 2], 1), [1 0;1 0;1 0;0 -1;0 -1])
%!assert (repelem ([1 0; 0 -1], [3 2], 2),
%!        [1 1 0 0;1 1 0 0;1 1 0 0;0 0 -1 -1;0 0 -1 -1])
%!assert (repelem ([1 0; 0 -1], [2 3] ,[3 2]),
%!        [1 1 1 0 0;1 1 1 0 0;0 0 0 -1 -1;0 0 0 -1 -1;0 0 0 -1 -1])
%!assert (repelem (cat(3,[1 1 1 0;0 1 0 0],[1 1 1 1;0 0 0 1],[1 0 0 1;1 1 0 1]),
%!                2, 3),
%!        cat (3,[1 1 1 1 1 1 1 1 1 0 0 0
%!                1 1 1 1 1 1 1 1 1 0 0 0
%!                0 0 0 1 1 1 0 0 0 0 0 0
%!                0 0 0 1 1 1 0 0 0 0 0 0],
%!               [1 1 1 1 1 1 1 1 1 1 1 1
%!                1 1 1 1 1 1 1 1 1 1 1 1
%!                0 0 0 0 0 0 0 0 0 1 1 1
%!                0 0 0 0 0 0 0 0 0 1 1 1],
%!               [1 1 1 0 0 0 0 0 0 1 1 1
%!                1 1 1 0 0 0 0 0 0 1 1 1
%!                1 1 1 1 1 1 0 0 0 1 1 1
%!                1 1 1 1 1 1 0 0 0 1 1 1]))
%!assert (repelem (cat(3,[1 1 1 0;0 1 0 0],[1 1 1 1;0 0 0 1],[1 0 0 1;1 1 0 1]),
%!                2, [3 3 3 3]), ...
%!        cat (3,[1 1 1 1 1 1 1 1 1 0 0 0
%!                1 1 1 1 1 1 1 1 1 0 0 0
%!                0 0 0 1 1 1 0 0 0 0 0 0
%!                0 0 0 1 1 1 0 0 0 0 0 0], ...
%!               [1 1 1 1 1 1 1 1 1 1 1 1
%!                1 1 1 1 1 1 1 1 1 1 1 1
%!                0 0 0 0 0 0 0 0 0 1 1 1
%!                0 0 0 0 0 0 0 0 0 1 1 1], ...
%!               [1 1 1 0 0 0 0 0 0 1 1 1
%!                1 1 1 0 0 0 0 0 0 1 1 1
%!                1 1 1 1 1 1 0 0 0 1 1 1
%!                1 1 1 1 1 1 0 0 0 1 1 1]));
%!assert (repelem ([1 2 3 4 5], 2,[2 1 2 0 2]), [1 1 2 3 3 5 5;1 1 2 3 3 5 5])
%
## nargin > 3 tests
%!assert (repelem ([1 0;0 -1], 2, 3, 4), ...
%!        cat(3,[1 1 1 0 0 0;1 1 1 0 0 0;0 0 0 -1 -1 -1;0 0 0 -1 -1 -1], ...
%!              [1 1 1 0 0 0;1 1 1 0 0 0;0 0 0 -1 -1 -1;0 0 0 -1 -1 -1], ...
%!              [1 1 1 0 0 0;1 1 1 0 0 0;0 0 0 -1 -1 -1;0 0 0 -1 -1 -1], ...
%!              [1 1 1 0 0 0;1 1 1 0 0 0;0 0 0 -1 -1 -1;0 0 0 -1 -1 -1]))
%!assert (repelem (repmat([-1 0;0 1],1,1,2,3),2,2,2), ...
%!        repmat([-1 -1 0 0;-1 -1 0 0;0 0 1 1; 0 0 1 1],1,1,4,3))
%!assert (repelem (repmat([-1 0;0 1],1,1,2,3),[2 2],[2 2],2), ...
%!        repmat([-1 -1 0 0;-1 -1 0 0;0 0 1 1; 0 0 1 1],1,1,4,3))
%!assert (repelem (repmat([-1 0;0 1],1,1,2,3),2,2,2,2,2), ...
%!        repmat([-1 -1 0 0;-1 -1 0 0;0 0 1 1; 0 0 1 1],1,1,4,6,2))
%!assert (repelem ([1,0,-1;-1,0,1],[2 3],[2 3 4],2), ...
%!        cat (3,[ 1  1 0 0 0 -1 -1 -1 -1
%!                 1  1 0 0 0 -1 -1 -1 -1
%!                -1 -1 0 0 0  1  1  1  1
%!                -1 -1 0 0 0  1  1  1  1
%!                -1 -1 0 0 0  1  1  1  1], ...
%!               [ 1  1 0 0 0 -1 -1 -1 -1
%!                 1  1 0 0 0 -1 -1 -1 -1
%!                -1 -1 0 0 0  1  1  1  1
%!                -1 -1 0 0 0  1  1  1  1
%!                -1 -1 0 0 0  1  1  1  1]));
%!assert (repelem ([1 2 3;4 5 6],[0 2],2,2), repmat([4 4 5 5 6 6],2,1,2))

## test with structures
%!test
%! a(2).x = 1;
%! a(2).y = 2;
%! a(1).x = 3;
%! a(1).y = 4;
%! b = repelem (a, 2, [1 3]);
%! assert (size (b) == [2, 4]);
%! assert ([b.y], [4 4 2 2 2 2 2 2]);

## test with cell arrays
%!test
%! assert (repelem ({-1 0 1},  2), {-1 -1 0 0 1 1});
%! assert (repelem ({-1 0 1}', 2), {-1; -1; 0; 0; 1; 1;});
%! assert (repelem ({1 0;0 -1}, 2, 3),
%!         {1 1 1 0 0 0;1 1 1 0 0 0;0 0 0 -1 -1 -1;0 0 0 -1 -1 -1});

%!test <*54275>
%! assert (repelem (11:13, [1 3 0]), [11 12 12 12]);

%!test <*59705>
%! xs = sparse (magic (3));
%! assert (repelem (xs, 1, 2), ...
%!         sparse ([8,8,1,1,6,6; 3,3,5,5,7,7; 4,4,9,9,2,2]));

## nargin <= 1 error tests
%!error <Invalid call> repelem ()
%!error <Invalid call> repelem (1)
%!error repelem (5,[])
%!error repelem ([1 2 3 3 2 1])
%!error repelem ([1 2 3; 3 2 1])

## nargin == 2 error tests
%!error repelem ([1 2 3; 3 2 1],[])
%!error repelem ([1 2 3; 3 2 1],2)
%!error repelem ([1 2 3; 3 2 1],2)
%!error repelem ([1 2 3; 3 2 1],[1 2 3])
%!error repelem ([1 2 3; 3 2 1],[1 2 3]')
%!error repelem ([1 2 3; 3 2 1],[1 2 2 1])
%!error repelem ([1 2 3; 3 2 1],[1 2 3;4 5 6])
%!error repelem ([1 2 3 4 5],[1 2 3 4 5;1 2 3 4 5])

## nargin == 3 error tests
%!error repelem ([1 2 3; 3 2 1], 1, [1 2;1 2])
%!error repelem ([1 2 3; 3 2 1], 1, [1 2])
%!error repelem ([1 2 3; 3 2 1], 2, [])
%!error repelem ([1 2 3; 3 2 1], [1 2 3], [1 2 3])
%!error repelem ([1 2 3; 3 2 1], [1 2 3], [1 2 3 4])
%!error repelem ([1 2 3; 3 2 1], [1 2], [1 2 3 4])

## nargin > 3 error tests
%!error repelem ([1 2 3; 3 2 1], 1, [1 2;1 2],1,2,3)
%!error repelem ([1 2 3; 3 2 1], [],1,2,3)
%!error repelem ([1 2 3; 3 2 1], [1 2], [1 2 3],1,2,[1 2;1 2])
%!error repelem ([1 2 3; 3 2 1], [1 2 3], [1 2 3],1,2)
%!error repelem ([1 2 3; 3 2 1], [1 2], [1 2 3 4],1,2)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} repmat (@var{A}, @var{m})
## @deftypefnx {} {} repmat (@var{A}, @var{m}, @var{n})
## @deftypefnx {} {} repmat (@var{A}, @var{m}, @var{n}, @var{p} @dots{})
## @deftypefnx {} {} repmat (@var{A}, [@var{m} @var{n}])
## @deftypefnx {} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
## Repeat matrix or N-D array.
##
## Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
## @var{A} as each element.
##
## If @var{n} is not specified, form an @var{m} by @var{m} block matrix.  For
## copying along more than two dimensions, specify the number of times to copy
## across each dimension @var{m}, @var{n}, @var{p}, @dots{}, in a vector in the
## second argument.
##
## @seealso{bsxfun, kron, repelems}
## @end deftypefn

function x = repmat (A, m, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  if (nargin == 3)
    n = varargin{1};
    if (! isempty (m) && isempty (n))
      m = m(:).';
      n = 1;
    elseif (isempty (m) && ! isempty (n))
      m = n(:).';
      n = 1;
    elseif (isempty (m) && isempty (n))
      m = n = 1;
    else
      if (all (size (m) > 1))
        m = m(:,1);
        if (numel (m) < 3)
          n = n(end);
        else
          n = [];
        endif
      endif
      if (all (size (n) > 1))
        n = n(:,1);
      endif
      m = m(:).';
      n = n(:).';
    endif
  else
    if (nargin > 3)
      ## input check for m and varargin
      if (isscalar (m) && all (cellfun ("numel", varargin) == 1))
        m = [m varargin{:}];
        n = [];
      else
        error ("repmat: all input arguments must be scalar");
      endif
    elseif (isempty (m))
      m = n = 1;
    elseif (isscalar (m))
      n = m;
    elseif (ndims (m) > 2)
      error ("repmat: M has more than 2 dimensions");
    elseif (all (size (m) > 1))
      m = m(:,1).';
      n = [];
    else
      m = m(:).';
      n = [];
    endif
  endif
  idx = [m, n];

  if (all (idx < 0))
    error ("repmat: invalid dimensions");
  else
    idx = max (idx, 0);
  endif

  if (numel (A) == 1)
    ## optimize the scalar fill case.
    if (any (idx == 0))
      x = resize (A, idx);
    else
      x(1:prod (idx)) = A;
      x = reshape (x, idx);
    endif
  elseif (ndims (A) == 2 && length (idx) < 3)
    if (issparse (A))
      x = kron (ones (idx), A);
    else
      ## indexing is now faster, so we use it rather than kron.
      m = rows (A); n = columns (A);
      p = idx(1); q = idx(2);
      x = reshape (A, m, 1, n, 1);
      x = x(:, ones (1, p), :, ones (1, q));
      x = reshape (x, m*p, n*q);
    endif
  else
    aidx = size (A);
    ## ensure matching size
    idx(end+1:length (aidx)) = 1;
    aidx(end+1:length (idx)) = 1;
    ## create subscript array
    cidx = cell (2, length (aidx));
    for i = 1:length (aidx)
      cidx{1,i} = ':';
      cidx{2,i} = ones (1, idx (i));
    endfor
    aaidx = aidx;
    ## add singleton dims
    aaidx(2,:) = 1;
    A = reshape (A, aaidx(:));
    x = reshape (A (cidx{:}), idx .* aidx);
  endif

endfunction


## Tests for ML compatibility
%!shared x
%! x = [1 2 3];
%!assert (repmat (x, [3, 1]), repmat (x, 3, []))
%!assert (repmat (x, [3, 1]), repmat (x, [], 3))
%!assert (repmat (x, [1, 3]), repmat (x, [], [1, 3]))
%!assert (repmat (x, [1, 3]), repmat (x, [1, 3], []))
%!assert (repmat (x, [1 3]), repmat (x, [1 3; 3 3]))
%!assert (repmat (x, [1 1 2]), repmat (x, [1 1; 1 3; 2 1]))
%!assert (repmat (x, [1 3; 1 3], [1; 3]), repmat (x, [1 1 3]))
%!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1; 4]))
%!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1 2; 3 4]))
%!assert (repmat (x, [1 1], 4), repmat (x, [1 1 4]))
%!assert (repmat (x, [1 1], 4), repmat (x, 1, [1 4]))

## Test various methods of providing size parameters
%!shared x
%! x = [1 2;3 4];
%!assert (repmat (x, [1 1]), repmat (x, 1))
%!assert (repmat (x, [3 3]), repmat (x, 3))
%!assert (repmat (x, [1 1]), repmat (x, 1, 1))
%!assert (repmat (x, [1 3]), repmat (x, 1, 3))
%!assert (repmat (x, [3 1]), repmat (x, 3, 1))
%!assert (repmat (x, [3 3]), repmat (x, 3, 3))
%!assert (repmat (pi, [1,2,3,4]), repmat (pi, 1,2,3,4))

## Tests for numel==1 case:
%!shared x, r
%! x = [ 65 ];
%! r = kron (ones (2,2), x);
%!assert (r, repmat (x, [2 2]))
%!assert (char (r), repmat (char (x), [2 2]))
%!assert (int8 (r), repmat (int8 (x), [2 2]))

## Tests for ndims==2 case:
%!shared x, r
%! x = [ 65 66 67 ];
%! r = kron (ones (2,2), x);
%!assert (r, repmat (x, [2 2]))
%!assert (char (r), repmat (char (x), [2 2]))
%!assert (int8 (r), repmat (int8 (x), [2 2]))

## Tests for dim>2 case:
%!shared x, r
%! x = [ 65 66 67 ];
%! r = kron (ones (2,2), x);
%! r(:,:,2) = r(:,:,1);
%!assert (r, repmat (x, [2 2 2]))
%!assert (char (r), repmat (char (x), [2 2 2]))
%!assert (int8 (r), repmat (int8 (x), [2 2 2]))

## Test that sparsity is kept
%!assert (sparse (4,4), repmat (sparse (2,2),[2 2]))

%!assert (size (repmat (".", -1, 1)), [0, 1])
%!assert (size (repmat (".", 1, -1)), [1, 0])

%!assert (size (repmat (1, [1, 0])), [1, 0])
%!assert (size (repmat (1, [5, 0])), [5, 0])
%!assert (size (repmat (1, [0, 1])), [0, 1])
%!assert (size (repmat (1, [0, 5])), [0, 5])

%!assert (size (repmat (ones (0, 3), [2 3])), [0 9])
%!assert (size (repmat (ones (0, 0, 3), [2 3])), [0 0 3])

%!shared x
%! x = struct ("a", [], "b", []);
%!assert (size (repmat (x, [1, 0])), [1, 0])
%!assert (size (repmat (x, [5, 0])), [5, 0])
%!assert (size (repmat (x, [0, 1])), [0, 1])
%!assert (size (repmat (x, [0, 5])), [0, 5])

%!assert (size (repmat ({1}, [1, 0])), [1, 0])
%!assert (size (repmat ({1}, [5, 0])), [5, 0])
%!assert (size (repmat ({1}, [0, 1])), [0, 1])
%!assert (size (repmat ({1}, [0, 5])), [0, 5])

%!error size (repmat (".", -1, -1))
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{B} =} rescale (@var{A})
## @deftypefnx {} {@var{B} =} rescale (@var{A}, @var{l}, @var{u})
## @deftypefnx {} {@var{B} =} rescale (@dots{}, "inputmin", @var{inmin})
## @deftypefnx {} {@var{B} =} rescale (@dots{}, "inputmax", @var{inmax})
## Scale matrix elements to a specified range of values.
##
## When called with a single matrix argument @var{A}, rescale elements to
## occupy the interval [0, 1].
##
## The optional inputs @code{[@var{l}, @var{u}]} will scale @var{A} to the
## interval with lower bound @var{l} and upper bound @var{u}.
##
## The optional input @qcode{"inputmin"} replaces all elements less than
## the specified value @var{inmin} with @var{inmin}.  Similarly, the optional
## input @qcode{"inputmax"} replaces all elements greater than the specified
## value @var{inmax} with @var{inmax}.  If unspecified the minimum and maximum
## are taken from the data itself (@w{@code{@var{inmin} = min (A(:))}} and
## @w{@code{@var{inmax} = max (A(:))}}).
##
## Programming Notes:
## The applied formula is
##
## @tex
## $$B = l + {A - inmin \over inmax - inmin} \cdot (u - l)$$
## @end tex
## @ifnottex
## @var{B} = @var{l} + ((@var{A} - @var{inmin}) ./ (@var{inmax} - @var{inmin}))
## .* (@var{u} - @var{l})
## @end ifnottex
##
## The class of the output matrix @var{B} is single if the input @var{A} is
## single, but otherwise is of class double for inputs which are of double,
## integer, or logical type.
##
## @seealso{bounds, min, max}
## @end deftypefn

function B = rescale (A, varargin)

  if (! any (nargin == [1,3,5,7]))
    print_usage ();
  endif

  ## Verify A input.
  if (! (isnumeric (A) || islogical (A)))
    error ("rescale: A must be a numeric or logical matrix");
  endif
  ## Use class double for integers and logical types
  if (! isa (A, "single"))
    A = double (A);
  endif

  l = 0;  u = 1;

  ## If 2nd and 3rd argument are numeric, set non-default interval [l, u].
  if (nargin > 1 && isnumeric (varargin{1}))
    if (! isnumeric (varargin{2}))
      error ("rescale: upper bound U must be numeric");
    endif
    l = varargin{1};  u = varargin{2};
    varargin(1:2) = [];
    if (any ((l > u)(:)))
      error ("rescale: lower bound L must be smaller than upper bound U");
    endif
    ## FIXME: Need input validation for cases where l or u is not a scalar
  endif

  truncate_range = false;

  ## Check for named argument "inputmin".
  inminidx = find (strcmpi (varargin, "inputmin"), 1, "last");
  if (! isempty (inminidx))
    if (! isnumeric (varargin{inminidx + 1}))
      error ("rescale: INMIN must be numeric");
    endif
    inmin = varargin{inminidx + 1};
    varargin(inminidx:inminidx + 1) = [];
    truncate_range = true;
  else
    inmin = min (A(:));
  endif

  ## Check for named argument "inputmax".
  inmaxidx = find (strcmpi (varargin, "inputmax"), 1, "last");
  if (! isempty (inmaxidx))
    if (! isnumeric (varargin{inmaxidx + 1}))
      error ("rescale: INMAX must be numeric");
    endif
    inmax = varargin{inmaxidx + 1};
    varargin(inmaxidx:inmaxidx + 1) = [];
    truncate_range = true;
  else
    inmax = max (A(:));
  endif

  ## Verify all options were processed
  if (! isempty (varargin))
    error ("rescale: invalid option(s)");
  endif

  ## Rescale A to interval [l,u] in range interval [inmin, inmax].
  range = inmax - inmin;
  range(range == 0) = 1;  # Avoid division by 0 resulting in NaN
  B = l + (A - inmin) ./ range .* (u - l);
  if (truncate_range)
    B(A < inmin) = l;
    B(A > inmax) = u;
  endif

endfunction


%!assert (rescale ([]), [])
%!assert (rescale ([0]), [0])
%!assert (rescale ([1]), [0])
%!assert (rescale (0:5), (0:5)/5)

## Test [l,u] input
%!assert (rescale (1:4, 3, 9), [3,5,7,9])
%!test
%! A = repmat ([1:3]', [1, 3]);
%! B = rescale (A, [1, 2, 3], 5);
%! assert (B, [1, 2, 3; 3, 3.5, 4; 5, 5, 5]);
%!test
%! A = repmat ([1:3]', [1, 3]);
%! B = rescale (A, [1; 2; 3], 5);
%! assert (B, [1, 1, 1; 3.5, 3.5, 3.5; 5, 5, 5]);

## Test property/value options
%!assert (rescale (0:6, "inputmin", 1, "inputmax", 5), [0,0,0.25,0.5,0.75,1,1])

## Test class of returned output
%!assert (class (rescale (single ([0, 5]))), "single")
%!assert (class (rescale (double ([0, 5]))), "double")
%!assert (class (rescale (int8 ([0, 5]))), "double")
%!assert (class (rescale (logical ([0, 1]))), "double")

## Test input validation
%!error <Invalid call> rescale ()
%!error <Invalid call> rescale (1, 2)
%!error <Invalid call> rescale (1, 2, 3, 4)
%!error <Invalid call> rescale (1, 2, 3, 4, 5, 6)
%!error <Invalid call> rescale (1, 2, 3, 4, 5, 6, 7, 8)
%!error <A must be a numeric or logical matrix> rescale ("abc")
%!error <A must be a numeric or logical matrix> rescale ({ [1] })
%!error <U must be numeric> rescale (1, 0, "A")
%!error <L must be smaller than .* U> rescale (1, 2, 0)
## FIXME: Need BIST tests here when input validation has been added for
##        l and u not being scalar.
%!error <INMIN must be numeric> rescale (1, "inputmin", "abc")
%!error <INMAX must be numeric> rescale (1, "inputmax", "abc")
%!error <invalid option> rescale (1, "foobar", 1)
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} rng (@var{seed})
## @deftypefnx {} {} rng (@var{seed}, "@var{generator}")
## @deftypefnx {} {} rng ("shuffle")
## @deftypefnx {} {} rng ("shuffle", "@var{generator}")
## @deftypefnx {} {} rng ("default")
## @deftypefnx {} {@var{s} =} rng ()
## @deftypefnx {} {} rng (@var{s})
## @deftypefnx {} {@var{s} =} rng (@dots{})
## Set or query the seed of the random number generator used by @code{rand} and
## @code{randn}.
##
## The input @var{seed} is a scalar numeric value used to initialize the state
## vector of the random number generator.
##
## The optional string @var{generator} specifies the type of random number
## generator to be used.  Its value can be @qcode{"twister"},
## @qcode{"v5uniform"}, or @qcode{"v5normal"}.  The @qcode{"twister"} keyword
## is described below.  @qcode{"v5uniform"} and @qcode{"v5normal"} refer to
## older versions of Octave that used to use a different random number
## generator.
##
## The state or seed of the random number generator can be reset to a new
## random value using the @qcode{"shuffle"} keyword.
##
## The random number generator can be reset to default values using the
## @qcode{"default"} keyword.  The default values are to use the Mersenne
## Twister generator with a seed of 0.
##
## The optional return value @var{s} contains the state of the random number
## generator at the time the function is called (i.e., before it might be
## modified according to the input arguments).  It is encoded as a structure
## variable with three fields: @qcode{"Type"}, @qcode{"Seed"}, and
## @qcode{"State"}.  The random number generator can be restored to the state
## @var{s} using @code{rng (@var{s})}.  This is useful when the identical
## sequence of pseudo-random numbers is required for an algorithm.
##
## By default, and with the @qcode{"twister"} option, pseudo-random sequences
## are computed using the Mersenne Twister with a period of @math{2^{19937}-1}
## (See @nospell{M. Matsumoto and T. Nishimura},
## @cite{Mersenne Twister: A 623-dimensionally equidistributed uniform
## pseudorandom number generator},
## @nospell{ACM} Trans.@: on Modeling and Computer Simulation Vol.@: 8, No.@: 1,
## pp.@: 3--30, January 1998,
## @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).
## Do @strong{not} use for cryptography without securely hashing several
## returned values together, otherwise the generator state can be learned after
## reading 624 consecutive values.
##
## @seealso{rand, randn}
## @end deftypefn

function retval = rng (varargin)

  if (nargin > 2)
    print_usage ();
  endif

  ## Store current settings of random number generator
  ## FIXME: there doesn't seem to be a way to query the type of generator
  ##        currently used in Octave - assume "twister".
  ## FIXME: there doesn't seem to be a way to query the seed initialization
  ##        value - use "Not applicable".
  ## FIXME: rand and randn use different generators - storing both states.
  ## For older Matlab generators (v4, v5), the settings are stored like this:
  ##   struct ("Type","Legacy", "Seed", "Not applicable", "State",{[],[],...})

  ## Type is the generator name.
  ## Seed is the initial seed value.
  ## State is a structure describing internal state of the generator.
  s = struct ("Type", "twister",
              "Seed", "Not applicable",
              "State", {{rand("state"), randn("state")}});

  if (nargin == 0)
    retval = s;
    return;
  endif

  arg1 = varargin{1};
  if (isscalar (arg1) && isnumeric (arg1) && isreal (arg1) && arg1 >= 0)
    s_rand = s_randn = arg1;
    generator = check_generator (varargin(2:end));

  elseif (ischar (arg1) && strcmpi (arg1, "shuffle"))
    ## Seed the random number generator based on the current time
    s_rand = s_randn = "reset";  # or sum (1000*clock)
    generator = check_generator (varargin(2:end));

  elseif (ischar (arg1) && strcmpi (arg1, "default") && nargin == 1)
    generator = "twister";
    s_rand = s_randn = 0;  # FIXME: In Matlab, seed 0 corresponds to 5489

  elseif (isstruct (arg1) && isscalar (arg1) && nargin == 1)
    if (numfields (arg1) != 3
        || ! all (isfield (arg1, {"Type", "Seed", "State"})))
      error ('rng: input structure requires "Type", "Seed", "State" fields"');
    endif
    ## Only the internal state "State" and generator type "Type" are needed
    generator = arg1.Type;
    if (iscell (arg1.State))
      [s_rand, s_randn] = deal (arg1.State{:});
    else
      s_rand = s_randn = arg1.State;
    endif

  else
    print_usage ();
  endif

  ## Set the type of random number generator and seed it
  if (isempty (generator))
    generator = s.Type;
  endif
  switch (generator)
    case "twister"
      rand ("state", s_rand);
      randn ("state", s_randn);

    case "legacy"
      rand ("seed", s_rand);
      randn ("seed", s_randn);

    case "v5uniform"
      rand ("seed", s_rand);

    case "v5normal"
      randn ("seed", s_randn);

    otherwise
      error ('rng: invalid GENERATOR: "%s"', generator);

  endswitch

  if (nargout > 0)
    retval = s;
  endif

endfunction


function gen = check_generator (val)

  if (isempty (val))
    gen = "";
    return;
  elseif (! iscellstr (val))
    error ("rng: GENERATOR must be a string");
  endif

  gen = tolower (char (val));
  if (any (strcmp (gen, {"simdtwister", "combrecursive", "philox", "threefry", "multfibonacci", "v4"})))
    error ('rng: random number generator "%s" is not available in Octave', gen);
  elseif (! any (strcmp (gen, {"twister", "v5uniform", "v5normal"})))
    error ('rng: unknown random number generator "%s"', gen);
  endif

endfunction


%!test
%! state = rng ();
%! unwind_protect
%!   rng (42);
%!   ru1 = rand ();
%!   rn1 = randn ();
%!   rng (42);
%!   ru2 = rand ();
%!   rn2 = randn ();
%!   assert (ru2, ru1);
%!   assert (rn2, rn1);
%!   s1 = rng ();
%!   s2 = rng (42);
%!   assert (isequal (s1, s2));
%!   ru1 = rand ();
%!   rn1 = randn ();
%!   s3 = rng (42);
%!   ru2 = rand ();
%!   rn2 = randn ();
%!   assert (ru2, ru1);
%!   assert (rn2, rn1);
%! unwind_protect_cleanup
%!   rng (state);
%! end_unwind_protect

%!test
%! state = rng ();
%! unwind_protect
%!   rng (42, "twister");
%!   ru1 = rand ();
%!   rn1 = randn ();
%!   rng (42, "twister");
%!   ru2 = rand ();
%!   rn2 = randn ();
%!   assert (ru2, ru1);
%!   assert (rn2, rn1);
%!   s1 = rng ();
%!   s2 = rng (42, "twister");
%!   assert (isequal (s1, s2));
%!   ru1 = rand ();
%!   rn1 = randn ();
%!   s3 = rng (42, "twister");
%!   ru2 = rand ();
%!   rn2 = randn ();
%!   assert (ru2, ru1);
%!   assert (rn2, rn1);
%! unwind_protect_cleanup
%!   rng (state);
%! end_unwind_protect

%!test
%! state = rng ();
%! unwind_protect
%!   rng ("shuffle");
%!   rng ("shuffle", "twister");
%!   s = rng ("shuffle");
%!   assert (! isequal (s, rng ("shuffle")));
%!   s = rng ("shuffle", "twister");
%!   assert (! isequal (s, rng ("shuffle", "twister")));
%! unwind_protect_cleanup
%!   rng (state);
%! end_unwind_protect

%!test
%! state = rng ();
%! unwind_protect
%!   rng ("default");
%!   ru1 = rand ();
%!   rn1 = randn ();
%!   rng (0, "twister");
%!   ru2 = rand ();
%!   rn2 = randn ();
%!   assert (ru2, ru1);
%!   assert (rn2, rn1);
%!   rng (0, "twister");
%!   s = rng ("default");
%!   assert (isequal (s, rng ()));
%! unwind_protect_cleanup
%!   rng (state);
%! end_unwind_protect

%!test
%! state = rng ();
%! unwind_protect
%!   s = rng ();
%!   ru1 = rand ();
%!   rn1 = randn ();
%!   rng (s);
%!   ru2 = rand ();
%!   rn2 = randn ();
%!   assert (ru2, ru1);
%!   assert (rn2, rn1);
%!   rng (42);  rand (1,2);  x = rand (1,2);
%!   rng (42);  rand (1,2);  s = rng ();  y = rand (1,2);
%!   assert (x, y);
%!   rng (s);  z = rand (1,2);
%!   assert (x, z);
%!   s1 = rng ();
%!   s2 = rng (s1);
%!   assert (isequal (s1, s2));
%! unwind_protect_cleanup
%!   rng (state);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> rng (1, 2, 3)
%!error <Invalid call> rng (eye (2))
%!error <Invalid call> rng ({})
%!error <Invalid call> rng (2i)
%!error <Invalid call> rng (-2)
%!error <Invalid call> rng ("foobar")
%!error <Invalid call> rng ("default", "twister")
%!error <Invalid call> rng (struct ("Seed", {1, 2}))
%!error <Invalid call> rng (struct ("Type",[],"State",[],"Seed",[]), "twister")
%!error <input structure requires "Type"> rng (struct ())
%!error <input structure requires "Type">
%! rng (struct ("Type1",[],"State",[],"Seed",[]));
%!error <GENERATOR must be a string> rng (0, struct ())
%!error <"philox" is not available in Octave> rng (0, "philox")
%!error <GENERATOR must be a string> rng ("shuffle", struct ())
%!error <unknown random number generator "foobar"> rng ("shuffle", "foobar")
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} rot90 (@var{A})
## @deftypefnx {} {} rot90 (@var{A}, @var{k})
## Rotate array by 90 degree increments.
##
## Return a copy of @var{A} with the elements rotated counterclockwise in
## 90-degree increments.
##
## The second argument is optional, and specifies how many 90-degree rotations
## are to be applied (the default value is 1).  Negative values of @var{k}
## rotate the matrix in a clockwise direction.
## For example,
##
## @example
## @group
## rot90 ([1, 2; 3, 4], -1)
##     @result{}  3  1
##         4  2
## @end group
## @end example
##
## @noindent
## rotates the given matrix clockwise by 90 degrees.  The following are all
## equivalent statements:
##
## @example
## @group
## rot90 ([1, 2; 3, 4], -1)
## rot90 ([1, 2; 3, 4], 3)
## rot90 ([1, 2; 3, 4], 7)
## @end group
## @end example
##
## The rotation is always performed on the plane of the first two dimensions,
## i.e., rows and columns.  To perform a rotation on any other plane, use
## @code{rotdim}.
##
## @seealso{rotdim, fliplr, flipud, flip}
## @end deftypefn

function B = rot90 (A, k = 1)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isscalar (k) && isreal (k) && k == fix (k)))
    error ("rot90: K must be a single real integer");
  endif

  k = mod (k, 4);
  nd = ndims (A);

  if (k == 0)
    B = A;
  elseif (k == 1)
    B = flipud (permute (A, [2 1 3:1:nd]));
  elseif (k == 2)
    idx(1:nd) = {':'};
    idx{1} = rows (A):-1:1;
    idx{2} = columns (A):-1:1;
    B = A(idx{:});
  elseif (k == 3)
    B = permute (flipud (A), [2 1 3:1:nd]);
  else
    error ("rot90: internal error!");
  endif

endfunction


%!test
%! x1 = [1, 2; 3, 4];
%! x2 = [2, 4; 1, 3];
%! x3 = [4, 3; 2, 1];
%! x4 = [3, 1; 4, 2];
%!
%! assert (rot90 (x1), x2);
%! assert (rot90 (x1, 2), x3);
%! assert (rot90 (x1, 3), x4);
%! assert (rot90 (x1, 4), x1);
%! assert (rot90 (x1, 5), x2);
%! assert (rot90 (x1, -1), x4);

## Test NDArrays
%!test
%! a(1:2,1:2,1) = [1 2; 3 4];
%! a(1:2,1:2,2) = [5 6; 7 8];
%! b(1:2,1:2,1) = [2 4; 1 3];
%! b(1:2,1:2,2) = [6 8; 5 7];
%! assert (rot90 (a, 1), b);
%! assert (rot90 (a, 2), rot90 (b, 1));
%! assert (rot90 (a, 3), rot90 (b, 2));

%!test
%! a = b = zeros (2, 2, 1, 2);
%! a(1:2,1:2,:,1) = [1 2; 3 4];
%! a(1:2,1:2,:,2) = [5 6; 7 8];
%! b(1:2,1:2,:,1) = [2 4; 1 3];
%! b(1:2,1:2,:,2) = [6 8; 5 7];
%! assert (rot90 (a, 1), b);
%! assert (rot90 (a, 2), rot90 (b, 1));
%! assert (rot90 (a, 3), rot90 (b, 2));

## With non-square matrices
%!test
%! a = zeros (3, 2, 1, 2);
%! b = zeros (2, 3, 1, 2);
%! a(1:2,1:3,:,1) = [ 1  2  3;  4  5  6];
%! a(1:2,1:3,:,2) = [ 7  8  9; 10 11 12];
%! b(1:3,1:2,:,1) = [ 3  6;  2  5;  1  4];
%! b(1:3,1:2,:,2) = [ 9 12;  8 11;  7 10];
%! assert (rot90 (a, 1), b);
%! assert (rot90 (a, 2), rot90 (b, 1));
%! assert (rot90 (a, 3), rot90 (b, 2));

## Test input validation
%!error <Invalid call> rot90 ()
%!error rot90 (1, ones (2))
%!error rot90 (1, 1.5)
%!error rot90 (1, 1+i)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} rotdim (@var{x})
## @deftypefnx {} {} rotdim (@var{x}, @var{n})
## @deftypefnx {} {} rotdim (@var{x}, @var{n}, @var{plane})
## Return a copy of @var{x} with the elements rotated counterclockwise in
## 90-degree increments.
##
## The second argument @var{n} is optional, and specifies how many 90-degree
## rotations are to be applied (the default value is 1).  Negative values of
## @var{n} rotate the matrix in a clockwise direction.
##
## The third argument is also optional and defines the plane of the rotation.
## If present, @var{plane} is a two element vector containing two different
## valid dimensions of the matrix.  When @var{plane} is not given the first two
## non-singleton dimensions are used.
##
## For example,
##
## @example
## @group
## rotdim ([1, 2; 3, 4], -1, [1, 2])
##      @result{}  3  1
##          4  2
## @end group
## @end example
##
## @noindent
## rotates the given matrix clockwise by 90 degrees.  The following are all
## equivalent statements:
##
## @example
## @group
## rotdim ([1, 2; 3, 4], -1, [1, 2])
## rotdim ([1, 2; 3, 4], 3, [1, 2])
## rotdim ([1, 2; 3, 4], 7, [1, 2])
## @end group
## @end example
## @seealso{rot90, fliplr, flipud, flip}
## @end deftypefn

function y = rotdim (x, n, plane)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin > 1 && ! isempty (n))
    if (! isscalar (n) || ! isreal (n) || fix (n) != n)
      error ("rotdim: N must be a scalar integer");
    endif
  else
    n = 1;
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 3)
    if (nd > 2)
      ## Find the first two non-singleton dimension.
      plane = [];
      dim = 0;
      while (dim < nd)
        dim += 1;
        if (sz (dim) != 1)
          plane = [plane, dim];
          if (length (plane) == 2)
            break;
          endif
        endif
      endwhile
      if (length (plane) < 1)
        plane = [1, 2];
      elseif (length (plane) < 2)
        plane = [1, plane];
      endif
    else
      plane = [1, 2];
    endif
  else
    if (! (isvector (plane) && length (plane) == 2
           && all (plane == fix (plane)) && all (plane > 0)
           && all (plane < (nd + 1)) && plane(1) != plane(2)))
      error ("rotdim: PLANE must be a 2 element integer vector defining a valid PLANE");
    endif
  endif

  n = rem (n, 4);
  if (n < 0)
    n += 4;
  endif
  if (n == 0)
    y = x;
  elseif (n == 2)
    y = flip (flip (x, plane(1)), plane(2));
  elseif (n == 1 || n == 3)
    perm = 1:nd;
    perm(plane(1)) = plane(2);
    perm(plane(2)) = plane(1);
    y = permute (x, perm);
    if (n == 1)
      y = flip (y, min (plane));
    else
      y = flip (y, max (plane));
    endif
  else
    error ("rotdim: internal error!");
  endif

endfunction


%!shared r, rr
%! r = [1,2,3];  rr = [3,2,1];
%!assert (rotdim (r, 0), r)
%!assert (rotdim (r, 1), rr')
%!assert (rotdim (r, 2), rr)
%!assert (rotdim (r, 3), r')
%!assert (rotdim (r, 3), rotdim (r, -1))
%!assert (rotdim (r, 1), rotdim (r))

%!shared c, cr
%! c = [1;2;3];  cr = [3;2;1];
%!assert (rotdim (c, 0), c)
%!assert (rotdim (c, 1), c')
%!assert (rotdim (c, 2), cr)
%!assert (rotdim (c, 3), cr')
%!assert (rotdim (c, 3), rotdim (c, -1))
%!assert (rotdim (c, 1), rotdim (c))

%!shared m
%! m = [1,2;3,4];
%!assert (rotdim (m, 0), m)
%!assert (rotdim (m, 1), [2,4;1,3])
%!assert (rotdim (m, 2), [4,3;2,1])
%!assert (rotdim (m, 3), [3,1;4,2])
%!assert (rotdim (m, 3), rotdim (m, -1))
%!assert (rotdim (m, 1), rotdim (m))

## FIXME: We need tests for multidimensional arrays
##        and different values of PLANE.

%!error <Invalid call> rotdim ()
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} shift (@var{x}, @var{b})
## @deftypefnx {} {} shift (@var{x}, @var{b}, @var{dim})
## If @var{x} is a vector, perform a circular shift of length @var{b} of
## the elements of @var{x}.
##
## If @var{x} is a matrix, do the same for each column of @var{x}.
##
## If the optional @var{dim} argument is given, operate along this dimension.
## @end deftypefn

function y = shift (x, b, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (numel (x) < 1)
    error ("shift: X must not be empty");
  elseif (! (isscalar (b) && b == fix (b)))
    error ("shift: B must be an integer");
  endif

  nd = ndims (x);
  sz = size (x);

  if (nargin == 3)
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("shift: DIM must be an integer and a valid dimension");
    endif
  else
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  endif

  d = sz(dim);

  idx = repmat ({':'}, nd, 1);
  if (b > 0)
    b = rem (b, d);
    idx{dim} = [d-b+1:d, 1:d-b];
  elseif (b < 0)
    b = rem (abs (b), d);
    idx{dim} = [b+1:d, 1:b];
  endif

  y = x(idx{:});

endfunction


%!test
%! a = [1, 2, 3];
%! b = [4, 5, 6];
%! c = [7, 8, 9];
%!
%! r = [a, b, c];
%! m = [a; b; c];
%!
%! assert (shift (r, 0), r);
%! assert (shift (r, 3), [c, a, b]);
%! assert (shift (r, -6), [c, a, b]);
%! assert (shift (r, -3), [b, c, a]);
%! assert (shift (m, 1), [c; a; b]);
%! assert (shift (m, -2), [c; a; b]);

## Test input validation
%!error <Invalid call> shift ()
%!error <Invalid call> shift (1)
%!error <X must not be empty> shift ([], 1)
%!error <B must be an integer> shift (ones (2), ones (2))
%!error <B must be an integer> shift (ones (2), 1.5)
%!error <DIM must be an integer> shift (1, 1, 1.5)
%!error <DIM must be .* a valid dimension> shift (1, 1, 0)
%!error <DIM must be .* a valid dimension> shift (1, 1, 3)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} shiftdim (@var{x}, @var{n})
## @deftypefnx {} {[@var{y}, @var{ns}] =} shiftdim (@var{x})
## Shift the dimensions of @var{x} by @var{n}, where @var{n} must be
## an integer scalar.
##
## When @var{n} is positive, the dimensions of @var{x} are shifted to the left,
## with the leading dimensions circulated to the end.  If @var{n} is negative,
## then the dimensions of @var{x} are shifted to the right, with @var{n}
## leading singleton dimensions added.
##
## Called with a single argument, @code{shiftdim}, removes the leading
## singleton dimensions, returning the number of dimensions removed in the
## second output argument @var{ns}.
##
## For example:
##
## @example
## @group
## x = ones (1, 2, 3);
## size (shiftdim (x, -1))
##   @result{}   1   1   2   3
## size (shiftdim (x, 1))
##   @result{}   2   3
## [b, ns] = shiftdim (x)
##   @result{} b =
##         1   1   1
##         1   1   1
##   @result{} ns = 1
## @end group
## @end example
## @seealso{reshape, permute, ipermute, circshift, squeeze}
## @end deftypefn

function [y, ns]  = shiftdim (x, n)

  if (nargin < 1)
    print_usage ();
  endif

  nd = ndims (x);
  orig_dims = size (x);

  if (nargin == 1)
    ## Find the first non-singleton dimension.
    (n = find (orig_dims != 1, 1) - 1) || (n = nd);
  elseif (! (isscalar (n) && n == fix (n)))
    error ("shiftdim: N must be a scalar integer");
  endif

  if (n >= nd)
    n = rem (n, nd);
  endif

  if (n < 0)
    singleton_dims = ones (1, -n);
    y = reshape (x, [singleton_dims, orig_dims]);
  elseif (n > 0)
    ## We need permute here instead of reshape to shift values in a
    ## compatible way.
    y = permute (x, [n+1:nd 1:n]);
  else
    y = x;
  endif

  ns = n;

endfunction


%!test
%! x = rand (1, 1, 4, 2);
%! [y, ns] = shiftdim (x);
%! assert (size (y), [4 2]);
%! assert (ns, 2);
%! assert (shiftdim (y, -2), x);
%! assert (size (shiftdim (x, 2)), [4 2]);

%!assert (size (shiftdim (rand (0, 1, 2))), [0 1 2])

## Test input validation
%!error <Invalid call> shiftdim ()
%!error shiftdim (1, ones (2))
%!error shiftdim (1, 1.5)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{s}, @var{i}] =} sortrows (@var{A})
## @deftypefnx {} {[@var{s}, @var{i}] =} sortrows (@var{A}, @var{c})
## Sort the rows of the matrix @var{A} according to the order of the columns
## specified in @var{c}.
##
## By default (@var{c} omitted, or a particular column unspecified in @var{c})
## an ascending sort order is used.  However, if elements of @var{c} are
## negative then the corresponding column is sorted in descending order.  If
## the elements of @var{A} are strings then a lexicographical sort is used.
##
## Example: sort by column 2 in descending order, then 3 in ascending order
##
## @example
## @group
## x = [ 7, 1, 4;
##       8, 3, 5;
##       9, 3, 6 ];
## sortrows (x, [-2, 3])
##    @result{} 8  3  5
##       9  3  6
##       7  1  4
## @end group
## @end example
##
## @seealso{sort}
## @end deftypefn

function [s, i] = sortrows (A, c)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 2)
    if (! (isnumeric (c) && isvector (c)))
      error ("sortrows: C must be a numeric vector");
    elseif (any (c == 0) || any (abs (c) > columns (A)))
      error ("sortrows: all elements of C must be in the range [1, columns (A)]");
    endif
  endif

  default_mode = "ascend";
  reverse_mode = "descend";

  if (issparse (A) || iscell (A))
    ## FIXME: Eliminate this case once __sort_rows_idx__ is fixed to
    ##        handle sparse matrices.
    if (nargin == 1)
      i = sort_rows_idx_generic (default_mode, reverse_mode, A);
    else
      i = sort_rows_idx_generic (default_mode, reverse_mode, A, c);
    endif
  elseif (nargin == 1)
    i = __sort_rows_idx__ (A, default_mode);
  elseif (all (c > 0))
    i = __sort_rows_idx__ (A(:,c), default_mode);
  elseif (all (c < 0))
    i = __sort_rows_idx__ (A(:,-c), reverse_mode);
  else
    ## Otherwise, fall back to the old algorithm.
    i = sort_rows_idx_generic (default_mode, reverse_mode, A, c);
  endif

  ## Only bother to compute s if needed.
  if (isargout (1))
    s = A(i,:);
  endif

endfunction

function i = sort_rows_idx_generic (default_mode, reverse_mode, m, c)

  if (nargin == 3)
    indices = [1:columns(m)]';
    mode(1:columns(m)) = {default_mode};
  else
    for j = 1:length (c)
      if (c(j) < 0)
        mode{j} = reverse_mode;
      else
        mode{j} = default_mode;
      endif
    endfor
    indices = abs (c(:));
  endif

  ## Since sort is 'stable' the order of identical elements will be
  ## preserved, so by traversing the sort indices in reverse order we
  ## will make sure that identical elements in index i are subsorted by
  ## index j.
  indices = flipud (indices);
  mode = flipud (mode');
  i = [1:rows(m)]';
  for j = 1:length (indices)
    M = m(i, indices(j));
    if (iscell (M) && ! iscellstr (M))
      M = cell2mat (M);
    endif
    [~, idx] = sort (M, mode{j});
    i = i(idx);
  endfor

endfunction


%!test
%! m = [1, 1; 1, 2; 3, 6; 2, 7];
%! c = [1, -2];
%! [x, idx] = sortrows (m, c);
%! [sx, sidx] = sortrows (sparse (m), c);
%! assert (x, [1, 2; 1, 1; 2, 7; 3, 6]);
%! assert (idx, [2; 1; 4; 3]);
%! assert (issparse (sx));
%! assert (x, full (sx));
%! assert (idx, sidx);

%!test
%! m = [1, 0, 0, 4];
%! c = 1;
%! [x, idx] = sortrows (m, c);
%! [sx, sidx] = sortrows (sparse (m), c);
%! assert (x, m);
%! assert (idx, 1);
%! assert (issparse (sx));
%! assert (x, full (sx));
%! assert (idx, sidx);

%!test <*42523>
%! C = {1, 2, "filename1";
%!      3, 4, "filename2";
%!      5, 6, "filename3"};
%! C2 = sortrows (C, -1);
%! assert (C2, flipud (C));

## Test input validation
%!error <Invalid call> sortrows ()
%!error sortrows (1, "ascend")
%!error sortrows (1, ones (2,2))
%!error sortrows (1, 0)
%!error sortrows (1, 2)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{theta}, @var{phi}, @var{r})
## @deftypefnx {} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{S})
## Transform spherical coordinates to Cartesian coordinates.
##
## The inputs @var{theta}, @var{phi}, and @var{r} must be the same shape, or
## scalar.  If called with a single matrix argument then each row of @var{S}
## must represent a spherical coordinate triplet (@var{theta}, @var{phi},
## @var{r}).
##
## The outputs @var{x}, @var{y}, @var{z} match the shape of the inputs.  For a
## matrix input @var{S} the outputs are column vectors with rows corresponding
## to the rows of the input matrix.
##
## @var{theta} describes the azimuth angle relative to the positive x-axis
## measured in the xy-plane.
##
## @var{phi} is the elevation angle measured relative to the xy-plane.
##
## @var{r} is the distance to the origin @w{(0, 0, 0)}.
##
## The coordinate transformation is computed using:
##
## @tex
## $$ x = r \cos \phi  \cos \theta $$
## $$ y = r \cos \phi  \sin \theta $$
## $$ z = r \sin \phi $$
## @end tex
## @ifnottex
##
## @example
## @group
## @var{x} = r * cos (@var{phi}) * cos (@var{theta})
## @var{y} = r * cos (@var{phi}) * sin (@var{theta})
## @var{z} = r * sin (@var{phi})
## @end group
## @end example
##
## @end ifnottex
## @c FIXME: Remove this note in Octave 9.1 (two releases after 7.1).
## Note: For @sc{matlab} compatibility, this function no longer returns a full
## coordinate matrix when called with a single return argument.
## @seealso{cart2sph, pol2cart, cart2pol}
## @end deftypefn

function [x, y, z] = sph2cart (theta, phi, r)

  if (nargin != 1 && nargin != 3)
    print_usage ();
  endif

  if (nargin == 1)
    if (! (isnumeric (theta) && ismatrix (theta)))
      error ("sph2cart: matrix input must be a 2-D numeric array");
    endif
    if (columns (theta) != 3 && numel (theta) != 3)
      error ("sph2cart: matrix input must be a 3-element vector or 3-column array");
    endif

    if (numel (theta) == 3)
      r = theta(3);
      phi = theta(2);
      theta = theta(1);
    else
      r = theta(:,3);
      phi = theta(:,2);
      theta = theta(:,1);
    endif

  else
    if (! (isnumeric (theta) && isnumeric (phi) && isnumeric (r)))
      error ("sph2cart: THETA, PHI, R must be numeric arrays or scalars");
    endif
    [err, theta, phi, r] = common_size (theta, phi, r);
    if (err)
      error ("sph2cart: THETA, PHI, R must be the same size or scalars");
    endif
  endif

  x = r .* cos (phi) .* cos (theta);
  y = r .* cos (phi) .* sin (theta);
  z = r .* sin (phi);

endfunction


%!test
%! t = [0, 0, 0];
%! p = [0, 0, 0];
%! r = [0, 1, 2];
%! [x, y, z] = sph2cart (t, p, r);
%! assert (x, r);
%! assert (y, [0, 0, 0]);
%! assert (z, [0, 0, 0]);

%!test
%! t = [0; 0; 0];
%! p = [0; 0; 0];
%! r = [0; 1; 2];
%! [x, y, z] = sph2cart (t, p, r);
%! assert (x, [0; 1; 2]);
%! assert (y, [0; 0; 0]);
%! assert (z, [0; 0; 0]);

%!test
%! t = 0;
%! p = [0, 0, 0];
%! r = [0, 1, 2];
%! [x, y, z] = sph2cart (t, p, r);
%! assert (x, [0, 1, 2]);
%! assert (y, [0, 0, 0]);
%! assert (z, [0, 0, 0]);

%!test
%! t = [0, 0, 0];
%! p = 0;
%! r = [0, 1, 2];
%! [x, y, z] = sph2cart (t, p, r);
%! assert (x, r);
%! assert (y, [0, 0, 0]);
%! assert (z, [0, 0, 0]);

%!test
%! t = [0, 0.5, 1]*pi;
%! p = [0, 0, 0];
%! r = 1;
%! [x, y, z] = sph2cart (t, p, r);
%! assert (x, [1, 0, -1], eps);
%! assert (y, [0, 1, 0], eps);
%! assert (z, [0, 0, 0], eps);

%!test
%! [x, y, z] = sph2cart ([0 0 0], 0, 1);
%! assert (x, [1, 1, 1], eps);
%! assert (y, [0, 0, 0], eps);
%! assert (z, [0, 0, 0], eps);

%!test
%! S = [ 0, 0, 1; 0.5*pi, 0, 1; pi, 0, 1];
%! [x, y, z] = sph2cart (S);
%! assert (x, [1; 0; -1], eps);
%! assert (y, [0; 1; 0], eps);
%! assert (z, [0; 0; 0], eps);

%!test
%! S = [ 0, 0, 1; 0.5*pi, 0, 1; pi, 0, 1; pi, pi, 1];
%! [x, y, z] = sph2cart (S);
%! assert (x, [1; 0; -1; 1], eps);
%! assert (y, [0; 1; 0; 0], eps);
%! assert (z, [0; 0; 0; 0], eps);


%!test
%! [t, p, r] = meshgrid ([0, pi/2], [0, pi/2], [0, 1]);
%! [x, y, z] = sph2cart (t, p, r);
%! X = zeros (2, 2, 2);
%! X(1, 1, 2) = 1;
%! Y = zeros (2, 2, 2);
%! Y(1, 2, 2) = 1;
%! Z = zeros (2, 2, 2);
%! Z(2, :, 2) = [1 1];
%! assert (x, X, eps);
%! assert (y, Y, eps);
%! assert (z, Z);

## Test input validation
%!error <Invalid call> sph2cart ()
%!error <Invalid call> sph2cart (1,2)
%!error <matrix input must be a 2-D numeric array> sph2cart ({1,2,3})
%!error <matrix input must be a 2-D numeric array> sph2cart (ones (3,3,2))
%!error <matrix input must be a 3-element> sph2cart ([1,2,3,4])
%!error <matrix input must be a 3-element> sph2cart ([1,2,3,4; 1,2,3,4; 1,2,3,4])
%!error <must be numeric arrays or scalars> sph2cart ({1,2,3}, [1,2,3], [1,2,3])
%!error <must be numeric arrays or scalars> sph2cart ([1,2,3], {1,2,3}, [1,2,3])
%!error <must be numeric arrays or scalars> sph2cart ([1,2,3], [1,2,3], {1,2,3})
%!error <must be the same size or scalars> sph2cart ([1,2,3], [1,2,3], [1,2,3]')
%!error <must be the same size or scalars> sph2cart (ones (3,3,3), 1, ones (3,2,3))
%!error <must be the same size or scalars> sph2cart (ones (3,3,3), ones (3,2,3), 1)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} structfun (@var{func}, @var{S})
## @deftypefnx {} {[@var{A}, @dots{}] =} structfun (@dots{})
## @deftypefnx {} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
## @deftypefnx {} {} structfun (@dots{}, "UniformOutput", @var{val})
##
## Evaluate the function named @var{name} on the fields of the structure
## @var{S}.  The fields of @var{S} are passed to the function @var{func}
## individually.
##
## @code{structfun} accepts an arbitrary function @var{func} in the form of an
## inline function, function handle, or the name of a function (in a character
## string).  In the case of a character string argument, the function must
## accept a single argument named @var{x}, and it must return a string value.
## If the function returns more than one argument, they are returned as
## separate output variables.
##
## If the parameter @qcode{"UniformOutput"} is set to true (the default), then
## the function must return a single element which will be concatenated into
## the return value.  If @qcode{"UniformOutput"} is false, the outputs are
## placed into a structure with the same fieldnames as the input structure.
##
## @example
## @group
## s.name1 = "John Smith";
## s.name2 = "Jill Jones";
## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s,
##            "UniformOutput", false)
##   @result{} scalar structure containing the fields:
##        name1 = Smith
##        name2 = Jones
## @end group
## @end example
##
## Given the parameter @qcode{"ErrorHandler"}, @var{errfunc} defines a function
## to call in case @var{func} generates an error.  The form of the function is
##
## @example
## function [@dots{}] = errfunc (@var{se}, @dots{})
## @end example
##
## @noindent
## where there is an additional input argument to @var{errfunc} relative to
## @var{func}, given by @nospell{@var{se}}.  This is a structure with the
## elements @qcode{"identifier"}, @qcode{"message"} and @qcode{"index"},
## giving respectively the error identifier, the error message, and the index
## into the input arguments of the element that caused the error.  For an
## example on how to use an error handler, @pxref{XREFcellfun,,@code{cellfun}}.
##
## @seealso{cellfun, arrayfun, spfun}
## @end deftypefn

function varargout = structfun (func, S, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  nargs = length (varargin);

  recognized_opts = {"UniformOutput", "ErrorHandler"};
  uo_str = recognized_opts{1};

  uniform_output = true;

  while (nargs >= 2)
    opt_match = strcmpi (varargin{nargs-1}, recognized_opts);
    if (opt_match(1))
      uniform_output = varargin{nargs};
    endif
    if (any (opt_match))
      nargs -= 2;
    else
      break;
    endif
  endwhile

  if (nargs > 0)
    error ("structfun: invalid options");
  endif

  varargout = cell (max ([nargout, 1]), 1);
  [varargout{:}] = cellfun (func, struct2cell (S), varargin{:});

  if (! uniform_output)
    varargout = cellfun ("cell2struct", varargout, {fieldnames(S)}, {1}, ...
                         uo_str, false);
  endif

endfunction


%!test
%! s.name1 = "John Smith";
%! s.name2 = "Jill Jones";
%! l.name1 = "Smith";
%! l.name2 = "Jones";
%! o = structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s,
%!                "UniformOutput", false);
%! assert (o, l);

%!function [a, b] = __twoouts (x)
%!  a = x + x;
%!  b = x * x;
%!endfunction

%!test
%! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
%! c(1:2, 1, 1) = [2; 8];
%! c(1:2, 1, 2) = [4; 10];
%! c(1:2, 1, 3) = [6; 12];
%! d(1:2, 1, 1) = [1; 16];
%! d(1:2, 1, 2) = [4; 25];
%! d(1:2, 1, 3) = [9; 36];
%! [aa, bb] = structfun (@__twoouts, s);
%! assert (aa, c);
%! assert (bb, d);

%!test
%! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
%! c = struct ("a", {2, 4, 6}, "b", {8, 10, 12});
%! d = struct ("a", {1, 4, 9}, "b", {16, 25, 36});
%! [aa, bb] = structfun (@__twoouts, s, "UniformOutput", false);
%! assert (aa, c);
%! assert (bb, d);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{idx} =} subsindex (@var{obj})
## Convert an object to an index vector.
##
## When @var{obj} is a class object defined with a class constructor, then
## @code{subsindex} is the overloading method that allows the conversion of
## this class object to a valid indexing vector.  It is important to note that
## @code{subsindex} must return a zero-based real integer vector of the class
## @qcode{"double"}.  For example, if the class constructor were
##
## @example
## @group
## function obj = myclass (a)
##   obj = class (struct ("a", a), "myclass");
## endfunction
## @end group
## @end example
##
## @noindent
## then the @code{subsindex} function
##
## @example
## @group
## function idx = subsindex (obj)
##   idx = double (obj.a) - 1.0;
## endfunction
## @end group
## @end example
##
## @noindent
## could be used as follows
##
## @example
## @group
## a = myclass (1:4);
## b = 1:10;
## b(a)
## @result{} 1  2  3  4
## @end group
## @end example
##
## @seealso{class, subsref, subsasgn}
## @end deftypefn

function idx = subsindex (obj)

  if (nargin < 1)
    print_usage ();
  endif

  ## Only way to get here is if subsindex has not been overloaded by a class.
  error ('subsindex: not defined for class "%s"', class (obj));

endfunction


%!error <not defined for class "double"> subsindex (1)

## Test input validation
%!error <Invalid call> subsindex ()
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} trapz (@var{y})
## @deftypefnx {} {@var{q} =} trapz (@var{x}, @var{y})
## @deftypefnx {} {@var{q} =} trapz (@dots{}, @var{dim})
##
## Numerically evaluate the integral of points @var{y} using the trapezoidal
## method.
##
## @w{@code{trapz (@var{y})}} computes the integral of @var{y} along the first
## non-singleton dimension.  When the argument @var{x} is omitted an equally
## spaced @var{x} vector with unit spacing (1) is assumed.
## @code{trapz (@var{x}, @var{y})} evaluates the integral with respect to the
## spacing in @var{x} and the values in @var{y}.  This is useful if the points
## in @var{y} have been sampled unevenly.
##
## If the optional @var{dim} argument is given, operate along this dimension.
##
## Application Note: If @var{x} is not specified then unit spacing will be
## used.  To scale the integral to the correct value you must multiply by the
## actual spacing value (deltaX).  As an example, the integral of @math{x^3}
## over the range [0, 1] is @math{x^4/4} or 0.25.  The following code uses
## @code{trapz} to calculate the integral in three different ways.
##
## @example
## @group
## x = 0:0.1:1;
## y = x.^3;
## ## No scaling
## q = trapz (y)
##   @result{} q = 2.5250
## ## Approximation to integral by scaling
## q * 0.1
##   @result{} 0.25250
## ## Same result by specifying @var{x}
## trapz (x, y)
##   @result{} 0.25250
## @end group
## @end example
##
## @seealso{cumtrapz}
## @end deftypefn

function z = trapz (x, y, dim)

  if (nargin < 1)
    print_usage ();
  endif

  have_xy = have_dim = false;

  if (nargin == 3)
    have_xy = true;
    have_dim = true;
  elseif (nargin == 2)
    if (isscalar (y) && ! isscalar (x))
      have_dim = true;
      dim = y;
    else
      have_xy = true;
    endif
  endif

  if (have_xy)
    nd = ndims (y);
    sz = size (y);
  else
    nd = ndims (x);
    sz = size (x);
  endif

  if (! have_dim)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("trapz: DIM must be an integer and a valid dimension");
    endif
  endif

  n = sz(dim);
  idx1 = idx2 = {':'}(ones (nd, 1));  # repmat ({':'}, [nd, 1]), but faster
  idx1{dim} = 2 : n;
  idx2{dim} = 1 : (n - 1);

  if (! have_xy)
    z = 0.5 * sum (x(idx1{:}) + x(idx2{:}), dim);
  elseif (isscalar (x))
    z = x * 0.5 * sum (y(idx1{:}) + y(idx2{:}), dim);
  elseif (isvector (x))
    if (length (x) != n)
      error ("trapz: length of X and length of Y along DIM must match");
    endif
    ## Reshape spacing vector x to point along dimension DIM
    shape = ones (nd, 1);
    shape(dim) = n;
    x = reshape (x, shape);
    z = 0.5 * sum (diff (x) .* (y(idx1{:}) + y(idx2{:})), dim);
  else
    if (! size_equal (x, y))
      error ("trapz: X and Y must have same shape");
    endif
    z = 0.5 * sum (diff (x, 1, dim) .* (y(idx1{:}) + y(idx2{:})), dim);
  endif

endfunction


%!assert (trapz (1:5), 12)
%!assert (trapz (1, 1:5), 12)
%!assert (trapz (0.5, 1:5), 6)
%!assert (trapz ([1:5], [1:5]), 12)
%!assert (trapz ([1:5], [1:5]'), 12)
%!assert (trapz ([1:5]', [1:5]'), 12)
%!assert (trapz ([1:5]', [1:5]), 12)
%!assert (trapz (0:0.5:2,1:5), 6)
%!assert (trapz ([1:5;1:5].', 1), [12, 12])
%!assert (trapz ([1:5;1:5], 2), [12; 12])
%!assert (trapz (repmat (reshape (1:5,1,1,5),2,2), 3), [12 12; 12 12])
%!assert (trapz ([0:0.5:2;1:5].', [1:5;1:5].', 1), [6, 12])
%!assert (trapz ([0:0.5:2;1:5], [1:5;1:5], 2), [6; 12])
%!assert (trapz (repmat (reshape ([0:0.5:2],1,1,5),2,2), ...
%!               repmat (reshape (1:5,1,1,5),2,2), 3), [6 6; 6 6])
%!assert (trapz (0:0.5:2, [(1:5)', (1:5)']), [6, 6])
%!assert (trapz (0:0.5:2, [(1:5); (1:5)], 2), [6; 6])
%!assert (trapz (0:0.5:2, repmat (reshape (1:5,1,1,5),2,2),3), [6 6; 6 6])
%!assert <*54277> (trapz (ones (1,3), 1), zeros (1,3))
%!assert <*54277> (trapz (ones (3,1), 2), zeros (3,1))

## Test input validation
%!error <Invalid call> trapz ()
%!error <DIM must be an integer> trapz (1, 2, [1 2])
%!error <DIM must be an integer> trapz (1, 2, 1.5)
%!error <DIM must be .* a valid dimension> trapz (1, 2, 0)
%!error <length of X and length of Y.*must match> trapz ([1 2], [1 2 3])
%!error <X and Y must have same shape> trapz (ones (2,3), ones (2,4))
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} triplequad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb})
## @deftypefnx {} {} triplequad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb}, @var{tol})
## @deftypefnx {} {} triplequad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb}, @var{tol}, @var{quadf})
## @deftypefnx {} {} triplequad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{za}, @var{zb}, @var{tol}, @var{quadf}, @dots{})
## Numerically evaluate the triple integral of @var{f}.
##
## @var{f} is a function handle, inline function, or string containing the name
## of the function to evaluate.  The function @var{f} must have the form
## @math{w = f(x,y,z)} where either @var{x} or @var{y} is a vector and the
## remaining inputs are scalars.  It should return a vector of the same length
## and orientation as @var{x} or @var{y}.
##
## @var{xa}, @var{ya}, @var{za} and @var{xb}, @var{yb}, @var{zb} are the lower
## and upper limits of integration for x, y, and z respectively.  The
## underlying integrator determines whether infinite bounds are accepted.
##
## The optional argument @var{tol} defines the absolute tolerance used to
## integrate each sub-integral.  The default value is 1e-6.
##
## The optional argument @var{quadf} specifies which underlying integrator
## function to use.  Any choice but @code{quad} is available and the default
## is @code{quadcc}.
##
## Additional arguments, are passed directly to @var{f}.  To use the default
## value for @var{tol} or @var{quadf} one may pass @qcode{':'} or an empty
## matrix ([]).
## @seealso{integral3, integral2, dblquad, quad, quadv, quadl, quadgk, quadcc,
##          trapz}
## @end deftypefn

function q = triplequad (f, xa, xb, ya, yb, za, zb, tol = 1e-6, quadf = @quadcc, varargin)

  if (nargin < 7)
    print_usage ();
  endif

  ## Allow use of empty matrix ([]) to indicate default
  if (isempty (tol))
    tol = 1e-6;
  endif
  if (isempty (quadf))
    quadf = @quadcc;
  endif

  inner = @__triplequad_inner__;
  if (ischar (f))
    f = @(x,y,z) feval (f, x, y, z, varargin{:});
    varargin = {};
  endif

  q = dblquad (@(y, z) inner (y, z, f, xa, xb, tol, quadf, varargin{:}), ...
               ya, yb, za, zb, tol);

endfunction

function q = __triplequad_inner__ (y, z, f, xa, xb, tol, quadf, varargin)
  q = zeros (size (y));
  for i = 1 : length (y)
    q(i) = feval (quadf, @(x) f (x, y(i), z, varargin{:}), xa, xb, tol);
  endfor
endfunction


%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadcc), pi^(3/2) * erf (1).^3, 1e-6)

## These tests are too expensive to run normally (~30 sec each).  Disable them
#%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadgk), pi^(3/2) * erf (1).^3, 1e-6)
#%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadl), pi^(3/2) * erf (1).^3, 1e-6)
#%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadv), pi^(3/2) * erf (1).^3, 1e-6)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{z} =} xor (@var{x}, @var{y})
## @deftypefnx {} {@var{z} =} xor (@var{x1}, @var{x2}, @dots{})
## Return the @dfn{exclusive or} of @var{x} and @var{y}.
##
## For boolean expressions @var{x} and @var{y},
## @code{xor (@var{x}, @var{y})} is true if and only if one of @var{x} or
## @var{y} is true.  Otherwise, if @var{x} and @var{y} are both true or both
## false, @code{xor} returns false.
##
## The truth table for the xor operation is
##
## @multitable @columnfractions 0.44 .03 .05 .03 0.44
## @item @tab @var{x} @tab @var{y} @tab @var{z} @tab
## @item @tab - @tab - @tab - @tab
## @item @tab 0 @tab 0 @tab 0 @tab
## @item @tab 1 @tab 0 @tab 1 @tab
## @item @tab 0 @tab 1 @tab 1 @tab
## @item @tab 1 @tab 1 @tab 0 @tab
## @end multitable
##
## If more than two arguments are given the xor operation is applied
## cumulatively from left to right:
##
## @example
## (@dots{}((x1 XOR x2) XOR x3) XOR @dots{})
## @end example
##
## @seealso{and, or, not}
## @end deftypefn

function z = xor (x, y, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  z = __xor__ (x, y);

  ## Slow expansion to multiple arguments.
  ## Probably okay number of elements will be small.
  if (! isempty (varargin))
    for i = 1:numel (varargin)
      z = __xor__ (z, varargin{i});
    endfor
  endif

endfunction

function z = __xor__ (x, y)

  if (isscalar (x) || isscalar (y) || size_equal (x, y))
    ## Typecast to logicals is necessary for other numeric types.
    z = logical (x) != logical (y);
  else
    try
      z = bsxfun (@xor, x, y);
    catch
      error ("xor: X and Y must be of compatible size or scalars");
    end_try_catch
  endif

endfunction


%!assert (xor ([1, 1, 0, 0], [0, 1, 0, 1]), logical ([1, 0, 0, 1]))
%!assert (xor ([i, i, 0, 0], [1, 0, 1, 0]), logical ([0, 1, 1, 0]))

%!assert (xor (eye (2), fliplr (eye (2))), logical (ones (2)))
%!assert (xor (speye (2), fliplr (speye (2))), sparse (logical (ones (2))))

## Test XOR reduction
%!assert (xor ([1 0], [1 1], [0 0]), logical ([0 1]))

## Test input validation
%!error <Invalid call> xor ()
%!error <Invalid call> xor (1)
%!error <X and Y must be of compatible size> xor (ones (3,2), ones (2,3))
encoding=utf-8
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} __gripe_missing_component__ (@var{caller}, @var{component})
## Undocumented internal function.
## @end deftypefn

function __gripe_missing_component__ (caller, component)

  if (nargin != 2)
    print_usage ();
  endif

  msg = "";
  fcn = missing_component_hook ();

  ftype = exist (fcn);
  if (ftype == 2 || ftype == 3 || ftype == 5 || ftype == 103)
    msg = feval (fcn, component);
  endif

  if (isempty (msg))
    switch (component)
      case "info-file"
        msg = "unable to find the Octave info manual, Octave installation is incomplete";
      case "mkoctfile"
        msg = "unable to find the mkoctfile command, Octave installation is incomplete";
      case "octave"
        msg = "unable to find the octave executable, Octave installation is incomplete";
      case "octave-config"
        msg = "unable to find the octave-config command, Octave installation is incomplete";
      otherwise
        msg = ['unable to find required Octave component "' component '"'];
    endswitch
  endif

  error ("%s: %s\n", caller, msg);

endfunction


## NOTE: Tests cannot rely on the exact error strings shown above because we
##       specifically allow these messages to be overridden by
##       missing_component_hook.  The prefix is all we can be sure of.
%!error <abc: .*> __gripe_missing_component__ ("abc", "info-file")
%!error <abc: .*> __gripe_missing_component__ ("abc", "octave")
%!error <abc: .*> __gripe_missing_component__ ("abc", "octave-config")
%!error <abc: .*> __gripe_missing_component__ ("abc", "xyz")

%!error <Invalid call> __gripe_missing_component__ ()
%!error <Invalid call> __gripe_missing_component__ ("fcn")
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{retval}, @var{status}] =} __makeinfo__ (@var{text}, @var{output_type})
## @deftypefnx {} {[@var{retval}, @var{status}] =} __makeinfo__ (@var{text}, @var{output_type}, @var{fsee_also})
## Undocumented internal function.
## @end deftypefn

## Run @code{makeinfo} on a given text.
##
## The string @var{text} is run through the @code{__makeinfo__} program
## to generate output in various formats.  This string must contain valid
## Texinfo formatted text.
##
## The @var{output_type} selects the format of the output.  This can be either
## @t{"html"}, @t{"texinfo"}, or @t{"plain text"}.  By default this is
## @t{"plain text"}.  If @var{output_type} is @t{"texinfo"}, the @t{@@seealso}
## macro is expanded, but otherwise the text is unaltered.
##
## If the optional argument @var{see_also} is present, it is used to expand the
## Octave specific @t{@@seealso} macro.  This argument must be a function
## handle, that accepts a cell array of strings as input argument (each
## elements of the array corresponds to the arguments to the @t{@@seealso}
## macro), and return the expanded string.  If this argument is not given, the
## @t{@@seealso} macro will be expanded to the text
##
## @example
## See also: arg1, arg2, ...
## @end example
##
## @noindent
## for @t{"plain text"} output, and
##
## @example
## See also: @@ref@{arg1@}, @@ref@{arg2@}, ...
## @end example
##
## @noindent
## otherwise.
##
## The optional output argument @var{status} contains the exit status of the
## @code{makeinfo} program as returned by @code{system}.

function [retval, status] = __makeinfo__ (text, output_type = "plain text", fsee_also)

  ## Check input
  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (text))
    error ("__makeinfo__: first input argument must be a string");
  endif

  if (! ischar (output_type))
    error ("__makeinfo__: second input argument must be a string");
  endif

  ## NOTE: The 3rd argument is used by Octave Forge function
  ##       generate_package_html, not by core Octave.  This functionality
  ##       can only be removed when that function has been updated.
  if (nargin < 3)
    if (strcmpi (output_type, "plain text"))
      fsee_also = @(T) ["\nSee also:", sprintf(" %s,", T{:})(1:end-1), "\n"];
    else
      fsee_also = @(T) ["\nSee also:", sprintf(" @ref{%s},", T{:})(1:end-1), "\n"];
    endif
  endif

  if (! is_function_handle (fsee_also))
    error ("__makeinfo__: third input argument must be a function handle");
  endif

  ## Formatting in m-files has an extra space at the beginning of every line.
  ## Remove these unwanted spaces if present.  First text char is "\n" delim.
  if (text(2) == " ")
    text = strrep (text, "\n ", "\n");
  endif
  ## Texinfo crashes if @end tex does not appear first on the line.
  text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
  text = regexprep (text, '@seealso', '@xseealso');

  ## We don't want *ref macros to clutter plain text output with "Note ..."
  if (strcmp (output_type, "plain text"))
    text  = regexprep (text, '@ref{(?:[^}]*?),?(?:XREF)?([^,}]+)}', '$1');
    text  = regexprep (text, '@xref{(?:[^}]*?),?(?:XREF)?([^,}]+)}', 'See $1');
    text  = regexprep (text, '@pxref{(?:[^}]*?),?(?:XREF)?([^,}]+)}', 'see $1');
  endif

  file = texi_macros_file ();
  fid = fopen (file, "r");
  if (fid < 0)
    error ("unable to open %s for reading", file);
  else
    macros_text = fread (fid, Inf, "*char")';
    text = [macros_text text];
  endif
  fclose (fid);

  if (strcmpi (output_type, "texinfo"))
    status = 0;
    retval = text;
    return;
  endif

  ## Create the final TeXinfo input string
  text = sprintf ("\\input texinfo\n\n%s\n\n@bye\n", text);

  unwind_protect
    ## Write Texinfo to tmp file
    template = "octave-help-XXXXXX";
    [fid, name] = mkstemp (fullfile (tempdir, template), true);
    if (fid < 0)
      error ("__makeinfo__: could not create temporary file");
    endif
    fprintf (fid, "%s", text);
    fclose (fid);

    ## Take action depending on output type
    switch (lower (output_type))
      case "plain text"
        cmd = sprintf ('%s --no-headers --no-warn --no-validate --plaintext --output=- "%s"',
                       makeinfo_program (), name);
      case "html"
        cmd = sprintf ('%s --no-headers --html --no-warn --no-validate --output=- "%s"',
                       makeinfo_program (), name);
      otherwise
        error ("__makeinfo__: unsupported output type: '%s'", output_type);
    endswitch

    ## Call makeinfo
    [status, retval] = system (cmd);

    ## On error, retry with force to ensure user gets *something*
    if (status)
      cmd = regexprep (cmd, '--output=', '--force --output=', 'once');
      [status_force, retval] = system (cmd);
      ## original return value usually more useful
      if (status_force)
        status = status_force;
      endif
    endif

    ## Clean up extra newlines generated by makeinfo
    if (strcmpi (output_type, "plain text"))
      if (numel (retval) > 2 && retval(end-1:end) == "\n\n")
        retval = retval(1:end-2);
      endif
    endif

    ## Clean up start of @deftypefn expansion which includes extra ':'
    retval = regexprep (retval, '^ -- : +', ' -- ', "lineanchors");

  unwind_protect_cleanup
    if (exist (name, "file"))
      delete (name);
    endif
  end_unwind_protect

endfunction


## No test needed for internal helper function.
%!assert (1)
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{txt} =} __unimplemented__ (@var{fcn})
## Return specific help text for the unimplemented function @var{fcn}.
##
## This is usually a suggestion for an existing compatible function to use in
## place of @var{fcn}.
##
## This function is not called by users, but by the Octave interpreter when it
## fails to recognize an input string as a valid function name.  See
## @code{missing_function_hook} for using a different handler for this event.
## @seealso{missing_function_hook}
## @end deftypefn


function txt = __unimplemented__ (fcn)

  if (nargin < 1)
    print_usage ();
  endif

  is_matlab_function = true;

  ## Some smarter cases, add more as needed.
  switch (fcn)
    case {"avifile", "aviinfo", "aviread"}
      txt = ["Basic video file support is provided in the video package.  ", ...
             "See @url{https://octave.sourceforge.io/video/}."];

    case "funm"
      txt = ["funm is not currently part of core Octave.  ", ...
             "See the linear-algebra package at ", ...
             "@url{https://octave.sourceforge.io/linear-algebra/}."];

    case "griddedInterpolant"
      txt = ["griddedInterpolant is not implemented.  ", ...
             "Consider using griddata."];

    case "linprog"
      txt = ["Octave does not currently provide linprog.  ", ...
             "Linear programming problems may be solved using @code{glpk}.  ", ...
             "Try @code{help glpk} for more info."];

    case "matlabrc"
      txt = ["matlabrc is not implemented.  ", ...
             "Octave uses the file '.octaverc' instead."];

    case {"ode113", "ode23t", "ode23tb"}
      txt = ["Octave provides lsode and ode15i, ode15s, ode23, ode23s, ", ...
             "and ode45 for solving differential equations.  For more", ...
             "information try @code{help lsode}, @code{help ode45}.  ", ...
             "Further specialized ODE solvers are provided by the odepkg ", ...
             "package.  See @url{https://wiki.octave.org/Odepkg}."];

    case "polarplot"
      txt = ["polarplot is not implemented.  Consider using polar."];

    case "startup"
      txt = ["'startup.m' is a user startup and configuration script.  ", ...
             "Try @code{doc startup} for more information."];

    case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
      txt = ["Functions for spreadsheet style I/O ", ...
             "(.xls .xlsx .sxc .ods .dbf .wk1 etc.) " , ...
             "are provided in the io package. ", ...
             "See @url{https://octave.sourceforge.io/io/}."];

    ## control system
    case {"absorbDelay", "allmargin", "append", "augstate", "balreal", ...
          "balred", "balredOptions", "bdschur", "bode", ...
          "bodemag", "bodeoptions", "bodeplot", "c2d", "c2dOptions", ...
          "canon", "care", "chgFreqUnit", "chgTimeUnit", "connect", ...
          "connectOptions", "covar", "ctrb", "ctrbf", "ctrlpref", "d2c", ...
          "d2cOptions", "d2d", "d2dOptions", "damp", "dare", "db2mag", ...
          "dcgain", "delay2z", "delayss", "dlqr", "dlyap", "dlyapchol", ...
          "drss", "dsort", "dss", "dssdata", "esort", "estim", "evalfr", ...
          "feedback", "filt", "frd", "frdata", "freqresp", "gcare", "gdare", ...
          "genfrd", "genmat", "gensig", "genss", "get", "getBlockValue", ...
          "getDelayModel", "getGainCrossover", "getIOTransfer", ...
          "getLFTModel", "getLoopTransfer", "getNominal", "getoptions", ...
          "getPeakGain", "getSwitches", "getValue", "gram", "hasdelay", ...
          "hasInternalDelay", "hsvd", "hsvdOptions", "hsvoptions", ...
          "hsvplot", "imp2exp", "impulse", "impulseplot", "initial", ...
          "initialplot", "iopzmap", "iopzplot", "isct", "isdt", ...
          "isfinite", "isParametric", "isproper", "isreal", "issiso", ...
          "isstable", "isstatic", "kalman", "kalmd", "lft", "loopswitch", ...
          "lqg", "lqgreg", "lqgtrack", "lqi", "lqr", "lqrd", "lqry", "lsim", ...
          "lsiminfo", "lsimplot", "ltiview", "lyap", "lyapchol", "mag2db", ...
          "margin", "minreal", "modred", "modsep", "nblocks", "ndims", ...
          "ngrid", "nichols", "nicholsoptions", "nicholsplot", "nmodels", ...
          "norm", "nyquist", "nyquistoptions", "nyquistplot", "obsv", ...
          "obsvf", "order", "pade", "parallel", "permute", "pid", "piddata", ...
          "pidstd", "pidstddata", "pidtool", "pidtune", "pidtuneOptions", ...
          "place", "pole", "prescale", "pzmap", "pzoptions", "pzplot", ...
          "realp", "reg", "replaceBlock", "repsys", "reshape", "rlocus", ...
          "rlocusplot", "rss", "series", "set", "setBlockValue", ...
          "setDelayModel", "setoptions", "setValue", "sgrid", ...
          "showBlockValue", "showTunable", "sigma", "sigmaoptions", ...
          "sigmaplot", "sisoinit", "sisotool", "sminreal", "ss", ...
          "ss2ss", "ssdata", "stabsep", "stabsepOptions", "stack", "step", ...
          "stepDataOptions", "stepinfo", "stepplot", "sumblk", "tf", ...
          "tfdata", "thiran", "timeoptions", "totaldelay", "tzero", ...
          "updateSystem", "upsample", "xperm", "zero", "zgrid", "zpk", ...
          "zpkdata"}
      txt = check_package (fcn, "control");

    ## communications
    case {"algdeintrlv", "algintrlv", "alignsignals", "amdemod", "ammod", ...
          "arithdeco", "arithenco", "awgn", "bchdec", "bchenc", ...
          "bchgenpoly", "bchnumerr", "berawgn", "bercoding", "berconfint", ...
          "berfading", "berfit", "bersync", "bertool", "bi2de", "bin2gray", ...
          "biterr", "bsc", "cma", "commscope", "compand", "convdeintrlv", ...
          "convenc", "convintrlv", "convmtx", "cosets", "cyclgen", ...
          "cyclpoly", "de2bi", "decode", "deintrlv", "dfe", "dftmtx", ...
          "distspec", "doppler", "dpcmdeco", "dpcmenco", "dpcmopt", ...
          "dpskdemod", "dpskmod", "dvbs2ldpc", "encode", "equalize", ...
          "eyediagram", "EyeScope", "finddelay", "fmdemod", "fmmod", ...
          "fskdemod", "fskmod", "gaussdesign", "gen2par", "genqamdemod", ...
          "genqammod", "gf", "gfadd", "gfconv", "gfcosets", "gfdeconv", ...
          "gfdiv", "gffilter", "gflineq", "gfminpol", "gfmul", "gfpretty", ...
          "gfprimck", "gfprimdf", "gfprimfd", "gfrank", "gfrepcov", ...
          "gfroots", "gfsub", "gftable", "gftrunc", "gftuple", "gfweight", ...
          "gray2bin", "hammgen", "heldeintrlv", "helintrlv", ...
          "helscandeintrlv", "helscanintrlv", "huffmandeco", "huffmandict", ...
          "huffmanenco", "intdump", "intrlv", "iscatastrophic", ...
          "isprimitive", "istrellis", "legacychannelsim", "lineareq", ...
          "lloyds", "lms", "lteZadoffChuSeq", "marcumq", ...
          "mask2shift", "matdeintrlv", "matintrlv", "minpol", "mldivide", ...
          "mlseeq", "modnorm", "muxdeintrlv", "muxintrlv", "noisebw", ...
          "normlms", "oct2dec", "oqpskdemod", "oqpskmod", "pamdemod", ...
          "pammod", "pmdemod", "pmmod", "poly2trellis", "primpoly", ...
          "pskdemod", "pskmod", "qamdemod", "qammod", "qfunc", "qfuncinv", ...
          "quantiz", "randdeintrlv", "randerr", "randintrlv", "randsrc", ...
          "rayleighchan", "rcosdesign", "rectpulse", "reset", "ricianchan", ...
          "rls", "rsdec", "rsenc", "rsgenpoly", "rsgenpolycoeffs", ...
          "scatterplot", "sdrexamples", "sdrfgensysace", "sdrfroot", ...
          "sdrinfo", "sdrload", "sdrsetup", "semianalytic", "shift2mask", ...
          "signlms", "ssbdemod", "ssbmod", "stdchan", ...
          "supportPackageInstaller", "symerr", "syndtable", "varlms", ...
          "vec2mat", "vitdec", "wgn"}
      txt = check_package (fcn, "communications");

    ## dicom
    case {"addContour", "convertToInfo", "dicomanon", "dicomBrowser", ...
          "dicomCollection", "dicomContours", "dicomdict", "dicomdisp", ...
          "dicominfo", "dicomlookup", "dicomread", "dicomreadVolume", ...
          "dicomuid", "dicomwrite", "deleteContour", ...
          "images.dicom.decodeUID", "images.dicom.parseDICOMDIR", "isdicom", ...
          "plotContour"}
      txt = check_package (fcn, "dicom");

    ## finance
    case {"abs2active", "accrfrac", "acrubond", "acrudisc", "active2abs", ...
          "addEquality", "addGroupRatio", "addGroups", "addInequality", ...
          "adline", "adosc", "amortize", "annurate", "annuterm", ...
          "arith2geom", "ascii2fts", "beytbill", "binprice", "blkimpv", ...
          "blkprice", "blsdelta", "blsgamma", "blsimpv", "blslambda", ...
          "blsprice", "blsrho", "blstheta", "blsvega", "bndconvp", ...
          "bndconvy", "bnddurp", "bnddury", "bndkrdur", "bndprice", ...
          "bndspread", "bndtotalreturn", "bndyield", "bolling", "bollinger", ...
          "boxcox", "busdate", "busdays", "candle", "cdai", "cdprice", ...
          "cdyield", "cfamounts", "cfbyzero", "cfconv", "cfdates", "cfdur", ...
          "cfplot", "cfport", "cfprice", "cfspread", "cftimes", "cfyield", ...
          "chaikosc", "chaikvolat", "chartfts", "checkFeasibility", ...
          "chfield", "convert2sur", ...
          "convertto", "corr2cov", "cov2corr", "cpncount", "cpndaten", ...
          "cpndatenq", "cpndatep", "cpndaysp", "cpnpersz", "createholidays", ...
          "cumsum", "cur2frac", "cur2str", "date2time", "dateaxis", ...
          "datedisp", "datefind", "datemnth", "datewrkdy", "day", "days360", ...
          "days360e", "days360isda", "days360psa", "days365", "daysact", ...
          "daysadd", "daysdif", "dec2thirtytwo", "depfixdb", "depgendb", ...
          "deprdv", "depsoyd", "depstln", "diff", "disc2zero", "discrate", ...
          "ecmmvnrfish", "ecmmvnrmle", "ecmmvnrobj", "ecmmvnrstd", ...
          "ecmnfish", "ecmnhess", "ecmninit", "ecmnmle", "ecmnobj", ...
          "ecmnstd", "effrr", "elpm", "emaxdrawdown", "end", "eomdate", ...
          "estimateAssetMoments", "estimateBounds", ...
          "estimateFrontier", ...
          "estimateFrontierByReturn", ...
          "estimateFrontierByRisk", ...
          "estimateFrontierLimits", ...
          "estimateMaxSharpeRatio", "estimatePortMoments", ...
          "estimatePortReturn", ...
          "estimatePortRisk", ...
          "estimatePortStd", "estimatePortVaR", ...
          "estimateScenarioMoments", "ewstats", ...
          "exp", "extfield", "fbusdate", "fetch", "fieldnames", "fillts", ...
          "fints", "floatdiscmargin", "floatmargin", "fpctkd", "frac2cur", ...
          "freqnum", "freqstr", "frontcon", "frontier", "fts2ascii", ...
          "fts2mat", "ftsbound", "ftsgui", "ftsinfo", "ftstool", "ftsuniq", ...
          "fvdisc", "fvfix", "fvvar", "fwd2zero", "geom2arith", ...
          "getAssetMoments", "getBounds", ...
          "getBudget", ...
          "getCosts", "getEquality", ...
          "getGroupRatio", "getGroups", ...
          "getInequality", ...
          "getnameidx", "getOneWayTurnover", ...
          "getScenarios", ...
          "hhigh", "highlow", "holdings2weights", ...
          "holidays", "horzcat", "hour", "inforatio", "irr", "isbusday", ...
          "iscompatible", "isfield", "issorted", "kagi", "lagts", ...
          "lbusdate", "leadts", "length", "linebreak", "llow", ...
          "log10", "log2", "lpm", "lweekdate", "m2xdate", "macd", ...
          "maxdrawdown", "medprice", "merge", "minus", "minute", "mirr", ...
          "month", "months", "movavg", "mrdivide", "mtimes", "mvnrfish", ...
          "mvnrmle", "mvnrobj", "mvnrstd", "negvolidx", ...
          "nomrr", "nweekdate", "nyseclosures", "onbalvol", "opprofit", ...
          "payadv", "payodd", "payper", "payuni", "pcalims", "pcgcomp", ...
          "pcglims", "pcpval", "peravg", "periodicreturns", "plotFrontier", ...
          "plus", "pointfig", "portalloc", ...
          "portalpha", "portcons", "Portfolio", "PortfolioCVaR", ...
          "PortfolioMAD", "portopt", "portrand", "portror", "portsim", ...
          "portstats", "portvar", "portvrisk", "posvolidx", "power", ...
          "prbyzero", "prcroc", "prdisc", "priceandvol", "prmat", "prtbill", ...
          "pvfix", "pvtrend", "pvvar", "pyld2zero", "rdivide", "renko", ...
          "resamplets", "ret2tick", "rmfield", "rsindex", "selectreturn", ...
          "setAssetList", "setAssetMoments", ...
          "setBounds", "setBudget", ...
          "setCosts", ...
          "setDefaultConstraints", ...
          "setEquality", ...
          "setGroupRatio", ...
          "setGroups", "setInequality", ...
          "setInitPort", ...
          "setOneWayTurnover", ...
          "setProbabilityLevel", "setScenarios", ...
          "setSolver", ...
          "setTurnover", "sharpe", ...
          "simulateNormalScenariosByData", ...
          "simulateNormalScenariosByMoments", ...
          "smoothts", "sortfts", ...
          "spctkd", "stochosc", "subsasgn", "subsref", "targetreturn", ...
          "taxedrr", "tbilldisc2yield", "tbillprice", "tbillrepo", ...
          "tbillval01", "tbillyield", "tbillyield2disc", "tbl2bond", ...
          "thirdwednesday", "thirtytwo2dec", "tick2ret", "time2date", ...
          "times", "toannual", "todaily", "today", "todecimal", "tomonthly", ...
          "toquarterly", "toquoted", "tosemi", "totalreturnprice", ...
          "toweekly", "tr2bonds", "transprob", "transprobbytotals", ...
          "transprobfromthresholds", "transprobgrouptotals", ...
          "transprobprep", "transprobtothresholds", "tsaccel", "tsmom", ...
          "tsmovavg", "typprice", "ugarch", "ugarchllf", "ugarchpred", ...
          "ugarchsim", "uicalendar", "uminus", "uplus", "vertcat", ...
          "volarea", "volroc", "wclose", "weeknum", "weights2holdings", ...
          "willad", "willpctr", "wrkdydif", "x2mdate", "xirr", "year", ...
          "yeardays", "yearfrac", "ylddisc", "yldmat", "yldtbill", ...
          "zbtprice", "zbtyield", "zero2disc", "zero2fwd", "zero2pyld"}
      txt = check_package (fcn, "financial");

    ## image processing
    case {"activecontour", "adapthisteq", "affine2d", "affine3d", ...
          "analyze75info", "analyze75read", "applycform", "applylut", ...
          "axes2pix", "bestblk", "blockproc", "bwarea", "bwareaopen", ...
          "bwboundaries", "bwconncomp", "bwconvhull", "bwdist", ...
          "bwdistgeodesic", "bweuler", "bwhitmiss", "bwlabel", "bwlabeln", ...
          "bwlookup", "bwmorph", "bwpack", "bwperim", "bwselect", ...
          "bwtraceboundary", "bwulterode", "bwunpack", "checkerboard", ...
          "col2im", "colfilt", "conndef", "convmtx2", "corner", ...
          "cornermetric", "corr2", "cp2tform", "cpcorr", "cpselect", ...
          "cpstruct2pairs", "dct2", "dctmtx", "deconvblind", "deconvlucy", ...
          "deconvreg", "deconvwnr", "decorrstretch", "demosaic", ...
          "edge", "edgetaper", "entropy", "entropyfilt", "fan2para", ...
          "fanbeam", "findbounds", "fitgeotrans", "fliptform", "freqz2", ...
          "fsamp2", "fspecial", "ftrans2", "fwind1", "fwind2", "getheight", ...
          "getimage", "getimagemodel", "getline", "getneighbors", ...
          "getnhood", "getpts", "getrect", "getsequence", "graycomatrix", ...
          "graycoprops", "graydist", "grayslice", "graythresh", "hdrread", ...
          "hdrwrite", "histeq", "hough", "houghlines", "houghpeaks", ...
          "iccfind", "iccread", "iccroot", "iccwrite", "idct2", "ifanbeam", ...
          "im2bw", "im2col", "im2double", "im2int16", "im2java2d", ...
          "im2single", "im2uint16", "im2uint8", "imabsdiff", "imadd", ...
          "imadjust", "ImageAdapter", "imageinfo", "imapplymatrix", ...
          "imapprox", "imattributes", "imbothat", "imclearborder", ...
          "imclose", "imcolormaptool", "imcomplement", "imcontour", ...
          "imcontrast", "imcrop", "imdilate", "imdisplayrange", ...
          "imdistline", "imdivide", "imellipse", "imerode", "imextendedmax", ...
          "imextendedmin", "imfill", "imfilter", "imfindcircles", ...
          "imfreehand", "imfuse", "imgca", "imgcf", "imgetfile", ...
          "imgradient", "imgradientxy", "imhandles", "imhist", ...
          "imhistmatch", "imhmax", "imhmin", "imimposemin", "imlincomb", ...
          "imline", "immagbox", "immovie", "immultiply", "imnoise", ...
          "imopen", "imoverview", "imoverviewpanel", "impixel", ...
          "impixelinfo", "impixelinfoval", "impixelregion", ...
          "impixelregionpanel", "implay", "impoint", "impoly", "improfile", ...
          "impyramid", "imquantize", "imreconstruct", "imrect", "imref2d", ...
          "imref3d", "imregconfig", "imregionalmax", "imregionalmin", ...
          "imregister", "imregtform", "imresize", "imroi", "imrotate", ...
          "imsave", "imscrollpanel", "imsharpen", "imshowpair", ...
          "imsubtract", "imtool", "imtophat", "imtransform", "imwarp", ...
          "interfileinfo", "interfileread", "intlut", "iptaddcallback", ...
          "iptcheckconn", "iptcheckhandle", "iptgetapi", ...
          "iptGetPointerBehavior", "iptgetpref", "ipticondir", ...
          "iptPointerManager", "iptprefs", "iptremovecallback", ...
          "iptSetPointerBehavior", "iptsetpref", "iptwindowalign", "iradon", ...
          "isflat", "isicc", "isrset", "lab2double", "lab2uint16", ...
          "lab2uint8", "label2rgb", "labelmatrix", "makecform", ...
          "makeConstrainToRectFcn", "makehdr", "makelut", "makeresampler", ...
          "maketform", "mat2gray", "mean2", "medfilt2", "montage", ...
          "multithresh", "nitfinfo", "nitfread", "nlfilter", "normxcorr2", ...
          "openrset", "ordfilt2", "otf2psf", "padarray", "para2fan", ...
          "phantom", "poly2mask", "projective2d", "psf2otf", "qtdecomp", ...
          "qtgetblk", "qtsetblk", "radon", "rangefilt", "reflect", ...
          "regionprops", "rgb2gray", "rgb2ycbcr", "roicolor", "roifill", ...
          "roifilt2", "roipoly", "rsetwrite", "std2", "stdfilt", "strel", ...
          "stretchlim", "subimage", "tformarray", "tformfwd", "tforminv", ...
          "tonemap", "translate", "truesize", "viscircles", "warp", ...
          "watershed", "whitepoint", "wiener2", "xyz2double", "xyz2uint16", ...
          "ycbcr2rgb"}
      txt = check_package (fcn, "image");

    ## signal processing
    case {"ac2poly", "ac2rc", "angle", "arburg", "arcov", "armcov", ...
          "aryule", "bandpower", "barthannwin", "besselap", "besself", ...
          "bilinear", "bitrevorder", "blackmanharris", "bohmanwin", ...
          "buffer", "buttap", "butter", "buttord", "cceps", "cconv", ...
          "cell2sos", "cfirpm", "cheb1ap", "cheb1ord", "cheb2ap", ...
          "cheb2ord", "chebwin", "cheby1", "cheby2", "chirp", "convmtx", ...
          "corrmtx", "cpsd", "czt", "db", "db2mag", "db2pow", "dct", ...
          "decimate", "demod", "design", "designmethods", "designopts", ...
          "dfilt", "dftmtx", "digitrevorder", "diric", "downsample", "dpss", ...
          "dpssclear", "dpssdir", "dpssload", "dspdata", "dspfwiz", ...
          "dutycycle", "ellip", "ellipap", "ellipord", "enbw", "equiripple", ...
          "falltime", "fdatool", "fdesign", "filt2block", "filterbuilder", ...
          "filternorm", "filtfilt", "filtic", "filtord", "findpeaks", ...
          "fir1", "fir2", "fircls", "fircls1", "firls", "firpm", "firpmord", ...
          "firrcos", "firtype", "flattopwin", "freqs", "freqsamp", "fvtool", ...
          "fwht", "gauspuls", "gaussdesign", "gaussfir", "gausswin", ...
          "gmonopuls", "goertzel", "grpdelay", "hann", "hilbert", "icceps", ...
          "idct", "ifwht", "impinvar", "impz", "impzlength", "interp", ...
          "intfilt", "invfreqs", "invfreqz", "is2rc", "isallpass", ...
          "islinphase", "ismaxphase", "isminphase", "isstable", "kaiser", ...
          "kaiserord", "kaiserwin", "lar2rc", "latc2tf", "latcfilt", ...
          "levinson", "lp2bp", "lp2bs", "lp2hp", "lp2lp", "lpc", "lsf2poly", ...
          "mag2db", "marcumq", "maxflat", "medfilt1", "midcross", ...
          "modulate", "mscohere", "nuttallwin", "overshoot", "parzenwin", ...
          "pburg", "pcov", "peak2peak", "peak2rms", "peig", "phasedelay", ...
          "phasez", "pmcov", "pmtm", "pmusic", "poly2ac", "poly2lsf", ...
          "poly2rc", "polyscale", "polystab", "pow2db", "prony", ...
          "pulseperiod", "pulsesep", "pulsewidth", "pulstran", "pwelch", ...
          "pyulear", "rc2ac", "rc2is", "rc2lar", "rc2poly", "rceps", ...
          "rcosdesign", "realizemdl", "rectpuls", "rectwin", "resample", ...
          "residuez", "risetime", "rlevinson", "rms", "rooteig", ...
          "rootmusic", "rssq", "sawtooth", "schurrc", "seqperiod", ...
          "setspecs", "settlingtime", "sfdr", "sgolay", "sgolayfilt", ...
          "shiftdata", "sigwin", "sinad", "slewrate", "snr", "sos2cell", ...
          "sos2ss", "sos2tf", "sos2zp", "sosfilt", "spectrogram", ...
          "spectrum", "sptool", "square", "ss2sos", "ss2tf", "ss2zp", ...
          "statelevels", "stepz", "stmcb", "strips", "taylorwin", "tf2latc", ...
          "tf2sos", "tf2ss", "tf2zp", "tf2zpk", "tfestimate", "thd", "toi", ...
          "triang", "tripuls", "tukeywin", "udecode", "uencode", ...
          "undershoot", "unshiftdata", "upfirdn", "upsample", ...
          "validstructures", "vco", "window", "wintool", "wvtool", "xcorr", ...
          "xcorr2", "xcov", "yulewalk", "zerophase", "zp2sos", "zp2ss", ...
          "zp2tf", "zplane"}
      txt = check_package (fcn, "signal");

    ## statistics
    case {"addedvarplot", "addlevels", "addTerms", "adtest", "andrewsplot", ...
          "anova", "anova1", "anova2", "anovan", "ansaribradley", ...
          "aoctool", "bartlett_test", "barttest", "bbdesign", "betacdf", ...
          "betafit", "betainv", "betalike", "betapdf", "betarnd", ...
          "betastat", "binocdf", "binofit", "binoinv", "binopdf", ...
          "binornd", "binostat", "biplot", "bootci", "bootstrp", "boxplot", ...
          "candexch", "candgen", "canoncorr", "capability", "capaplot", ...
          "caseread", "casewrite", "cauchy_cdf", "cauchy_inv", ...
          "cauchy_pdf", "cauchy_rnd", "ccdesign", "cdf", "cdfplot", ...
          "cell2dataset", "chi2cdf", "chi2gof", "chi2inv", "chi2pdf", ...
          "chi2rnd", "chi2stat", "chisquare_test_homogeneity", ...
          "chisquare_test_independence", "cholcov", ...
          "ClassificationBaggedEnsemble", "ClassificationDiscriminant", ...
          "ClassificationEnsemble", "ClassificationKNN", ...
          "ClassificationPartitionedEnsemble", ...
          "ClassificationPartitionedModel", "ClassificationTree", ...
          "classify", "classregtree", "cloglog", "cluster", "clusterdata", ...
          "cmdscale", "coefCI", "coefTest", "combnk", "compact", ...
          "CompactClassificationDiscriminant", ...
          "CompactClassificationEnsemble", "CompactClassificationTree", ...
          "CompactRegressionEnsemble", "CompactRegressionTree", ...
          "CompactTreeBagger", "compare", "confusionmat", "controlchart", ...
          "controlrules", "cophenet", "copulacdf", "copulafit", ...
          "copulaparam", "copulapdf", "copularnd", "copulastat", ...
          "cordexch", "corrcov", "cor_test", "covarianceParameters", ...
          "coxphfit", "createns", "crosstab", "crossval", "cvpartition", ...
          "datasample", "dataset", "dataset2cell", "dataset2struct", ...
          "dataset2table", "datasetfun", "daugment", "dcovary", ...
          "dendrogram", "designMatrix", "devianceTest", "dfittool", ...
          "disttool", "droplevels", "dummyvar", "dwtest", "ecdf", ...
          "ecdfhist", "evalclusters", "evcdf", "evfit", "evinv", "evlike", ...
          "evpdf", "evrnd", "evstat", "ExhaustiveSearcher", "expcdf", ...
          "expfit", "expinv", "explike", "export", "exppdf", "exprnd", ...
          "expstat", "factoran", "fcdf", "ff2n", "finv", "fitdist", ...
          "fitensemble", "fitglm", "fitlm", "fitlme", "fitlmematrix", ...
          "fitnlm", "fitted", "fixedEffects", "fpdf", "fracfact", ...
          "fracfactgen", "friedman", "frnd", "fsurfht", "fullfact", ...
          "f_test_regression", "gagerr", "gamcdf", "gamfit", "gaminv", ...
          "gamlike", "gampdf", "gamrnd", "gamstat", ...
          "GeneralizedLinearModel", "geocdf", "geoinv", "geomean", ...
          "geopdf", "geornd", "geostat", "getlabels", "getlevels", ...
          "gevcdf", "gevfit", "gevinv", "gevlike", "gevpdf", "gevrnd", ...
          "gevstat", "gline", "glmfit", "glmval", "glyphplot", ...
          "gmdistribution", "gname", "gpcdf", "gpfit", "gpinv", "gplike", ...
          "gplotmatrix", "gppdf", "gprnd", "gpstat", "grp2idx", "grpstats", ...
          "gscatter", "haltonset", "harmmean", "hist3", "histfit", ...
          "hmmdecode", "hmmestimate", "hmmgenerate", "hmmtrain", ...
          "hmmviterbi", "hotelling_test", "hotelling_test_2", "hougen", ...
          "hygecdf", "hygeinv", "hygepdf", "hygernd", "hygestat", "icdf", ...
          "inconsistent", "interactionplot", "invpred", "islevel", ...
          "ismissing", "isundefined", "iwishrnd", "jackknife", "jbtest", ...
          "johnsrnd", "join", "KDTreeSearcher", "kmeans", "knnsearch", ...
          "kolmogorov_smirnov_cdf", "kolmogorov_smirnov_test", ...
          "kolmogorov_smirnov_test_2", "kruskalwallis", ...
          "kruskal_wallis_test", "ksdensity", "kstest", "kstest2", ...
          "labels", "laplace_cdf", "laplace_inv", "laplace_pdf", ...
          "laplace_rnd", "lasso", "lassoglm", "lassoPlot", "levelcounts", ...
          "leverage", "lhsdesign", "lhsnorm", "lillietest", ...
          "LinearMixedModel", "LinearModel", "linhyptest", "linkage", ...
          "logistic_cdf", "logistic_inv", "logistic_pdf", ...
          "logistic_regression", "logistic_rnd", "logit", "logncdf", ...
          "lognfit", "logninv", "lognlike", "lognpdf", "lognrnd", ...
          "lognstat", "lsline", "mad", "mahal", "maineffectsplot", ...
          "makedist", "manova", "manova1", "manovacluster", "mat2dataset", ...
          "mcnemar_test", "mdscale", "mergelevels", "mhsample", "mle", ...
          "mlecov", "mnpdf", "mnrfit", "mnrnd", "mnrval", "multcompare", ...
          "multivarichart", "mvncdf", "mvnpdf", "mvnrnd", "mvregress", ...
          "mvregresslike", "mvtcdf", "mvtpdf", "mvtrnd", "NaiveBayes", ...
          "nancov", "nanmax", "nanmean", "nanmedian", "nanmin", "nanstd", ...
          "nansum", "nanvar", "nbincdf", "nbinfit", "nbininv", "nbinpdf", ...
          "nbinrnd", "nbinstat", "ncfcdf", "ncfinv", "ncfpdf", "ncfrnd", ...
          "ncfstat", "nctcdf", "nctinv", "nctpdf", "nctrnd", "nctstat", ...
          "ncx2cdf", "ncx2inv", "ncx2pdf", "ncx2rnd", "ncx2stat", ...
          "negloglik", "nlinfit", "nlintool", "nlmefit", "nlmefitsa", ...
          "nlparci", "nlpredci", "nnmf", "nominal", "NonLinearModel", ...
          "normcdf", "normfit", "norminv", "normlike", "normpdf", ...
          "normplot", "normrnd", "normspec", "normstat", ...
          "optimalleaforder", "ordinal", "parallelcoords", "paramci", ...
          "paretotails", "partialcorr", "partialcorri", "pca", "pcacov", ...
          "pcares", "pdf", "pdist", "pdist2", "pearsrnd", "perfcurve", ...
          "plotAdded", "plotAdjustedResponse", "plotDiagnostics", ...
          "plotEffects", "plotInteraction", "plotResiduals", "plotSlice", ...
          "plsregress", "poisscdf", "poissfit", "poissinv", "poisspdf", ...
          "poissrnd", "poisstat", "polyconf", "polytool", "ppca", ...
          "prctile", "predict", "princomp", "ProbDistUnivKernel", ...
          "ProbDistUnivParam", "probit", "probplot", "procrustes", ...
          "proflik", "prop_test_2", "qqplot", "qrandset", "qrandstream", ...
          "random", "randomEffects", "randsample", "randtool", ...
          "rangesearch", "ranksum", "raylcdf", "raylfit", "raylinv", ...
          "raylpdf", "raylrnd", "raylstat", "rcoplot", "refcurve", ...
          "refline", "regress", "RegressionBaggedEnsemble", ...
          "RegressionEnsemble", "RegressionPartitionedEnsemble", ...
          "RegressionPartitionedModel", "RegressionTree", "regstats", ...
          "relieff", "removeTerms", "residuals", "response", "ridge", ...
          "robustdemo", "robustfit", "rotatefactors", "rowexch", "rsmdemo", ...
          "rstool", "runstest", "run_test", "sampsizepwr", "scatterhist", ...
          "sequentialfs", "setlabels", "signrank", "signtest", "sign_test", ...
          "silhouette", "slicesample", "sobolset", "squareform", "statget", ...
          "statset", "stdnormal_cdf", "stdnormal_inv", "stdnormal_pdf", ...
          "stdnormal_rnd", "step", "stepwise", "stepwisefit", ...
          "stepwiseglm", "stepwiselm", "struct2dataset", "surfht", ...
          "svmclassify", "svmtrain", "table2dataset", "tabulate", ...
          "tblread", "tblwrite", "tcdf", "tdfread", "tiedrank", "tinv", ...
          "tpdf", "TreeBagger", "trimmean", "trnd", "truncate", "tstat", ...
          "ttest", "ttest2", "t_test", "t_test_2", "t_test_regression", ...
          "unidcdf", "unidinv", "unidpdf", "unidrnd", "unidstat", ...
          "unifcdf", "unifinv", "unifit", "unifpdf", "unifrnd", "unifstat", ...
          "u_test", "vartest", "vartest2", "vartestn", "var_test", ...
          "wblcdf", "wblfit", "wblinv", "wbllike", "wblpdf", "wblplot", ...
          "wblrnd", "wblstat", "welch_test", "wienrnd", "wilcoxon_test", ...
          "wishrnd", "x2fx", "xlsread", "xptread", "ztest", "z_test", ...
          "z_test_2"}
      txt = check_package (fcn, "statistics");

    ## symbolic
    case {"argnames", "bernoulli", "catalan", "charpoly", "chebyshevT", ...
          "chebyshevU", "children", "coshint", "cosint", "dawson", ...
          "digits", "dilog", "dirac", "divisors", "dsolve", "ei", ...
          "ellipticCE", "ellipticCK", "ellipticCPi", "ellipticE", ...
          "ellipticF", "ellipticK", "ellipticPi", "euler", "eulergamma", ...
          "expand", "finverse", "formula", "fresnelc", "fresnels", ...
          "funtool", "gegenbauerC", "harmonic", "heaviside", "hermiteH", ...
          "hypergeom", "igamma", "jacobiP", "kroneckerDelta", "kummerU", ...
          "laguerreL", "legendreP", "logint", "minpoly", "pochhammer", ...
          "poles", "poly2sym", "polylog", "pretty", "quorem", ...
          "rectangularPulse", "signIm", "simplify", "sinhint", "sinint", ...
          "solve", "ssinint", "sym", "sym2poly", "symfun", "sympref", ...
          "syms", "symvar", "triangularPulse", "vpa", "vpasolve", ...
          "whittakerM", "whittakerW", "zeta"}
      classes = {"sym", "symfun"};
      txt = check_package (fcn, "symbolic", classes);

    ## optimization
    case {"bintprog", "color", "fgoalattain", "fmincon", "fminimax", ...
          "fminsearch", "fseminf", "fzmult", "gangstr", "ktrlink", ...
          "linprog", "lsqcurvefit", "lsqlin", "lsqnonlin", "optimoptions", ...
          "optimtool", "quadprog"}
      txt = check_package (fcn, "optim");

    otherwise
      if (ismember (fcn, missing_functions ()))
        txt = ["The '" fcn "' function is not yet implemented in Octave."];
      else
        is_matlab_function = false;
        txt = "";
      endif
  endswitch

  if (is_matlab_function)
    txt = [txt, "\n\n@noindent\nPlease read ", ...
           "@url{https://www.octave.org/missing.html} to learn how ", ...
           "you can contribute missing functionality."];
    txt = __makeinfo__ (txt);
  endif

  if (nargout == 0)
    error ("Octave:missing-function", "%s\n", txt);
  endif

endfunction

function txt = check_package (fcn, name, classes)

  if (nargin < 3)
    classes = {};
  endif

  txt = sprintf ("The '%s' function belongs to the %s package from Octave Forge",
                 fcn, name);

  [~, status] = pkg ("describe", name);
  switch (tolower (status{1}))
    case "loaded",
      for i = 1:length (classes)
        cls = classes{i};
        try
          meths = methods (cls);
        catch
          meths = {};
        end_try_catch
        if (any (strcmp (fcn, meths)))
          txt = sprintf (["'%s' is a method of class '%s'; it must be ", ...
                          "called with a '%s' argument (see 'help @@%s/%s')."],
                         fcn, cls, cls, cls, fcn);
          return;
        endif
      endfor
      txt = sprintf ("%s but has not yet been implemented.", txt);
    case "not loaded",
      txt = sprintf (["%s which you have installed but not loaded.  To ", ...
                      "load the package, run 'pkg load %s' from the ", ...
                      "Octave prompt."], txt, name);
    otherwise
      ## this includes "not installed" and anything else if pkg changes
      ## the output of describe
      txt = sprintf ("%s which seems to not be installed in your system.", txt);
  endswitch

endfunction

function rlist = missing_functions ()
  persistent list = {
  "addboundary",
  "addcats",
  "addCause",
  "addedge",
  "addmulti",
  "addnode",
  "addpoints",
  "addRequired",
  "addsample",
  "addsampletocollection",
  "addts",
  "adjacency",
  "align",
  "alim",
  "alpha",
  "alphamap",
  "alphaShape",
  "alphaSpectrum",
  "alphaTriangulation",
  "animatedline",
  "animatedLine",
  "append",
  "array2table",
  "array2timetable",
  "bar3",
  "bar3h",
  "barycentricToCartesian",
  "bctree",
  "bench",
  "between",
  "bfsearch",
  "bicgstabl",
  "biconncomp",
  "binary",
  "binscatter",
  "bitnot",
  "boundary",
  "boundaryFacets",
  "boundingbox",
  "brush",
  "builddocsearchdb",
  "bvp4c",
  "bvp5c",
  "bvpget",
  "bvpinit",
  "bvpset",
  "bvpxtend",
  "caldays",
  "caldiff",
  "calendarDuration",
  "calllib",
  "callSoapService",
  "calmonths",
  "calquarters",
  "calweeks",
  "calyears",
  "camdolly",
  "cameratoolbar",
  "campan",
  "camproj",
  "cartesianToBarycentric",
  "cartToBary",
  "categorical",
  "categories",
  "cdf2rdf",
  "cdfepoch",
  "cdfinfo",
  "cdflib",
  "cdfread",
  "cdfwrite",
  "cell2table",
  "cellplot",
  "centrality",
  "centroid",
  "checkcode",
  "checkin",
  "checkout",
  "circumcenter",
  "circumcenters",
  "classUnderlying",
  "clearAllMemoizedCaches",
  "clearCache",
  "clearpoints",
  "clipboard",
  "clone",
  "cmopts",
  "collapse",
  "colordef",
  "colormapeditor",
  "compose",
  "condensation",
  "coneplot",
  "conncomp",
  "contains",
  "contourslice",
  "convertCharsToStrings",
  "convertStringsToChars",
  "convexHull",
  "copyHDU",
  "count",
  "countcats",
  "countEachLabel",
  "createClassFromWsdl",
  "createFile",
  "createImg",
  "createSoapMessage",
  "createTbl",
  "criticalAlpha",
  "customverctrl",
  "daqread",
  "datacursormode",
  "datastore",
  "datatipinfo",
  "dateshift",
  "datetime",
  "day",
  "days",
  "dbmex",
  "dde23",
  "ddeget",
  "ddensd",
  "ddesd",
  "ddeset",
  "decomposition",
  "degree",
  "delaunayTriangulation",
  "deleteCol",
  "deleteFile",
  "deleteHDU",
  "deleteKey",
  "deleteproperty",
  "deleteRecord",
  "deleteRows",
  "delevent",
  "DelimitedTextImportOptions",
  "delsample",
  "delsamplefromcollection",
  "depdir",
  "depfun",
  "details",
  "detectImportOptions",
  "deval",
  "dfsearch",
  "digraph",
  "discretize",
  "dissect",
  "distances",
  "dither",
  "docsearch",
  "dragrect",
  "duration",
  "dynamicprops",
  "echodemo",
  "edgeAttachments",
  "edges",
  "empty",
  "enableservice",
  "enumeration",
  "eraseBetween",
  "eventlisteners",
  "events",
  "exceltime",
  "Execute",
  "export2wsdlg",
  "exportsetupdlg",
  "extractAfter",
  "extractBefore",
  "extractBetween",
  "faceNormal",
  "faceNormals",
  "fcontour",
  "featureEdges",
  "Feval",
  "fewerbins",
  "figurepalette",
  "FileDatastore",
  "filemarker",
  "fileMode",
  "fileName",
  "fillmissing",
  "filloutliers",
  "fimplicit",
  "fimplicit3",
  "findedge",
  "findgroups",
  "findnode",
  "findprop",
  "fitsdisp",
  "fitsinfo",
  "fitsread",
  "fitswrite",
  "FixedWidthImportOptions",
  "flipedge",
  "flow",
  "fmesh",
  "fplot3",
  "freeBoundary",
  "freqspace",
  "fsurf",
  "FunctionTestCase",
  "functiontests",
  "funm",
  "gather",
  "gcmr",
  "geobubble",
  "geolimits",
  "getabstime",
  "getAColParms",
  "getaudiodata",
  "getBColParms",
  "GetCharArray",
  "getColName",
  "getColType",
  "getConstantValue",
  "getdatasamples",
  "getdatasamplesize",
  "getEqColType",
  "getFileFormats",
  "GetFullMatrix",
  "getHdrSpace",
  "getHDUnum",
  "getHDUtype",
  "getImgSize",
  "getImgType",
  "getinterpmethod",
  "getnext",
  "getNumCols",
  "getNumHDUs",
  "getNumInputs",
  "getNumOutputs",
  "getNumRows",
  "getOpenFiles",
  "getpoints",
  "getProfiles",
  "getqualitydesc",
  "getReport",
  "getsamples",
  "getsampleusingtime",
  "gettimeseriesnames",
  "gettsafteratevent",
  "gettsafterevent",
  "gettsatevent",
  "gettsbeforeatevent",
  "gettsbeforeevent",
  "gettsbetweenevents",
  "GetVariable",
  "getvaropts",
  "getVersion",
  "GetWorkspaceData",
  "gobjects",
  "graph",
  "GraphPlot",
  "graymon",
  "griddedInterpolant",
  "guide",
  "h5create",
  "h5disp",
  "h5info",
  "h5read",
  "h5readatt",
  "h5write",
  "h5writeatt",
  "handle",
  "hasdata",
  "hasFrame",
  "hasnext",
  "hdf5info",
  "hdf5read",
  "hdf5write",
  "hdfan",
  "hdfdf24",
  "hdfdfr8",
  "hdfh",
  "hdfhd",
  "hdfhe",
  "hdfhx",
  "hdfinfo",
  "hdfml",
  "hdfpt",
  "hdfread",
  "hdftool",
  "hdfv",
  "hdfvf",
  "hdfvh",
  "hdfvs",
  "head",
  "heatmap",
  "height",
  "helpbrowser",
  "helpdesk",
  "helpwin",
  "hgexport",
  "hgsetget",
  "highlight",
  "histcounts",
  "histcounts2",
  "histogram",
  "histogram2",
  "hms",
  "holes",
  "hour",
  "hours",
  "idealfilter",
  "im2java",
  "ImageDatastore",
  "imapprox",
  "imgCompress",
  "import",
  "imresize",
  "incenter",
  "incenters",
  "incidence",
  "indegree",
  "inmem",
  "innerjoin",
  "inOutStatus",
  "insertAfter",
  "insertATbl",
  "insertBefore",
  "insertBTbl",
  "insertCol",
  "insertImg",
  "insertRows",
  "inShape",
  "inspect",
  "instrcallback",
  "instrfind",
  "instrfindall",
  "interfaces",
  "interp1q",
  "interpstreamspeed",
  "invoke",
  "isaUnderlying",
  "isbetween",
  "iscalendarduration",
  "iscategorical",
  "iscategory",
  "ischange",
  "iscom",
  "isCompressedImg",
  "isConnected",
  "isdag",
  "isdatetime",
  "isdst",
  "isduration",
  "isEdge",
  "isenum",
  "isevent",
  "ishole",
  "isIllConditioned",
  "isinterface",
  "isinterior",
  "isInterior",
  "isisomorphic",
  "islocalmax",
  "islocalmin",
  "isLocked",
  "ismembertol",
  "ismissing",
  "isnat",
  "isomorphism",
  "isordinal",
  "isoutlier",
  "isprotected",
  "isregular",
  "issimplified",
  "issortedrows",
  "isStringScalar",
  "istable",
  "istall",
  "istimetable",
  "isundefined",
  "isvalid",
  "isweekend",
  "javaMethodEDT",
  "javaObjectEDT",
  "join",
  "juliandate",
  "labeledge",
  "labelnode",
  "lag",
  "laplacian",
  "last",
  "layout",
  "ldl",
  "libfunctions",
  "libfunctionsview",
  "libisloaded",
  "libpointer",
  "libstruct",
  "linkdata",
  "loadlibrary",
  "lsqminnorm",
  "lsqr",
  "makehgtform",
  "mapreduce",
  "mapreducer",
  "matfile",
  "maxflow",
  "MaximizeCommandWindow",
  "maxk",
  "memmapfile",
  "memoize",
  "MemoizedFunction",
  "mergecats",
  "meta.abstractDetails",
  "meta.DynamicProperty",
  "meta.EnumeratedValue",
  "meta.MetaData",
  "methodsview",
  "MException",
  "milliseconds",
  "MinimizeCommandWindow",
  "mink",
  "minres",
  "minspantree",
  "minute",
  "minutes",
  "missing",
  "mlint",
  "mlintrpt",
  "mmfileinfo",
  "month",
  "morebins",
  "movAbsHDU",
  "move",
  "movie2avi",
  "movNamHDU",
  "movRelHDU",
  "mput",
  "multibandread",
  "multibandwrite",
  "NaT",
  "nccreate",
  "ncdisp",
  "ncinfo",
  "ncread",
  "ncreadatt",
  "ncwrite",
  "ncwriteatt",
  "ncwriteschema",
  "nearest",
  "nearestNeighbor",
  "neighbors",
  "netcdf",
  "noanimate",
  "notebook",
  "notify",
  "nsidedpoly",
  "num2ruler",
  "numArgumentsFromSubscript",
  "numboundaries",
  "numedges",
  "numnodes",
  "numpartitions",
  "numRegions",
  "numsides",
  "ode113",
  "ode23t",
  "ode23tb",
  "odextend",
  "openFile",
  "opengl",
  "outdegree",
  "outerjoin",
  "pad",
  "pagesetupdlg",
  "parse",
  "parseSoapResponse",
  "partition",
  "parula",
  "path2rc",
  "pathtool",
  "pcode",
  "pdepe",
  "pdeval",
  "perimeter",
  "plotbrowser",
  "plotedit",
  "plottools",
  "pointLocation",
  "polaraxes",
  "polarhistogram",
  "polarplot",
  "polarscatter",
  "polybuffer",
  "polyshape",
  "posixtime",
  "predecessors",
  "preview",
  "printdlg",
  "printopt",
  "printpreview",
  "profsave",
  "propedit",
  "propertyeditor",
  "PutCharArray",
  "PutFullMatrix",
  "PutWorkspaceData",
  "pyargs",
  "pyversion",
  "quarter",
  "Quit",
  "RandStream",
  "rbbox",
  "readall",
  "readasync",
  "readATblHdr",
  "readBTblHdr",
  "readCard",
  "readCol",
  "readFrame",
  "readimage",
  "readImg",
  "readKey",
  "readKeyCmplx",
  "readKeyDbl",
  "readKeyLongLong",
  "readKeyLongStr",
  "readKeyUnit",
  "readRecord",
  "readtable",
  "recordblocking",
  "regions",
  "registerevent",
  "regmatlabserver",
  "release",
  "Remove",
  "RemoveAll",
  "removecats",
  "removets",
  "renamecats",
  "reordercats",
  "reordernodes",
  "replace",
  "replaceBetween",
  "resample",
  "retime",
  "reverse",
  "rlim",
  "rmboundary",
  "rmedge",
  "rmholes",
  "rmmissing",
  "rmnode",
  "rmslivers",
  "rowfun",
  "rtickangle",
  "rtickformat",
  "rticklabels",
  "ruler2num",
  "runperf",
  "scale",
  "scatteredInterpolant",
  "scroll",
  "second",
  "seconds",
  "selectmoveresize",
  "sendmail",
  "serial",
  "serialbreak",
  "seriallist",
  "setabstime",
  "setBscale",
  "setcats",
  "setCompressionType",
  "setHCompScale",
  "setHCompSmooth",
  "setinterpmethod",
  "setpixelposition",
  "setTileDim",
  "settimeseriesnames",
  "setTscale",
  "setuniformtime",
  "setvaropts",
  "setvartype",
  "sheetnames",
  "shortestpath",
  "shortestpathtree",
  "showplottool",
  "shuffle",
  "simplify",
  "smoothdata",
  "snapnow",
  "sortboundaries",
  "sortregions",
  "sortx",
  "sorty",
  "split",
  "splitapply",
  "splitEachLabel",
  "splitlines",
  "SpreadsheetDatastore",
  "SpreadsheetImportOptions",
  "ss2tf",
  "stack",
  "standardizeMissing",
  "stats",
  "step",
  "stopasync",
  "str2mat",
  "streamparticles",
  "streamslice",
  "string",
  "strings",
  "strip",
  "strlength",
  "struct2table",
  "subgraph",
  "subtract",
  "subvolume",
  "successors",
  "summary",
  "superclasses",
  "support",
  "supportPackageInstaller",
  "surf2patch",
  "surfaceArea",
  "symmlq",
  "synchronize",
  "syntax",
  "table",
  "table2array",
  "table2cell",
  "table2struct",
  "table2timetable",
  "TabularTextDatastore",
  "tail",
  "tall",
  "TallDatastore",
  "tallrng",
  "targetupdater",
  "tcpclient",
  "Test",
  "TestResult",
  "testsuite",
  "texlabel",
  "textwrap",
  "tfqmr",
  "thetalim",
  "thetatickformat",
  "thetaticklabels",
  "throw",
  "throwAsCaller",
  "Tiff",
  "timeit",
  "timeofday",
  "timer",
  "timerange",
  "timeseries",
  "timetable",
  "timetable2table",
  "timezones",
  "todatenum",
  "toolboxdir",
  "topkrows",
  "toposort",
  "transclosure",
  "translate",
  "transreduction",
  "triangulation",
  "TriRep",
  "TriScatteredInterp",
  "tscollection",
  "tzoffset",
  "uialert",
  "uiaxes",
  "uibutton",
  "uicheckbox",
  "uiconfirm",
  "uidropdown",
  "uieditfield",
  "uifigure",
  "uigauge",
  "uigetpref",
  "uiimport",
  "uiknob",
  "uilabel",
  "uilamp",
  "uilistbox",
  "uiopen",
  "uiradiobutton",
  "uisave",
  "uisetcolor",
  "uisetpref",
  "uislider",
  "uispinner",
  "uistack",
  "uiswitch",
  "uitab",
  "uitabgroup",
  "uitextarea",
  "uitogglebutton",
  "uitree",
  "uitreenode",
  "undocheckout",
  "uniquetol",
  "unloadlibrary",
  "unmesh",
  "unregisterallevents",
  "unregisterevent",
  "unstack",
  "upgradePreviouslyInstalledSupportPackages",
  "userpath",
  "ValueIterator",
  "varfun",
  "vartype",
  "verctrl",
  "vertexAttachments",
  "vertexNormal",
  "VideoReader",
  "VideoWriter",
  "viewmtx",
  "visdiff",
  "volume",
  "volumebounds",
  "voronoiDiagram",
  "websave",
  "week",
  "whatsnew",
  "width",
  "winopen",
  "withtol",
  "wordcloud",
  "write",
  "writeChecksum",
  "writeCol",
  "writeComment",
  "writeDate",
  "writeHistory",
  "writeImg",
  "writeKey",
  "writeKeyUnit",
  "writetable",
  "writeVideo",
  "xline",
  "xmlread",
  "xmlwrite",
  "xslt",
  "xtickformat",
  "year",
  "years",
  "yline",
  "ymd",
  "ytickformat",
  "yyaxis",
  "yyyymmdd",
  "ztickformat",
  };

  rlist = list;

endfunction


%!test
%! str = __unimplemented__ ("no_name_function");
%! assert (isempty (str));

%!test
%! str = __unimplemented__ ("matlabrc");
%! assert (str(1:71), "matlabrc is not implemented.  Octave uses the file '.octaverc' instead.");

%!test
%! str = __unimplemented__ ("MException");
%! assert (str(1:58), "The 'MException' function is not yet implemented in Octave");
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @defvr {Automatic Variable} ans
## The most recently computed result that was not explicitly assigned to a
## variable.
##
## For example, after the expression
##
## @example
## 3^2 + 4^2
## @end example
##
## @noindent
## is evaluated, the value returned by @code{ans} is 25.
## @end defvr


## Mark file as being tested.  No real test needed for a documentation .m file
%!assert (1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{J}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})
## @deftypefnx {} {[@var{Y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})
## @deftypefnx {} {[@var{I}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})
## @deftypefnx {} {[@var{K}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})
## @deftypefnx {} {[@var{H}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})
## Compute Bessel or Hankel functions of various kinds.
##
## All functions begin with the prefix @qcode{"bessel"}.  The list of
## functions is:
##
## @table @code
## @item besselj
## Bessel functions of the first kind.  If the argument @var{opt} is supplied,
## the result is multiplied by @code{exp (-abs (imag (x)))}.
##
## @item bessely
## Bessel functions of the second kind.  If the argument @var{opt} is supplied,
## the result is multiplied by @w{@code{exp (-abs (imag (x)))}}.
##
## @item besseli
## Modified Bessel functions of the first kind.  If the argument @var{opt} is
## supplied, the result is multiplied by @w{@code{exp (-abs (real (x)))}}.
##
## @item besselk
## Modified Bessel functions of the second kind.  If the argument @var{opt} is
## supplied, the result is multiplied by @w{@code{exp (x)}}.
##
## @item besselh
## Compute Hankel functions of the first (@var{k} = 1) or second (@var{k} = 2)
## kind.  If the argument @var{opt} is supplied, the result is multiplied by
## @w{@code{exp (-I*@var{x})}} for @var{k} = 1 or @w{@code{exp (I*@var{x})}}
## for @var{k} = 2.
## @end table
##
## If @var{alpha} is a scalar, the result is the same size as @var{x}.  If
## @var{x} is a scalar, the result is the same size as @var{alpha}.  If
## @var{alpha} is a row vector and @var{x} is a column vector, the result is
## a matrix with @code{length (@var{x})} rows and @code{length
## (@var{alpha})} columns.  Otherwise, @var{alpha} and @var{x} must conform
## and the result will be the same size.
##
## The order of the Bessel function @var{alpha} must be real.  The points for
## evaluation @var{x} may be complex.
##
## If requested, @var{ierr} contains the following status information and is
## the same size as the result.
##
## @enumerate 0
## @item
## Normal return.
##
## @item
## Input error, return @code{NaN}.
##
## @item
## Overflow, return @code{Inf}.
##
## @item
## Loss of significance by argument reduction results in less than half of
## machine accuracy.
##
## @item
## Loss of significance by argument reduction, output may be inaccurate.
##
## @item
## Error---no computation, algorithm termination condition not met, return
## @code{NaN}.
## @end enumerate
##
## @seealso{besselj, bessely, besseli, besselk, besselh}
## @end deftypefn

function bessel ()
  error ("bessel: you must use besselj, bessely, besseli, besselk, or besselh\n");
endfunction


%!error <you must use besselj, ...> bessel ()
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} debug ()
## Summary of debugging commands.
##
## For more information on each command and available options use
## @code{help CMD}.
##
## The debugging commands available in Octave are
##
## @table @code
## @item dbstop
## Add a breakpoint.
##
## @item dbclear
## Remove a breakpoint.
##
## @item dbstatus
## List all breakpoints.
##
## @item dbwhere
## Report the current file and line number where execution is stopped.
##
## @item dbtype
## Display the code of the function being debugged, enumerating
## the line numbers.
##
## @item dblist
## List 10 lines of code centered around the line number where execution is
## stopped.
##
## @item  dbstep
## @itemx dbnext
## Execute (step) one or more lines, follow execution into (step into) a
## function call, or execute until the end of a function (step out), and
## re-enter debug mode.
##
## @item dbcont
## Continue normal code execution from the debug prompt.
##
## @item dbquit
## Quit debugging mode immediately and return to the main prompt.
##
## @item dbstack
## Print a backtrace of the execution stack.
##
## @item dbup
## Move up the execution stack.
##
## @item dbdown
## Move down the execution stack.
##
## @item keyboard
## Force entry into debug mode from an m-file.
##
## @item debug_on_error
## Configure whether Octave enters debug mode when it encounters an error.
##
## @item debug_on_warning
## Configure whether Octave enters debug mode when it encounters a warning.
##
## @item debug_on_interrupt
## Configure whether Octave enters debug mode when it encounters an interrupt.
##
## @item isdebugmode
## Return true if in debug mode.
## @end table
##
## @noindent
## When Octave encounters a breakpoint, or other reason to enter debug mode,
## the prompt changes to @qcode{"debug>"}.  The workspace of the function
## where the breakpoint was encountered becomes available and any Octave
## command that is valid in that workspace context may be executed.
##
## @seealso{dbstop, dbclear, dbstatus, dbwhere, dbtype, dbcont, dbquit,
## dbstack, dbup, dbdown, keyboard, debug_on_error, debug_on_warning,
## debug_on_interrupt, isdebugmode}
## @end deftypefn

function debug ()
  help ("debug");
endfunction


## Mark file as being tested.  No real test needed for a documentation .m file
%!assert (1)
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} doc @var{function_name}
## @deftypefnx {} {} doc
## Display documentation for the function @var{function_name} directly from an
## online version of the printed manual, using the GNU Info browser.
##
## If invoked without an argument, the manual is shown from the beginning.
##
## For example, the command @kbd{doc rand} starts the GNU Info browser at the
## @code{rand} node in the online version of the manual.
##
## Once the GNU Info browser is running, help for using it is available using
## the command @kbd{C-h}.
## @seealso{help}
## @end deftypefn

function retval = doc (function_name)

  if (nargin == 1)
    if (! ischar (function_name))
      error ("doc: FUNCTION_NAME must be a string");
    endif
    ftype = exist (function_name);
  else
    function_name = "";
    ftype = 0;
  endif

  ## Give event manager the first shot.

  status = ! __event_manager_show_documentation__ (function_name);

  if (status)

    if (ftype == 2 || ftype == 3)
      ffile = which (function_name);
    else
      ffile = "";
    endif

    if (isempty (ffile))
      info_dir = __octave_config_info__ ("infodir");
    else
      info_dir = fileparts (ffile);
    endif

    ## Determine if a file called doc.info exist in the same
    ## directory as the function.
    info_file_name = fullfile (info_dir, "doc.info");

    [~, err] = stat (info_file_name);

    if (err < 0)
      info_file_name = info_file ();

      if (! exist (info_file_name, "file")
          && ! exist ([info_file_name ".gz"], "file")
          && ! exist ([info_file_name ".bz2"], "file"))
        __gripe_missing_component__ ("doc", "info-file");
      endif
    endif

    ## FIXME: Don't change the order of the arguments below because
    ## the info-emacs-info script currently expects --directory DIR as
    ## the third and fourth arguments.  Someone should fix that.
    cmd = sprintf ('"%s" --file "%s" --directory "%s"',
                   info_program (), info_file_name, info_dir);

    have_fname = ! isempty (function_name);

    if (have_fname)
      status = system (sprintf ('%s --index-search "%s"', cmd, function_name));
    endif

    if (! (have_fname && status == 0))
      status = system (cmd);
      if (status == 127)
        warning ("doc: unable to find info program '%s'", info_program ());
      endif
    endif

  endif

  if (nargout > 0)
    retval = status;
  endif

endfunction


%!testif ENABLE_DOCS
%! ifile = info_file ();
%! if (exist (ifile) != 2 && exist (sprintf ("%s.gz", ifile)) != 2)
%!   error ("Info file %s or %s.gz does not exist!", ifile, ifile);
%! endif
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} doc_cache_create (@var{out_file}, @var{directory})
## @deftypefnx {} {} doc_cache_create (@var{out_file})
## @deftypefnx {} {} doc_cache_create ()
## Generate documentation cache for all functions in @var{directory}.
##
## A documentation cache is generated for all functions in @var{directory}
## which may be a single string or a cell array of strings.  The cache is used
## to speed up the function @code{lookfor}.
##
## The cache is saved in the file @var{out_file} which defaults to the value
## @file{doc-cache} if not given.
##
## If no directory is given (or it is the empty matrix), a cache for built-in
## functions, operators, and keywords is generated.
##
## @seealso{doc_cache_file, lookfor, path}
## @end deftypefn

function doc_cache_create (out_file = "doc-cache", directory = [])

  ## Check input
  if (! ischar (out_file))
    print_usage ();
  endif

  ## Generate cache
  if (isempty (directory))
    cache = gen_builtin_cache ();
  elseif (iscell (directory))
    if (all (cellfun ("isclass", directory, "char")))
      cache = gen_doc_cache_in_dir (directory);
    else
      error ("doc_cache_create: cell must contain only strings");
    endif
  elseif (ischar (directory))
     cache = gen_doc_cache_in_dir (directory);
  else
     error ("doc_cache_create: second input argument must be a string or a cell of strings");
  endif

  ## Save cache
  if (! isempty (cache))
     save_header_format_string (["# doc-cache created by Octave " OCTAVE_VERSION], "local");
     save ("-text", out_file, "cache");
  endif

endfunction

function [text, first_sentence, status] = handle_function (f, text, format)

  first_sentence = "";
  ## Skip internal functions starting with "__"
  if (strncmp (f, "__", 2))
    status = 1;
    return;
  endif

  ## Take action depending on help text format
  switch (lower (format))
    case "plain text"
      status = 0;
    case "texinfo"
      [text, status] = __makeinfo__ (text, "plain text");
    case "html"
      [text, status] = strip_html_tags (text);
    otherwise
      status = 1;
  endswitch

  ## Did we get the help text?
  if (status != 0 || isempty (text))
    warning ("doc_cache_create: unusable help text found in file '%s'", f);
    return;
  endif

  ## Get first sentence of help text
  first_sentence = get_first_help_sentence (f);

endfunction

function cache = create_cache (list)

  cache = {};

  ## For each function:
  for n = 1:length (list)
    f = list{n};

    ## Get help text
    [text, format] = get_help_text (f);

    [text, first_sentence, status] = handle_function (f, text, format);

    ## Did we get the help text?
    if (status != 0)
      continue;
    endif

    ## Store the help text
    cache(1, end+1) = f;
    cache(2, end) = text;
    cache(3, end) = first_sentence;
  endfor

endfunction

function cache = gen_doc_cache_in_dir (directory)

  ## If 'directory' is not in the current path, add it so we search it
  dir_in_path = ismember (directory, ostrsplit (path (), pathsep ()));

  ## dirs not in path
  if (! iscell (directory))
    directory = {directory};
  endif
  dirs_notpath = {directory{! dir_in_path}};

  ## add them
  if (! isempty (dirs_notpath))
    addpath (dirs_notpath{:});
  endif

  ## create cache
  func = @(s_) create_cache (__list_functions__ (s_));
  cache = cellfun (func, directory, "UniformOutput", false);

  ## concatenate results
  cache = [cache{:}];

  ## remove dirs from path
  if (! isempty (dirs_notpath))
    rmpath (dirs_notpath{:});
  endif

endfunction

function cache = gen_builtin_cache ()

  operators = __operators__ ();
  keywords = __keywords__ ();
  builtins = __builtins__ ();
  list = {operators{:}, keywords{:}, builtins{:}};

  cache = create_cache (list);

endfunction


## No true tests desirable for this function.
## Test input validation
%!error doc_cache_create (1)
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @cindex error ids
##
## @table @code
## @item Octave:bad-alloc
## Indicates that memory couldn't be allocated.
##
## @item Octave:invalid-context
## Indicates the error was generated by an operation that cannot be executed in
## the scope from which it was called.  For example, the function
## @code{print_usage ()} when called from the Octave prompt raises this error.
##
## @item Octave:invalid-fun-call
## Indicates that a function was called in an incorrect way, e.g., wrong number
## of input arguments.
##
## @item Octave:invalid-indexing
## Indicates that a data-type was indexed incorrectly, e.g., real-value index
## for arrays, nonexistent field of a structure.
##
## @item Octave:invalid-input-arg
## Indicates that a function was called with invalid input arguments.
##
## @item Octave:undefined-function
## Indicates a call to a function that is not defined.  The function may exist
## but Octave is unable to find it in the search path.
##
## @end table
##

function error_ids ()
  help ("error_ids");
endfunction


## Mark file as being tested.  No real test needed for a documentation .m file
%!assert (1)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{text} =} get_first_help_sentence (@var{name})
## @deftypefnx {} {@var{text} =} get_first_help_sentence (@var{name}, @var{max_len})
## @deftypefnx {} {[@var{text}, @var{status}] =} get_first_help_sentence (@dots{})
## Return the first sentence of a function's help text.
##
## The first sentence is defined as the text after the function declaration
## until either the first period (".") or the first appearance of two
## consecutive newlines ("\n\n").  The text is truncated to a maximum length of
## @var{max_len}, which defaults to 80.  If the text must be truncated the last
## three characters of the text are replaced with @qcode{"..."} to indicate
## that more text was available.
##
## The optional output argument @var{status} returns the status reported by
## @code{makeinfo}.  If only one output argument is requested, and @var{status}
## is nonzero, a warning is displayed.
##
## As an example, the first sentence of this help text is
##
## @example
## @group
## get_first_help_sentence ("get_first_help_sentence")
## @print{} ans = Return the first sentence of a function's help text.
## @end group
## @end example
## @end deftypefn

function [text, status] = get_first_help_sentence (name, max_len = 80)

  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (name))
    error ("get_first_help_sentence: NAME must be a string");
  endif

  if (! isnumeric (max_len) || max_len <= 0 || max_len != fix (max_len))
    error ("get_first_help_sentence: MAX_LEN must be positive integer");
  endif

  ## First, we get the raw help text
  [help_text, format] = get_help_text (name);

  ## Then, we take action depending on the format
  switch (lower (format))
    case "plain text"
      [text, status] = first_sentence_plain_text (help_text, max_len);
    case "texinfo"
      [text, status] = first_sentence_texinfo (help_text, max_len);
    case "html"
      [text, status] = first_sentence_html (help_text, max_len);
    case "not documented"
      error ("get_first_help_sentence: '%s' is not documented\n", name);
    case "not found"
      error ("get_first_help_sentence: '%s' not found\n", name);
    otherwise
      error ("get_first_help_sentence: internal error: unsupported help text format: '%s'\n", format);
  endswitch

  if (nargout <= 1 && status != 0)
    warning ("get_first_help_sentence: couldn't run makeinfo on '%s'", name);
  endif

endfunction

## This function extracts the first sentence from a plain text help text
function [text, status] = first_sentence_plain_text (help_text, max_len)

  ## Extract first line by searching for a period followed by whitespace
  ## followed by a capital letter (Nearly the same rule as Texinfo).
  period_idx = regexp (help_text, '\.\s+(?:[A-Z]|\n)', "once");
  ## ... or a double end-of-line (we subtract 1 because we are not interested
  ## in capturing the first newline).
  line_end_idx = regexp (help_text, "\n\n", "once") - 1;
  help_len = length (help_text);
  min_idx = min ([period_idx, line_end_idx, help_len]);
  if (min_idx < max_len)
    text = help_text(1:min_idx);
  else
    if (max_len > 3)
      text = help_text(1:(max_len-3));
      text = [text, "..."];
    else
      text = help_text(1:max_len);
    endif
  endif

  status = 0;

endfunction

## This function extracts the first sentence from a Texinfo help text.
## The function works by removing @def* from the texinfo text.  After this, we
## render the text to plain text using makeinfo, and then extract the first
## line.
function [text, status] = first_sentence_texinfo (help_text, max_len)

  ## Lines ending with "@\n" are continuation lines, so they should be
  ## concatenated with the following line.
  help_text = strrep (help_text, "@\n", " ");

  ## Find, and remove, lines that start with @def.  This should remove things
  ## such as @deftypefn, @deftypefnx, @defvar, etc.
  keep = true (size (help_text));
  def_idx = strfind (help_text, "@def");
  if (! isempty (def_idx))
    endl_idx = find (help_text == "\n");
    for k = 1:length (def_idx)
      endl = endl_idx(find (endl_idx > def_idx(k), 1));
      if (isempty (endl))
        endl = numel (keep);
      endif
      keep(def_idx(k):endl) = false;
    endfor

    ## Remove the @end ... that corresponds to the @def we removed above
    def1 = def_idx(1);
    space_idx = find (help_text == " ");
    space_idx = space_idx(find (space_idx > def1, 1));
    bracket_idx = find (help_text == "{" | help_text == "}");
    bracket_idx = bracket_idx(find (bracket_idx > def1, 1));
    if (isempty (space_idx) && isempty (bracket_idx))
      error ("get_first_help_sentence: couldn't parse texinfo");
    endif
    sep_idx = min (space_idx, bracket_idx);
    def_type = help_text(def1+1:sep_idx-1);

    end_idx = strfind (help_text, sprintf ("@end %s", def_type));
    if (isempty (end_idx))
      error ("get_first_help_sentence: couldn't parse texinfo");
    endif
    keep(end_idx(1):end) = false;

    help_text = help_text(keep);
  endif

  ## Run makeinfo to generate plain text
  [help_text, status] = __makeinfo__ (help_text, "plain text");

  ## Extract first line with plain text method.
  text = first_sentence_plain_text (help_text, max_len);

endfunction

## This function extracts the first sentence from a html help text.
## The function simply removes the tags and treats the text as plain text.
function [text, status] = first_sentence_html (help_text, max_len)

  ## Strip tags
  [help_text, status] = strip_html_tags (help_text);

  ## Extract first line with plain text method.
  text = first_sentence_plain_text (help_text, max_len);

endfunction


%!assert (get_first_help_sentence ('get_first_help_sentence'), ...
%!        "Return the first sentence of a function's help text.")

%!assert (get_first_help_sentence ('get_first_help_sentence', 28), ...
%!        "Return the first sentence...")

## Test input validation
%!error <Invalid call> get_first_help_sentence ()
%!error <NAME must be a string> get_first_help_sentence (1)
%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", "a")
%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 0)
%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 80.1)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} help @var{name}
## @deftypefnx {} {} help --list
## @deftypefnx {} {} help .
## @deftypefnx {} {} help
## Display the help text for @var{name}.
##
## For example, the command @kbd{help help} prints a short message describing
## the @code{help} command.
##
## Given the single argument @code{--list}, list all operators, keywords,
## built-in functions, and loadable functions available in the current session
## of Octave.
##
## Given the single argument @code{.}, list all operators available in the
## current session of Octave.
##
## If invoked without any arguments, @code{help} displays instructions on how
## to access help from the command line.
##
## The help command can provide information about most operators, but
## @var{name} must be enclosed by single or double quotes to prevent
## the Octave interpreter from acting on @var{name}.  For example,
## @code{help "+"} displays help on the addition operator.
## @seealso{doc, lookfor, which, info}
## @end deftypefn

function retval = help (name)

  if (nargin == 0)

    text = "\n\
  For help with individual commands and functions type\n\
\n\
    help NAME\n\
\n\
  (replace NAME with the name of the command or function you would\n\
  like to learn more about; for an operator, enclose \"NAME\" in quotes).\n\
\n\
  For a more detailed introduction to GNU Octave, consult the manual.\n\
  The manual may be read from the prompt by typing\n\
\n\
    doc\n\
\n\
  GNU Octave is supported and developed by its user community.\n\
  For more information visit https://www.octave.org.\n\n";

    if (nargout == 0)
      puts (text);
    else
      retval = text;
    endif

  elseif (nargin == 1 && ischar (name))

    if (strcmp (name, "--list"))
      list = do_list_functions ();
      if (nargout == 0)
        printf ("%s", list);
      else
        retval = list;
      endif
      return;
    endif

    if (strcmp (name, "."))
      list = do_list_operators ();
      if (nargout == 0)
        printf ("%s", list);
      else
        retval = list;
      endif
      return;
    endif

    ## Get help text
    [text, format] = get_help_text (name);

    ## Take action depending on help text format
    switch (lower (format))
      case "plain text"
        status = 0;
      case "texinfo"
        [text, status] = __makeinfo__ (text, "plain text");
      case "html"
        [text, status] = strip_html_tags (text);
      case "not documented"
        error ("help: '%s' is not documented\n", name);
      case "not found"
        do_contents (name);
        return;
      otherwise
        error ("help: internal error: unsupported help text format: '%s'\n", format);
    endswitch

    ## Print text
    if (status != 0)
      warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
    endif

    if (nargout == 0)
      if (! any (strcmp (name, {'./', '.\', '...'})))
        evalin ("caller", ['which ("' undo_string_escapes(name) '")']);
      endif
      printf ("\n%s\n%s", text, __additional_help_message__ ());
    else
      retval = text;
    endif

  else
    error ("help: invalid input\n");
  endif

endfunction

function retval = do_list_operators ()
  retval = sprintf ("*** operators:\n\n%s\n%s\n\n",
                    list_in_columns (__operators__ ()),
                    ["To obtain help on an operator, type\n"...
                     "      help \"NAME\"   or   help 'NAME'"]);
endfunction

function retval = do_list_functions ()

  operators = do_list_operators ();

  keywords = sprintf ("*** keywords:\n\n%s\n\n",
                      list_in_columns (__keywords__ ()));

  builtins = sprintf ("*** builtins:\n\n%s\n\n",
                      list_in_columns (__builtins__ ()));

  dirs = ostrsplit (path, pathsep);
  flist = "";
  for i = 2:numel (dirs)
    files = sort ({dir(fullfile (dirs{i}, "*.m")).name, ...
                   dir(fullfile (dirs{i}, "*.oct")).name, ...
                   dir(fullfile (dirs{i}, "*.mex")).name});

    if (! isempty (files))
      flist = sprintf ("%s*** functions in %s:\n\n%s\n\n",
                       flist, dirs{i}, list_in_columns (files));
    endif
  endfor

  retval = [operators, keywords, builtins, flist];

endfunction

function do_contents (name)

  found = false;

  dlist = dir_in_loadpath (name, "all");

  for i = 1:numel (dlist)
    fname = make_absolute_filename (fullfile (dlist{i}, "Contents.m"));

    [text, format] = get_help_text_from_file (fname);

    ## Take action depending on help text format
    switch (lower (format))
      case "plain text"
        status = 0;
      case "texinfo"
        [text, status] = __makeinfo__ (text, "plain text");
      case "html"
        [text, status] = strip_html_tags (text);
    endswitch

    if (! isempty (text))
      found = true;
      ## Print text.
      if (status != 0)
        warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
      endif
      printf ("%s:\n\n%s\n", fname, text);
    endif

  endfor

  if (found)
    puts (__additional_help_message__ ());
  else
    msg = feval (missing_function_hook, name);

    if (isempty (msg))
      msg = sprintf ("'%s' not found", name);
    endif

    error ("help: %s\n", msg);
  endif

endfunction


%!assert (! isempty (strfind (help ("ls"), "List directory contents")))
%!assert (! isempty (strfind (help ("."), "||")))

## Test input validation
%!error <invalid input> help (42)
%!error <called with too many inputs> help ("abc", "def")
%!error <'_! UNLIKELY_FCN! _' not found> help ("_! UNLIKELY_FCN! _")
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} lookfor @var{str}
## @deftypefnx {} {} lookfor -all @var{str}
## @deftypefnx {} {[@var{fcn}, @var{help1str}] =} lookfor (@var{str})
## @deftypefnx {} {[@var{fcn}, @var{help1str}] =} lookfor ("-all", @var{str})
## Search for the string @var{str} in the documentation of all functions in the
## current function search path.
##
## By default, @code{lookfor} looks for @var{str} in just the first sentence of
## the help string for each function found.  The entire help text of each
## function can be searched by using the @qcode{"-all"} argument.  All searches
## are case insensitive.
##
## When called with no output arguments, @code{lookfor} prints the list of
## matching functions to the terminal.  Otherwise, the output argument
## @var{fcns} contains the function names and @var{help1str} contains the first
## sentence from the help string of each function.
##
## Programming Note: The ability of @code{lookfor} to correctly identify the
## first sentence of the help text is dependent on the format of the function's
## help.  All Octave core functions are correctly formatted, but the same can
## not be guaranteed for external packages and user-supplied functions.
## Therefore, the use of the @qcode{"-all"} argument may be necessary to find
## related functions that are not a part of Octave.
##
## The speed of lookup is greatly enhanced by having a cached documentation
## file.  For more information,
## @pxref{XREFdoc_cache_create,,@code{doc_cache_create}}.
## @seealso{help, doc, which, path, doc_cache_create}
## @end deftypefn

function [fcn, help1str] = lookfor (str, arg2)

  if (strcmpi (str, "-all"))
    ## The difference between using '-all' and not is which part of the caches
    ## we search.  The cache is organized such that row
    ## 1) contains the function name
    ## 2) contains the full help text
    ## 3) contains the first sentence of the help text.
    str = arg2;
    search_type = 2;  # search the second row (full help text)
  else
    search_type = 3;  # search the third column (first help sentence)
  endif
  str = lower (str);  # Compare is case insensitive

  ## Search functions, operators, and keywords that come with Octave
  cache_file = doc_cache_file ();
  if (exist (cache_file, "file"))
    [fcnlist, help_text] = search_cache (str, cache_file, search_type);
    had_core_cache = true;
  else
    fcnlist = help_text = {};
    had_core_cache = false;
  endif

  ## Search functions in new path dirs.
  orig_path = ostrsplit (__pathorig__ (), pathsep ());

  ## ditto for path.
  new_path = ostrsplit (path (), pathsep ());

  ## remove directories already covered by orig_path.
  if (had_core_cache)
    new_path = setdiff (new_path, orig_path);
  endif

  for n = 1:numel (new_path)
    fcndir = new_path{n};
    cache_file = fullfile (fcndir, "doc-cache");
    if (exist (cache_file, "file"))
      ## We have a cache in the directory, then read it and search it!
      [fcns, htext] = search_cache (str, cache_file, search_type);
      fcnlist(end+1:end+length (fcns)) = fcns;
      help_text(end+1:end+length (htext)) = htext;

    else
      ## We don't have a cache.  Search files.
      for fcn_in_fcndir = (__list_functions__ (fcndir)).'
        fn = fcn_in_fcndir{1};

        ## Skip files that start with "__"
        if (strncmp (fn, "__", 2))
          continue;
        endif

        status = 0;

        ## Extract first sentence
        try
          warn_state = warning ();
          unwind_protect
            warning ("off");
            first_sentence = get_first_help_sentence (fn, 1024);
          unwind_protect_cleanup
            warning (warn_state);
          end_unwind_protect
        catch
          status = 1;
        end_try_catch

        if (status)
          ## Error getting first help sentence
        elseif (search_type == 3)
          ## only search the first sentence of the help text
          text = first_sentence;
        elseif (search_type == 2)
          ## search entire help text
          try
            warn_state = warning ();
            unwind_protect
              warning ("off");
              [text, fmt] = get_help_text (fn);
              switch (lower (fmt))
                case "plain text"
                  status = 0;
                case "texinfo"
                  [text, status] = __makeinfo__ (text, "plain text");
                case "html"
                  [text, status] = strip_html_tags (text);
                otherwise
                  status = 1;
              endswitch
            unwind_protect_cleanup
              warning (warn_state);
            end_unwind_protect
          catch
            status = 1;
          end_try_catch
        endif

        ## Search the help text
        if (status == 0 && strfind (lower (text), str))
          fcnlist(end+1) = fn;
          help_text(end+1) = first_sentence;
        endif
      endfor
    endif
  endfor

  if (nargout == 0)
    ## Print the results (FIXME: it would be nice to break at word boundaries)
    indent = 20;
    term_width = (terminal_size ())(2);
    desc_width = term_width - indent - 2;
    indent_space = blanks (indent);
    for k = 1:length (fcnlist)
      f = fcnlist{k};
      f(end+1:indent-1) = " ";
      puts ([f " "]);
      lf = length (f);
      desc = strtrim (strrep (help_text{k}, "\n", " "));
      ldesc = length (desc);
      printf ("%s\n", desc(1:min (ldesc, desc_width - (lf - indent))));
      for start = (desc_width - (lf - indent) + 1):desc_width:ldesc
        stop = min (start + desc_width, ldesc);
        printf ("%s%s\n", indent_space, strtrim (desc (start:stop)));
      endfor
    endfor
  else
    ## Return the results instead of displaying them
    fcn = fcnlist;
    help1str = help_text;
  endif

endfunction

function [fcns, help_texts] = search_cache (str, cache_file, search_type)

  load (cache_file);

  if (isempty (cache))
    fcns = help_texts = {};
  else
    t1 = strfind (lower (cache(1, :)), str);
    t2 = strfind (lower (cache(search_type, :)), str);
    cache_idx = find (! (cellfun ("isempty", t1) & cellfun ("isempty", t2)));
    fcns = cache(1, cache_idx);
    help_texts = cache(3, cache_idx);
  endif

endfunction
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} print_usage ()
## @deftypefnx {} {} print_usage (@var{name})
## Print the usage message for the function @var{name}.
##
## When called with no input arguments the @code{print_usage} function displays
## the usage message of the currently executing function.
## @seealso{help}
## @end deftypefn

function print_usage (name)

  x = dbstack ();
  ## Handle input
  if (nargin == 0)
    ## Determine the name of the calling function
    if (numel (x) > 1)
      name = x(2).name;
    else
      error ("Octave:invalid-context", "print_usage: invalid function\n");
    endif
    fullname = evalin ("caller", 'mfilename ("fullpath")');
    if (strcmp (fullname(end-length (name)+1:end), name))
      fullname = [fullname ".m"];
    endif
  elseif (! ischar (name))
    error ("Octave:invalid-input-arg",
           "print_usage: input argument must be a string");
  else
    fullname = name;
  endif

  ## Determine if we were called from top level.
  at_toplev = length (x) < 2 || (length (x) == 2 && strcmp (x(2).name, name));

  ## Do the actual work
  [text, format] = get_help_text (fullname);
  max_len = 80;
  switch (lower (format))
    case "plain text"
      [usage_string, status] = get_usage_plain_text (text, max_len);
    case "texinfo"
      [usage_string, status] = get_usage_texinfo (text, max_len);
    case "html"
      [usage_string, status] = get_usage_html (text, max_len);
    case "not documented"
      error ("print_usage: '%s' is not documented\n", name);
    case "not found"
      error ("print_usage: '%s' not found\n", name);
    otherwise
      error ("print_usage: internal error: unsupported help text format: '%s'\n", format);
  endswitch

  ## Raise the final error
  if (status != 0)
    warning ("print_usage: Texinfo formatting filter exited abnormally");
    warning ("print_usage: raw Texinfo source of help text follows...\n");
  endif

  ## We don't want to start the debugger here if debug_on_error is true
  ## so we set it to false and make the change local.  Then
  ## debug_on_error will be reset to true after this function returns
  ## and the debugger will start at the location of the call to
  ## print_usage.
  debug_on_error (false, "local");

  if (at_toplev)
    error ("Octave:invalid-fun-call",
           "Invalid call to %s.  Correct usage is:\n\n%s\n%s",
           name, usage_string, __additional_help_message__ ());
  else
    msg = sprintf ("Invalid call to %s.  Correct usage is:\n\n%s",
                   name, usage_string);
    ## Ensure that the error doesn't end up with a newline, as that disables
    ## backtraces.
    if (msg(end) == "\n")
      msg(end) = " ";
    endif

    error ("Octave:invalid-fun-call", msg);
  endif

endfunction

function [retval, status] = get_usage_plain_text (help_text, max_len)
  ## Extract first line by searching for a double line-end.
  line_end_idx = strfind (help_text, "\n\n");
  retval = help_text (1:min ([line_end_idx , max_len, length(help_text)]));
  status = 0;
endfunction

function [retval, status] = get_usage_texinfo (help_text, max_len)

  ## Lines ending with "@\n" are continuation lines, so they should be
  ## concatenated with the following line.
  help_text = strrep (help_text, "@\n", " ");

  ## Find, and keep, lines that start with @def or @end def.  This should
  ## include things such as @deftypefn, @deftypefnx, @defvar, etc. and their
  ## corresponding @end's.
  def_idx = strfind (help_text, "@def");
  if (isempty (def_idx))
    [retval, status] = get_usage_plain_text (help_text, max_len);
    return;
  endif

  endf_idx = strfind (help_text, "@end def");
  def_idx = sort ([def_idx, endf_idx]);
  endl_idx = find (help_text == "\n");
  buffer = "";
  for k = 1:length (def_idx)
    endl = endl_idx(find (endl_idx > def_idx(k), 1));
    if (isempty (endl))
      buffer = [buffer, help_text(def_idx(k):end), "\n"];
    else
      buffer = [buffer, help_text(def_idx(k):endl)];
    endif
  endfor

  ## Run makeinfo to generate plain text
  [retval, status] = __makeinfo__ (buffer, "plain text");

endfunction

function [retval, status] = get_usage_html (help_text, max_len)

  ## Strip tags
  [help_text, status] = strip_html_tags (help_text);

  ## Extract first line with plain text method.
  retval = get_usage_plain_text (help_text, max_len);

endfunction


## Stop reporting function as missing tests.  No good tests possible.
%!assert (1)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} __additional_help_message__ ()
## Undocumented internal function.
## @end deftypefn

function msg = __additional_help_message__ ()

  if (suppress_verbose_help_message ())
    msg = "";
  else
    msg = "\n\
Additional help for built-in functions and operators is\n\
available in the online version of the manual.  Use the command\n\
'doc <topic>' to search the manual index.\n\
\n\
Help and information about Octave is also available on the WWW\n\
at https://www.octave.org and via the help@octave.org\n\
mailing list.\n";
  endif

endfunction
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{text}, @var{status}] =} __strip_html_tags__ (@var{html_text})
## Undocumented internal function.
## @end deftypefn

## Remove HTML tags from text.  This is used as a simple HTML-to-text
## function.

function [text, status] = __strip_html_tags__ (html_text)

  start = find (html_text == "<");
  stop  = find (html_text == ">");
  if (length (start) == length (stop))
    text = html_text;
    for n = length (start):-1:1
      text (start (n):stop (n)) = [];
    endfor
    text = strip_superfluous_endlines (text);
    status = 0;
  else
    warning ("help: invalid HTML data -- raw HTML source follows...");
    disp (html_text);
    text = "";
    status = 1;
  endif

endfunction

## This function removes end-lines (\n) that makes printing look bad
function text = strip_superfluous_endlines (text)

  ## Find groups of end-lines
  els = find (text == "\n");
  dels = diff (els);
  groups = [els(1), 1]; # list containing [start, length] of each group
  for k = 1:length (dels)
    if (dels (k) == 1)
      groups(end, 2)++;
    else
      groups(end+1, 1:2) = [els(k+1), 1];
    endif
  endfor

  keep = true (size (text));

  ## Remove end-lines in the beginning
  if (groups (1, 1) == 1)
    keep(1:groups (1, 2)) = false;
  endif

  ## Remove end-lines from the end
  if (sum (groups(end, :)) - 1 == length (text))
    keep(groups(end, 1):end) = false;
  endif

  ## Remove groups of end-lines with more than 3 end-lines next to each other
  idx = find (groups (:, 2) >= 3);
  for k = 1:length (idx)
    start = groups(idx(k), 1);
    stop = start + groups(idx(k), 2) - 1;
    keep(start+2:stop) = false;
  endfor

  ## Actually remove the elements
  text = text(keep);

endfunction
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @documentencoding UTF-8
## @defvr {Documentation} slash
## Backslash and slash perform various sorts of division.
##
## @table @asis
## @item @code{\} Matrix Left Division (``backslash'')
## Solve systems of equations
## @iftex
## $Ax = b$ for $x$.
## @end iftex
## @ifnottex
## Ax = b for x.
## @end ifnottex
## @code{A \ b} is conceptually equivalent to @code{inv (A) * b} but is
## computed more efficiently and accurately, without forming the matrix
## inverse directly.
##
## Example:
##
## @example
## @group
## A = [1 2; 3 4];
## b = [4; 2];
## x = A \ b
##   @result{} x =
##        -6
##         5
## isequal (A*x, b)
##   @result{} 1
## @end group
## @end example
##
## If the system is not square, or if the matrix is singular, a minimum-norm
## solution is computed (@code{norm (A*x - b)}).
##
## For dense matrices, backslash uses the Gaussian Elimination algorithm
## with partial pivoting.  For sparse matrices, backslash uses a direct
## method to compute an LU factorization (@pxref{XREFlu,,@code{lu}}).  The
## direct method tries to minimize ``fill-in'' of zeros but it could
## nonetheless use a lot of memory; if this is a concern, consider an iterative
## method (@pxref{XREFcgs,,@code{cgs}} or @pxref{XREFgmres,,@code{gmres}}).
##
## @item @code{/} Matrix Right Division
## The forward slash notation can be used to solve systems of the form
## @iftex
## $AB = C$ for $A$
## @end iftex
## @ifnottex
## AB = C for A
## @end ifnottex
## using @code{A = C / B}.
##
## @item @code{./} and @code{.\} Component-wise ``Hadamard'' Division
## The ``dot slash'' operators perform element-by-element division, for
## example:
##
## @example
## @group
## A = [1 10 12; 24 30 42];
## B = [1 5 4; 6 6 7];
## A ./ B
##   @result{}
##        1   2   3
##        4   5   6
## @end group
## @end example
##
## If the sizes are not the same, ``broadcasting'' may apply
## (@pxref{Broadcasting}):
##
## @example
## @group
## 420 ./ B
##   @result{}
##        420    84   105
##         70    70    60
## [20; 42] ./ B
##   @result{}
##        20    4    5
##         7    7    6
## @end group
## @end example
##
## @end table
##
## @seealso{mldivide, mrdivide, ldivide, rdivide, linsolve}
## @end defvr


## Mark file as being tested.  No real test needed for a documentation .m file
%!assert (1)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} type @var{name} @dots{}
## @deftypefnx {} {} type -q @var{name} @dots{}
## @deftypefnx {} {text =} type ("@var{name}", @dots{})
## Display the contents of @var{name} which may be a file, function (m-file),
## variable, operator, or keyword.
##
## @code{type} normally prepends a header line describing the category of
## @var{name} such as function or variable; The @option{-q} option suppresses
## this behavior.
##
## If no output variable is used the contents are displayed on screen.
## Otherwise, a cell array of strings is returned, where each element
## corresponds to the contents of each requested function.
## @end deftypefn

function text = type (varargin)

  if (nargin == 0)
    print_usage ();
  elseif (! iscellstr (varargin))
    error ("type: input arguments must be strings");
  endif

  quiet = false;
  idx = strcmpi (varargin, "-q") | strcmpi (varargin, "-quiet");
  if (any (idx))
    quiet = true;
    varargin(idx) = [];
  endif

  if (nargout > 0)
    text = cell (size (varargin));
  endif

  for n = 1:length (varargin)
    name = varargin{n};

    ## Find function and get its code
    txt = "";
    cmd = sprintf ("exist ('%s')", name);
    e = evalin ("caller", cmd);
    if (e == 1)
      ## Variable
      cmd = sprintf ("disp (%s);", name);
      desc = evalin ("caller", cmd);
      if (quiet)
        txt = desc;
      else
        txt = sprintf ("%s is a variable\n%s", name, desc);
      endif
    elseif (e == 2)
      ## m-file or ordinary file
      file = which (name);
      if (length (file) > 2)
        ext = file(end-1:end);
      endif
      if (isempty (file) || ! strcmpi (ext, ".m"))
        ## 'name' is an ordinary file, and not a function name.
        file = file_in_loadpath (name);
        quiet = true;
      endif

      ## Read the file
      fid = fopen (file, "r");
      if (fid < 0)
        error ("type: couldn't open '%s' for reading", file);
      endif
      contents = char (fread (fid).');
      fclose (fid);

      if (quiet)
        txt = contents;
      else
        txt = sprintf ("%s is the user-defined function defined from: %s\n\n%s",
                        name, file, contents);
      endif
    elseif (e == 3)
      txt = sprintf ("%s is a dynamically-linked function", name);
    elseif (e == 5)
      txt = sprintf ("%s is a built-in function", name);
    elseif (e == 103)
      contents = __get_cmdline_fcn_txt__ (name);
      if (isempty (contents))
        txt = sprintf ("%s is a command-line function with no definition",
                       name);
      else
        if (quiet)
          txt = contents;
        else
          txt = sprintf ("%s is the command-line function:\n\n%s",
                         name, contents);
        endif
      endif
    elseif (any (strcmp (__operators__ (), name)))
      txt = sprintf ("%s is an operator", name);
    elseif (any (strcmp (__keywords__ (), name)))
      txt = sprintf ("%s is a keyword", name);
    else
      error ("type: '%s' undefined\n", name);
    endif

    if (nargout == 0)
      disp (txt);
    else
      text{n} = txt;
    endif
  endfor

endfunction


%!test
%! var = 1;
%! txt = type ("var");
%! typestr = txt{1}(1:17);
%! assert (typestr, "var is a variable");

%!test
%! txt = type ("ls");
%! typestr = txt{1}(1:31);
%! assert (typestr, "ls is the user-defined function");

%!test
%! txt = type ("ls", "-q");
%! assert (regexp (txt{1}, '[#\s]*Copyright \(C\) 2006'));

%!assert (type ("fftw"){1}, "fftw is a dynamically-linked function")
%!assert (type ("cat"){1}, "cat is a built-in function")
%!assert (type ("+"){1}, "+ is an operator")
%!assert (type ("end"){1}, "end is a keyword")

%!error <Invalid call> type ()
%!error <'__NO_NAME__' undefined> type ('__NO_NAME__')
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @cindex warning ids
##
## @table @code
## @item Octave:abbreviated-property-match
## If the @code{Octave:abbreviated-property-match} warning is enabled, a
## warning is printed if a non-exact or ambiguous match is being used for a
## operation specifying an object property.  For example, for a graphics
## object, @var{fig}, with the property @qcode{'displayname'},
## @code{get (@var{fig}, 'dis')} elicits a warning if the
## @code{Octave:abbreviated-property-match} warning is enabled.
## By default, the @code{Octave:abbreviated-property-match} warning is enabled.
##
## @item Octave:addpath-pkg
## If the @code{Octave:addpath-pkg} warning is enabled,
## Octave will warn when a package directory (i.e., +package_name) is added
## to the @code{path}.  Typically, only the parent directory which contains the
## package directory should be added to the load path.
## By default, the @code{Octave:addpath-pkg} warning is enabled.
##
## @item Octave:array-as-logical
## If the @code{Octave:array-as-logical} warning is enabled,
## Octave will warn when an array of size greater than 1x1 is used
## as a truth value in an if, while, or until statement.
## By default, the @code{Octave:array-as-logical} warning is disabled.
##
## @item Octave:array-to-scalar
## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
## warn when an implicit conversion from an array to a scalar value is
## attempted.
## By default, the @code{Octave:array-to-scalar} warning is disabled.
##
## @item Octave:array-to-vector
## If the @code{Octave:array-to-vector} warning is enabled, Octave will
## warn when an implicit conversion from an array to a vector value is
## attempted.
## By default, the @code{Octave:array-to-vector} warning is disabled.
##
## @item Octave:assign-as-truth-value
## If the @code{Octave:assign-as-truth-value} warning is
## enabled, a warning is issued for statements like
##
## @example
## @group
## if (s = t)
##   @dots{}
## @end group
## @end example
##
## @noindent
## since such statements are not common, and it is likely that the intent
## was to write
##
## @example
## @group
## if (s == t)
##   @dots{}
## @end group
## @end example
##
## @noindent
## instead.
##
## There are times when it is useful to write code that contains
## assignments within the condition of a @code{while} or @code{if}
## statement.  For example, statements like
##
## @example
## @group
## while (c = getc ())
##   @dots{}
## @end group
## @end example
##
## @noindent
## are common in C programming.
##
## It is possible to avoid all warnings about such statements by
## disabling the @code{Octave:assign-as-truth-value} warning,
## but that may also let real errors like
##
## @example
## @group
## if (x = 1)  # intended to test (x == 1)!
##   @dots{}
## @end group
## @end example
##
## @noindent
## slip by.
##
## In such cases, it is possible suppress errors for specific statements by
## writing them with an extra set of parentheses.  For example, writing the
## previous example as
##
## @example
## @group
## while ((c = getc ()))
##   @dots{}
## @end group
## @end example
##
## @noindent
## will prevent the warning from being printed for this statement, while
## allowing Octave to warn about other assignments used in conditional
## contexts.
##
## By default, the @code{Octave:assign-as-truth-value} warning is enabled.
##
## @item Octave:autoload-relative-file-name
## If the @code{Octave:autoload-relative-file-name} is enabled,
## Octave will warn when parsing autoload() function calls with relative
## paths to function files.  This usually happens when using autoload()
## calls in PKG_ADD files, when the PKG_ADD file is not in the same
## directory as the .oct file referred to by the autoload() command.
## By default, the @code{Octave:autoload-relative-file-name} warning is
## enabled.
##
## @item Octave:charmat-truncated
## If the @code{Octave:charmat-truncated} warning is enabled, a warning is
## printed when a character matrix with multiple rows is converted to a string.
## In this case, the Octave interpreter keeps only the first row and discards
## the others.
## By default, the @code{Octave:charmat-truncated} warning is enabled.
##
## @item Octave:classdef-to-struct
## If the @code{Octave:classdef-to-struct} warning is enabled, a warning
## is issued when a classdef object is forcibly converted into a struct with
## @code{struct (@var{CLASSDEF_OBJ})}.  Conversion removes the access
## restrictions from the object and makes private and protected properties
## visible.
## By default, the @code{Octave:classdef-to-struct} warning is enabled.
##
## @item Octave:colon-complex-argument
## If the @code{Octave:colon-complex-argument} warning is enabled, a warning
## is issued when one of the three arguments to the colon operator (base,
## increment, limit) is a complex value.  For example, @code{1:3*i} will
## cause a warning to be emitted.
## By default, the @code{Octave:colon-complex-argument} warning is enabled.
##
## @item Octave:colon-nonscalar-argument
## If the @code{Octave:colon-nonscalar-argument} warning is enabled, a warning
## is issued when one of the three arguments to the colon operator (base,
## increment, limit) is not a scalar.  For example, @code{1:[3, 5]} will
## cause a warning to be emitted.
## By default, the @code{Octave:colon-nonscalar-argument} warning is enabled.
##
## @item Octave:data-file-in-path
## If the @code{Octave:data-file-in-path} warning is enabled, a warning is
## issued when Octave does not find the target of a file operation such as
## @code{load} or @code{fopen} directly, but is able to locate the file in
## Octave's search @code{path} for files.  The warning could indicate that a
## different file target than the programmer intended is being used.
## By default, the @code{Octave:data-file-in-path} warning is enabled.
##
## @item Octave:deprecated-function
## If the @code{Octave:deprecated-function} warning is enabled, a
## warning is issued when Octave encounters a function that is obsolete and
## scheduled for removal from Octave.
## By default, the @code{Octave:deprecated-function} warning is enabled.
##
## @item Octave:deprecated-keyword
## If the @code{Octave:deprecated-keyword} warning is enabled, a
## warning is issued when Octave encounters a keyword that is obsolete and
## scheduled for removal from Octave.
## By default, the @code{Octave:deprecated-keyword} warning is enabled.
##
## @item Octave:deprecated-option
## If the @code{Octave:deprecated-option} warning is enabled, a
## warning is issued when an obsolete option or input to a function is used.
## By default, the @code{Octave:deprecated-option} warning is enabled.
##
## @item Octave:deprecated-property
## If the @code{Octave:deprecated-property} warning is enabled, a
## warning is issued when Octave encounters a graphics property that
## is obsolete and scheduled for removal from Octave.
## By default, the @code{Octave:deprecated-property} warning is enabled.
##
## @item Octave:eigs:UnconvergedEigenvalues
## If the @code{Octave:eigs:UnconvergedEigenvalues} warning is enabled then
## the eigs function will issue a warning if the number of calculated
## eigenvalues is less than the number of requested eigenvalues.
## By default, the @code{Octave:eigs:UnconvergedEigenvalues} warning is
## enabled.
##
## @item Octave:empty-index
## If the @code{Octave:empty-index} warning is enabled then Octave will emit a
## warning whenever indexing operators are used without an index, for example
## @code{@var{x}()}.
## By default, the @code{Octave:empty-index} warning is enabled.
##
## @item Octave:erase:chararray
## If the @code{Octave:erase:chararray} warning is enabled then the erase
## function will issue a warning if the input pattern is a character array
## rather than a string or cell array of strings.
## By default, the @code{Octave:erase:chararray} warning is enabled.
##
## @item Octave:function-name-clash
## If the @code{Octave:function-name-clash} warning is enabled, a
## warning is issued when Octave finds that the name of a function
## defined in a function file differs from the name of the file.  (If
## the names disagree, the name declared inside the file is ignored.)
## By default, the @code{Octave:function-name-clash} warning is enabled.
##
## @item Octave:future-time-stamp
## If the @code{Octave:future-time-stamp} warning is enabled, Octave
## will print a warning if it finds a function file with a time stamp
## that is in the future.
## By default, the @code{Octave:future-time-stamp} warning is enabled.
##
## @item Octave:glyph-render
## If the @code{Octave:glyph-render} warning is enabled, Octave will
## print a warning if the glyph for a character couldn't be rendered with
## the current font.
## By default, the @code{Octave:glyph-render} warning is enabled.
##
## @item Octave:imag-to-real
## If the @code{Octave:imag-to-real} warning is enabled, a warning is
## printed for implicit conversions of complex numbers to real numbers.
## By default, the @code{Octave:imag-to-real} warning is disabled.
##
## @item Octave:infinite-loop
## If the @code{Octave:infinite-loop} warning is enabled, a warning is
## printed when an infinite loop is detected such as @code{for i = 1:Inf} or
## @code{while (1)}.
## By default, the @code{Octave:infinite-loop} warning is enabled.
##
## @item Octave:language-extension
## Print warnings when using features that are unique to the Octave
## language and that may still be missing in @sc{matlab}.
## By default, the @code{Octave:language-extension} warning is disabled.
## The @option{--traditional} or @option{--braindead} startup options for
## Octave may also be of use, @pxref{Command Line Options}.
##
## @item Octave:legacy-function
## If the @code{Octave:legacy-function} warning is enabled, a
## warning is issued when Octave encounters a function that @sc{matlab} has
## suggested should be avoided.  The function may become obsolete at some
## point in the future and removed, in which case the warning will change to
## @code{Octave:deprecated-function}, and the function will continue to exist
## for two further versions of Octave before being removed.
## By default, the @code{Octave:legacy-function} warning is enabled.
##
## @item Octave:logical-conversion
## If the @code{Octave:logical-conversion} warning is enabled, a warning is
## printed if an implicit conversion of an array from numerical to boolean
## occurs and any of the elements in the array are not equal to zero or one.
## By default, the @code{Octave:logical-conversion} warning is enabled.
##
## @item Octave:lu:sparse_input
## If the @code{Octave:lu:sparse_input} warning is enabled, Octave
## will warn when the lu function is called with a sparse input and less than
## four output arguments.  In this case, sparsity-preserving column
## permutations are not performed and the result may be inaccurate.
## By default, the @code{Octave:lu:sparse_input} warning is enabled.
##
## @item Octave:missing-glyph
## If the @code{Octave:glyph-render} warning is enabled, Octave will
## print a warning if the current font doesn't provide a glyph for a
## used character.
## By default, the @code{Octave:missing-glyph} warning is enabled.
##
## @item Octave:missing-semicolon
## If the @code{Octave:missing-semicolon} warning is enabled, Octave
## will warn when statements in function definitions don't end in
## semicolons.
## By default the @code{Octave:missing-semicolon} warning is disabled.
##
## @item Octave:mixed-string-concat
## If the @code{Octave:mixed-string-concat} warning is enabled, print a
## warning when concatenating a mixture of double and single quoted strings.
## By default, the @code{Octave:mixed-string-concat} warning is disabled.
##
## @item  Octave:nearly-singular-matrix
## @itemx Octave:singular-matrix
## These warnings are emitted if a (nearly) singular matrix is inverted.
## By default, the @code{Octave:nearly-singular-matrix} and
## @code{Octave:singular-matrix} warnings are enabled.
##
## @item Octave:neg-dim-as-zero
## If the @code{Octave:neg-dim-as-zero} warning is enabled, print a warning
## for expressions like
##
## @example
## eye (-1)
## @end example
##
## @noindent
## By default, the @code{Octave:neg-dim-as-zero} warning is disabled.
##
## @item Octave:noninteger-range-as-index
## If the @code{Octave:noninteger-range-as-index} warning is enabled, a warning
## is printed if an array is indexed with a range that contains non-integer
## values.  For example,
##
## @example
## @group
## a = [1 2 3 4 5];
## b = 2.2:4.2
## @result{} 1.2  2.2  3.2
## a(b)
## @result{} 2 3 4
## @end group
## @end example
##
## @noindent
## elicits a warning if the @code{Octave:noninteger-range-as-index} warning is
## enabled.
## By default, the @code{Octave:noninteger-range-as-index} warning is enabled.
##
## @item Octave:num-to-str
## If the @code{Octave:num-to-str} warning is enabled, a warning is
## printed for implicit conversions of numbers to their UTF-8 encoded character
## equivalents when strings are constructed using a mixture of strings and
## numbers in matrix notation.  For example,
##
## @example
## @group
## [ "f", 111, 111 ]
## @result{} "foo"
## @end group
## @end example
##
## @noindent
## elicits a warning if the @code{Octave:num-to-str} warning is
## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
##
## @item Octave:possible-matlab-short-circuit-operator
## If the @code{Octave:possible-matlab-short-circuit-operator} warning
## is enabled, Octave will warn about using the not short circuiting
## operators @code{&} and @code{|} inside @code{if} or @code{while}
## conditions.  They normally never short circuit, but they do short
## circuit when used in a condition.
## By default, the @code{Octave:possible-matlab-short-circuit-operator} warning
## is enabled.
##
## @item Octave:recursive-path-search
## If the @code{Octave:recursive-path-search} warning is enabled, Octave
## will issue a warning if @code{addpath} is used with double trailing
## slashes.
## By default, the @code{Octave:recursive-path-search} warning is enabled.
##
## @item Octave:remove-init-dir
## The @code{path} function changes the search path that Octave uses
## to find functions.  It is possible to set the path to a value which
## excludes Octave's own built-in functions.  If the
## @code{Octave:remove-init-dir} warning is enabled then Octave will warn
## when the @code{path} function has been used in a way that may render
## Octave unworkable.
## By default, the @code{Octave:remove-init-dir} warning is enabled.
##
## @item Octave:reload-forces-clear
## If several functions have been loaded from the same file, Octave must
## clear all the functions before any one of them can be reloaded.  If
## the @code{Octave:reload-forces-clear} warning is enabled, Octave will
## warn you when this happens, and print a list of the additional
## functions that it is forced to clear.
## By default, the @code{Octave:reload-forces-clear} warning is enabled.
##
## @item Octave:separator-insert
## Print warning if commas or semicolons might be inserted
## automatically in literal matrices.
## By default, the @code{Octave:separator-insert} warning is disabled.
##
## @item Octave:shadowed-function
## If the @code{Octave:shadowed-function} warning is enabled, Octave will
## warn if a path is added to the search path that contains functions
## that shadow core functions.
## By default, the @code{Octave:shadowed-function} warning is enabled.
##
## @item Octave:single-quote-string
## Print warning if a single quote character is used to introduce a
## string constant.
## By default, the @code{Octave:single-quote-string} warning is disabled.
##
## @item Octave:sqrtm:SingularMatrix
## If the @code{Octave:sqrtm:SingularMatrix} warning is enabled, a warning is
## printed if the matrix square root function @code{sqrtm} is called with an
## input matrix that is singular.
## By default, the @code{Octave:sqrtm:SingularMatrix} warning is enabled.
##
## @item Octave:str-to-num
## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
## for implicit conversions of strings to their numeric UTF-8 encoded byte
## sequences.  For example,
##
## @example
## @group
## "abc" + 0
## @result{} 97 98 99
## @end group
## @end example
##
## @noindent
## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
## By default, the @code{Octave:str-to-num} warning is disabled.
##
## @item Octave:LaTeX:internal-error
## If the @code{Octave:LaTeX:internal-error} warning is enabled, a warning is
## printed whenever the LaTeX renderer for text in plots encounters an issue.
## By default, the @code{Octave:LaTeX:internal-error} warning is enabled.
##
## @item Octave:unimplemented-matlab-functionality
## If the @code{Octave:unimplemented-matlab-functionality} warning is enabled,
## a warning is printed when a @sc{matlab} code construct is used which the
## Octave interpreter parses as valid, but for which Octave does not yet
## implement the functionality.
## By default, the @code{Octave:unimplemented-matlab-functionality} warning is
## enabled.
##
## @item Octave:variable-switch-label
## If the @code{Octave:variable-switch-label} warning is enabled, Octave
## will print a warning if a switch label is not a constant or constant
## expression.
## By default, the @code{Octave:variable-switch-label} warning is disabled.
## @end table
##

function warning_ids ()
  help ("warning_ids");
endfunction


## Mark file as being tested.  No real test needed for a documentation .m file
%!assert (1)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} which name @dots{}
## Display the type of each @var{name}.
##
## If @var{name} is defined from a function file, the full name of the file is
## also displayed.
## @seealso{help, lookfor}
## @end deftypefn

function varargout = which (varargin)

  if (nargin == 0 || ! iscellstr (varargin))
    print_usage ();
  endif

  m = __which__ (varargin{:});

  ## Check whether each name is a variable, variables take precedence over
  ## functions in name resolution.
  for i = 1:nargin
    m(i).is_variable = evalin ("caller",
                               ['exist ("' undo_string_escapes(m(i).name) '", "var")'], "");
    if (m(i).is_variable)
      m(i).file = "variable";
    endif
  endfor

  if (nargout == 0)
    for i = 1:nargin
      if (m(i).is_variable)
        printf ("'%s' is a variable\n", m(i).name);
      elseif (isempty (m(i).file))
        if (! isempty (m(i).type))
          printf ("'%s' is a %s\n",
                  m(i).name, m(i).type);
        endif
      else
        if (isempty (m(i).type))
          if (isfolder (m(i).file))
            printf ("'%s' is the directory %s\n",
                    m(i).name, m(i).file);
          else
            printf ("'%s' is the file %s\n",
                    m(i).name, m(i).file);
          endif
        else
          printf ("'%s' is a %s from the file %s\n",
                  m(i).name, m(i).type, m(i).file);
        endif
      endif
    endfor
  else
    varargout = {m.file};
    ## Return type, instead of "", for built-in classes (bug #50541).
    ## FIXME: remove code if __which__ is updated to return path for classes
    idx = find (cellfun ("isempty", varargout));
    if (idx)
      varargout(idx) = m(idx).type;
    endif
  endif

endfunction


%!test
%! str = which ("ls");
%! assert (str(end-17:end), fullfile ("miscellaneous", "ls.m"));
%!test
%! str = which ("fftw");
%! assert (str(end-7:end), "fftw.oct");
%!assert <*49434> (which ("inputParser"), file_in_loadpath ("inputParser.m"));
%!test
%! x = 3;
%! str = which ("x");
%! assert (str, "variable");

%!assert (which ("__NO_SUCH_NAME__"), "")

%!test
%! str = which ("fftw");
%! assert (str(end-7:end), "fftw.oct");
%! fftw = 12;
%! str = which ("fftw");
%! assert (str, "variable");
%! clear fftw;
%! str = which ("fftw");
%! assert (str(end-7:end), "fftw.oct");

%!error <Invalid call> which ()
%!error <Invalid call> which (1)

encoding=utf-8
########################################################################
##
## Copyright (C) 2003-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} beep ()
## Produce a beep from the speaker (or visual bell).
##
## This function sends the alarm character @qcode{"@backslashchar{}a"} to
## the terminal.  Depending on the user's configuration this may produce an
## audible beep, a visual bell, or nothing at all.
## @seealso{puts, fputs, printf, fprintf}
## @end deftypefn

function beep ()

  puts ("\a");

endfunction


%!error beep (1)
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} csvread (@var{filename})
## @deftypefnx {} {@var{x} =} csvread (@var{filename}, @var{dlm_opt1}, @dots{})
## Read the comma-separated-value (CSV) file @var{filename} into the matrix
## @var{x}.
##
## Note: only CSV files containing numeric data can be read.
##
## This function is equivalent to
##
## @example
## @var{x} = dlmread (@var{filename}, "," , @var{dlm_opt1}, @dots{})
## @end example
##
## Any optional arguments are passed directly to @code{dlmread}
## (@pxref{XREFdlmread,,@code{dlmread}}).
## @seealso{dlmread, textscan, csvwrite, dlmwrite}
## @end deftypefn

function x = csvread (filename, varargin)
  x = dlmread (filename, ",", varargin{:});
endfunction


## Tests for csvread() are in csvwrite()
## Mark file as being tested
%!assert (1)
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} csvwrite (@var{filename}, @var{x})
## @deftypefnx {} {} csvwrite (@var{filename}, @var{x}, @var{dlm_opt1}, @dots{})
## Write the numeric matrix @var{x} to the file @var{filename} in
## @w{comma-separated-value} (CSV) format.
##
## This function is equivalent to
##
## @example
## dlmwrite (@var{filename}, @var{x}, ",", @var{dlm_opt1}, @dots{})
## @end example
##
## Any optional arguments are passed directly to @code{dlmwrite}
## (@pxref{XREFdlmwrite,,@code{dlmwrite}}).
## @seealso{csvread, dlmwrite, dlmread}
## @end deftypefn

function csvwrite (filename, x, varargin)
  dlmwrite (filename, x, ",", varargin{:});
endfunction


%!shared fname
%! fname = tempname ();

%!test
%! csvwrite (fname, magic (3));
%! data = csvread (fname);
%! unlink (fname);
%! assert (data, magic (3));

%!test
%! csvwrite (fname, magic (3), "precision", "%2.1f", "newline", "unix");
%! fid = fopen (fname, "rt");
%! txt = char (fread (fid,Inf,'char')');
%! fclose (fid);
%! unlink (fname);
%! assert (txt, "8.0,1.0,6.0\n3.0,5.0,7.0\n4.0,9.0,2.0\n");
########################################################################
##
## Copyright (C) 2002-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dlmwrite (@var{file}, @var{M})
## @deftypefnx {} {} dlmwrite (@var{file}, @var{M}, @var{delim}, @var{r}, @var{c})
## @deftypefnx {} {} dlmwrite (@var{file}, @var{M}, @var{key}, @var{val} @dots{})
## @deftypefnx {} {} dlmwrite (@var{file}, @var{M}, "-append", @dots{})
## @deftypefnx {} {} dlmwrite (@var{fid}, @dots{})
## Write the numeric matrix @var{M} to the text file @var{file} using a
## delimiter.
##
## @var{file} should be a filename or a writable file ID given by @code{fopen}.
##
## The parameter @var{delim} specifies the delimiter to use to separate values
## on a row.  If no delimiter is specified the comma character @samp{,} is
## used.
##
## The value of @var{r} specifies the number of delimiter-only lines to add to
## the start of the file.
##
## The value of @var{c} specifies the number of delimiters to prepend to each
## line of data.
##
## If the argument @qcode{"-append"} is given, append to the end of @var{file}.
##
## In addition, the following keyword value pairs may appear at the end of
## the argument list:
##
## @table @asis
## @item @qcode{"append"}
## Either @qcode{"on"} or @qcode{"off"}.  See @qcode{"-append"} above.
##
## @item @qcode{"delimiter"}
## See @var{delim} above.
##
## @item @qcode{"newline"}
## The character(s) to separate each row.  Three special cases exist for this
## option.  @qcode{"unix"} is changed into @qcode{"@backslashchar{}n"},
## @qcode{"pc"} is changed into @qcode{"@backslashchar{}r@backslashchar{}n"},
## and @qcode{"mac"} is changed into @qcode{"@backslashchar{}r"}.  Any other
## value is used directly as the newline separator.
##
## @item @qcode{"roffset"}
## See @var{r} above.
##
## @item @qcode{"coffset"}
## See @var{c} above.
##
## @item @qcode{"precision"}
## The precision to use when writing the file.  It can either be a format
## string (as used by fprintf) or a number of significant digits.
## @end table
##
## @example
## dlmwrite ("file.csv", reshape (1:16, 4, 4));
## @end example
##
## @example
## dlmwrite ("file.tex", a, "delimiter", "&", "newline", "\n")
## @end example
##
## @seealso{dlmread, csvread, csvwrite}
## @end deftypefn

## Author: Paul Kienzle <pkienzle@users.sf.net>
##
## This program was originally granted to the public domain
##
## 2002-03-08 Paul Kienzle <pkienzle@users.sf.net>
## * Initial revision
## 2005-11-27 Bill Denney <bill@givebillmoney.com>
## * Significant modifications of the input arguments for additional
## functionality.

function dlmwrite (file, M, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  ## set defaults
  delim = ",";
  r = c = 0;
  newline = "\n";
  if (ischar (M))
    precision = "%c";
  else
    precision = "%.16g";
  endif
  opentype = "wt";

  ## process the input arguments
  i = 0;
  while (i < length (varargin))
    i += 1;
    if (strcmpi (varargin{i}, "delimiter"))
      delim = varargin{++i};
    elseif (strcmpi (varargin{i}, "newline"))
      newline = varargin{++i};
      if (strcmpi (newline, "unix"))
        newline = "\n";
      elseif (strcmpi (newline, "pc"))
        newline = "\r\n";
      elseif (strcmpi (newline, "mac"))
        newline = "\r";
      endif
    elseif (strcmpi (varargin{i}, "roffset"))
      r = varargin{++i};
    elseif (strcmpi (varargin{i}, "coffset"))
      c = varargin{++i};
    elseif (strcmpi (varargin{i}, "precision"))
      precision = varargin{++i};
      if (! strcmpi (class (precision), "char"))
        precision = sprintf ("%%.%gg", precision);
      endif
    elseif (strcmpi (varargin{i}, "-append"))
      opentype = "at";
    elseif (strcmpi (varargin{i}, "append"))
      i += 1;
      if (strcmpi (varargin{i}, "on"))
        opentype = "at";
      elseif (strcmpi (varargin{i}, "off"))
        opentype = "wt";
      else
        error ('dlmwrite: append must be "on" or "off"');
      endif
    else
      if (i == 1)
        delim = varargin{i};
      elseif (i == 2)
        r = varargin{i};
      elseif (i == 3)
        c = varargin{i};
      else
        print_usage ();
      endif
    endif
  endwhile

  ## Expand '\t' to TAB for Matlab compatibility
  if (strcmp (delim, '\t'))
    delim = "\t";
  endif

  if (ischar (file))
    [fid, msg] = fopen (file, opentype);
  elseif (is_valid_file_id (file))
    [fid, msg] = deal (file, "invalid file number");
  else
    error ("dlmwrite: FILE must be a filename string or numeric FID");
  endif

  if (fid < 0)
    error (["dlmwrite: " msg]);
  else
    if (r > 0)
      fprintf (fid, "%s",
               repmat ([repmat(delim, 1, c + columns(M)-1), newline], 1, r));
    endif
    if (iscomplex (M))
      cprecision = regexprep (precision, '^%([-\d.])', '%+$1');
      template = [precision, cprecision, "i", ...
                  repmat([delim, precision, cprecision, "i"], 1, ...
                  columns(M) - 1), newline ];
    else
      template = [precision, repmat([delim, precision], 1, columns(M)-1),...
                  newline];
    endif
    if (c > 0)
      template = [repmat(delim, 1, c), template];
    endif
    if (iscomplex (M))
      M = M.';
      b = zeros (2*rows (M), columns (M));
      b(1: 2 : end, :) = real (M);
      b(2: 2 : end, :) = imag (M);
      fprintf (fid, template, b);
    else
      fprintf (fid, template, M.');
    endif
    if (ischar (file))
      fclose (fid);
    endif
  endif

endfunction


%!test
%! f = tempname ();
%! dlmwrite (f,[1,2;3,4],"precision","%5.2f","newline","unix","roffset",1,"coffset",1);
%! fid = fopen (f,"rt");
%! f1 = char (fread (fid,Inf,"char")');
%! fclose (fid);
%! dlmwrite (f,[5,6],"precision","%5.2f","newline","unix","coffset",1,"delimiter",",","-append");
%! fid = fopen (f,"rt");
%! f2 = char (fread (fid,Inf,"char")');
%! fclose (fid);
%! unlink (f);
%!
%! assert (f1,",,\n, 1.00, 2.00\n, 3.00, 4.00\n");
%! assert (f2,",,\n, 1.00, 2.00\n, 3.00, 4.00\n, 5.00, 6.00\n");
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{str} =} fileread (@var{filename})
## Read the contents of @var{filename} and return it as a string.
## @seealso{fread, fscanf, importdata, textscan, type}
## @end deftypefn

function str = fileread (filename)

  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (filename))
    error ("fileread: FILENAME argument must be a string");
  endif

  fid = fopen (filename, "r");
  if (fid < 0)
    error ("fileread: cannot open file");
  endif

  unwind_protect
    str = (fread (fid, "*char")).';
  unwind_protect_cleanup
    fclose (fid);
  end_unwind_protect

endfunction


%!test
%! cstr = {"Hello World", "The answer is 42", "Goodbye World"};
%! fname = tempname ();
%! fid = fopen (fname, "w");
%! fprintf (fid, "%s\n", cstr{:});
%! fclose (fid);
%! str = fileread (fname);
%! unlink (fname);
%! assert (str, [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);

## Test input validation
%!error <Invalid call> fileread ()
%!error <FILENAME argument must be a string> fileread (1)
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{A} =} importdata (@var{fname})
## @deftypefnx {} {@var{A} =} importdata (@var{fname}, @var{delimiter})
## @deftypefnx {} {@var{A} =} importdata (@var{fname}, @var{delimiter}, @var{header_rows})
## @deftypefnx {} {[@var{A}, @var{delimiter}] =} importdata (@dots{})
## @deftypefnx {} {[@var{A}, @var{delimiter}, @var{header_rows}] =} importdata (@dots{})
## Import data from the file @var{fname}.
##
## Input parameters:
##
## @itemize
## @item @var{fname}
## The name of the file containing data.
##
## @item @var{delimiter}
## The character separating columns of data.  Use @code{\t} for tab.
## (Only valid for ASCII files)
##
## @item @var{header_rows}
## The number of header rows before the data begins.  (Only valid for ASCII
## files)
## @end itemize
##
## Different file types are supported:
##
## @itemize
## @item ASCII table
##
## Import ASCII table using the specified number of header rows and the
## specified delimiter.
##
## @item Image file
##
## @item @sc{matlab} file
##
## @item Spreadsheet files (depending on external software)
##
## @item WAV file
##
## @end itemize
##
## @seealso{textscan, dlmread, csvread, load}
## @end deftypefn

function [output, delimiter, header_rows] = importdata (fname, delimiter = "", header_rows = -1)

  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (fname))
    error ("importdata: FNAME must be a string");
  elseif (strcmpi (fname, "-pastespecial"))
    error ("importdata: option -pastespecial not implemented");
  endif

  if (nargin > 1)
    if (! ischar (delimiter)
        || (length (delimiter) > 1 && ! strcmp (delimiter, '\t')))
      error ("importdata: DELIMITER must be a single character");
    endif
    if (strcmp (delimiter, '\t'))
      delimiter = "\t";
    endif
  endif

  if (nargin > 2)
    if (! isnumeric (header_rows) || header_rows < 0
        || header_rows != fix (header_rows))
      error ("importdata: HEADER_ROWS must be an integer >= 0");
    endif
  endif

  ## Check file format
  ## Get the extension from the filename.
  [~, ~, ext] = fileparts (fname);
  ext = lower (ext);

  switch (ext)
    case {".au", ".snd", ".flac", ".ogg", ".wav", ".wave"}
      [output.data, output.fs] = audioread (fname);
    case {".avi", ".mj2", ".mpg", ".asf", ".asx", ".wmv", ".mp4", ".m4v", ...
          ".mov"}
      error ("importdata: not implemented for file format %s", ext);
    case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", ...
          ".jp2", ".jpf", ".jpx", ".j2c", ".j2k", ".pbm", ".pcx", ".pgm", ...
          ".png", ".pnm", ".ppm", ".ras", ".tif", ".tiff", ".xwd"}
      delimiter = NaN;
      header_rows = 0;
      [output.cdata, output.colormap, output.alpha] = imread (fname);
    case ".mat"
      delimiter = NaN;
      header_rows = 0;
      output = load (fname);
    case {".xls", ".xlsx", ".wk1", ".dbf", ".pxl"}
      ## If there's no Excel file support simply fall back to unimplemented.m
      output = xlsread (fname);
    case {".ods", ".sxc", ".fods", ".uos", ".xml"}
      ## unimplemented.m only knows ML functions; odsread isn't one but is in OF
      try
        output = odsread (fname);
      catch
        ## Fall back to unimplemented.m.
        output = xlsread (fname);
      end_try_catch
    otherwise
      ## Assume the file is in ASCII format.
      [output, delimiter, header_rows] = ...
        importdata_ascii (fname, delimiter, header_rows);
  endswitch

  ## If there are any empty fields in the output structure, then remove them
  if (isstruct (output) && numel (output) == 1)
    fields = fieldnames (output);
    for i=1:length (fields)
      if (isempty (output.(fields{i})))
        output = rmfield (output, fields{i});
      endif
    endfor

    ## If only one field is left, replace the structure with the field,
    ## i.e., output = output.onlyFieldLeft

    ## Update the list of fields
    if (numfields (output) == 1)
      output = output.(fields{1});
    endif
  endif

endfunction

function [output, delimiter, header_rows] = importdata_ascii (fname, delimiter, num_header_rows)

  ## Define fields in the output structure so that the order will be correct.
  output.data       = [];
  output.textdata   = {};
  output.rowheaders = {};
  output.colheaders = {};

  [fid, msg] = fopen (fname, "r");
  if (fid == -1)
    error (msg);
  endif

  header_rows = 0;
  header_cols = 0;

  ## Work through first few rows line by line until a delimiter is found.
  while (ischar (row = fgetl (fid)))

    ## If no delimiter determined yet, make a guess.
    if (isempty (delimiter))
      ## Look for number, DELIMITER, DELIMITER*, number
      delim = regexpi (row, '[-+]?\d*[.]?\d+(?:[ed][-+]?\d+)?[ij]?([^-+\d.deij])\1*[-+]?\d*[.]?\d+(?:[ed][-+]?\d+)?[ij]?',
                       'tokens', 'once');
      if (! isempty (delim))
        delimiter = delim{1};
      endif
    endif

    if (delimiter == " ")
      row_entries = regexp (strtrim (row), ' +', 'split');
    else
      row_entries = ostrsplit (row, delimiter);
    endif
    row_data = str2double (row_entries);
    if (header_rows < num_header_rows)
      header_rows += 1;
      output.textdata{end+1, 1} = row;
    elseif (all (isnan (row_data)) && header_rows < 25)
      header_rows += 1;
      output.textdata{end+1, 1} = row;
    elseif (all (isnan (row_data)))
      ## Failed to find any numeric input in first 25 lines
      row = -1;
      break;
    else
      ## The number of header rows and header columns is now known.
      header_cols = find (! isnan (row_data), 1) - 1;
      has_rowheaders = (header_cols == 1);

      ## Set colheaders output from textdata if appropriate
      ## NOTE: Octave chooses to be Matlab incompatible and return
      ## both 'rowheaders' and 'colheaders' when they are present.
      ## Matlab allows only one to be present at a time.
      if (! isempty (output.textdata))
        if (delimiter == " ")
          output.colheaders = regexp (strtrim (output.textdata{end}),
                                      ' +', 'split');
        else
          output.colheaders = ostrsplit (output.textdata{end}, delimiter);
        endif

        nc_hdr = numel (output.colheaders);
        nc_dat = numel (row_data);
        if (! has_rowheaders)
          if (nc_hdr != nc_dat)
            output = rmfield (output, {"rowheaders", "colheaders"});
          else
            output = rmfield (output, "rowheaders");
          endif
        else
          if (nc_hdr != nc_dat-1)
            output = rmfield (output, "colheaders");
          endif
        endif
      endif

      break;
    endif

  endwhile

  if (row == -1)
    ## No numeric data found => return file as cellstr array
    ## 1. Read as char string
    fseek (fid, 0, "bof");
    output = fread (fid, Inf, "*char")';
    fclose (fid);
    ## 2. Find EOL type
    idx = find (output(1:min (4096, length (output))) == "\n", 1) - 1;
    if (isindex (idx) && output(idx) == "\r")
      dlm = "\r\n";
    else
      dlm = "\n";
    endif
    ## 3. Split each line into a cell (column vector)
    output = strsplit (output, dlm)';
    ## 4. Remove last cell (for files with -proper- EOL before EOF)
    if (isempty (output{end}))
      output(end) = [];
    endif
    ## 5. Return after setting some output data
    delimiter = "";
    header_rows = numel (output);
    return;
  endif

  fclose (fid);

  if (num_header_rows >= 0)
    ## User has defined a number of header rows which disagrees with the
    ## auto-detected number.  Print a warning.
    if (num_header_rows < header_rows)
      warning ("Octave:importdata:headerrows_mismatch",
               "importdata: detected %d header rows, but HEADER_ROWS input configured %d rows", header_rows, num_header_rows);
    endif
  else
    ## use the automatically detected number of header rows
    num_header_rows = header_rows;
  endif

  ## Now, let the efficient built-in routine do the bulk of the work.
  if (delimiter == " ")
    output.data = dlmread (fname, "", num_header_rows, header_cols,
                           "emptyvalue", NA);
  else
    output.data = dlmread (fname, delimiter, num_header_rows, header_cols,
                           "emptyvalue", NA);
  endif

  ## Go back and correct any individual values that did not convert.
  ## FIXME: This is only efficient when the number of bad conversions is small.
  ##        Any file with 'rowheaders' will cause the for loop to execute over
  ##        *every* line in the file.

  na_idx = isna (output.data);
  if (header_cols > 0)
    na_idx = [(true (rows (na_idx), header_cols)), na_idx];
  endif
  if (any (na_idx(:)))

    file_content = ostrsplit (fileread (fname), "\r\n", true);

    na_rows = find (any (na_idx, 2));
    ## Prune text lines in header that were already collected
    idx = (na_rows(1:min (header_rows, end)) + num_header_rows) <= header_rows;
    na_rows(idx) = [];
    for ridx = na_rows(:)'
      row = file_content{ridx+num_header_rows};
      if (delimiter == " ")
        fields = regexp (strtrim (row), ' +', 'split');
      else
        fields = ostrsplit (row, delimiter);
      endif

      missing_idx = na_idx(ridx,:);
      if (! size_equal (missing_idx, fields))
        ## Fields completely missing at end of line.  Replace with NA.
        col = columns (fields);
        ## FIXME: This code should be redundant because dlmread was called
        ##        with "emptyval", NA.  Delete if there are no problems
        ##        detected after some time.  Commented out: 5/23/2020.
        ##output.data(ridx, (col+1):end) = NA;
        missing_idx = missing_idx(1:col);
      endif
      text = fields(missing_idx);

      text = text(! strcmpi (text, "NA"));  #  Remove valid "NA" entries
      text = text(! strcmpi (text, ""));    #  Remove empty entries
      if (! isempty (text))
        output.textdata(end+1, 1:columns (text)) = text;
      endif

      if (has_rowheaders)
        output.rowheaders(end+1, 1) = fields(1);
      endif
    endfor

  endif

  ## Final cleanup to satisfy Matlab compatibility
  if (all (cellfun ("isempty", output.textdata)))
    output = output.data;
  else
    ## Text fields should be cell array of strings, rather than just cell.
    try
      output.textdata = cellstr (output.textdata);
    end_try_catch
    try
      output.rowheaders = cellstr (output.rowheaders);
    end_try_catch
    try
      output.colheaders = cellstr (output.colheaders);
    end_try_catch
  endif

  if (num_header_rows != header_rows)
    header_rows = num_header_rows;
  endif

endfunction


%!test
%! ## Comma separated values
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1,-7.2,0\n0.012,6.5,128");
%! fclose (fid);
%! [a1,d1,h1] = importdata (fn, ",");
%! [a2,d2,h2] = importdata (fn);
%! unlink (fn);
%! assert (a1, A);
%! assert (d1, ",");
%! assert (h1, 0);
%! assert (a2, A);
%! assert (d2, ",");
%! assert (h2, 0);

%!test
%! ## Tab separated values
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
%! fclose (fid);
%! [a1,d1,h1] = importdata (fn, "\t");
%! [a2,d2,h2] = importdata (fn);
%! unlink (fn);
%! assert (a1, A);
%! assert (d1, "\t");
%! assert (h1, 0);
%! assert (a2, A);
%! assert (d2, "\t");
%! assert (h2, 0);

%!test
%! ## Space separated values, using multiple spaces to align in columns.
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A');
%! fclose (fid);
%! [a1,d1,h1] = importdata (fn, " ");
%! [a2,d2,h2] = importdata (fn);
%! unlink (fn);
%! assert (a1, A);
%! assert (d1, " ");
%! assert (h1, 0);
%! assert (a2, A);
%! assert (d2, " ");
%! assert (h2, 0);

%!test
%! ## No separator, 1 column of data only
%! A = [3.1;-7.2;0;0.012;6.5;128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fprintf (fid, "%f\n", A);
%! fclose (fid);
%! [a1,d1,h1] = importdata (fn, "");
%! [a2,d2,h2] = importdata (fn);
%! unlink (fn);
%! assert (a1, A);
%! assert (d1, "");
%! assert (h1, 0);
%! assert (a2, A);
%! assert (d2, "");
%! assert (h2, 0);

%!test
%! ## Header text
%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
%! A.textdata = {"This is a header row."; ...
%!               "this row does not contain any data, but the next one does."};
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fprintf (fid, "%s\n", A.textdata{:});
%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 2);

%!test
%! ## Column headers, only last row is returned in colheaders
%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
%! A.textdata = {"Label1\tLabel2\tLabel3";
%!               "";
%!               "col 1\tcol 2\tcol 3"};
%! A.colheaders = {"col 1", "col 2", "col 3"};
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fprintf (fid, "%s\n", A.textdata{:});
%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 3);

%!test
%! ## Row headers
%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
%! A.textdata = {"row1"; "row2"};
%! A.rowheaders = A.textdata;
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "row1\t3.1\t-7.2\t0\nrow2\t0.012\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!test
%! ## Row/Column headers and Header Text
%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
%! A.textdata = {"This is introductory header text"
%!               "col1\tcol2\tcol3"
%!               "row1"
%!               "row2"};
%! A.rowheaders = A.textdata(3:4);
%! A.colheaders = {"col1", "col2", "col3"};
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fprintf (fid, "%s\n", A.textdata{1:2});
%! fputs (fid, "row1\t3.1\t-7.2\t0\nrow2\t0.012\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 2);

%!test
%! ## Ignore empty rows containing only spaces
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(1,:));
%! fputs (fid, "      ");
%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(2,:));
%! fclose (fid);
%! [a,d,h] = importdata (fn, " ");
%! unlink (fn);
%! assert (a, A);
%! assert (d, " ");
%! assert (h, 0);

%!test
%! ## Exponentials
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "+3.1e0\t-72E-1\t0\n12e-3\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!testif ; ! ismac ()
%! ## Complex numbers
%! A = [3.1 -7.2 0-3.4i; 0.012 -6.5+7.2i 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\t-7.2\t0-3.4i\n0.012\t-6.5+7.2i\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!test <47413>
%! ## Same test code as above, but intended only for test statistics on Mac.
%! if (! ismac ()), return; endif
%! ## Complex numbers
%! A = [3.1 -7.2 0-3.4i; 0.012 -6.5+7.2i 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\t-7.2\t0-3.4i\n0.012\t-6.5+7.2i\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!test
%! ## Exceptional values (Inf, NaN, NA)
%! A = [3.1 Inf NA; -Inf NaN 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\tInf\tNA\n-Inf\tNaN\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!test
%! ## Missing values and Text Values
%! A.data = [3.1 NA 0; 0.012 NA 128];
%! A.textdata = {"NO DATA"};
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\t\t0\n0.012\tNO DATA\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!#test
%! ## CRLF for line breaks
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\t-7.2\t0\r\n0.012\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!#test
%! ## CR for line breaks
%! A = [3.1 -7.2 0; 0.012 6.5 128];
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "3.1\t-7.2\t0\r0.012\t6.5\t128");
%! fclose (fid);
%! [a,d,h] = importdata (fn, '\t');
%! unlink (fn);
%! assert (a, A);
%! assert (d, "\t");
%! assert (h, 0);

%!test <*43393>
%! ## Distinguish double from complex when no delimiter is supplied
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "2.0000e+02   4.0000e-04");
%! fclose (fid);
%! [a, d, h] = importdata (fn);
%! unlink (fn);
%! assert (a, [2e2, 4e-4]);
%! assert (d, " ");
%! assert (h, 0);

%!test
%! ## Only text / no numeric data; \n as EOL
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "aaaa 11\nbbbbb 22\nccccc 3\n");
%! fclose (fid);
%! [a, d, h] = importdata (fn);
%! unlink (fn);
%! assert (a, {"aaaa 11"; "bbbbb 22"; "ccccc 3"});
%! assert (d, "");
%! assert (h, 3);

%!test
%! ## Only text / no numeric data; \r\n as EOL; missing last EOL before EOF
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "aaaa 11\r\nbbbbb 22\r\nccccc 3");
%! fclose (fid);
%! [a, d, h] = importdata (fn);
%! unlink (fn);
%! assert (a, {"aaaa 11"; "bbbbb 22"; "ccccc 3"});
%! assert (d, "");
%! assert (h, 3);

%!test <*58294>
%! ## Varying values of header lines field
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "header1\nheader2\n3.1\n4.2");
%! fclose (fid);
%! warning ("off", "Octave:importdata:headerrows_mismatch", "local");
%! ## Base import
%! [a, d, h] = importdata (fn, "");
%! assert (a.data, [3.1; 4.2]);
%! assert (a.textdata, {"header1"; "header2"});
%! assert (h, 2);
%! ## Import with 0 header lines
%! [a, d, h] = importdata (fn, "", 0);
%! assert (a.data, [NA; NA; 3.1; 4.2]);
%! assert (a.textdata, {"header1"; "header2"});
%! assert (h, 0);
%! ## Import with 1 header lines
%! [a, d, h] = importdata (fn, "", 1);
%! assert (a.data, [NA; 3.1; 4.2]);
%! assert (a.textdata, {"header1"; "header2"});
%! assert (h, 1);
%! ## Import with 3 header lines
%! [a, d, h] = importdata (fn, "", 3);
%! assert (a.data, [4.2]);
%! assert (a.textdata, {"header1"; "header2"; "3.1"});
%! assert (h, 3);
%! unlink (fn);

## Test input validation
%!error <Invalid call> importdata ()
%!error <FNAME must be a string> importdata (1)
%!error <option -pastespecial not implemented> importdata ("-pastespecial")
%!error <DELIMITER must be a single character> importdata ("foo", 1)
%!error <DELIMITER must be a single character> importdata ("foo", "ab")
%!error <HEADER_ROWS must be an integer> importdata ("foo", " ", "1")
%!error <HEADER_ROWS must be an integer> importdata ("foo", " ", 1.5)
%!error <not implemented for file format .avi> importdata ("foo.avi")
%!warning <detected 2 header rows, but HEADER_ROWS input configured 1 rows>
%! fn  = tempname ();
%! fid = fopen (fn, "w");
%! fputs (fid, "header1\nheader2\n3.1");
%! fclose (fid);
%! a = importdata (fn, "", 1);
%! unlink (fn);
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} is_valid_file_id (@var{fid})
## Return true if @var{fid} refers to an open file.
## @seealso{freport, fopen}
## @end deftypefn

function retval = is_valid_file_id (fid)

  if (nargin < 1)
    print_usage ();
  endif

  retval = false;

  try
    if (isscalar (fid))
      [file, mode, arch] = fopen (fid);
      retval = ! isempty (file);
    endif
  end_try_catch

endfunction


%!assert (is_valid_file_id (stdout))
%!assert (! is_valid_file_id ([1,2;3,4]))
%!assert (! is_valid_file_id ("not_a_file_id"))
%!assert (! is_valid_file_id (-1))
%!assert (! is_valid_file_id (pi))
encoding=utf-8
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} argnames (@var{fun})
## Return a cell array of character strings containing the names of the
## arguments of the inline function @var{fun}.
## @seealso{inline, formula, vectorize}
## @end deftypefn

function args = argnames (obj)

  if (nargin < 1)
    print_usage ();
  endif

  args = obj.args;

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} char (@var{fun})
## Return a character string representing the inline function @var{fun}.
##
## Note that @code{char (@var{fun})} is equivalent to
## @code{formula (@var{fun})}.
## @seealso{char, argnames, inline, vectorize}
## @end deftypefn

function expr = char (obj)

  if (nargin < 1)
    print_usage ();
  endif

  expr = obj.expr;

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

function retval = feval (fcn, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  fh = eval (sprintf ("@(%s) %s", strjoin (fcn.args, ","), fcn.expr));

  retval = fh (varargin{:});

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} formula (@var{fun})
## Return a character string representing the inline function @var{fun}.
##
## Note that @code{char (@var{fun})} is equivalent to
## @code{formula (@var{fun})}.
## @seealso{char, argnames, inline, vectorize}
## @end deftypefn

function expr = formula (obj)

  if (nargin < 1)
    print_usage ();
  endif

  expr = obj.expr;

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} inline (@var{str})
## @deftypefnx {} {} inline (@var{str}, @var{arg1}, @dots{})
## @deftypefnx {} {} inline (@var{str}, @var{n})
##
## This function is obsolete.  Use anonymous functions
## (@pxref{Anonymous Functions}) instead.
##
## Create an inline function from the character string @var{str}.
##
## If called with a single argument, the arguments of the generated
## function are extracted from the function itself.  The generated
## function arguments will then be in alphabetical order.  It should be
## noted that i and j are ignored as arguments due to the ambiguity
## between their use as a variable or their use as an built-in constant.
## All arguments followed by a parenthesis are considered to be
## functions.  If no arguments are found, a function taking a single
## argument named @code{x} will be created.
##
## If the second and subsequent arguments are character strings, they
## are the names of the arguments of the function.
##
## If the second argument is an integer @var{n}, the arguments are
## @qcode{"x"}, @qcode{"P1"}, @dots{}, @qcode{"P@var{N}"}.
##
## @strong{Caution:} the use of @code{inline} is discouraged and it may
## be removed from a future version of Octave.  The preferred way to
## create functions from strings is through the use of anonymous
## functions (@pxref{Anonymous Functions}) or @code{str2func}.
## @seealso{argnames, formula, vectorize, str2func}
## @end deftypefn

function obj = inline (expr, varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "inline is obsolete; use anonymous functions instead\n");
  endif

  if (nargin == 0)
    print_usage ();
  endif

  if (! ischar (expr))
    error ("inline: EXPR must be a string");
  endif

  if (nargin == 1)
    args = parse_expr_for_args (expr);
  elseif (nargin == 2)
    n = varargin{1};
    if (isnumeric (n))
      if (isscalar (n) && fix (n) == n)
        if (n > 0)
          args = strsplit (["x", sprintf(":P%d", 1:n)], ":");
        else
          error ("inline: N must be a positive integer");
        endif
      else
        error ("inline: N must be an integer");
      endif
    else
      args = {"x"};
    endif
  elseif (iscellstr (varargin))
    args = varargin;
  else
    error ("inline: additional arguments must be strings");
  endif

  p.expr = expr;
  p.args = args(:);
  p.numArgs = numel (args);
  tmp = [args; num2cell(1:numel(args))];
  p.inputExpr = sprintf ("%s = INLINE_INPUTS_{%d}; ", tmp{:});
  p.isEmpty = false;
  p.version = 1;

  obj = __inline_ctor__ (p);

endfunction

## The following function was translated directly from the original C++
## version.  Yes, it will be slow, but the use of inline functions is
## strongly discouraged anyway, and most expressions will probably be
## short.  It may also be buggy.  Well, don't use this object!  Use
## function handles instead!

function args = parse_expr_for_args (expr)

  persistent symbols_to_skip = {"i", "j", "NaN", "nan", "Inf", "inf", ...
                                "NA", "pi", "e", "eps"};

  is_arg = false;
  in_string = false;
  tmp_arg = "";
  i = 1;
  expr_length = length (expr);
  args = {};

  while (i <= expr_length)

    terminate_arg = false;
    c = expr(i++);

    if (in_string)
      if (c == "'" || c == '"')
        in_string = false;
      endif
    elseif (c == "'" || c == '"')
      in_string = true;
      if (is_arg)
        terminate_arg = true;
      endif
    elseif (! isalpha (c) && c != "_")
      if (! is_arg)
        continue;
      elseif (isdigit (c))
        tmp_arg(end+1) = c;
      else
        ## Before we do anything remove trailing whitespaces.
        while (i <= expr_length && isspace (c))
          c = expr(i++);
        endwhile

        ## Do we have a variable or a function?
        if (c != "(")
          terminate_arg = true;
        else
          tmp_arg = "";
          is_arg = false;
        endif
      endif
    elseif (! is_arg)
      if (c == "e" || c == "E")
        ## Possible number in exponent form, not arg.
        if (isdigit (expr(i)) || expr(i) == "-" || expr(i) == "+")
          continue;
        endif
      endif
      is_arg = true;
      tmp_arg(end+1) = c;
    else
      tmp_arg(end+1) = c;
    endif

    if (terminate_arg || (i == expr_length+1 && is_arg))
      have_arg = false;
      if (any (strcmp (tmp_arg, args)))
        have_arg = true;
      endif

      if (! (have_arg || any (strcmp (tmp_arg, symbols_to_skip))))
        args{end+1} = tmp_arg;
      endif

      tmp_arg = "";
      is_arg = false;
    endif

  endwhile

  ## Sort the arguments into ASCII order.
  args = sort (args);

  if (isempty (args))
    args = {"x"};
  endif

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{value} =} subsref (@var{fcn}, @var{idx})
## Perform subscripted function call on the inline function object @var{fcn}.
## @end deftypefn

function retval = subsref (fcn, idx)

  if (nargin != 2)
    print_usage ();
  endif

  if (isempty (idx))
    error ("@inline/subsref: missing index");
  endif

  if (strcmp (idx(1).type, "()"))
    args = idx.subs;
    if (numel (args) > 0)
      retval = feval (fcn, args{:});
    else
      retval = feval (fcn);
    endif
  else
    error ("@inline/subsref: invalid subscript type");
  endif

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} vectorize (@var{fun})
## Create a vectorized version of the inline function @var{fun} by
## replacing all occurrences of @code{*}, @code{/}, etc., with
## @code{.*}, @code{./}, etc.
##
## This may be useful, for example, when using inline functions with
## numerical integration or optimization where a vector-valued function
## is expected.
##
## @example
## @group
## fcn = vectorize (inline ("x^2 - 1"))
##    @result{} fcn = f(x) = x.^2 - 1
## quadv (fcn, 0, 3)
##    @result{} 6
## @end group
## @end example
## @seealso{inline, formula, argnames}
## @end deftypefn

## The following function was translated directly from the original C++
## version.  Yes, it will be slow, but the use of inline functions is
## strongly discouraged anyway, and most expressions will probably be
## short.  It may also be buggy.  Well, don't use this object!  Use
## function handles instead!

function fcn = vectorize (obj)

  if (nargin < 1)
    print_usage ();
  endif

  fcn = inline (__vectorize__ (obj.expr));

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} __vectorize__ (@var{expr})
## Undocumented internal function.
## @end deftypefn

function new_expr = __vectorize__ (expr);

  new_expr = "";

  len = length (expr);
  i = 1;

  while (i <= len)
    c = expr(i);

    if (c == "*" || c == "/" || c == "\\" || c == "^")
      if (i > 1 && expr(i-1) != ".")
        new_expr(end+1) = ".";
      endif

      ## Special case for ** operator.
      if (c == '*' && i < (len - 1) && expr(i+1) == '*')
        new_expr(end+1) = "*";
        i++;
      endif
    endif

    new_expr(end+1) = c;
    i++;

  endwhile

endfunction
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} findstr (@var{s}, @var{t})
## @deftypefnx {} {} findstr (@var{s}, @var{t}, @var{overlap})
##
## This function is obsolete.  Use @code{strfind} instead.
##
## Return the vector of all positions in the longer of the two strings @var{s}
## and @var{t} where an occurrence of the shorter of the two starts.
##
## If the optional argument @var{overlap} is true (default), the returned
## vector can include overlapping positions.  For example:
##
## @example
## @group
## findstr ("ababab", "a")
##      @result{} [1, 3, 5];
## findstr ("abababa", "aba", 0)
##      @result{} [1, 5]
## @end group
## @end example
##
## @strong{Caution:} @code{findstr} is obsolete.  Use @code{strfind} in all new
## code.
## @seealso{strfind, strmatch, strcmp, strncmp, strcmpi, strncmpi, find}
## @end deftypefn

## Note that this implementation swaps the strings if second one is longer
## than the first, so try to put the longer one first.

function v = findstr (s, t, overlap = true)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "findstr is obsolete; use strfind instead\n");
  endif

  if (nargin < 2)
    print_usage ();
  endif

  if (all (size (s) > 1) || all (size (t) > 1))
    error ("findstr: arguments must have only one non-singleton dimension");
  endif

  ## Make S be the longer string.
  if (length (s) < length (t))
    [s, t] = deal (t, s);
  endif

  l_s = length (s);
  l_t = length (t);

  if (l_t == 0)
    ## zero length target: return empty set
    v = [];

  elseif (l_t == 1)
    ## length one target: simple find
    v = find (s == t);

  elseif (l_t == 2)
    ## length two target: find first at i and second at i+1
    v = find (s(1:l_s-1) == t(1) & s(2:l_s) == t(2));

  else
    ## length three or more: match the first three by find then go through
    ## the much smaller list to determine which of them are real matches
    limit = l_s - l_t + 1;
    v = find (  s(1:limit)   == t(1)
              & s(2:limit+1) == t(2)
              & s(3:limit+2) == t(3));
  endif

  ## Need to search the index vector if our find was too short
  ## (target length > 3), or if we don't allow overlaps.  Note though
  ## that there cannot be any overlaps if the first character in the
  ## target is different from the remaining characters in the target,
  ## so a single character, two different characters, or first character
  ## different from the second two don't need to be searched.
  if (l_t >= 3 || (! overlap && l_t > 1 && any (t(1) == t(2:l_t))))
    ## force strings to be both row vectors or both column vectors
    if (all (size (s) != size (t)))
      t = t.';
    endif

    ## determine which ones to keep
    keep = zeros (size (v));
    ind = 0:l_t-1;
    if (overlap)
      for idx = 1:length (v)
        keep(idx) = all (s(v(idx) + ind) == t);
      endfor
    else
      ## First possible position for next non-overlapping match.
      next = 1;
      for idx = 1:length (v)
        if (v(idx) >= next && s(v(idx) + ind) == t)
          keep(idx) = 1;
          ## Skip to the next possible match position.
          next = v(idx) + l_t;
        else
          keep(idx) = 0;
        endif
      endfor
    endif
    if (! isempty (v))
      v = v(find (keep));
    endif
  endif

  if (isempty (v))
    v = [];
  endif

  ## Always return a row vector, because that's what the old one did.
  if (iscolumn (v))
    v = v.';
  endif

endfunction


## First test is necessary to provoke 1-time legacy warning
%!test
%! warning ("off", "Octave:legacy-function", "local");
%! findstr ("", "");

%!assert (findstr ("abababa", "a"), [1, 3, 5, 7])
%!assert (findstr ("abababa", "aba"), [1, 3, 5])
%!assert (findstr ("aba", "abababa", 0), [1, 5])

## Test input validation
%!error <Invalid call> findstr ()
%!error <Invalid call> findstr ("str1")
%!error <must have only one non-singleton dimension> findstr (["AB" ; "CD"], "C")
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} flipdim (@var{x})
## @deftypefnx {} {} flipdim (@var{x}, @var{dim})
## This function is obsolete.  Use @code{flip} instead.
## @seealso{flip, fliplr, flipud, rot90, rotdim}
## @end deftypefn

function y = flipdim (varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "flipdim is obsolete; please use flip instead");
  endif

  y = flip (varargin{:});

endfunction
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{varname} =} genvarname (@var{str})
## @deftypefnx {} {@var{varname} =} genvarname (@var{str}, @var{exclusions})
##
## This function is obsolete.  Use @code{matlab.lang.makeValidName} or
## @code{matlab.lang.makeUniqueStrings} instead.
##
## Create valid unique variable name(s) from @var{str}.
##
## If @var{str} is a cellstr, then a unique variable is created for each cell
## in @var{str}.
##
## @example
## @group
## genvarname (@{"foo", "foo"@})
##   @result{}
##      @{
##        [1,1] = foo
##        [1,2] = foo1
##      @}
## @end group
## @end example
##
## If @var{exclusions} is given, then the variable(s) will be unique to each
## other and to @var{exclusions} (@var{exclusions} may be either a string or a
## cellstr).
##
## @example
## @group
## x = 3.141;
## genvarname ("x", who ())
##   @result{} x1
## @end group
## @end example
##
## Note that the result is a char array or cell array of strings, not the
## variables themselves.  To define a variable, @code{eval()} can be used.
## The following trivial example sets @code{x} to 42.
##
## @example
## @group
## name = genvarname ("x");
## eval ([name " = 42"]);
##   @result{} x =  42
## @end group
## @end example
##
## This can be useful for creating unique struct field names.
##
## @example
## @group
## x = struct ();
## for i = 1:3
##   x.(genvarname ("a", fieldnames (x))) = i;
## endfor
##   @result{} x =
##      @{
##        a =  1
##        a1 =  2
##        a2 =  3
##      @}
## @end group
## @end example
##
## Since variable names may only contain letters, digits, and underscores,
## @code{genvarname} will replace any sequence of disallowed characters with
## an underscore.  Also, variables may not begin with a digit; in this case
## an @samp{x} is added before the variable name.
##
## Variable names beginning and ending with two underscores @qcode{"__"} are
## valid, but they are used internally by Octave and should generally be
## avoided; therefore, @code{genvarname} will not generate such names.
##
## @code{genvarname} will also ensure that returned names do not clash with
## keywords such as @qcode{"for"} and @qcode{"if"}.  A number will be
## appended if necessary.  Note, however, that this does @strong{not} include
## function names such as @qcode{"sin"}.  Such names should be included in
## @var{exclusions} if necessary.
## @seealso{matlab.lang.makeValidName, matlab.lang.makeUniqueStrings,
## namelengthmax, isvarname, iskeyword, exist, who, tempname, eval}
## @end deftypefn

function varname = genvarname (str, exclusions = {})

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "genvarname is obsolete; use matlab.lang.makeValidName or matlab.lang.makeUniqueStrings instead\n");
  endif

  if (nargin < 1)
    print_usage ();
  endif

  strinput = ischar (str);
  ## Process the inputs
  if (strinput)
    if (rows (str) != 1)
      error ("genvarname: if more than one STR is given, it must be a cellstr");
    endif
    str = {str};
  elseif (! iscellstr (str))
    error ("genvarname: STR must be a string or cellstr");
  endif

  if (ischar (exclusions))
    if (rows (exclusions) != 1)
      error ("genvarname: if more than one exclusion is given, it must be a cellstr");
    endif
    exclusions = {exclusions};
  elseif (! iscellstr (exclusions))
    error ("genvarname: EXCLUSIONS must be a string or cellstr");
  else
    exclusions = exclusions(:);
  endif

  varname = cell (size (str));
  for i = 1:numel (str)
    ## Perform any modifications to the varname to make sure that it is
    ## a valid variable name.

    ## remove invalid characters
    str{i}(! (isalnum (str{i}) | str{i} == "_")) = "_";
    ## do not use keywords
    if (iskeyword (str{i}))
      firstcharacter = toupper (str{i}(1));
      str{i} = ["x", firstcharacter, str{i}(2:end)];
    endif
    ## The variable cannot be empty
    if (isempty (str{i}))
      str{i} = "x";
    endif
    ## Leading underscores are not Matlab compatible
    if (str{i}(1) == "_")
      str{i} = ["x", str{i}];
    endif
    ## it cannot start with a number
    if (isdigit (str{i}(1)))
      str{i} = ["x", str{i}];
    endif

    ## make sure that the variable is unique relative to other variables
    ## and the exclusions list
    excluded = any (strcmp (str{i}, exclusions));
    if (excluded && isdigit (str{i}(end)))
      ## if it is not unique and ends with a digit, add an underscore to
      ## make the variable name more readable ("x1_1" instead of "x11")
      str{i} = [str{i}, "_"];
    endif
    varname(i) = str(i);
    idx = 0;
    while (excluded)
      idx += 1;
      varname{i} = sprintf ("%s%d", str{i}, idx);
      excluded = any (strcmp (varname{i}, exclusions));
    endwhile
    exclusions(end+1) = varname(i);
  endfor

  if (strinput)
    varname = varname{1};
  endif

endfunction


## a single argument
%!assert (genvarname ("a"), "a")
## a single argument with a non-conflicting exception
%!assert (genvarname ("a", "b"), "a")
## a single argument with a conflicting exception
%!assert (genvarname ("a", "a"), "a1")
## a single argument as a cell
%!assert (genvarname ({"a"}), {"a"})
%!assert (genvarname ({"a"}, "b"), {"a"})
%!assert (genvarname ({"a"}, {"b"}), {"a"})
%!assert (genvarname ({"a"}, "a"), {"a1"})
%!assert (genvarname ({"a"}, {"a"}), {"a1"})
## Test different arguments
## orientation
%!assert (genvarname ({"a" "b"}), {"a" "b"})
%!assert (genvarname ({"a";"b"}), {"a";"b"})
%!assert (genvarname ({"a" "a"}), {"a" "a1"})
%!assert (genvarname ({"a" "b";"c" "d"}), {"a" "b";"c" "d"})
%!assert (genvarname ({"a" "a" "a";"a" "a" "a"}),
%!        {"a" "a2" "a4";"a1" "a3" "a5"})
## more than one repetition
%!assert (genvarname ({"a" "a" "a"}), {"a" "a1" "a2"})
%!assert (genvarname ({"a" "a" "a"}, {"a" "a1" "a2"}), {"a3" "a4" "a5"})
## more than one repetition not in order
%!assert (genvarname ({"a" "b" "a" "b" "a"}), {"a" "b" "a1" "b1" "a2"})
## Variable name munging
%!assert (genvarname ("__x__"), "x__x__")
%!assert (genvarname ("123456789"), "x123456789")
%!assert (genvarname ("_$1__"), "x__1__")
%!assert (genvarname ("__foo__", "x__foo__"), "x__foo__1")
%!assert (genvarname ("1million_and1", "x1million_and1"), "x1million_and1_1")
%!assert (genvarname ({"", "", ""}), {"x", "x1", "x2"})
%!assert (genvarname ("if"), "xIf")
%!assert (genvarname ({"if", "if", "if"}), {"xIf", "xIf1", "xIf2"})
## Exclusions in odd format
%!assert (genvarname ("x", {"a", "b"; "x", "d"}), "x1")

## Test input validation
%!error <Invalid call> genvarname ()
%!error <more than one STR is given, it must be a cellstr> genvarname (char ("a", "b", "c"))
%!error <STR must be a string or cellstr> genvarname (1)
%!error <more than one exclusion is given, it must be a cellstr> genvarname ("x", char ("a", "b", "c"))
%!error <EXCLUSIONS must be a string or cellstr> genvarname ("x", 1)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isdir (@var{f})
##
## This function is not recommended.  Use @code{isfolder} or
## @code{file_in_loadpath} instead.
##
## Return true if @var{f} is a directory and false otherwise.
##
## Compatibility Note: The @sc{matlab} function of the same name will also
## search for @var{f} in the load path directories.  To emulate this behavior
## use
##
## @example
## @var{tf} = ! isempty (file_in_loadpath (@var{f}))
## @end example
##
## @seealso{isfolder, file_in_loadpath, exist, stat, is_absolute_filename,
## is_rooted_relative_filename}
## @end deftypefn

function retval = isdir (f)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "isdir is obsolete; use isfolder or dir_in_loadpath instead\n");
  endif

  if (nargin < 1)
    print_usage ();
  endif

  ## Exist returns an integer but isdir should return a logical.
  retval = (exist (f, "dir") == 7);

endfunction


## First test is necessary to provoke 1-time legacy warning
%!test
%! warning ("off", "Octave:legacy-function", "local");
%! isdir (pwd ());

%!assert (isdir (pwd ()))
%!assert (! isdir (tempname ()))

%!error <Invalid call> isdir ()
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} isequalwithequalnans (@var{x1}, @var{x2}, @dots{})
## This function is obsolete.  Use @code{isequaln} instead.
## @seealso{isequaln}
## @end deftypefn

## At one time, Matlab docs stated that this function is obsolete and would be
## removed in some future version.  Now users are told that it should be
## avoided, but there is no mention of possible future removal.

function retval = isequalwithequalnans (varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "isequalwithequalnans is obsolete; please use isequaln instead");
  endif

  retval = isequaln (varargin{:});

endfunction
########################################################################
##
## Copyright (C) 2003-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isstr (@var{x})
## This function is obsolete.  Use @code{ischar} instead.
## @seealso{ischar}
## @end deftypefn

## At one time, Matlab docs stated that this function is obsolete and would be
## removed in some future version.  Now users are told that it should be
## avoided, but there is no mention of possible future removal.

function retval = isstr (varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "isstr is obsolete; please use ischar instead");
  endif

  retval = ischar (varargin{:});

endfunction
########################################################################
##
## Copyright (C) 2021-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{n} =} maxNumCompThreads ()
## @deftypefnx {} {@var{n_old} =} maxNumCompThreads (@var{n})
## @deftypefnx {} {@var{n_old} =} maxNumCompThreads ("automatic")
## This function is provided for @sc{matlab} compatibility only.
##
## The output @var{n} is the number of available processors as determined by
## the @code{nproc} function.
##
## Programming Note: The function may be called with an argument to set the
## number of computational threads, but that setting has @strong{no effect}.
## @seealso{nproc}
## @end deftypefn

function retval = maxNumCompThreads (arg)

  persistent nthreads = nproc ();

  retval = nthreads;

  if (nargin == 1)
    if (isnumeric (arg) && isscalar (arg) && arg == fix (arg)
        && arg > 0 && isfinite (arg))
      ## FIXME: Should there be an upper limit?
      nthreads = arg;
      warning ("Octave:maxNumCompThreads:no-effect",
               "maxNumCompThreads: setting number of threads has no effect");
    elseif (ischar (arg) && strcmpi (arg, "automatic"))
      nthreads = nproc ();
    else
      error ("maxNumCompThreads: invalid input argument");
    endif
  endif

endfunction


%!test
%! maxNumCompThreads ("automatic");
%! assert (maxNumCompThreads (), nproc ());

%!test
%! warning ("off", "Octave:maxNumCompThreads:no-effect", "local");
%! maxNumCompThreads (4);
%! assert (maxNumCompThreads ("automatic"), 4);

%!error <invalid input argument> maxNumCompThreads ([1, 2])
%!error <invalid input argument> maxNumCompThreads ("foobar")
########################################################################
##
## Copyright (C) 2003-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{s} =} setstr (@var{x})
## This function is obsolete.  Use @code{char} instead.
## @seealso{char}
## @end deftypefn

## At one time, Matlab docs stated that this function is obsolete and would be
## removed in some future version.  Now users are told that it should be
## avoided, but there is no mention of possible future removal.

function retval = setstr (varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "setstr is obsolete; please use char instead");
  endif

  retval = char (varargin{:});

endfunction
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} strmatch (@var{s}, @var{A})
## @deftypefnx {} {} strmatch (@var{s}, @var{A}, "exact")
##
## This function is obsolete.  @strong{Use an alternative} such as
## @code{strncmp} or @code{strcmp} instead.
##
## Return indices of entries of @var{A} which begin with the string @var{s}.
##
## The second argument @var{A} must be a string, character matrix, or a cell
## array of strings.
##
## If the third argument @qcode{"exact"} is not given, then @var{s} only
## needs to match @var{A} up to the length of @var{s}.  Trailing spaces and
## nulls in @var{s} and @var{A} are ignored when matching.
##
## For example:
##
## @example
## @group
## strmatch ("apple", "apple juice")
##      @result{} 1
##
## strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
##      @result{} [1; 2]
##
## strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
##      @result{} [1]
## @end group
## @end example
##
## @strong{Caution:} @code{strmatch} is obsolete (and can produce incorrect
## results in @sc{matlab} when used with cell arrays of strings.  Use
## @code{strncmp} (normal case) or @code{strcmp} (@qcode{"exact"} case) in all
## new code.  Other replacement possibilities, depending on application,
## include @code{regexp} or @code{validatestring}.
## @seealso{strncmp, strcmp, regexp, strfind, validatestring}
## @end deftypefn

function idx = strmatch (s, A, exact)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "strmatch is obsolete; use strncmp or strcmp instead\n");
  endif

  if (nargin < 2)
    print_usage ();
  endif

  if (iscellstr (s))
    if (numel (s) > 1)
      error ("strmatch: a cell array S must contain only one string");
    endif
    s = char (s);
  elseif (! ischar (s) || (! isempty (s) && ! isrow (s)))
    error ("strmatch: S must be a string");
  elseif (! (ischar (A) || iscellstr (A)))
    error ("strmatch: A must be a string or cell array of strings");
  endif

  ## Trim blanks and nulls from search string
  if (any (s != " " & s != "\0"))
    s = regexprep (s, "[ \\0]+$", '');
  endif
  len = length (s);

  exact = nargin == 3 && ischar (exact) && strcmp (exact, "exact");

  if (ischar (A))
    [nr, nc] = size (A);
    if (len > nc)
      idx = [];
    else
      match = all (bsxfun (@eq, A(:,1:len), s), 2);
      if (exact)
        AA = A(:,len+1:nc);
        match &= all (AA == " " | AA == "\0", 2);
      endif
      idx = find (match);
    endif
  else
    if (len > 0)
      idx = find (strncmp (s, A, len));
    else
      idx = find (strcmp (s, A));
    endif
    if (exact)
      ## We can't just use strcmp, because we need to ignore spaces at end.
      B = regexprep (A(idx), "[ \\0]+$", '');
      idx = idx(strcmp (s, B));
    endif
  endif

  ## Return exactly sized and shaped values for Matlab compatibility.
  if (isempty (idx))
    idx = [];  # always return 0x0 empty matrix for non-match.
  else
    idx = idx(:);  # always return column vector.
  endif

endfunction


## First test is necessary to provoke 1-time legacy warning
%!test
%! warning ("off", "Octave:legacy-function", "local");
%! strmatch ("", "");

%!assert (strmatch ("a", {"aaa", "bab", "bbb"}), 1)
%!assert (strmatch ("apple", "apple juice"), 1)
%!assert (strmatch ("apple", ["apple pie"; "apple juice"; "an apple"]), [1; 2])
%!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}), [1; 2])
%!assert (strmatch ("apple pie", "apple"), [])
%!assert (strmatch ("a ", "a"), 1)
%!assert (strmatch ("a", "a \0", "exact"), 1)
%!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1)
%!assert (strmatch ("", {"", "foo", "bar", ""}), [1; 4])
%!assert (strmatch ('', {'', '% comment', 'var a = 5', ''}, "exact"), [1;4])

## Weird Matlab corner cases
%!test <*49601>
%! assert (strmatch (" ", " "), 1);
%! assert (strmatch (" ", "   "), 1);
%! assert (strmatch ("  ", " "), []);
%! assert (strmatch ("  ", "  "), 1);
%!test <*54432>
%! assert (strmatch ({"a"}, {"aaa", "bab", "bbb"}), 1);
%! assert (isempty (strmatch ({}, {"aaa", "bab"})));
%!test <*59917>
%! a = { "dfr", "tgh", "rere", "rere" };
%! b = strmatch ("rere", a, "exact");
%! assert (b, [3; 4]);

## Test input validation
%!error <Invalid call to strmatch> strmatch ()
%!error <Invalid call to strmatch> strmatch ("a")
%!error <called with too many inputs> strmatch ("a", "aaa", "exact", 1)
%!error <S must contain only one string> strmatch ({"a", "b"}, "aaa")
%!error <S must be a string> strmatch (1, "aaa")
%!error <S must be a string> strmatch (char ("a", "bb"), "aaa")
%!error <A must be a string> strmatch ("a", 1)
%!error <A must be a string> strmatch ("a", {"hello", [1]})
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## or <https://octave.org/copyright/>.
##
## Parts Copyright (C) 2012-2019 Philip Nienhuis
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{a}, @dots{}] =} strread (@var{str})
## @deftypefnx {} {[@var{a}, @dots{}] =} strread (@var{str}, @var{format})
## @deftypefnx {} {[@var{a}, @dots{}] =} strread (@var{str}, @var{format}, @var{format_repeat})
## @deftypefnx {} {[@var{a}, @dots{}] =} strread (@var{str}, @var{format}, @var{prop1}, @var{value1}, @dots{})
## @deftypefnx {} {[@var{a}, @dots{}] =} strread (@var{str}, @var{format}, @var{format_repeat}, @var{prop1}, @var{value1}, @dots{})
##
## This function is obsolete.  Use @code{textscan} instead.
##
## Read data from a string.
##
## The string @var{str} is split into words that are repeatedly matched to the
## specifiers in @var{format}.  The first word is matched to the first
## specifier, the second to the second specifier and so forth.  If there are
## more words than specifiers, the process is repeated until all words have
## been processed.
##
## The string @var{format} describes how the words in @var{str} should be
## parsed.  It may contain any combination of the following specifiers:
##
## @table @code
## @item %s
## The word is parsed as a string.
##
## @item  %f
## @itemx %n
## The word is parsed as a number and converted to double.
##
## @item  %d
## @itemx %u
## The word is parsed as a number and converted to int32.
##
## @item  %*
## @itemx %*f
## @itemx %*s
## The word is skipped.
##
## For %s and %d, %f, %n, %u and the associated %*s @dots{} specifiers an
## optional width can be specified as %Ns, etc.@: where N is an integer > 1.
## For %f, format specifiers like %N.Mf are allowed.
##
## @item literals
## In addition the format may contain literal character strings; these will be
## skipped during reading.
## @end table
##
## Parsed word corresponding to the first specifier are returned in the first
## output argument and likewise for the rest of the specifiers.
##
## By default, @var{format} is @t{"%f"}, meaning that numbers are read from
## @var{str}.  This will do if @var{str} contains only numeric fields.
##
## For example, the string
##
## @example
## @group
## @var{str} = "\
## Bunny Bugs   5.5\n\
## Duck Daffy  -7.5e-5\n\
## Penguin Tux   6"
## @end group
## @end example
##
## @noindent
## can be read using
##
## @example
## [@var{a}, @var{b}, @var{c}] = strread (@var{str}, "%s %s %f");
## @end example
##
## Optional numeric argument @var{format_repeat} can be used for limiting the
## number of items read:
##
## @table @asis
## @item -1
## (default) read all of the string until the end.
##
## @item N
## Read N times @var{nargout} items.  0 (zero) is an acceptable value for
## @var{format_repeat}.
## @end table
##
## The behavior of @code{strread} can be changed via property-value pairs.  The
## following properties are recognized:
##
## @table @asis
## @item @qcode{"commentstyle"}
## Parts of @var{str} are considered comments and will be skipped.
## @var{value} is the comment style and can be any of the following.
##
## @itemize
## @item @qcode{"shell"}
## Everything from @code{#} characters to the nearest end-of-line is skipped.
##
## @item @qcode{"c"}
## Everything between @code{/*} and @code{*/} is skipped.
##
## @item @qcode{"c++"}
## Everything from @code{//} characters to the nearest end-of-line is skipped.
##
## @item @qcode{"matlab"}
## Everything from @code{%} characters to the nearest end-of-line is skipped.
##
## @item user-supplied.  Two options:
## (1) One string, or 1x1 cell string: Skip everything to the right of it;
## (2) 2x1 cell string array: Everything between the left and right strings
## is skipped.
## @end itemize
##
## @item @qcode{"delimiter"}
## Any character in @var{value} will be used to split @var{str} into words
## (default value = any whitespace).  Note that whitespace is implicitly added
## to the set of delimiter characters unless a @qcode{"%s"} format conversion
## specifier is supplied; see @qcode{"whitespace"} parameter below.  The set
## of delimiter characters cannot be empty; if needed Octave substitutes a
## space as delimiter.
##
## @item @qcode{"emptyvalue"}
## Value to return for empty numeric values in non-whitespace delimited data.
## The default is NaN@.  When the data type does not support NaN (int32 for
## example), then default is zero.
##
## @item @qcode{"multipledelimsasone"}
## Treat a series of consecutive delimiters, without whitespace in between,
## as a single delimiter.  Consecutive delimiter series need not be vertically
## @qcode{"aligned"}.
##
## @item @qcode{"treatasempty"}
## Treat single occurrences (surrounded by delimiters or whitespace) of the
## string(s) in @var{value} as missing values.
##
## @item @qcode{"returnonerror"}
## If @var{value} true (1, default), ignore read errors and return normally.
## If false (0), return an error.
##
## @item @qcode{"whitespace"}
## Any character in @var{value} will be interpreted as whitespace and trimmed;
## the string defining whitespace must be enclosed in double quotes for proper
## processing of special characters like @qcode{"@backslashchar{}t"}.  In
## each data field, multiple consecutive whitespace characters are collapsed
## into one space and leading and trailing whitespace is removed.  The default
## value for whitespace is
## @c Note: the next line specifically has a newline which generates a space
## @c       in the output of qcode, but keeps the next line < 80 characters.
## @qcode{"
## @backslashchar{}b@backslashchar{}r@backslashchar{}n@backslashchar{}t"}
## (note the space).  Whitespace is always added to the set of delimiter
## characters unless at least one @qcode{"%s"} format conversion specifier is
## supplied; in that case only whitespace explicitly specified in
## @qcode{"delimiter"} is retained as delimiter and removed from the set of
## whitespace characters.  If whitespace characters are to be kept as-is (in
## e.g., strings), specify an empty value (i.e., @qcode{""}) for
## @qcode{"whitespace"}; obviously, whitespace cannot be a delimiter then.
##
## @end table
##
## When the number of words in @var{str} doesn't match an exact multiple of
## the number of format conversion specifiers, strread's behavior depends on
## the last character of @var{str}:
##
## @table @asis
## @item last character = @qcode{"@backslashchar{}n"}
## Data columns are padded with empty fields or NaN so that all columns have
## equal length
##
## @item last character is not @qcode{"@backslashchar{}n"}
## Data columns are not padded; strread returns columns of unequal length
##
## @end table
##
## @seealso{textscan, sscanf}
## @end deftypefn

function varargout = strread (str, format = "%f", varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "strread is obsolete; use textscan instead\n");
  endif

  ## Check input
  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (str))
    ## Return empty args (no match), rather than raising an error
    varargout = cell (1, nargout);
    return;
  endif

  if (isempty (format))
    format = "%f";
  endif

  if (! ischar (str) || ! ischar (format))
    error ("strread: STR and FORMAT arguments must be strings");
  endif

  if (strcmp (typeinfo (format), "sq_string"))
    format = do_string_escapes (format);
  endif

  ## Parse format string to compare number of conversion fields and nargout
  nfields = numel (regexp (format, '(%(\d*|\d*\.\d*)?[nfduscq]|%\[)', "match"));
  ## If str only has numeric fields, a (default) format ("%f") will do.
  ## Otherwise:
  if (! nfields)
    error ("strread.m: no valid format conversion specifiers found\n");
  elseif ((max (nargout, 1) != nfields) && ! strcmp (format, "%f"))
    error ("strread: the number of output variables must match that specified by FORMAT");
  endif

  ## Check for format string repeat count
  format_repeat_count = -1;
  if (nargin > 2 && isnumeric (varargin{1}))
    if (varargin{1} >= 0)
      format_repeat_count = varargin{1};
    endif
    if (nargin > 3)
      varargin = varargin(2:end);
    else
      varargin = {};
    endif
  endif

  ## Parse options.  First initialize defaults
  comment_flag = false;
  open_comment = false;
  cmt_eol = "\n";
  delimiter_str = "";
  empty_str = "";
  eol_char = "";
  err_action = 0;
  mult_dlms_s1 = false;
  numeric_fill_value = NaN;
  white_spaces = " \b\r\n\t";
  for n = 1:2:length (varargin)
    switch (lower (varargin{n}))
      case "bufsize"
        ## We could synthesize this, but that just seems weird...
        warning ("strread: property 'bufsize' is not implemented");
      case "commentstyle"
        comment_flag = true;
        switch (lower (varargin{n+1}))
          case "c"
            [comment_start, comment_end] = deal ("/*", "*/");
          case "c++"
            [comment_start, comment_end] = deal ("//", "cmt_eol");
            open_comment = true;
          case "shell"
            [comment_start, comment_end] = deal ("#" , "cmt_eol");
            open_comment = true;
          case "matlab"
            [comment_start, comment_end] = deal ("%" , "cmt_eol");
            open_comment = true;
          otherwise
            if (ischar (varargin{n+1})
                || (numel (varargin{n+1}) == 1 && iscellstr (varargin{n+1})))
              [comment_start, comment_end] = deal (char (varargin{n+1}), "cmt_eol");
            open_comment = true;
            elseif (iscellstr (varargin{n+1}) && numel (varargin{n+1}) == 2)
              [comment_start, comment_end] = deal (varargin{n+1}{:});
            else
              ## FIXME: A user may have numeric values specified: {'//', 7}
              ##        this will lead to an error in the warning message
              error ("strread: unknown or unrecognized comment style '%s'",
                      varargin{n+1});
            endif
        endswitch
      case "delimiter"
        delimiter_str = varargin{n+1};
        if (strcmp (typeinfo (delimiter_str), "sq_string"))
          delimiter_str = do_string_escapes (delimiter_str);
        endif
      case "emptyvalue"
        numeric_fill_value = varargin{n+1};
      case "expchars"
        warning ("strread: property 'expchars' is not implemented");
      case "whitespace"
        white_spaces = varargin{n+1};
        if (strcmp (typeinfo (white_spaces), "sq_string"))
          white_spaces = do_string_escapes (white_spaces);
        endif
      ## The following parameters are specific to textscan and textread
      case "endofline"
        eol_char = varargin{n+1};
        if (strcmp (typeinfo (eol_char), "sq_string"))
          eol_char = do_string_escapes (eol_char);
        endif
        cmt_eol = eol_char;
        open_comment = false;
      case "returnonerror"
        err_action = varargin{n+1};
      case "multipledelimsasone"
        mult_dlms_s1 = varargin{n+1};
      case "treatasempty"
        if (iscellstr (varargin{n+1}))
          empty_str = varargin{n+1};
        elseif (ischar (varargin{n+1}))
          empty_str = varargin(n+1);
        else
          error ("strread: 'treatasempty' value must be string or cellstr");
        endif
      otherwise
        warning ("strread: unknown property '%s'", varargin{n});
    endswitch
  endfor

  ## First parse of FORMAT
  if (strcmpi (strtrim (format), "%f"))
    ## Default format specified.  Expand it (to desired nargout)
    fmt_words = cell (max (nargout, 1), 1);
    fmt_words (1:max (nargout, 1)) = format;
  else
    ## Determine the number of words per line as a first guess.  Forms
    ## like %f<literal>) (w/o delimiter in between) are fixed further on
    format = strrep (format, "%", " %");
    fmt_words = regexp (format, '[^ ]+', "match");

    ## Find position of conversion specifiers (they start with %)
    fcs_ptrn = '(%\*?(\d*|\d*\.\d*)?[nfduscq]|%\*?\[)';
    idy2 = find (! cellfun ("isempty", regexp (fmt_words, fcs_ptrn)));

    ## Check for unsupported format specifiers
    errpat = '(\[.*\]|[cq]|[nfdu]8|[nfdu]16|[nfdu]32|[nfdu]64)';
    if (! all (cellfun ("isempty", regexp (fmt_words(idy2), errpat))))
      error ("strread: %q, %c, %[] or bit width format specifiers are not supported yet");
    endif

    ## Format conversion specifiers following literals w/o space/delim
    ## in between are separate now.  Separate those w trailing literals
    a = strfind (fmt_words(idy2), "%");
    b = regexp (fmt_words(idy2), '[nfdus]', "end");
    for jj = 1:numel (a)
      ## From right to left to avoid losing track
      ii = numel (a) - jj + 1;
      ## Check for illegal format specifiers
      if (isempty (b{ii}))
        error ("strread: unknown format specifier #%d ('%s')\n",
              ii, fmt_words{idy2(ii)});
      endif
      if (! (length (fmt_words{idy2(ii)}) == b{ii}(1)))
        ## Split fmt_words(ii) into % conv specifier and trailing literal
        fmt_words(idy2(ii)+1 : end+1) = fmt_words(idy2(ii) : end);
        fmt_words{idy2(ii)} = fmt_words{idy2(ii)}(a{ii} : b{ii}(1));
        fmt_words{idy2(ii)+1} = fmt_words{idy2(ii)+1}(b{ii}+1:end);
      endif
    endfor
  endif
  num_words_per_line = numel (fmt_words);

  ## Special handling for CRLF EOL character in str
  if (! isempty (eol_char) && strcmp (eol_char, "\r\n"))
    ## Strip CR from CRLF sequences
    str = strrep (str, "\r\n", "\n");
    ## CR serves no further purpose in function
    eol_char = "\n";
  endif

  ## Remove comments in str
  if (comment_flag)
    ## Expand 'cmt_eol' here, after option processing which may have set value
    comment_end = strrep (comment_end, "cmt_eol", cmt_eol);
    cstart = strfind (str, comment_start);
    cstop  = strfind (str, comment_end);
    if (open_comment)
      cstop -= 1;
    endif
    ## Treat end of string as additional comment stop
    if (isempty (cstop) || cstop(end) != length (str))
      cstop(end+1) = length (str);
    endif
    if (! isempty (cstart))
      ## Ignore nested openers.
      [idx, cidx] = unique (lookup (cstop, cstart), "first");
      if (idx(end) == length (cstop))
        cidx(end) = []; # Drop the last one if orphaned.
      endif
      cstart = cstart(cidx);
    endif
    if (! isempty (cstop))
      ## Ignore nested closers.
      [idx, cidx] = unique (lookup (cstart, cstop), "first");
      if (idx(1) == 0)
        cidx(1) = []; # Drop the first one if orphaned.
      endif
      cstop = cstop(cidx);
    endif
    len = length (str);
    c2len = length (comment_end);
    if (cstop + c2len == len)
      ## Ignore last char of to-the-end-of-line comments
      c2len += 1;
    endif
    str = cellslices (str, [1, cstop + c2len], [cstart - 1, len]);
    str = [str{:}];
  endif

  if (! isempty (white_spaces))
    ## For numeric fields, whitespace is always a delimiter, but not for text
    ## fields
    if (isempty (regexp (format, '%\*?\d*s')))
      ## Add whitespace to delimiter set
      delimiter_str = unique ([white_spaces delimiter_str]);
    else
      ## Remove any delimiter chars from white_spaces list
      white_spaces = setdiff (white_spaces, delimiter_str);
    endif
  endif
  if (isempty (delimiter_str))
    delimiter_str = " ";
  endif
  if (! isempty (eol_char))
    ## Add eol_char to delimiter collection
    delimiter_str = unique ([delimiter_str eol_char]);
    ## and remove it from whitespace collection
    white_spaces = strrep (white_spaces, eol_char, '');
  endif

  ii = numel (fmt_words);
  while (ii > 0)
    if (ismember (fmt_words{ii}, delimiter_str)(1))
      fmt_words(ii) = [];
      --num_words_per_line;
    endif
    --ii;
  endwhile

  pad_out = 0;
  ## Trim whitespace if needed
  if (! isempty (white_spaces))
    ## Check if trailing "\n" might signal padding output arrays to equal size
    ## before it is trimmed away below
    if (str(end) == "\n" && nargout > 1)
      pad_out = 1;
    endif
    ## Condense all repeated whitespace into one single space
    ## FIXME: this will also fold repeated whitespace in a char field
    rxp_wsp = sprintf ("[%s]+", white_spaces);
    str = regexprep (str, rxp_wsp, ' ');
    ## Remove possible leading space at string
    if (str(1) == " ")
       str = str(2:end);
    endif
    ## Check for single delimiter followed/preceded by whitespace
    if (! isempty (delimiter_str))
      dlmstr = setdiff (delimiter_str, " ");
      if (! isempty (dlmstr))
        rxp_dlmwsp = sprintf ('( [%s] | [%s]|[%s] )', dlmstr, dlmstr, dlmstr);
        str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
      endif
    endif
    ## Wipe leading and trailing whitespace on each line (it may be
    ## delimiter too)
    ## FIXME: Double strrep on str is enormously expensive in CPU time.
    ## Can this be eliminated?
    if (! isempty (eol_char))
      str = strrep (str, [eol_char " "], eol_char);
      str = strrep (str, [" " eol_char], eol_char);
    endif
  endif

  ## Split 'str' into words
  words = split_by (str, delimiter_str, mult_dlms_s1, eol_char);
  if (! isempty (white_spaces))
    ## Trim leading and trailing 'white_spaces'.
    ## All whitespace has been converted to space above
    words = strtrim (words);
  endif
  num_words = numel (words);
  ## First guess at nr. of lines in file (ignoring leading/trailing literals)
  num_lines = ceil (num_words / num_words_per_line);

  ## Replace TreatAsEmpty char sequences by empty strings
  if (! isempty (empty_str))
    for ii = 1:numel (empty_str)
      idz = strncmp (empty_str{ii}, words, length (empty_str{ii}));
      words(idz) = {""};
    endfor
  endif

  ## fmt_words has been split properly now, but words{} has only been split on
  ## delimiter positions.  As numeric fields can also be separated by
  ## whitespace, more splits may be needed.
  ## We also don't know the number of lines (as EndOfLine may have been set to
  ## "" (empty) by the caller).
  ##
  ## We also may have to cope with 3 cases as far as literals go:
  ## A: Trailing literals (%f<literal>) w/o delimiter in between.
  ## B: Leading literals (<literal>%f) w/o delimiter in between.
  ## C. Skipping leftover parts of specified skip fields (%*N )
  ## Some words columns may have to be split further to fix these.
  ## To find out, we'll match fmt_words to the words array to see what
  ## needs to be done.  fwptr tracks which {fmt_words} starts in what {words}

  ## Find indices and pointers to possible literals in fmt_words
  idf = cellfun ("isempty", strfind (fmt_words, "%"));
  ## Find indices and pointers to conversion specifiers with fixed width
  idg = ! cellfun ("isempty", regexp (fmt_words, '%\*?\d'));
  idy = find (idf | idg);
  ## Find indices to numeric conversion specifiers
  idn = ! cellfun ("isempty", regexp (fmt_words, '%[dnfu]'));

  ## If needed, split up columns in three steps:
  if (! isempty (idy))
    ## Try-catch because complexity of strings to read can be infinite
    try

      ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
      ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
      ## Alternative below goes by simply parsing a first grab of words and
      ## matching fmt_words to words until the fmt_words array is exhausted.
      ## iwrd: ptr to current analyzed word.
      ## iwrdp: ptr to pos before analyzed char.
      iwrd = 1; iwrdp = 0; iwrdl = length (words{1});
      fwptr = zeros (1, numel (fmt_words));
      ii = 1;
      while (ii <= numel (fmt_words))

        nxt_wrd = 0;
        ## Keep track of which words nr. every fmt_words{} is (starts) in.
        fwptr(ii) = iwrd;

        if (idf(ii))
          ## Literal expected
          if (isempty (strfind (fmt_words{ii}, words(iwrd))))
            ## Not found in current word; supposed to be in next word
            nxt_wrd = 1;
          else
            ## Found it in current word.  Subtract literal length
            iwrdp += length (fmt_words{ii});
            if (iwrdp > iwrdl)
              ## Parse error.  Literal extends beyond delimiter (word boundary)
              warning ("strread: literal '%s' (fmt spec # %d) does not match data", ...
                fmt_words{ii}, ii);
              ## Word assumed to be completely "used up".  Next word
              nxt_wrd = 1;
            elseif (iwrdp == iwrdl)
              ## Word completely "used up".  Next word
              nxt_wrd = 1;
            endif
          endif

        elseif (idg(ii))
          ## Fixed width specifier (%N or %*N): read just a part of word
          sw = regexp (fmt_words{ii}, '\d', "once");
          ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
          iwrdp += floor (str2double (fmt_words{ii}(sw:ew)));
          if (iwrdp > iwrdl)
            ## Match error.  Field extends beyond word boundary.
            warning  ...
            ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
               fmt_words{ii}, ii);
            ## Assume word to be completely "used up".  Next word
            nxt_wrd = 1;
          elseif (iwrdp == iwrdl)
            ## Word completely "used up".  Next word
            nxt_wrd = 1;
          endif

        else
          ## A simple format conv. specifier.  Either (1) uses rest of word, or
          ## (2) is squeezed between current iwrdp and next literal, or (3) uses
          ## next word. (3) is already taken care of.  So just check (1) & (2)
          if (ii < numel (fmt_words) && idf(ii+1))
            ## Next fmt_word is a literal...
            if (! index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}))
              ## ...but not found in current word => field uses rest of word
              nxt_wrd = 1;
            else
              ## ..or it IS found.  Add inferred width of current conversion field
              iwrdp += index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}) - 1;
            endif
          elseif (iwrdp <= iwrdl)
            ## No bordering literal to the right => field occupies (rest of) word
            nxt_wrd = 1;
          endif

        endif

        if (nxt_wrd)
          ++iwrd; iwrdp = 0;
          if (iwrd > numel (words))
            ## Apparently EOF; assume incomplete row already at L.1 of data
            ii = numel (fmt_words);
          elseif (ii < numel (fmt_words) && iwrd <= numel (words))
            iwrdl = length (words{iwrd});
          endif
        endif

        ++ii;

      endwhile
      ## Done
      words_period = max (iwrd - 1, 1);
      num_lines = ceil (num_words / words_period);

      ## 2. Pad words array so that it can be reshaped
      num_words_padded = num_lines * words_period - num_words;
      if (num_words_padded)
        words = [words'; cell(num_words_padded, 1)];
      endif
      words = reshape (words, words_period, num_lines);

      ## 3. Do the column splitting on rectangular words array
      icol = 1; ii = 1;    # icol = current column, ii = current fmt_word
      while (ii <= num_words_per_line)

        ## Check if fmt_words(ii) contains a literal or fixed-width
        if ((idf(ii) || idg(ii)) && (rows (words) < num_words_per_line))
          if (idf(ii))
            s = strfind (words(icol, 1), fmt_words{ii});
            if (isempty (s{:}))
              error ("strread: Literal '%s' not found in column %d", fmt_words{ii}, icol);
            endif
            s = s{:}(1);
            e = s(1) + length (fmt_words{ii}) - 1;
          endif
          if (! strcmp (fmt_words{ii}, words{icol, 1}))
            ## Column doesn't exactly match literal => split needed.
            ## Insert a column
            words(icol+1:end+1, :) = words(icol:end, :);
            ## Watch out for empty cells
            jptr = find (! cellfun ("isempty", words(icol, :)));

            ## Distinguish leading or trailing literals
            if (! idg(ii) && ! isempty (s) && s(1) == 1)
              ## Leading literal.
              ## Assign literal to icol, paste rest in icol + 1
              ## Apply only to those cells that do have something beyond literal
              jptr = find (cellfun ("length", words(icol+1, jptr), ...
                                    "UniformOutput", false) > e(1));
              words(icol+1, :) = {""};
              words(icol+1, jptr) = cellfun (
                @(x) substr (x, e(1)+1, length (x) - e(1)), words(icol, jptr),
                "UniformOutput", false);
              words(icol, jptr) = fmt_words{ii};
              fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];

            else
              if (idg(ii))
                ## Current field = fixed width.
                ## Strip into icol, rest in icol+1
                sw = regexp (fmt_words{ii}, '\d', "once");
                ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
                wdth = floor (str2double (fmt_words{ii}(sw:ew)));
                words(icol+1, jptr) = cellfun (@(x) x(wdth+1:end),
                     words(icol,jptr), "UniformOutput", false);
                if (isempty ([words(icol+1, :){:}]))
                  ## Apparently split wasn't needed as turns out to cover
                  ## entire column. So delete column again
                  words(icol+1, :) = [];
                else
                  words(icol, jptr) = strtrunc (words(icol, jptr), wdth);
                  fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
                endif
              else
                if (! isempty (strfind (fmt_words{ii-1}, "%s")))
                  ## Trailing literal.
                  ## Could be ambiguous if preceding format == '%s'
                  warning ("strread.m:\n  Ambiguous '%%s' specifier immediately before literal in column %d", icol);
                endif
                ## FIXME: this assumes char(254)/char(255) won't occur in input!
                clear wrds;
                wrds(1:2:2*numel (words(icol, jptr))) = ...
                     strrep (words(icol, jptr), fmt_words{ii}, ...
                     [char(255) char(254)]);
                wrds(2:2:2*numel (words(icol, jptr))-1) = char (255);
                wrds = ostrsplit ([wrds{:}], char (255));
                words(icol, jptr) = ...
                  wrds(find (cellfun ("isempty", strfind (wrds, char (254)))));
                wrds(find (cellfun ("isempty", strfind (wrds, char (254))))) ...
                   = char (255);
                words(icol+1, jptr) = ostrsplit (strrep ([wrds{2:end}], ...
                   char (254), fmt_words{ii}), char (255));
                ## Former trailing literal may now be leading for next specifier
                --ii;
                fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
              endif
            endif
          endif

        else
          ## Conversion specifier.
          ## Peek if next fmt_word needs split from current column.
          if (ii < num_words_per_line)
            if (fwptr(ii) == fwptr(ii+1))
              --icol;
            endif
          endif
        endif
        ## Next fmt_word, next column
        ++ii; ++icol;
      endwhile

      ## Done.
      ## Reshape words back into one long vector and strip padded empty words
      words = reshape (words, 1, numel (words))(1 : end-num_words_padded);

    catch
      warning ("strread: unable to parse text or file with given format string");
      return;

    end_try_catch
  endif

  ## For each specifier, process corresponding column
  k = 1;
  for m = 1:num_words_per_line
    try
      if (format_repeat_count < 0)
        data = words(m:num_words_per_line:end);
      elseif (format_repeat_count == 0)
        data = {};
      else
        lastline = ...
          min (num_words_per_line * format_repeat_count + m - 1, numel (words));
        data = words(m:num_words_per_line:lastline);
        if (num_lines > format_repeat_count)
          num_lines = format_repeat_count;
        endif
      endif

      ## Map to format
      ## FIXME: Add support for formats like "<%s>", "%[a-zA-Z]"
      ##        Someone with regexp experience is needed.
      switch (fmt_words{m}(1:min (2, length (fmt_words{m}))))
        case "%s"
          if (pad_out)
            data(end+1:num_lines) = {""};
          endif
          varargout{k} = data';
          k += 1;
        case {"%d", "%u", "%f", "%n"}
          n = cellfun ("isempty", data);
          ### FIXME: Erroneously formatted data lead to NaN, not an error
          data = str2double (data);
          if (! isempty (regexp (fmt_words{m}, "%[du]")))
            ## Cast to integer
            ## FIXME: NaNs will be transformed into zeros
            data = int32 (data);
          endif
          data(n) = numeric_fill_value;
          if (pad_out)
            data(end+1:num_lines) = numeric_fill_value;
          endif
          varargout{k} = data.';
          k += 1;
        case {"%0", "%1", "%2", "%3", "%4", "%5", "%6", "%7", "%8", "%9"}
          sw = regexp (fmt_words{m}, '\d', "once");
          ew = regexp (fmt_words{m}, '[nfudsq]') - 1;
          nfmt = ostrsplit (fmt_words{m}(2:ew), ".");
          swidth = str2double (nfmt{1});
          switch (fmt_words{m}(ew+1))
            case {"d", "u", "f", "n"}
              n = cellfun ("isempty", data);
              ### FIXME: Erroneously formatted data lead to NaN, not an error
              ###        => ReturnOnError can't be implemented for numeric data
              data = str2double (strtrunc (data, swidth));
              data(n) = numeric_fill_value;
              if (pad_out)
                data(end+1:num_lines) = numeric_fill_value;
              endif
              if (numel (nfmt) > 1)
                sprec = str2double (nfmt{2});
                data = 10^-sprec * round (10^sprec * data);
              elseif (! isempty (regexp (fmt_words{m}, "[du]")))
                ## Cast to integer
                ## FIXME: NaNs will be transformed into zeros
                data = int32 (data);
              endif
              varargout{k} = data.';
              k += 1;
            case "s"
              if (pad_out)
                data(end+1:num_lines) = {""};
              endif
              varargout{k} = strtrunc (data, swidth)';
              k += 1;
            otherwise
          endswitch
        case {"%*", "%*s"}
          ## skip the word
        otherwise
          ## Ensure descriptive content is consistent.
          ## Test made a bit lax to accommodate for incomplete last lines
          n = find (! cellfun ("isempty", data));
          if (numel (unique (data(n))) > 1
              || ! strcmpi (unique (data), fmt_words{m}))
            error ("strread: FORMAT does not match data");
          endif
      endswitch
    catch
      ## As strread processes columnwise, ML-compatible error processing
      ## (row after row) is not feasible.  In addition Octave sets
      ## unrecognizable numbers to NaN w/o error.  But maybe Octave is better
      ## in this respect.
      if (err_action)
        ## Just try the next column where ML bails out
      else
        rethrow (lasterror);
      endif
    end_try_catch
  endfor

endfunction

function out = split_by (text, sep, mult_dlms_s1, eol_char)

  ## Check & if needed, process MultipleDelimsAsOne parameter
  if (mult_dlms_s1)
    mult_dlms_s1 = true;
    ## FIXME: Should re-implement strsplit() function here in order
    ## to avoid strrep on megabytes of data.
    ## If \n is in sep collection we need to enclose it in text
    ## to avoid it being included in consecutive delim series
    enchr = ' ';
    ## However watch out if eol_char is also in delimiters
    if (index (sep, eol_char)); enchr = char (255); endif
    text = strrep (text, eol_char, [enchr eol_char enchr]);
  else
    mult_dlms_s1 = false;
  endif

  ## Split text string along delimiters
  out = ostrsplit (text, sep, mult_dlms_s1);
  if (index (sep, eol_char)); out = strrep (out, char (255), ''); endif
  ## In case of trailing delimiter, strip stray last empty word
  if (! isempty (out) && any (sep == text(end)) && ! mult_dlms_s1)
    out(end) = [];
  endif

  ## Empty cells converted to empty cellstrings.
  out(cellfun ("isempty", out)) = {""};

endfunction


## First test is necessary to provoke 1-time legacy warning
%!test
%! warning ("off", "Octave:legacy-function", "local");
%! strread ("");

%!test
%! [a, b] = strread ("1 2", "%f%f");
%! assert (a, 1);
%! assert (b, 2);

%!test
%! str = "";
%! a = rand (10, 1);
%! b = char (randi ([65, 85], 10, 1));
%! for k = 1:10
%!   str = sprintf ("%s %.6f %s\n", str, a(k), b(k));
%! endfor
%! [aa, bb] = strread (str, "%f %s");
%! assert (aa, a, 1e-6);
%! assert (bb, cellstr (b));

%!test
%! str = "";
%! a = rand (10, 1);
%! b = char (randi ([65, 85], 10, 1));
%! for k = 1:10
%!   str = sprintf ("%s %.6f %s\n", str, a(k), b(k));
%! endfor
%! aa = strread (str, "%f %*s");
%! assert (aa, a, 1e-6);

%!test
%! str = sprintf ("/* this is\nacomment*/ 1 2 3");
%! a = strread (str, "%f", "commentstyle", "c");
%! assert (a, [1; 2; 3]);

%!test
%! str = "# comment\n# comment\n1 2 3";
%! [a, b] = strread (str, "%n %s", "commentstyle", "shell", "endofline", "\n");
%! assert (a, [1; 3]);
%! assert (b, {"2"});

%!test
%! assert (strread ("Hello World! // this is comment", "%s",
%!                  "commentstyle", "c++"),
%!         {"Hello"; "World!"});
%! assert (strread ("Hello World! % this is comment", "%s",...
%!                  "commentstyle", "matlab"), ...
%!         {"Hello"; "World!"});
%! assert (strread ("Hello World! # this is comment", "%s",...
%!                  "commentstyle", "shell"), ...
%!         {"Hello"; "World!"});

%!test <*49454>
%! assert (strread ("hello%foo\nworld, another%bar\r\nday", "%s", ...
%!                  "commentstyle", "matlab", "delimiter", " ,"),...
%!         {"hello"; "world"; "another"; "day"});

%!test
%! str = sprintf ("Tom 100 miles/hr\nDick 90 miles/hr\nHarry 80 miles/hr");
%! fmt = "%s %f miles/hr";
%! c = cell (1, 2);
%! [c{:}] = strread (str, fmt);
%! assert (c{1}, {"Tom"; "Dick"; "Harry"});
%! assert (c{2}, [100; 90; 80]);

%!test
%! a = strread ("a b c, d e, , f", "%s", "delimiter", ",");
%! assert (a, {"a b c"; "d e"; ""; "f"});

%! ## Format repeat counters w & w/o trailing EOL even within partly read files
%!test
%! [a, b] = strread ("10 a 20 b\n 30 c 40", "%d %s", 4);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"});
%! [a, b] = strread ("10 a 20 b\n 30 c 40\n", "%d %s", 4);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; ""});
%! [a, b] = strread ("10 a 20 b\n 30 c 40", "%d %s", 1);
%! assert (a, int32 (10));
%! assert (b, {"a"});

%!test <*33536>
%! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
%! assert (a{1}, "1");
%! assert (b{1}, "");
%! assert (c{1}, "2");

%!test <*33536>
%!test
%! a = strread ("[SomeText]", "[%s", "delimiter", "]");
%! assert (a{1}, "SomeText");

%!test
%! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
%! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
%! assert (a{2}, "=  =  =  =  =");
%! assert (double (a{3}(end-5:end)), [32 110 97 109 101 62]);

%!test
%! [a, b, c, d] = strread ("1,2,3,,5,6", "%d%f%d%f", "delimiter", ",");
%! assert (c, int32 (3));
%! assert (d, NaN);

%!test
%! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", "delimiter", ",");
%! assert (c, [3; NaN]);
%! assert (d, int32 ([0; 0]));

## Default format (= %f)
%!test
%! [a, b, c] = strread ("0.12 0.234 0.3567");
%! assert (a, 0.12);
%! assert (b, 0.234);
%! assert (c, 0.3567);

%!test
%! [a, b] = strread ("0.41 8.24 3.57 6.24 9.27", "%f%f", 2, "delimiter", " ");
%! assert (a, [0.41; 3.57]);

## TreatAsEmpty
%!test
%! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",", "TreatAsEmpty", "NN");
%! assert (c, int32 ([3; 0]));
%! assert (d, [NaN; NaN]);

## No delimiters at all besides EOL.  Plain reading numbers & strings
%!test
%! str = "Text1Text2Text\nText398Text4Text\nText57Text";
%! [a, b] = strread (str, "Text%dText%1sText");
%! assert (a, int32 ([1; 398; 57]));
%! assert (b(1:2), {"2"; "4"});
%! assert (isempty (b{3}), true);

## MultipleDelimsAsOne
%!test
%! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
%! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
%! assert (a', [11, 21, NaN]);
%! assert (b', [12, 23, 33]);
%! assert (c', [13, 24, 34]);
%! assert (d', [15, 25, 35]);

%!assert <*44750> (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
%!                {"home"; "foo"})

## delimiter as sq_string and dq_string
%!assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
%!        strread ("1\n2\n3", "%d", "delimiter", '\n'))

## whitespace as sq_string and dq_string
%!assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
%!        strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))

%!test
%! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
%! fmt = "%f %f %f";
%! args = {"delimiter", " ", "endofline", "\n", "whitespace", " "};
%! [a, b, c] = strread (str, fmt, args{:});
%! assert (a, [0.31; 0.60], 0.01);
%! assert (b, [0.86; 0.72], 0.01);
%! assert (c, [0.94; 0.87], 0.01);

%!test
%! str =  "0.31,0.86,0.94\n0.60,0.72,0.87";
%! fmt = "%f %f %f";
%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
%! [a, b, c] = strread (str, fmt, args{:});
%! assert (a, [0.31; 0.60], 0.01);
%! assert (b, [0.86; 0.72], 0.01);
%! assert (c, [0.94; 0.87], 0.01);

%!test
%! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
%! fmt = "%f %f %f";
%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
%! [a, b, c] = strread (str, fmt, args{:});
%! assert (a, [0.31; 0.60], 0.01);
%! assert (b, [0.86; 0.72], 0.01);
%! assert (c, [0.94; 0.87], 0.01);

%!test
%! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
%! fmt = "%f %f %f";
%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
%! [a, b, c] = strread (str, fmt, args{:});
%! assert (a, [0.31; 0.60], 0.01);
%! assert (b, [0.86; 0.72], 0.01);
%! assert (c, [0.94; 0.87], 0.01);

%!test
%! [a, b] = strread (["Empty 1" char(10)], "Empty%s %f");
%! assert (a{1}, '1');
%! assert (b, NaN);

%!test
%! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
%! assert (a, NaN);
%! assert (b, NaN);

%!test <*35999>
%! [a, b, c] = strread ("", "%f");
%! assert (isempty (a));
%! assert (isempty (b));
%! assert (isempty (c));

%!test <*37023>
%! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
%! assert (a, [1; 2], 1e-15);
%! assert (b, [1; 3], 1e-15);

## Test for no output arg (interactive use)
%!assert (strread (",2,,4\n5,,7,", "", "delimiter", ","),
%!        [NaN; 2; NaN; 4; 5; NaN; 7])

## Test #1 bug #42609
%!test <*42609>
%! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", "%f %f %f\n");
%! assert (a, [1; 4; 7]);
%! assert (b, [2; 5; 8]);
%! assert (c, [3; 6; 9]);

## Test #2 bug #42609
%!test <*42609>
%! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", "%f %f\n%f");
%! assert (a, [1;4;7]);
%! assert (b, [2; 5; 8]);
%! assert (c, [3; 6; 9]);

## Test #3 bug #42609
%!test <*42609>
%! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", '%f %f %f\n');
%! assert (a, [1; 4; 7]);
%! assert (b, [2; 5; 8]);
%! assert (c, [3; 6; 9]);

## Test #4 bug #42609
%!test <*42609>
%! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", '%f %f\n%f');
%! assert (a, [1;4;7]);
%! assert (b, [2; 5; 8]);
%! assert (c, [3; 6; 9]);

## Unsupported format specifiers
%!error <format specifiers are not supported> strread ("a", "%c")
%!error <format specifiers are not supported> strread ("a", "%*c %d")
%!error <format specifiers are not supported> strread ("a", "%q")
%!error <format specifiers are not supported> strread ("a", "%*q %d")
%!error <format specifiers are not supported> strread ("a", "%[a]")
%!error <format specifiers are not supported> strread ("a", "%*[a] %d")
%!error <format specifiers are not supported> strread ("a", "%[^a]")
%!error <format specifiers are not supported> strread ("a", "%*[^a] %d")
%!error <format specifiers are not supported> strread ("a", "%d8")
%!error <format specifiers are not supported> strread ("a", "%*d8 %s")
%!error <format specifiers are not supported> strread ("a", "%f64")
%!error <format specifiers are not supported> strread ("a", "%*f64 %s")
%!error <format specifiers are not supported> strread ("a", "%u32")
%!error <format specifiers are not supported> strread ("a", "%*u32 %d")

## Illegal format specifiers
%!error <no valid format conversion specifiers> strread ("1.0", "%z")

## Test for false positives in check for non-supported format specifiers
%!assert (strread ("Total: 32.5 % (of cm values)","Total: %f % (of cm values)"),
%!        32.5, 1e-5)

## Test various forms of string format specifiers
%!test <*45712>
%! str = "14 :1 z:2 z:3 z:5 z:11";
%! [a, b, c, d] = strread (str, "%f %s %*s %3s %*3s %f", "delimiter", ":");
%! assert ({a, b, c, d}, {14, {"1 z"}, {"3 z"}, 11});

## Allow cuddling %sliteral but warn that it is ambiguous
%!warning <Ambiguous '%s' specifier immediately before literal in column 1>
%! [a, b] = strread ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
%! assert (a([1 3]), {"abc"; "##"});
%! assert (isempty (a{2}), true);
%! assert (b, int32([51; 83; 101]));
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{a}, @dots{}] =} textread (@var{filename})
## @deftypefnx {} {[@var{a}, @dots{}] =} textread (@var{filename}, @var{format})
## @deftypefnx {} {[@var{a}, @dots{}] =} textread (@var{filename}, @var{format}, @var{n})
## @deftypefnx {} {[@var{a}, @dots{}] =} textread (@var{filename}, @var{format}, @var{prop1}, @var{value1}, @dots{})
## @deftypefnx {} {[@var{a}, @dots{}] =} textread (@var{filename}, @var{format}, @var{n}, @var{prop1}, @var{value1}, @dots{})
##
## This function is obsolete.  Use @code{textscan} instead.
##
## Read data from a text file.
##
## The file @var{filename} is read and parsed according to @var{format}.  The
## function behaves like @code{strread} except it works by parsing a file
## instead of a string.  See the documentation of @code{strread} for details.
##
## In addition to the options supported by @code{strread}, this function
## supports two more:
##
## @itemize
## @item @qcode{"headerlines"}:
## The first @var{value} number of lines of @var{filename} are skipped.
##
## @item @qcode{"endofline"}:
## Specify a single character or
## @qcode{"@backslashchar{}r@backslashchar{}n"}.  If no value is given, it
## will be inferred from the file.  If set to @qcode{""} (empty string) EOLs
## are ignored as delimiters.
## @end itemize
##
## The optional input @var{n} (format repeat count) specifies the number of
## times the format string is to be used or the number of lines to be read,
## whichever happens first while reading.  The former is equivalent to
## requesting that the data output vectors should be of length @var{N}.
## Note that when reading files with format strings referring to multiple
## lines, @var{n} should rather be the number of lines to be read than the
## number of format string uses.
##
## If the format string is empty (not just omitted) and the file contains only
## numeric data (excluding headerlines), textread will return a rectangular
## matrix with the number of columns matching the number of numeric fields on
## the first data line of the file.  Empty fields are returned as zero values.
##
## Examples:
##
## @example
## @group
##   Assume a data file like:
##   1 a 2 b
##   3 c 4 d
##   5 e
## @end group
## @end example
##
## @example
## @group
##   [a, b] = textread (f, "%f %s")
##   returns two columns of data, one with doubles, the other a
##   cellstr array:
##   a = [1; 2; 3; 4; 5]
##   b = @{"a"; "b"; "c"; "d"; "e"@}
## @end group
## @end example
##
## @example
## @group
##   [a, b] = textread (f, "%f %s", 3)
##   (read data into two culumns, try to use the format string
##   three times)
##   returns
##   a = [1; 2; 3]
##   b = @{"a"; "b"; "c"@}
##
## @end group
## @end example
##
## @example
## @group
##   With a data file like:
##   1
##   a
##   2
##   b
##
##   [a, b] = textread (f, "%f %s", 2)
##   returns a = 1 and b = @{"a"@}; i.e., the format string is used
##   only once because the format string refers to 2 lines of the
##   data file.  To obtain 2x1 data output columns, specify N = 4
##   (number of data lines containing all requested data) rather
##   than 2.
## @end group
## @end example
##
## @seealso{textscan, load, dlmread, fscanf, strread}
## @end deftypefn

function varargout = textread (filename, format = "%f", varargin)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "textread is obsolete; use textscan instead\n");
  endif

  ## Check input
  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (filename) || ! ischar (format))
    error ("textread: FILENAME and FORMAT arguments must be strings");
  endif

  if (! isempty (varargin) && isnumeric (varargin{1}))
    nlines = varargin{1};
  else
    nlines = Inf;
  endif
  if (nlines < 1)
    printf ("textread: N = 0, no data read\n");
    varargout = cell (1, nargout);
    return;
  endif

  BUFLENGTH = 4096;       # Read buffer to speed up processing @var{n}

  ## Read file
  fid = fopen (filename, "r");
  if (fid == -1)
    error ("textread: could not open '%s' for reading", filename);
  endif

  ## Skip header lines if requested
  headerlines = find (strcmpi (varargin, "headerlines"), 1);
  if (! isempty (headerlines))
    ## Beware of missing or wrong headerline value
    if (headerlines == numel (varargin)
       || ! isnumeric (varargin{headerlines + 1}))
      error ("textread: missing or invalid value for 'headerlines'" );
    endif
    ## Avoid conveying floats to fskipl
    varargin{headerlines + 1} = round (varargin{headerlines + 1});
    ## Beware of zero valued headerline, fskipl would skip to EOF
    if (varargin{headerlines + 1} > 0)
      fskipl (fid, varargin{headerlines + 1});
    elseif (varargin{headerlines + 1} < 0)
      warning ("textread: negative headerline value ignored");
    endif
    varargin(headerlines:headerlines+1) = [];
  endif
  st_pos = ftell (fid);

  ## Read a first file chunk.  Rest follows after endofline processing
  [str, count] = fscanf (fid, "%c", BUFLENGTH);
  if (isempty (str) || count < 1)
    warning ("textread: empty file");
    varargout = cell (1, nargout);
    return;
  endif

  endofline = find (strcmpi (varargin, "endofline"), 1);
  if (! isempty (endofline))
    ## 'endofline' option set by user.
    if (ischar (varargin{endofline + 1}))
      eol_char = varargin{endofline + 1};
      if (strcmp (typeinfo (eol_char), "sq_string"))
        eol_char = do_string_escapes (eol_char);
      endif
      if (! any (strcmp (eol_char, {"", "\n", "\r", "\r\n"})))
        error ("textread: invalid EndOfLine character value specified");
      endif
    else
      error ("textread: character value required for EndOfLine");
    endif
  else
    ## Determine EOL from file.
    ## Search for EOL candidates in the first BUFLENGTH chars
    ## FIXME: Ignore risk of 2-byte EOL (\r\n) being split at exactly BUFLENGTH
    eol_srch_len = min (length (str), BUFLENGTH);
    ## First try DOS (CRLF)
    if (! isempty (strfind (str(1 : eol_srch_len), "\r\n")))
      eol_char = "\r\n";
    ## Perhaps old Macintosh? (CR)
    elseif (! isempty (strfind (str(1 : eol_srch_len), "\r")))
      eol_char = "\r";
    ## Otherwise, use plain *nix (LF)
    else
      eol_char = "\n";
    endif
    ## Set up default endofline param value
    varargin(end+1:end+2) = {"endofline", eol_char};
  endif

  ## Now that we know what EOL looks like, we can process format_repeat_count.
  ## FIXME: The below isn't ML-compatible: counts lines, not format string uses
  if (isfinite (nlines) && (nlines > 0))
    l_eol_char = length (eol_char);
    eoi = strfind (str, eol_char);
    n_eoi = length (eoi);
    nblks = 0;
    ## Avoid slow repeated str concatenation, first seek requested end of data
    while (n_eoi < nlines && count == BUFLENGTH)
      [nstr, count] = fscanf (fid, "%c", BUFLENGTH);
      if (count > 0)
        ## Watch out for multichar EOL being missed across buffer boundaries
        if (l_eol_char > 1)
          str = [str(end - length (eol_char) + 2 : end) nstr];
        else
          str = nstr;
        endif
        eoi = strfind (str, eol_char);
        n_eoi += numel (eoi);
        ++nblks;
      endif
    endwhile
    ## Handle case of missing or incomplete trailing EOL
    if (! strcmp (str(end - length (eol_char) + 1 : end), eol_char))
      eoi = [ eoi (length (str)) ];
      ++n_eoi;
    endif
    ## Found EOL delimiting last requested line.  Compute ptr (incl. EOL)
    if (isempty (eoi))
      eoi_pos = nblks * BUFLENGTH + count;
    else
      eoi_pos = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi);
    endif
    fseek (fid, st_pos, "bof");
    str = fscanf (fid, "%c", eoi_pos);
  else
    fseek (fid, st_pos, "bof");
    str = fread (fid, "char=>char").';
  endif
  fclose (fid);

  ## Set up default whitespace param value if needed
  if (isempty (find (strcmpi ("whitespace", varargin))))
    varargin(end+1:end+2) = {"whitespace", " \b\t"};
  endif

  ## Call strread to make it do the real work
  warning ("off", "Octave:legacy-function", "local");
  [varargout{1:max (nargout, 1)}] = strread (str, format, varargin{:});

  ## Hack to concatenate/reshape numeric output into 2D array (undocumented ML)
  ## In ML this only works in case of an empty format string
  if (isempty (format))
    ## Get number of fields per line.
    ## 1. Get eol_char position
    iwhsp = find (strcmpi ("whitespace", varargin));
    whsp = varargin{iwhsp + 1};
    idx = regexp (str, eol_char, "once");
    ## 2. Get first data line til EOL. Avoid corner case of just one line
    if (! isempty (idx))
      str = str(1:idx-1);
    endif
    idelimiter = find (strcmpi (varargin, "delimiter"), 1);
    if (isempty (idelimiter))
      ## Assume delimiter = whitespace
      ## 3A. whitespace incl. consecutive whitespace => single space
      str = regexprep (str, sprintf ("[%s]+", whsp), ' ');
      ## 4A. Remove possible leading & trailing spaces
      str = strtrim (str);
      ## 5A. Count spaces, add one to get nr of data fields per line
      ncols = numel (strfind (str, " ")) + 1;
    else
      ## 3B. Just count delimiters. FIXME: delimiters could occur in literals
      delimiter = varargin{idelimiter+1};
      ncols = numel (regexp (str, sprintf ("[%s]", delimiter))) + 1;
    endif
    ## 6. Reshape; watch out, we need a transpose
    nrows = ceil (numel (varargout{1}) / ncols);
    pad = mod (numel (varargout{1}), ncols);
    if (pad > 0)
      pad = ncols - pad;
      varargout{1}(end+1 : end+pad) = NaN;
    endif
    varargout{1} = reshape (varargout{1}, ncols, nrows)';
    ## ML replaces empty values with NaNs
    varargout{1}(find (isnan (varargout{1}))) = 0;
  endif

endfunction


## First test is necessary to provoke 1-time legacy warning
%!test
%! warning ("off", "Octave:legacy-function", "local");
%! try
%!   textread ("");
%! catch
%!   ## Nothing to do, just wanted to suppress error.
%! end_try_catch

%!test
%! f = tempname ();
%! d = rand (5, 3);
%! dlmwrite (f, d, "precision", "%5.2f");
%! [a, b, c] = textread (f, "%f %f %f", "delimiter", ",", "headerlines", 3);
%! unlink (f);
%! assert (a, d(4:5, 1), 1e-2);
%! assert (b, d(4:5, 2), 1e-2);
%! assert (c, d(4:5, 3), 1e-2);

%!test
%! f = tempname ();
%! d = rand (7, 2);
%! dlmwrite (f, d, "precision", "%5.2f");
%! [a, b] = textread (f, "%f, %f", "headerlines", 1);
%! unlink (f);
%! assert (a, d(2:7, 1), 1e-2);

## Test reading 2D matrix with empty format
%!test
%! f = tempname ();
%! d = rand (5, 2);
%! dlmwrite (f, d, "precision", "%5.2f");
%! A = textread (f, "", "headerlines", 3);
%! unlink (f);
%! assert (A, d(4:5, :), 1e-2);

## Read multiple lines using empty format string
%!test
%! f = tempname ();
%! sts = unlink (f);
%! fid = fopen (f, "w");
%! d = rand (1, 4);
%! fprintf (fid, "  %f %f   %f  %f ", d);
%! fclose (fid);
%! A = textread (f, "");
%! unlink (f);
%! assert (A, d, 1e-6);

## Empty format, corner case = one line w/o EOL
%!test
%! f = tempname ();
%! sts = unlink (f);
%! fid = fopen (f, "w");
%! d = rand (1, 4);
%! fprintf (fid, "  %f %f   %f  %f ", d);
%! fclose (fid);
%! A = textread (f, "");
%! unlink (f);
%! assert (A, d, 1e-6);

## Tests with format repeat count #1
%!test
%! f = tempname ();
%! fid = fopen (f, "w");
%! fprintf (fid, "%2d %s %2d %s\n %2d %s %2d %s \n", ...
%!                10, "a", 20, "b", 30, "c", 40, "d");
%! fclose (fid);
%! [a, b] = textread (f, "%d %s", 1);
%! assert (a, int32 (10));
%! assert (b, {"a"});
%! [a, b] = textread (f, "%d %s", 2);
%! assert (a, int32 ([10; 20]));
%! assert (b, {"a"; "b"});
%! [a, b] = textread (f, "%d %s", 3);
%! assert (a, int32 ([10; 20; 30]));
%! assert (b, {"a"; "b"; "c"});
%! [a, b] = textread (f, "%d %s", 4);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; "d"});
%! [a, b] = textread (f, "%d %s", 5);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; "d"});
%! unlink (f);

## Tests with format repeat count #2, missing last EOL
%!test
%! f = tempname ();
%! fid = fopen (f, "w");
%! fprintf (fid, "%2d %s %2d %s\n %2d %s %2d %s", ...
%!                10, "a", 20, "b", 30, "c", 40, "d");
%! fclose (fid);
%! [a, b] = textread (f, "%d %s", 1);
%! assert (a, int32 (10));
%! assert (b, {"a"});
%! [a, b] = textread (f, "%d %s", 2);
%! assert (a, int32 ([10; 20]));
%! assert (b, {"a"; "b"});
%! [a, b] = textread (f, "%d %s", 3);
%! assert (a, int32 ([10; 20; 30]));
%! assert (b, {"a"; "b"; "c"});
%! [a, b] = textread (f, "%d %s", 4);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; "d"});
%! [a, b] = textread (f, "%d %s", 5);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; "d"});
%! unlink (f);

## Tests with format repeat count #3, incomplete last line
%!test
%! f = tempname ();
%! fid = fopen (f, "w");
%! fprintf (fid, "%2d %s %2d %s\n %2d %s %2d", ...
%!                10, "a", 20, "b", 30, "c", 40);
%! fclose (fid);
%! [a, b] = textread (f, "%d %s", 1);
%! assert (a, int32 (10));
%! assert (b, {"a"});
%! [a, b] = textread (f, "%d %s", 2);
%! assert (a, int32 ([10; 20]));
%! assert (b, {"a"; "b"});
%! [a, b] = textread (f, "%d %s", 3);
%! assert (a, int32 ([10; 20; 30]));
%! assert (b, {"a"; "b"; "c"});
%! [a, b] = textread (f, "%d %s", 4);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"});
%! [a, b] = textread (f, "%d %s", 5);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"});
%! unlink (f);

## Tests with format repeat count #4, incomplete last line but with trailing EOL
%!test
%! f = tempname ();
%! fid = fopen (f, "w");
%! fprintf (fid, "%2d %s %2d %s\n %2d %s %2d\n", ...
%!                10, "a", 20, "b", 30, "c", 40);
%! fclose (fid);
%! [a, b] = textread (f, "%d %s", 4);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; ""});
%! [a, b] = textread (f, "%d %s", 5);
%! assert (a, int32 ([10; 20; 30; 40]));
%! assert (b, {"a"; "b"; "c"; ""});
%! unlink (f);

### Tests with format repeat count #5, nr of data lines = limiting factor
#%!test
#%! f = tempname ();
#%! fid = fopen (f, "w");
#%! fprintf (fid, "%2d\n%s\n%2dn%s", ...
#%!                1, "a", 2, "b");
#%! fclose (fid);
#%! [a, b] = textread (f, "%d %s", 2);
#%! assert (a, int32 (1));
#%! assert (b, {"a"});

### Read multiple lines using empty format string, missing data (should be 0)
#%!test
#%! f = tempname ();
#%! unlink (f);
#%! fid = fopen (f, "w");
#%! d = rand (1, 4);
#%! fprintf (fid, "%f, %f, ,  %f,  %f ", d);
#%! fclose (fid);
#%! A = textread (f, "");
#%! unlink (f);
#%! assert (A, [ d(1:2) 0 d(3:4)], 1e-6);

### Test with empty positions - ML returns 0 for empty fields
#%!test
#%! f = tempname ();
#%! unlink (f);
#%! fid = fopen (f, "w");
#%! d = rand (1, 4);
#%! fprintf (fid, ",2,,4\n5,,7,\n");
#%! fclose (fid);
#%! A = textread (f, "", "delimiter", ",");
#%! unlink (f);
#%! assert (A, [0 2 0 4; 5 0 7 0], 1e-6);

### Another test with empty format + positions, now with more incomplete lower
### row (must be appended with zeros to get rectangular matrix)
#%!test
#%! f = tempname ();
#%! unlink (f);
#%! fid = fopen (f, "w");
#%! d = rand (1, 4);
#%! fprintf (fid, ",2,,4\n5,\n");
#%! fclose (fid);
#%! A = textread (f, "", "delimiter", ",");
#%! unlink (f);
#%! assert (A, [0 2 0 4; 5 0 0 0], 1e-6);

### Test endofline
#%!test <*45046>
#%! f = tempname ();
#%! fid = fopen (f, "w");
#%! fprintf (fid, "a\rb\rc");
#%! fclose (fid);
#%! ## Test EOL detection
#%! d = textread (f, "%s");
#%! assert (d, {"a";"b";"c"});
#%! ## Test explicit EOL specification (bug #45046)
#%! d = textread (f, "%s", "endofline", "\r");
#%! assert (d, {"a"; "b"; "c"});
#%! unlink (f);

### Properly process single-quoted EOL args
#%!test <*46477>
#%! f = tempname ();
#%! fid = fopen (f, "w");
#%! fprintf (fid, "hello, world!");
#%! fclose (fid);
#%! [a, b] = textread (f, "%s%s", "endofline", '\n');
#%! assert (a{1}, "hello,");
#%! assert (b{1}, "world!");

### Test input validation
#%!error textread ()
#%!error textread (1)
#%!error <arguments must be strings> textread (1, "%f")
#%!error <arguments must be strings> textread ("fname", 1)
#%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
#%!error <missing or invalid value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
#%!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} vectorize (@var{fun})
## Create a vectorized version of the anonymous function or expression
## @var{fun} by replacing all occurrences of @code{*}, @code{/}, etc.,
## with @code{.*}, @code{./}, etc.
##
## Note that the transformation is extremely simplistic.  Use of this
## function is strongly discouraged.  It may be removed from a future
## version of Octave.
## @end deftypefn

## The following function was translated directly from the original C++
## version.  Yes, it will be slow, but its use is strongly discouraged
## anyway, and most expressions will probably be short.  It may also be
## buggy.  Well, don't use this function!

function retval = vectorize (fun)

  persistent warned = false;
  if (! warned)
    warned = true;
    warning ("Octave:legacy-function",
             "vectorize is unreliable; its use is strongly discouraged\n");
  endif

  if (nargin < 1)
    print_usage ();
  endif

  if (isa (fun, "function_handle"))
    finfo = functions (fun);
    if (! strcmp (finfo.type, "anonymous"))
      error ("vectorize: FUN must be a string or anonymous function handle");
    endif
    expr = finfo.function;
    idx = index (expr, ")");
    args = expr(1:idx);
    expr = expr(idx+1:end);
    new_expr = __vectorize__ (expr);
    retval = str2func ([args, new_expr]);
  elseif (ischar (fun))
    retval = __vectorize__ (fun);
  else
    error ("vectorize: FUN must be a string or anonymous function handle");
  endif

endfunction


%!assert (vectorize ("x.^2 + 1"), "x.^2 + 1")
%!test
%! fh = @(x) x.^2 + 1;
%! finfo = functions (vectorize (fh));
%! assert (finfo.function, "@(x) x .^ 2 + 1");

%!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
%!test
%! fh = @(x, y, z) 1e-3*y + 2e4*z;
%! finfo = functions (vectorize (fh));
%! assert (finfo.function, "@(x, y, z) 1e-3 .* y + 2e4 .* z");

%!assert (vectorize ("2^x^5"), "2.^x.^5")
%!test
%! fh = @(x) 2^x^5;
%! finfo = functions (vectorize (fh));
%! assert (finfo.function, "@(x) 2 .^ x .^ 5");

## Test input validation
%!error <Invalid call> vectorize ()
%!error <FUN must be a string or anonymous function handle> vectorize (1)
encoding=utf-8
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{bw} =} bandwidth (@var{A}, @var{type})
## @deftypefnx {} {[@var{lower}, @var{upper}] =} bandwidth (@var{A})
## Compute the bandwidth of @var{A}.
##
## The @var{type} argument is the string @qcode{"lower"} for the lower
## bandwidth and @qcode{"upper"} for the upper bandwidth.  If no @var{type} is
## specified return both the lower and upper bandwidth of @var{A}.
##
## The lower/upper bandwidth of a matrix is the number of
## subdiagonals/superdiagonals with nonzero entries.
##
## @seealso{isbanded, isdiag, istril, istriu}
## @end deftypefn

function [lower, upper] = bandwidth (A, type)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (A) && ! islogical (A) || ndims (A) != 2)
    error ("bandwidth: A must be a 2-D numeric or logical matrix");
  elseif (nargin == 2 && ! (strcmp (type, "lower") || strcmp (type, "upper")))
    error ('bandwidth: TYPE must be "lower" or "upper"');
  endif

  if (nargin == 1)
    [i, j] = find (A);
    if (isempty (i))
      lower = upper = 0;
    else
      lower = max (0, max (i - j));
      upper = max (0, max (j - i));
    endif
  else
    [i, j] = find (A);
    if (isempty (i))
      lower = 0;
    elseif (strcmp (type, "lower"))
      lower = max (0, max (i - j));
    else
      lower = max (0, max (j - i));
    endif
  endif

endfunction


%!test
%! [a,b] = bandwidth (speye (100));
%! assert ([a,b], [0,0]);
%! assert (bandwidth (speye (100), "upper"), 0);
%! assert (bandwidth (speye (100), "lower"), 0);

%!test
%! A = [2 3 0 0 0; 1 2 3 0 0; 0 1 2 3 0; 0 0 1 2 3; 0 0 0 1 2];
%! [a,b] = bandwidth (A);
%! assert ([a,b], [1,1]);
%! assert (bandwidth (A, "lower"), 1);
%! assert (bandwidth (A, "upper"), 1);

%!assert (bandwidth ([], "lower"), 0)
%!assert (bandwidth ([], "upper"), 0)
%!assert (bandwidth ([]), 0)
%!assert (bandwidth (zeros (3,3), "lower"), 0)
%!assert (bandwidth (zeros (3,3), "upper"), 0)
%!assert (bandwidth (zeros (3,3)), 0)
%!assert (bandwidth (ones (5,5), "lower"), 4)
%!assert (bandwidth (ones (5,5), "upper"), 4)
%!assert (bandwidth (ones (5,5)), 4)

%!assert (bandwidth ([0,1,2,0]), 0)

%!test
%! [a,b] = bandwidth ([]);
%! assert ([a,b], [0,0]);
%!test
%! [a,b] = bandwidth (zeros (3,3));
%! assert ([a,b], [0,0]);
%!test
%! [a,b] = bandwidth (ones (5,5));
%! assert ([a,b], [4,4]);

## Test input validation
%!error <Invalid call> bandwidth ()
%!error <A must be a 2-D numeric or logical> bandwidth ("string", "lower")
%!error <A must be a 2-D numeric or logical> bandwidth (ones (3,3,3), "lower")
%!error <TYPE must be "lower" or "upper"> bandwidth (ones (2), "uper")
%!error <TYPE must be "lower" or "upper"> bandwidth (ones (2), "uppper")
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} commutation_matrix (@var{m}, @var{n})
## Return the commutation matrix
## @tex
##  $K_{m,n}$
## @end tex
## @ifnottex
## K(m,n)
## @end ifnottex
## which is the unique
## @tex
##  $m n \times m n$
## @end tex
## @ifnottex
## @var{m}*@var{n} by @var{m}*@var{n}
## @end ifnottex
## matrix such that
## @tex
##  $K_{m,n} \cdot {\rm vec} (A) = {\rm vec} (A^T)$
## @end tex
## @ifnottex
## @math{K(m,n) * vec(A) = vec(A')}
## @end ifnottex
## for all
## @tex
##  $m\times n$
## @end tex
## @ifnottex
## @math{m} by @math{n}
## @end ifnottex
## matrices
## @tex
##  $A$.
## @end tex
## @ifnottex
## @math{A}.
## @end ifnottex
##
## If only one argument @var{m} is given,
## @tex
##  $K_{m,m}$
## @end tex
## @ifnottex
## @math{K(m,m)}
## @end ifnottex
## is returned.
##
## See @nospell{Magnus and Neudecker} (1988), @cite{Matrix Differential
## Calculus with Applications in Statistics and Econometrics}.
## @end deftypefn

function k = commutation_matrix (m, n)

  if (nargin < 1)
    print_usage ();
  else
    if (! (isscalar (m) && m == fix (m) && m > 0))
      error ("commutation_matrix: M must be a positive integer");
    endif
    if (nargin == 1)
      n = m;
    elseif (! (isscalar (n) && n == fix (n) && n > 0))
      error ("commutation_matrix: N must be a positive integer");
    endif
  endif

  ## It is clearly possible to make this a LOT faster!
  k = zeros (m * n, m * n);
  for i = 1 : m
    for j = 1 : n
      k((i - 1) * n + j, (j - 1) * m + i) = 1;
    endfor
  endfor

endfunction


%!test
%! c = commutation_matrix (1,1);
%! assert (c,1);

%!test
%! A = rand (3,5);
%! vc = vec (A);
%! vr = vec (A');
%! c = commutation_matrix (3,5);
%! assert (c*vc, vr);

%!test
%! A = rand (4,6);
%! vc = vec (A);
%! vr = vec (A');
%! c = commutation_matrix (4,6);
%! assert (c*vc, vr);

%!error <M must be a positive integer> commutation_matrix (0,0)
%!error <N must be a positive integer> commutation_matrix (1,0)
%!error <M must be a positive integer> commutation_matrix (0,1)
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} cond (@var{A})
## @deftypefnx {} {} cond (@var{A}, @var{p})
## Compute the @var{p}-norm condition number of a matrix with respect to
## inversion.
##
## @code{cond (@var{A})} is defined as
## @tex
## $ {\parallel A \parallel_p * \parallel A^{-1} \parallel_p .} $
## @end tex
## @ifnottex
## @code{norm (@var{A}, @var{p}) * norm (inv (@var{A}), @var{p})}.
## @end ifnottex
##
## By default, @code{@var{p} = 2} is used which implies a (relatively slow)
## singular value decomposition.  Other possible selections are
## @code{@var{p} = 1, Inf, "fro"} which are generally faster.  For a full
## discussion of possible @var{p} values, @pxref{XREFnorm,,@code{norm}}.
##
## The condition number of a matrix quantifies the sensitivity of the matrix
## inversion operation when small changes are made to matrix elements.  Ideally
## the condition number will be close to 1.  When the number is large this
## indicates small changes (such as underflow or round-off error) will produce
## large changes in the resulting output.  In such cases the solution results
## from numerical computing are not likely to be accurate.
## @seealso{condest, rcond, condeig, norm, svd}
## @end deftypefn

function retval = cond (A, p = 2)

  if (nargin < 1)
    print_usage ();
  endif

  if (ndims (A) > 2)
    error ("cond: A must be a 2-D matrix");
  endif

  if (p == 2)
    if (isempty (A))
      retval = 0.0;
    elseif (any (! isfinite (A(:))))
      error ("cond: A must not contain Inf or NaN values");
    else
      sigma   = svd (A);
      sigma_1 = sigma(1);
      sigma_n = sigma(end);
      if (sigma_1 == 0 || sigma_n == 0)
        retval = Inf;
      else
        retval = sigma_1 / sigma_n;
      endif
    endif
  else
    retval = norm (A, p) * norm (inv (A), p);
  endif

endfunction


%!test
%! y = [7, 2, 3; 1, 3, 4; 6, 4, 5];
%! tol = 1e-6;
%! type = {1, 2, "fro", "inf", inf};
%! for n = 1:numel (type)
%!   rcondition(n) = 1 / cond (y, type{n});
%! endfor
%! assert (rcondition, [0.017460, 0.019597, 0.018714, 0.012022, 0.012022], tol);

%!assert (cond ([1, 2; 2, 1]), 3, sqrt (eps))
%!assert (cond ([1, 2, 3; 4, 5, 6; 7, 8, 9]) > 1.0e+16)

%!error <Invalid call> cond ()
%!error <A must be a 2-D matrix> cond (ones (1,3,3))
%!error <A must not contain Inf or NaN value> cond ([1, 2;Inf 4])
%!error <A must not contain Inf or NaN value> cond ([1, 2;NaN 4])
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} condeig (@var{a})
## @deftypefnx {} {[@var{v}, @var{lambda}, @var{c}] =} condeig (@var{a})
## Compute condition numbers of a matrix with respect to eigenvalues.
##
## The condition numbers are the reciprocals of the cosines of the angles
## between the left and right eigenvectors; Large values indicate that the
## matrix has multiple distinct eigenvalues.
##
## The input @var{a} must be a square numeric matrix.
##
## The outputs are:
##
## @itemize @bullet
## @item
## @var{c} is a vector of condition numbers for the eigenvalues of
## @var{a}.
##
## @item
## @var{v} is the matrix of right eigenvectors of @var{a}.  The result is
## equivalent to calling @code{[@var{v}, @var{lambda}] = eig (@var{a})}.
##
## @item
## @var{lambda} is the diagonal matrix of eigenvalues of @var{a}.  The
## result is equivalent to calling
## @code{[@var{v}, @var{lambda}] = eig (@var{a})}.
## @end itemize
##
## Example
##
## @example
## @group
## a = [1, 2; 3, 4];
## c = condeig (a)
##   @result{} c =
##        1.0150
##        1.0150
## @end group
## @end example
## @seealso{eig, cond, balance}
## @end deftypefn

function [v, lambda, c] = condeig (a)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (a) && issquare (a)))
    error ("condeig: A must be a square numeric matrix");
  endif

  if (issparse (a) && nargout <= 1)
    ## Try to use svds to calculate the condition number as it will typically
    ## be much faster than calling eig as only the smallest and largest
    ## eigenvalue are calculated.

    ## FIXME: This calculates one condition number for the entire matrix.
    ## In the full case, separate condition numbers are calculated for every
    ## eigenvalue.
    try
      s0 = svds (a, 1, 0);    # min eigenvalue
      v = svds (a, 1) / s0;   # max eigenvalue
    catch
      ## Caught an error as there is a singular value exactly at zero!!
      v = Inf;
    end_try_catch
    return;
  endif

  ## Right eigenvectors
  [v, lambda] = eig (a);

  if (isempty (a))
    c = [];
  else
    ## Corresponding left eigenvectors
    ## Use 2-argument form to suppress possible singular matrix warning.
    [vl, ~] = inv (v);
    vl = vl';
    ## Normalize vectors
    vl ./= repmat (sqrt (sum (abs (vl .^ 2))), rows (vl), 1);

    ## Condition numbers
    ## Definition: cos (angle) = (norm (v1) * norm (v2)) / dot (v1, v2)
    ## Eigenvectors have been normalized so 'norm (v1) * norm (v2)' = 1
    c = abs (1 ./ dot (vl, v)');
  endif

  if (nargout <= 1)
    v = c;
  endif

endfunction


%!test
%! a = [1, 2; 3, 4];
%! c = condeig (a);
%! expected_c = [1.0150; 1.0150];
%! assert (c, expected_c, 0.001);

%!test
%! a = [1, 3; 5, 8];
%! [v, lambda, c] = condeig (a);
%! [expected_v, expected_lambda] = eig (a);
%! expected_c = [1.0182; 1.0182];
%! assert (v, expected_v, 0.001);
%! assert (lambda, expected_lambda, 0.001);
%! assert (c, expected_c, 0.001);

## Test empty input
%!assert (condeig ([]), [])

## Test input validation
%!error <Invalid call> condeig ()
%!error <A must be a square numeric matrix> condeig ({1})
%!error <A must be a square numeric matrix> condeig (ones (3,2))
%!error <A must be a square numeric matrix> condeig (ones (2,2,2))
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{cest} =} condest (@var{A})
## @deftypefnx {} {@var{cest} =} condest (@var{A}, @var{t})
## @deftypefnx {} {@var{cest} =} condest (@var{A}, @var{Ainvfcn})
## @deftypefnx {} {@var{cest} =} condest (@var{A}, @var{Ainvfcn}, @var{t})
## @deftypefnx {} {@var{cest} =} condest (@var{A}, @var{Ainvfcn}, @var{t}, @var{p1}, @var{p2}, @dots{})
## @deftypefnx {} {@var{cest} =} condest (@var{Afcn}, @var{Ainvfcn})
## @deftypefnx {} {@var{cest} =} condest (@var{Afcn}, @var{Ainvfcn}, @var{t})
## @deftypefnx {} {@var{cest} =} condest (@var{Afcn}, @var{Ainvfcn}, @var{t}, @var{p1}, @var{p2}, @dots{})
## @deftypefnx {} {[@var{cest}, @var{v}] =} condest (@dots{})
##
## Estimate the 1-norm condition number of a square matrix @var{A} using
## @var{t} test vectors and a randomized 1-norm estimator.
##
## The optional input @var{t} specifies the number of test vectors (default 5).
##
## The input may be a matrix @var{A} (the algorithm is particularly
## appropriate for large, sparse matrices).  Alternatively, the behavior of
## the matrix can be defined implicitly by functions.  When using an implicit
## definition, @code{condest} requires the following functions:
##
## @itemize @minus
## @item @code{@var{Afcn} (@var{flag}, @var{x})} which must return
##
## @itemize @bullet
## @item
## the dimension @var{n} of @var{A}, if @var{flag} is @qcode{"dim"}
##
## @item
## true if @var{A} is a real operator, if @var{flag} is @qcode{"real"}
##
## @item
## the result @code{@var{A} * @var{x}}, if @var{flag} is "notransp"
##
## @item
## the result @code{@var{A}' * @var{x}}, if @var{flag} is "transp"
## @end itemize
##
## @item @code{@var{Ainvfcn} (@var{flag}, @var{x})} which must return
##
## @itemize @bullet
## @item
## the dimension @var{n} of @code{inv (@var{A})}, if @var{flag} is
## @qcode{"dim"}
##
## @item
## true if @code{inv (@var{A})} is a real operator, if @var{flag} is
## @qcode{"real"}
##
## @item
## the result @code{inv (@var{A}) * @var{x}}, if @var{flag} is "notransp"
##
## @item
## the result @code{inv (@var{A})' * @var{x}}, if @var{flag} is "transp"
## @end itemize
## @end itemize
##
## Any parameters @var{p1}, @var{p2}, @dots{} are additional arguments of
## @code{@var{Afcn} (@var{flag}, @var{x}, @var{p1}, @var{p2}, @dots{})}
## and @code{@var{Ainvfcn} (@var{flag}, @var{x}, @var{p1}, @var{p2}, @dots{})}.
##
## The principal output is the 1-norm condition number estimate @var{cest}.
##
## The optional second output @var{v} is an approximate null vector; it
## satisfies the equation @code{norm (@var{A}*@var{v}, 1) ==
## norm (@var{A}, 1) * norm (@var{v}, 1) / @var{cest}}.
##
## Algorithm Note: @code{condest} uses a randomized algorithm to approximate
## the 1-norms.  Therefore, if consistent results are required, the
## @qcode{"state"} of the random generator should be fixed before invoking
## @code{condest}.
##
## References:
##
## @itemize
## @item
## @nospell{N.J. Higham and F. Tisseur}, @cite{A Block Algorithm
## for Matrix 1-Norm Estimation, with an Application to 1-Norm
## Pseudospectra}.  SIMAX vol 21, no 4, pp 1185--1201.
## @url{https://dx.doi.org/10.1137/S0895479899356080}
##
## @item
## @nospell{N.J. Higham and F. Tisseur}, @cite{A Block Algorithm
## for Matrix 1-Norm Estimation, with an Application to 1-Norm
## Pseudospectra}.  @url{https://citeseer.ist.psu.edu/223007.html}
## @end itemize
##
## @seealso{cond, rcond, norm, normest1, normest}
## @end deftypefn

## Code originally licensed under:
##
## Copyright (c) 2007, Regents of the University of California
## All rights reserved.
##
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions
## are met:
##
##    * Redistributions of source code must retain the above copyright
##      notice, this list of conditions and the following disclaimer.
##
##    * Redistributions in binary form must reproduce the above
##      copyright notice, this list of conditions and the following
##      disclaimer in the documentation and/or other materials provided
##      with the distribution.
##
##    * Neither the name of the University of California, Berkeley nor
##      the names of its contributors may be used to endorse or promote
##      products derived from this software without specific prior
##      written permission.
##
## THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
## TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
## PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
## SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
## LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
## USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
## ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
## OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
## OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
## SUCH DAMAGE.

function [cest, v] = condest (varargin)

  if (nargin < 1 || nargin > 6)
    print_usage ();
  endif

  have_A = false;
  have_t = false;
  have_Afcn = false;
  have_Ainvfcn = false;

  if (isnumeric (varargin{1}))
    A = varargin{1};
    if (! issquare (A))
      error ("condest: A must be square");
    endif
    have_A = true;
    n = rows (A);
    if (nargin > 1)
      if (is_function_handle (varargin{2}))
        Ainvfcn = varargin{2};
        have_Ainvfcn = true;
        if (nargin > 2)
          t = varargin{3};
          have_t = true;
        endif
      else
        t = varargin{2};
        have_t = true;
      endif
    endif
  elseif (is_function_handle (varargin{1}))
    if (nargin == 1)
      error ("condest: must provide AINVFCN when using AFCN");
    endif
    Afcn = varargin{1};
    have_Afcn = true;
    if (! is_function_handle (varargin{2}))
      error ("condest: AINVFCN must be a function handle");
    endif
    Ainvfcn = varargin{2};
    have_Ainvfcn = true;
    n = Afcn ("dim", [], varargin{4:end});
    if (nargin > 2)
      t = varargin{3};
      have_t = true;
    endif
  else
    error ("condest: first argument must be a square matrix or function handle");
  endif

  if (! have_t)
    t = min (n, 5);
  endif

  ## Disable warnings which may be emitted during calculation process.
  warning ("off", "Octave:nearly-singular-matrix", "local");

  if (! have_Ainvfcn)
    ## Prepare Ainvfcn in normest1 form
    if (issparse (A))
      [L, U, P, Q] = lu (A);
      Ainvfcn = @inv_sparse_fcn;
    else
      [L, U, P] = lu (A);
      Q = [];
      Ainvfcn = @inv_full_fcn;
    endif

    ## Check for singular matrices before continuing (bug #46737)
    if (any (diag (U) == 0))
      cest = Inf;
      v = [];
      return;
    endif

    ## Initialize solver
    Ainvfcn ("init", A, L, U, P, Q);
    clear L U P Q;
  endif

  if (have_A)
    Anorm = norm (A, 1);
  else
    Anorm = normest1 (Afcn, t, [], varargin{4:end});
  endif
  [Ainv_norm, v, w] = normest1 (Ainvfcn, t, [], varargin{4:end});

  cest = Anorm * Ainv_norm;
  if (isargout (2))
    v = w / norm (w, 1);
  endif

  if (! have_Ainvfcn)
    Ainvfcn ("clear");  # clear persistent memory in subfunction
  endif

endfunction

function retval = inv_sparse_fcn (flag, x, varargin)

  ## FIXME: Sparse algorithm is less accurate than full matrix version.
  ##        See BIST test for asymmetric matrix where relative tolerance
  ##        of 1e-12 is used for sparse, but 4e-16 for full matrix.
  ##        BUT, does it really matter for an "estimate"?
  persistent Ainv Ainvt n isreal_op;

  switch (flag)
    case "dim"
      retval = n;
    case "real"
      retval = isreal_op;
    case "notransp"
      retval = Ainv * x;
    case "transp"
      retval = Ainvt * x;
    case "init"
      n = rows (x);
      isreal_op = isreal (x);
      [L, U, P, Q] = deal (varargin{1:4});
      Ainv = Q * (U \ (L \ P));
      Ainvt = P' * (L' \ (U' \ Q'));
    case "clear"  # called to free memory at end of condest function
      clear Ainv Ainvt n isreal_op;
  endswitch

endfunction

function retval = inv_full_fcn (flag, x, varargin)
  persistent Ainv Ainvt n isreal_op;

  switch (flag)
    case "dim"
      retval = n;
    case "real"
      retval = isreal_op;
    case "notransp"
      retval = Ainv * x;
    case "transp"
      retval = Ainvt \ x;
    case "init"
      n = rows (x);
      isreal_op = isreal (x);
      [L, U, P] = deal (varargin{1:3});
      Ainv = U \ (L \ P);
      Ainvt = P' * (L' \ U');
    case "clear"  # called to free memory at end of condest function
      clear Ainv Ainvt n isreal_op;
  endswitch

endfunction


## Note: These test bounds are very loose.  There is enough randomization to
## trigger odd cases with hilb().

%!function retval = __Afcn__ (flag, x, A, m)
%!  if (nargin == 3)
%!    m = 1;
%!  endif
%!  switch (flag)
%!    case "dim"
%!      retval = length (A);
%!    case "real"
%!      retval = isreal (A);
%!    case "notransp"
%!      retval = x; for i = 1:m, retval = A * retval;, endfor
%!    case "transp"
%!      retval = x; for i = 1:m, retval = A' * retval;, endfor
%!  endswitch
%!endfunction
%!function retval = __Ainvfcn__ (flag, x, A, m)
%!  if (nargin == 3)
%!    m = 1;
%!  endif
%!  switch (flag)
%!    case "dim"
%!      retval = length (A);
%!    case "real"
%!      retval = isreal (A);
%!    case "notransp"
%!      retval = x; for i = 1:m, retval = A \ retval;, endfor
%!    case "transp"
%!      retval = x; for i = 1:m, retval = A' \ retval;, endfor
%!  endswitch
%!endfunction

%!test
%! N = 6;
%! A = hilb (N);
%! cA = condest (A);
%! cA_test = norm (inv (A), 1) * norm (A, 1);
%! assert (cA, cA_test, -2^-8);

%!test
%! N = 12;
%! A = hilb (N);
%! [~, v] = condest (A);
%! x = A*v;
%! assert (norm (x, inf), 0, eps);

%!test
%! N = 6;
%! A = hilb (N);
%! Ainvfcn = @(flag, x) __Ainvfcn__ (flag, x, A);
%! cA = condest (A, Ainvfcn);
%! cA_test = norm (inv (A), 1) * norm (A, 1);
%! assert (cA, cA_test, -2^-6);

%!test
%! N = 6;
%! A = hilb (N);
%! Afcn = @(flag, x) __Afcn__ (flag, x, A);
%! Ainvfcn = @(flag, x) __Ainvfcn__ (flag, x, A);
%! cA = condest (Afcn, Ainvfcn);
%! cA_test = norm (inv (A), 1) * norm (A, 1);
%! assert (cA, cA_test, -2^-6);

%!test # parameters for apply and Ainvfcn functions
%! N = 6;
%! A = hilb (N);
%! m = 2;
%! cA = condest (@__Afcn__, @__Ainvfcn__, [], A, m);
%! cA_test = norm (inv (A^2), 1) * norm (A^2, 1);
%! assert (cA, cA_test, -2^-6);

## Test singular matrices
%!test <*46737>
%! A = [ 0         0         0
%!       0   3.33333 0.0833333
%!       0 0.0833333   1.66667];
%! [cest, v] = condest (A);
%! assert (cest, Inf);
%! assert (v, []);

## Test asymmetric matrices
%!test <*57968>
%! A = reshape (sqrt (0:15), 4, 4);
%! cexp = norm (A, 1) * norm (inv (A), 1);
%! cest = condest (A);
%! assert (cest, cexp, -2*eps);

%!testif HAVE_UMFPACK <*57968>
%! As = sparse (reshape (sqrt (0:15), 4, 4));
%! cexp = norm (As, 1) * norm (inv (As), 1);
%! cest = condest (As);
%! assert (cest, cexp, -1e-12);

## Test input validation
%!error <Invalid call> condest ()
%!error <Invalid call> condest (1,2,3,4,5,6,7)
%!error <A must be square> condest ([1, 2])
%!error <must provide AINVFCN when using AFCN> condest (@sin)
%!error <AINVFCN must be a function handle> condest (@sin, 1)
%!error <argument must be a square matrix or function handle> condest ({1})
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} cross (@var{x}, @var{y})
## @deftypefnx {} {} cross (@var{x}, @var{y}, @var{dim})
## Compute the vector cross product of two 3-dimensional vectors @var{x} and
## @var{y}.
##
## If @var{x} and @var{y} are matrices, the cross product is applied along the
## first dimension with three elements.
##
## The optional argument  @var{dim} forces the cross product to be calculated
## along the specified dimension.
##
## Example Code:
##
## @example
## @group
## cross ([1, 1, 0], [0, 1, 1])
##   @result{}
##        1   -1   1
## @end group
## @end example
##
## @seealso{dot, curl, divergence}
## @end deftypefn

function z = cross (x, y, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (ndims (x) < 3 && ndims (y) < 3 && nargin < 3)
    ## COMPATIBILITY -- opposite behavior for cross(row,col)
    ## Swap x and y in the assignments below to get the matlab behavior.
    ## Better yet, fix the calling code so that it uses conformant vectors.
    if (columns (x) == 1 && rows (y) == 1)
      warning ("cross: taking cross product of column by row");
      y = y.';
    elseif (rows (x) == 1 && columns (y) == 1)
      warning ("cross: taking cross product of row by column");
      x = x.';
    endif
  endif

  if (nargin == 2)
     dim = find (size (x) == 3, 1);
     if (isempty (dim))
       error ("cross: must have at least one dimension with 3 elements");
     endif
   else
     if (size (x, dim) != 3)
       error ("cross: dimension DIM must have 3 elements");
     endif
  endif

  nd = ndims (x);
  sz = size (x);
  idx2 = idx3 = idx1 = {':'}(ones (1, nd));
  idx1(dim) = 1;
  idx2(dim) = 2;
  idx3(dim) = 3;

  if (size_equal (x, y))
    x1 = x(idx1{:});
    x2 = x(idx2{:});
    x3 = x(idx3{:});
    y1 = y(idx1{:});
    y2 = y(idx2{:});
    y3 = y(idx3{:});
    z = cat (dim, (x2.*y3 - x3.*y2), (x3.*y1 - x1.*y3), (x1.*y2 - x2.*y1));
  else
    error ("cross: X and Y must have the same dimensions");
  endif

endfunction


%!test
%! x = [1 0 0];
%! y = [0 1 0];
%! r = [0 0 1];
%! assert (cross (x, y), r, 2e-8);

%!test
%! x = [1 2 3];
%! y = [4 5 6];
%! r = [(2*6-3*5) (3*4-1*6) (1*5-2*4)];
%! assert (cross (x, y), r, 2e-8);

%!test
%! x = [1 0 0; 0 1 0; 0 0 1];
%! y = [0 1 0; 0 0 1; 1 0 0];
%! r = [0 0 1; 1 0 0; 0 1 0];
%! assert (cross (x, y, 2), r, 2e-8);
%! assert (cross (x, y, 1), -r, 2e-8);

## Test input validation
%!error <Invalid call> cross ()
%!error <Invalid call> cross (1)
## FIXME: Need tests for other error() conditions and warning() calls.
%!error <must have at least one dimension with 3 elements> cross (0,0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} duplication_matrix (@var{n})
## Return the duplication matrix
## @tex
##  $D_n$
## @end tex
## @ifnottex
## @nospell{@math{Dn}}
## @end ifnottex
## which is the unique
## @tex
##  $n^2 \times n(n+1)/2$
## @end tex
## @ifnottex
## @math{n^2} by @math{n*(n+1)/2}
## @end ifnottex
## matrix such that
## @tex
##  $D_n * {\rm vech} (A) = {\rm vec} (A)$
## @end tex
## @ifnottex
## @nospell{@math{Dn vech (A) = vec (A)}}
## @end ifnottex
## for all symmetric
## @tex
##  $n \times n$
## @end tex
## @ifnottex
## @math{n} by @math{n}
## @end ifnottex
## matrices
## @tex
##  $A$.
## @end tex
## @ifnottex
## @math{A}.
## @end ifnottex
##
## See @nospell{Magnus and Neudecker} (1988), @cite{Matrix Differential
## Calculus with Applications in Statistics and Econometrics}.
## @end deftypefn

function d = duplication_matrix (n)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isscalar (n) && n > 0 && n == fix (n)))
    error ("duplication_matrix: N must be a positive integer");
  endif

  d = zeros (n * n, n * (n + 1) / 2);

  ## It is clearly possible to make this a LOT faster!
  count = 0;
  for j = 1 : n
    d((j - 1) * n + j, count + j) = 1;
    for i = (j + 1) : n
      d((j - 1) * n + i, count + i) = 1;
      d((i - 1) * n + j, count + i) = 1;
    endfor
    count += n - j;
  endfor

endfunction


%!test
%! N = 2;
%! A = rand (N);
%! B = A * A';
%! C = A + A';
%! D = duplication_matrix (N);
%! assert (D * vech (B), vec (B), 1e-6);
%! assert (D * vech (C), vec (C), 1e-6);

%!test
%! N = 3;
%! A = rand (N);
%! B = A * A';
%! C = A + A';
%! D = duplication_matrix (N);
%! assert (D * vech (B), vec (B), 1e-6);
%! assert (D * vech (C), vec (C), 1e-6);

%!test
%! N = 4;
%! A = rand (N);
%! B = A * A';
%! C = A + A';
%! D = duplication_matrix (N);
%! assert (D * vech (B), vec (B), 1e-6);
%! assert (D * vech (C), vec (C), 1e-6);

%!error <Invalid call> duplication_matrix ()
%!error duplication_matrix (0.5)
%!error duplication_matrix (-1)
%!error duplication_matrix (ones (1,4))
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} expm (@var{A})
## Return the exponential of a matrix.
##
## The matrix exponential is defined as the infinite Taylor series
## @tex
## $$
##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
## $$
## @end tex
## @ifnottex
##
## @example
## expm (A) = I + A + A^2/2! + A^3/3! + @dots{}
## @end example
##
## @end ifnottex
## However, the Taylor series is @emph{not} the way to compute the matrix
## exponential; see @nospell{Moler and Van Loan}, @cite{Nineteen Dubious Ways
## to Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
## uses Ward's diagonal Pad@'e approximation method with three step
## preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal
## Pad@'e approximations are rational polynomials of matrices
## @tex
## $D_q(A)^{-1}N_q(A)$
## @end tex
## @ifnottex
##
## @example
## @group
##      -1
## D (A)   N (A)
## @end group
## @end example
##
## @end ifnottex
## whose Taylor series matches the first
## @tex
## $2 q + 1 $
## @end tex
## @ifnottex
## @code{2q+1}
## @end ifnottex
## terms of the Taylor series above; direct evaluation of the Taylor series
## (with the same preconditioning steps) may be desirable in lieu of the
## Pad@'e approximation when
## @tex
## $D_q(A)$
## @end tex
## @ifnottex
## @code{Dq(A)}
## @end ifnottex
## is ill-conditioned.
## @seealso{logm, sqrtm}
## @end deftypefn

function r = expm (A)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (A) || ! issquare (A))
    error ("expm: A must be a square matrix");
  endif

  if (isempty (A))
    r = A;
    return;
  elseif (isscalar (A))
    r = exp (A);
    return;
  elseif (isdiag (A))
    r = diag (exp (diag (A)));
    return;
  endif

  n = rows (A);
  id = eye (n);
  ## Trace reduction.
  A(A == -Inf) = -realmax ();
  trshift = trace (A) / n;
  if (trshift > 0)
    A -= trshift * id;
  endif
  ## Balancing.
  [d, p, aa] = balance (A);
  [~, e] = log2 (norm (aa, "inf"));
  s = max (0, e);
  s = min (s, 1023);
  aa *= 2^(-s);

  ## Pade approximation for exp(A).
  c = [5.0000000000000000e-1, ...
       1.1666666666666667e-1, ...
       1.6666666666666667e-2, ...
       1.6025641025641026e-3, ...
       1.0683760683760684e-4, ...
       4.8562548562548563e-6, ...
       1.3875013875013875e-7, ...
       1.9270852604185938e-9];

  a2 = aa^2;
  x = (((c(8) * a2 + c(6) * id) * a2 + c(4) * id) * a2 + c(2) * id) * a2 + id;
  y = (((c(7) * a2 + c(5) * id) * a2 + c(3) * id) * a2 + c(1) * id) * aa;

  r = (x - y) \ (x + y);

  ## Undo scaling by repeated squaring.
  for k = 1:s
    r ^= 2;
  endfor

  ## inverse balancing.
  d = diag (d);
  r = d * r / d;
  r(p, p) = r;
  ## Inverse trace reduction.
  if (trshift > 0)
    r *= exp (trshift);
  endif

endfunction


%!assert (norm (expm ([1 -1;0 1]) - [e -e; 0 e]) < 1e-5)
%!assert (expm ([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5)

%!assert (expm ([]), [])
%!assert (expm (10), exp (10))
%!assert (full (expm (eye (3))), expm (full (eye (3))))
%!assert (full (expm (10*eye (3))), expm (full (10*eye (3))), 8*eps)
%!assert (expm (zeros (3)), eye (3))

## Test input validation
%!error <Invalid call> expm ()
%!error <expm: A must be a square matrix> expm ({1})
%!error <expm: A must be a square matrix> expm ([1 0;0 1; 2 2])
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{beta}, @var{v}, @var{r}] =} gls (@var{y}, @var{x}, @var{o})
## Generalized least squares (GLS) model.
##
## Perform a generalized least squares estimation for the multivariate model
## @tex
## $@var{y} = @var{x}\,@var{b} + @var{e}$
## @end tex
## @ifnottex
## @w{@math{@var{y} = @var{x}*@var{B} + @var{E}}}
## @end ifnottex
## where
## @tex
## $@var{y}$ is a $t \times p$ matrix, $@var{x}$ is a $t \times k$ matrix,
## $@var{b}$ is a $k \times p$ matrix and $@var{e}$ is a $t \times p$ matrix.
## @end tex
## @ifnottex
## @var{y} is a @math{t}-by-@math{p} matrix, @var{x} is a
## @math{t}-by-@math{k} matrix, @var{b} is a @math{k}-by-@math{p} matrix
## and @var{e} is a @math{t}-by-@math{p} matrix.
## @end ifnottex
##
## @noindent
## Each row of @var{y} is a @math{p}-variate observation in which each column
## represents a variable.  Likewise, the rows of @var{x} represent
## @math{k}-variate observations or possibly designed values.  Furthermore,
## the collection of observations @var{x} must be of adequate rank, @math{k},
## otherwise @var{b} cannot be uniquely estimated.
##
## The observation errors, @var{e}, are assumed to originate from an
## underlying @math{p}-variate distribution with zero mean but possibly
## heteroscedastic observations.  That is, in general,
## @tex
## $\bar{@var{e}} = 0$ and cov(vec(@var{e})) = $s^2@var{o}$
## @end tex
## @ifnottex
## @code{@math{mean (@var{e}) = 0}} and
## @code{@math{cov (vec (@var{e})) = (@math{s}^2)*@var{o}}}
## @end ifnottex
## in which @math{s} is a scalar and @var{o} is a
## @tex
## @math{t \, p \times t \, p}
## @end tex
## @ifnottex
## @math{t*p}-by-@math{t*p}
## @end ifnottex
## matrix.
##
## The return values @var{beta}, @var{v}, and @var{r} are
## defined as follows.
##
## @table @var
## @item beta
## The GLS estimator for matrix @var{b}.
##
## @item v
## The GLS estimator for scalar @math{s^2}.
##
## @item r
## The matrix of GLS residuals, @math{@var{r} = @var{y} - @var{x}*@var{beta}}.
## @end table
## @seealso{ols}
## @end deftypefn

function [beta, v, r] = gls (y, x, o)

  if (nargin != 3)
    print_usage ();
  endif

  if (! (isnumeric (x) && isnumeric (y) && isnumeric (o)))
    error ("gls: X, Y, and O must be numeric matrices or vectors");
  endif

  if (ndims (x) != 2 || ndims (y) != 2 || ndims (o) != 2)
    error ("gls: X, Y and O must be 2-D matrices or vectors");
  endif

  [rx, cx] = size (x);
  [ry, cy] = size (y);
  [ro, co] = size (o);
  if (rx != ry)
    error ("gls: number of rows of X and Y must be equal");
  endif
  if (! issquare (o) || ro != ry*cy)
    error ("gls: matrix O must be square matrix with rows = rows (Y) * cols (Y)");
  endif

  if (isinteger (x))
    x = double (x);
  endif
  if (isinteger (y))
    y = double (y);
  endif
  if (isinteger (o))
    o = double (o);
  endif

  ## Start of algorithm
  o ^= -1/2;
  z = kron (eye (cy), x);
  z = o * z;
  y1 = o * reshape (y, ry*cy, 1);
  u = z' * z;
  r = rank (u);

  if (r == cx*cy)
    b = inv (u) * z' * y1;
  else
    b = pinv (z) * y1;
  endif

  beta = reshape (b, cx, cy);

  if (isargout (2) || isargout (3))
    r = y - x * beta;
    if (isargout (2))
      v = (reshape (r, ry*cy, 1))' * (o^2) * reshape (r, ry*cy, 1) / (rx*cy - r);
    endif
  endif

endfunction


%!test
%! x = [1:5]';
%! y = 3*x + 2;
%! x = [x, ones(5,1)];
%! o = diag (ones (5,1));
%! assert (gls (y,x,o), [3; 2], 50*eps);

## Test input validation
%!error <Invalid call> gls ()
%!error <Invalid call> gls (1)
%!error <Invalid call> gls (1, 2)
%!error gls ([true, true], [1, 2], ones (2))
%!error gls ([1, 2], [true, true], ones (2))
%!error gls ([1, 2], [1, 2], true (2))
%!error gls (ones (2,2,2), ones (2,2), ones (4,4))
%!error gls (ones (2,2), ones (2,2,2), ones (4,4))
%!error gls (ones (2,2), ones (2,2), ones (4,4,4))
%!error gls (ones (1,2), ones (2,2), ones (2,2))
%!error gls (ones (2,2), ones (2,2), ones (2,2))
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{housv}, @var{beta}, @var{zer}] =} housh (@var{x}, @var{j}, @var{z})
## Compute Householder reflection vector @var{housv} to reflect @var{x} to be
## the j-th column of identity, i.e.,
##
## @example
## @group
## (I - beta*housv*housv')x =  norm (x)*e(j) if x(j) < 0,
## (I - beta*housv*housv')x = -norm (x)*e(j) if x(j) >= 0
## @end group
## @end example
##
## @noindent
## Inputs
##
## @table @var
## @item x
## vector
##
## @item j
## index into vector
##
## @item z
## threshold for zero  (usually should be the number 0)
## @end table
##
## @noindent
## Outputs (see @nospell{Golub and Van Loan}):
##
## @table @var
## @item beta
## If beta = 0, then no reflection need be applied (@nospell{zer} set to 0)
##
## @item housv
## householder vector
## @end table
## @end deftypefn

function [housv, beta, zer] = housh (x, j, z)

  if (nargin != 3)
    print_usage ();
  endif

  ## Check for valid inputs.
  if (! isvector (x) && ! isscalar (x))
    error ("housh: first input must be a vector");
  elseif (! isscalar (j))
    error ("housh: second argument must be an integer scalar");
  else
    housv = x;
    m = max (abs (housv));
    if (m != 0.0)
      housv /= m;
      alpha = norm (housv);
      if (alpha > z)
        beta = 1.0 / (alpha * (alpha + abs (housv(j))));
        sg = sign (housv(j));
        if (sg == 0)
          sg = 1;
        endif
        housv(j) = housv(j) + alpha*sg;
      else
        beta = 0.0;
      endif
    else
      beta = 0.0;
    endif
    zer = (beta == 0);
  endif

endfunction


%!test
%! x = [1 2 3]';
%! j = 3;
%! [hv, b, z] = housh (x, j, 0);
%! r = (eye (3) - b*hv*hv') * x;
%! d = - norm (x) * [0 0 1]';
%! assert (r, d, 2e-8);
%! assert (z, 0, 2e-8);

%!test
%! x = [7 -3 1]';
%! j = 2;
%! [hv, b, z] = housh (x, j, 0);
%! r = (eye (3) - b*hv*hv') * x;
%! d = norm (x) * [0 1 0]';
%! assert (r, d, 2e-8);
%! assert (z, 0, 2e-8);

%!test
%! x = [1 0 0]';
%! j = 1;
%! [hv, b, z] = housh (x, j, 10);
%! r = (eye (3) - b*hv*hv') * x;
%! d = norm (x) * [1 0 0]';
%! assert (r, d, 2e-8);
%! assert (z, 1, 2e-8);

%!test
%! x = [5 0 4 1]';
%! j = 2;
%! [hv, b, z] = housh (x, j, 0);
%! r = (eye (4) - b*hv*hv') * x;
%! d = - norm (x) * [0 1 0 0]';
%! assert (r, d, 2e-8);
%! assert (z, 0, 2e-8);

%!error <Invalid call> housh ()
%!error <Invalid call> housh (1)
%!error <Invalid call> housh (1,2)
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isbanded (@var{A}, @var{lower}, @var{upper})
## Return true if @var{A} is a matrix with entries confined between
## @var{lower} diagonals below the main diagonal and @var{upper} diagonals
## above the main diagonal.
##
## @var{lower} and @var{upper} must be non-negative integers.
## @seealso{isdiag, istril, istriu, bandwidth}
## @end deftypefn

function retval = isbanded (A, lower, upper)

  if (nargin != 3)
    print_usage ();
  endif

  if (! isreal (lower) || ! isreal (upper) || lower < 0 || upper < 0)
    error ("isbanded: LOWER and UPPER must be non-negative integers");
  endif

  if (isempty (A))
    retval = [];
  else
    retval = (isnumeric (A) || islogical (A)) && ndims (A) == 2;
    if (retval)
      [i, j] = find (A);
      pupp = j >= i;
      retval = all (j(pupp) - i(pupp) <= upper);
      if (retval)
        plow = i >= j;
        retval = all (i(plow) - j(plow) <= lower);
      endif
    endif
  endif

endfunction


%!assert (! isbanded ("string", 0, 0))
%!assert (! isbanded (zeros (2,2,2), 0, 0))
%!assert (isbanded ([], 0, 0), [])
%!assert (isbanded (1,0,0))
%!assert (isbanded (1,10,10))

%!assert (isbanded ([1, 1],1,1))
%!assert (isbanded ([1; 1],1,1))
%!assert (isbanded (eye (10),0,0))
%!assert (isbanded (eye (10),1,1))
%!assert (isbanded (i*eye (10),1,1))
%!assert (isbanded (logical (eye (10)),1,1))

%! A = [2 3 0 0 0; 1 2 3 0 0; 0 1 2 3 0; 0 0 1 2 3; 0 0 0 1 2];
%! assert (isbanded (A,1,1));
%! assert (! isbanded (A,0,1));
%! assert (! isbanded (A,1,0));

## Test input validation
%!error <Invalid call> isbanded ()
%!error <Invalid call> isbanded (1)
%!error <Invalid call> isbanded (1,2)
%!error <LOWER and UPPER must be non-negative> isbanded (1, -1, 1)
%!error <LOWER and UPPER must be non-negative> isbanded (1, 1, -1)
%!error <LOWER and UPPER must be non-negative> isbanded (1, {1}, 1)
%!error <LOWER and UPPER must be non-negative> isbanded (1, 1, {1})
########################################################################
##
## Copyright (C) 2003-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} isdefinite (@var{A})
## @deftypefnx {} {} isdefinite (@var{A}, @var{tol})
## Return true if @var{A} is symmetric positive definite matrix within the
## tolerance specified by @var{tol}.
##
## If @var{tol} is omitted, use a tolerance of
## @code{100 * eps * norm (@var{A}, "fro")}.
##
## Background: A positive definite matrix has eigenvalues which are all
## greater than zero.  A positive semi-definite matrix has eigenvalues which
## are all greater than or equal to zero.  The matrix @var{A} is very likely to
## be positive semi-definite if the following two conditions hold for a
## suitably small tolerance @var{tol}.
##
## @example
## @group
## isdefinite (@var{A}) @result{} 0
## isdefinite (@var{A} + 5*@var{tol}, @var{tol}) @result{} 1
## @end group
## @end example
## @seealso{issymmetric, ishermitian}
## @end deftypefn

function retval = isdefinite (A, tol)

  if (nargin < 1)
    print_usage ();
  endif

  ## Validate inputs
  retval = false;
  if (! isnumeric (A))
    return;
  endif

  if (! isfloat (A))
    A = double (A);
  endif

  if (nargin == 1)
    tol = 100 * eps (class (A)) * norm (A, "fro");
  elseif (! (isnumeric (tol) && isscalar (tol) && tol >= 0))
    error ("isdefinite: TOL must be a scalar >= 0");
  endif

  if (! ishermitian (A, tol))
    return;
  endif

  e = tol * eye (rows (A));
  [~, p] = chol (A - e);
  if (p == 0)
    retval = true;
  endif

endfunction


%!test
%! A = [-1, 0; 0, -1];
%! assert (isdefinite (A), false);

%!test
%! A = [1, 0; 0, 1];
%! assert (isdefinite (A), true);

%!test
%! A = [2, -1,  0; -1, 2, -1; 0, -1, 2];
%! assert (isdefinite (A), true);

## Test for positive semi-definite matrix
%!test
%! A = [1, 0; 0, 0];
%! assert (isdefinite (A), false);
%! tol = 100*eps;
%! assert (isdefinite (A+5*tol, tol), true);

%!assert (! isdefinite (magic (3)))

%!error <Invalid call> isdefinite ()
%!error <TOL must be a scalar .= 0> isdefinite (1, {1})
%!error <TOL must be a scalar .= 0> isdefinite (1, [1 1])
%!error <TOL must be a scalar .= 0> isdefinite (1, -1)
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isdiag (@var{A})
## Return true if @var{A} is a diagonal matrix.
## @seealso{isbanded, istril, istriu, diag, bandwidth}
## @end deftypefn

function retval = isdiag (A)

  if (nargin < 1)
    print_usage ();
  endif

  if (strfind (typeinfo (A), "diagonal matrix"))
    retval = true;
  elseif ((isnumeric (A) || islogical (A)) && ndims (A) == 2)
    [i, j] = find (A);
    retval = all (i == j);
  else
    retval = false;
  endif

endfunction


%!assert (isdiag ("string"), false)
%!assert (isdiag (zeros (2,2,2)), false)
%!assert (isdiag (zeros (2)))
%!assert (isdiag ([]))
%!assert (isdiag (1))
%!assert (isdiag ([1, 1]), false)
%!assert (isdiag ([1; 1]), false)
%!assert (isdiag (eye (10)))
%!assert (isdiag (single (eye (10))))
%!assert (isdiag (logical (eye (10))))
%!assert (isdiag (speye (1e2)))
%!assert (isdiag (diag (1:10)))

## Test input validation
%!error <Invalid call> isdiag ()
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} ishermitian (@var{A})
## @deftypefnx {} {} ishermitian (@var{A}, @var{tol})
## @deftypefnx {} {} ishermitian (@var{A}, @qcode{"skew"})
## @deftypefnx {} {} ishermitian (@var{A}, @qcode{"skew"}, @var{tol})
## Return true if @var{A} is a Hermitian or skew-Hermitian matrix within the
## tolerance specified by @var{tol}.
##
## The default tolerance is zero (uses faster code).
##
## The type of symmetry to check may be specified with the additional input
## @qcode{"nonskew"} (default) for regular Hermitian or @qcode{"skew"} for
## skew-Hermitian.
##
## Background: A matrix is Hermitian if the complex conjugate transpose of the
## matrix is equal to the original matrix: @w{@tcode{@var{A} == @var{A}'}}.  If
## a tolerance is given then the calculation is
## @code{norm (@var{A} - @var{A}', Inf) / norm (@var{A}, Inf) < @var{tol}}.
##
## A matrix is skew-Hermitian if the complex conjugate transpose of the matrix
## is equal to the negative of the original matrix:
## @w{@tcode{@var{A} == -@var{A}'}}.  If a
## tolerance is given then the calculation is
## @code{norm (@var{A} + @var{A}', Inf) / norm (@var{A}, Inf) < @var{tol}}.
## @seealso{issymmetric, isdefinite}
## @end deftypefn

function retval = ishermitian (A, skewopt = "nonskew", tol = 0)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 2)
    ## Decode whether second argument is skewopt or tol
    if (isnumeric (skewopt))
      tol = skewopt;
      skewopt = "nonskew";
    elseif (! ischar (skewopt))
      error ("ishermitian: second argument must be a non-negative scalar TOL, or one of the strings: 'skew' / 'nonskew'");
    endif
  endif

  ## Validate inputs
  retval = (isnumeric (A) || islogical (A)) && issquare (A);
  if (! retval)
    return;
  endif

  if (! (strcmp (skewopt, "skew") || strcmp (skewopt, "nonskew")))
    error ("ishermitian: SKEWOPT must be 'skew' or 'nonskew'");
  endif

  if (! (isnumeric (tol) && isscalar (tol) && tol >= 0))
    error ("ishermitian: TOL must be a scalar >= 0");
  endif

  ## Calculate Hermitian-ness
  if (strcmp (skewopt, "nonskew"))
    if (tol == 0)
      ## check for exact symmetry
      retval = full (! any ((A != A')(:)));
    else
      if (islogical (A))
        ## Hack to allow norm to work.  Choose single to minimize memory.
        A = single (A);
      endif
      norm_x = norm (A, Inf);
      retval = norm_x == 0 || norm (A - A', Inf) / norm_x <= tol;
    endif
  else
    ## skew-Hermitian
    if (tol == 0)
      retval = full (! any ((A != -A')(:)));
    else
      if (islogical (A))
        ## Hack to allow norm to work.  Choose single to minimize memory.
        A = single (A);
      endif
      norm_x = norm (A, Inf);
      retval = norm_x == 0 || norm (A + A', Inf) / norm_x <= tol;
    endif
  endif

endfunction


%!assert (ishermitian (1))
%!assert (! ishermitian ([1, 2]))
%!assert (ishermitian ([]))
%!assert (ishermitian ([1, 2; 2, 1]))
%!assert (ishermitian ([1, 2.1; 2, 1.1], 0.2))
%!assert (ishermitian ([1, -2i; 2i, 1]))
%!assert (ishermitian (speye (100)), true)  # Return full logical value.
%!assert (ishermitian (logical (eye (2))))
%!assert (! ishermitian (logical ([1 1; 0 1])))
%!assert (ishermitian (logical ([1 1; 0 1]), 0.5))
%!assert (ishermitian ([0, 2i; 2i, 0], "skew"))
%!assert (! ishermitian ([0, 2; -2, eps], "skew"))
%!assert (ishermitian ([0, 2; -2, eps], "skew", eps))

%!assert (! (ishermitian ("test")))
%!assert (! (ishermitian ("t")))
%!assert (! (ishermitian (["te"; "et"])))
%!assert (! ishermitian ({1}))
%!test
%! s.a = 1;
%! assert (! ishermitian (s));

## Test input validation
%!error <Invalid call> ishermitian ()
%!error <second argument must be> ishermitian (1, {"skew"})
%!error <SKEWOPT must be 'skew' or 'nonskew'> ishermitian (1, "foobar")
%!error <SKEWOPT must be 'skew' or 'nonskew'> ishermitian (1, "foobar")
%!error <TOL must be a scalar .= 0> ishermitian (1, "skew", {1})
%!error <TOL must be a scalar .= 0> ishermitian (1, "skew", [1 1])
%!error <TOL must be a scalar .= 0> ishermitian (1, -1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} issymmetric (@var{A})
## @deftypefnx {} {} issymmetric (@var{A}, @var{tol})
## @deftypefnx {} {} issymmetric (@var{A}, @qcode{"skew"})
## @deftypefnx {} {} issymmetric (@var{A}, @qcode{"skew"}, @var{tol})
## Return true if @var{A} is a symmetric or skew-symmetric matrix within the
## tolerance specified by @var{tol}.
##
## The default tolerance is zero (uses faster code).
##
## The type of symmetry to check may be specified with the additional input
## @qcode{"nonskew"} (default) for regular symmetry or @qcode{"skew"} for
## skew-symmetry.
##
## Background: A matrix is symmetric if the transpose of the matrix is equal
## to the original matrix: @w{@tcode{@var{A} == @var{A}.'}}.  If a tolerance
## is given then symmetry is determined by
## @code{norm (@var{A} - @var{A}.', Inf) / norm (@var{A}, Inf) < @var{tol}}.
##
## A matrix is skew-symmetric if the transpose of the matrix is equal to the
## negative of the original matrix: @w{@tcode{@var{A} == -@var{A}.'}}.  If a
## tolerance is given then skew-symmetry is determined by
## @code{norm (@var{A} + @var{A}.', Inf) / norm (@var{A}, Inf) < @var{tol}}.
## @seealso{ishermitian, isdefinite}
## @end deftypefn

function retval = issymmetric (A, skewopt = "nonskew", tol = 0)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 2)
    ## Decode whether second argument is skewopt or tol
    if (isnumeric (skewopt))
      tol = skewopt;
      skewopt = "nonskew";
    elseif (! ischar (skewopt))
      error ("issymmetric: second argument must be a non-negative scalar TOL, or one of the strings: 'skew' / 'nonskew'");
    endif
  endif

  ## Validate inputs
  if (! (isnumeric (A) || islogical (A) || ischar (A)))
    error ("issymmetric: A must be a numeric, logical, or character matrix");
  endif

  if (! (strcmp (skewopt, "skew") || strcmp (skewopt, "nonskew")))
    error ("issymmetric: SKEWOPT must be 'skew' or 'nonskew'");
  endif

  if (! (isnumeric (tol) && isscalar (tol) && tol >= 0))
    error ("issymmetric: TOL must be a scalar >= 0");
  endif

  if (! issquare (A))
    retval = false;
    return;
  endif

  ## Calculate symmetry
  if (strcmp (skewopt, "nonskew"))
    if (tol == 0)
      ## check for exact symmetry
      retval = full (! any ((A != A.')(:)));
    else
      if (! isnumeric (A))
        ## Hack to allow norm to work.  Choose single to minimize memory.
        A = single (A);
      endif
      norm_x = norm (A, Inf);
      retval = norm_x == 0 || norm (A - A.', Inf) / norm_x <= tol;
    endif
  else
    ## skew symmetry
    if (tol == 0)
      retval = full (! any ((A != -A.')(:)));
    else
      if (! isnumeric (A))
        ## Hack to allow norm to work.  Choose single to minimize memory.
        A = single (A);
      endif
      norm_x = norm (A, Inf);
      retval = norm_x == 0 || norm (A + A.', Inf) / norm_x <= tol;
    endif
  endif

endfunction


%!assert (issymmetric (1))
%!assert (! issymmetric ([1, 2]))
%!assert (issymmetric ([]))
%!assert (issymmetric ([1, 2; 2, 1]))
%!assert (issymmetric ([1, 2.1; 2, 1.1], 0.2))
%!assert (issymmetric ([1, 2i; 2i, 1]))
%!assert (issymmetric (speye (100)), true)  # Return full logical value.
%!assert (! issymmetric ([0, 2; -2, 0], "nonskew"))
%!assert (issymmetric ([0, 2; -2, 0], "skew"))
%!assert (! issymmetric ([0, 2; -2, eps], "skew"))
%!assert (issymmetric ([0, 2; -2, eps], "skew", eps))
%!assert (issymmetric (logical (eye (2))))
%!assert (! issymmetric (logical ([1 1; 0 1])))
%!assert (issymmetric (logical ([1 1; 0 1]), 0.5))
%!assert (! issymmetric ("test"))
%!assert (issymmetric ("t"))
%!assert (issymmetric (["te"; "et"]))

## Test input validation
%!error <Invalid call> issymmetric ()
%!error <second argument must be> issymmetric (1, {"skew"})
%!error <A must be a numeric,.* matrix> issymmetric ({1})
%!error <SKEWOPT must be 'skew' or 'nonskew'> issymmetric (1, "foobar")
%!error <TOL must be a scalar .= 0> issymmetric (1, "skew", {1})
%!error <TOL must be a scalar .= 0> issymmetric (1, "skew", [1 1])
%!error <TOL must be a scalar .= 0> issymmetric (1, -1)
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} istril (@var{A})
## Return true if @var{A} is a lower triangular matrix.
##
## A lower triangular matrix has nonzero entries only on the main diagonal and
## below.
## @seealso{istriu, isbanded, isdiag, tril, bandwidth}
## @end deftypefn

function retval = istril (A)

  if (nargin < 1)
    print_usage ();
  endif

  retval = (isnumeric (A) || islogical (A)) && ndims (A) == 2;
  if (retval)
    [i, j] = find (A);
    retval = all (i >= j);
  endif

endfunction


%!assert (! istril ("string"))
%!assert (istril ([]))
%!assert (! istril (zeros (2,2,2)))

%!assert (istril (1))
%!assert (! istril ([1, 1]))
%!assert (istril ([1; 1]))
%!assert (istril (eye (10)))
%!assert (istril (speye (100)))

%!assert (istril (tril (randn (10))))
%!assert (! istril (randn (10)))

## Test input validation
%!error <Invalid call> istril ()
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} istriu (@var{A})
## Return true if @var{A} is an upper triangular matrix.
##
## An upper triangular matrix has nonzero entries only on the main diagonal and
## above.
## @seealso{isdiag, isbanded, istril, triu, bandwidth}
## @end deftypefn

function retval = istriu (A)

  if (nargin < 1)
    print_usage ();
  endif

  retval = (isnumeric (A) || islogical (A)) && ndims (A) == 2;
  if (retval)
    [i, j] = find (A);
    retval = all (i <= j);
  endif

endfunction


%!assert (! istriu ("string"))
%!assert (istriu ([]))
%!assert (! istriu (zeros (2,2,2)))

%!assert (istriu (1))
%!assert (istriu ([1, 1]))
%!assert (! istriu ([1; 1]))
%!assert (istriu (eye (10)))
%!assert (istriu (speye (100)))

%!assert (istriu (triu (randn (10))))
%!assert (! istriu (randn (10)))

## Test input validation
%!error <Invalid call> istriu ()
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{u}, @var{h}, @var{nu}] =} krylov (@var{A}, @var{V}, @var{k}, @var{eps1}, @var{pflg})
## Construct an orthogonal basis @var{u} of a block Krylov subspace.
##
## The block Krylov subspace has the following form:
##
## @example
## [v a*v a^2*v @dots{} a^(k+1)*v]
## @end example
##
## @noindent
## The construction is made with Householder reflections to guard against loss
## of orthogonality.
##
## If @var{V} is a vector, then @var{h} contains the Hessenberg matrix
## such that @nospell{@tcode{a*u == u*h+rk*ek'}}, in which
## @code{rk = a*u(:,k)-u*h(:,k)}, and @nospell{@tcode{ek'}} is the vector
## @code{[0, 0, @dots{}, 1]} of length @var{k}.  Otherwise, @var{h} is
## meaningless.
##
## If @var{V} is a vector and @var{k} is greater than @code{length (A) - 1},
## then @var{h} contains the Hessenberg matrix such that @code{a*u == u*h}.
##
## The value of @var{nu} is the dimension of the span of the Krylov subspace
## (based on @var{eps1}).
##
## If @var{b} is a vector and @var{k} is greater than @var{m-1}, then @var{h}
## contains the Hessenberg decomposition of @var{A}.
##
## The optional parameter @var{eps1} is the threshold for zero.  The default
## value is 1e-12.
##
## If the optional parameter @var{pflg} is nonzero, row pivoting is used to
## improve numerical behavior.  The default value is 0.
##
## Reference: @nospell{A. Hodel, P. Misra}, @cite{Partial Pivoting in the
## Computation of Krylov Subspaces of Large Sparse Systems}, Proceedings of
## the 42nd IEEE Conference on Decision and Control, December 2003.
## @end deftypefn

function [Uret, H, nu] = krylov (A, V, k, eps1, pflg)

  if (isa (A, "single") || isa (V, "single"))
    defeps = 1e-6;
  else
    defeps = 1e-12;
  endif

  if (nargin < 3)
    print_usage ();
  elseif (nargin < 5)
    ## Default permutation flag.
    pflg = 0;
  endif

  if (nargin < 4)
    ## Default tolerance parameter.
    eps1 = defeps;
  endif

  if (isempty (eps1))
    eps1 = defeps;
  endif

  if (! issquare (A) || isempty (A))
    error ("krylov: A(%d x %d) must be a non-empty square matrix", rows (A), columns (A));
  endif
  na = rows (A);

  [m, kb] = size (V);
  if (m != na)
    error ("krylov: A(%d x %d), V(%d x %d): argument dimensions do not match",
           na, na, m, kb);
  endif

  if (! isscalar (k))
    error ("krylov: K must be a scalar integer");
  endif

  Vnrm = norm (V, Inf);

  ## check for trivial solution.
  if (Vnrm == 0)
    Uret = [];
    H = [];
    nu = 0;
    return;
  endif

  ## Identify trivial null space.
  abm = max (abs ([A, V]'));
  zidx = find (abm == 0);

  ## Set up vector of pivot points.
  pivot_vec = 1:na;

  iter = 0;
  alpha = [];
  nh = 0;
  while (length (alpha) < na) && (columns (V) > 0) && (iter < k)
    iter += 1;

    ## Get orthogonal basis of V.
    jj = 1;
    while (jj <= columns (V) && length (alpha) < na)
      ## Index of next Householder reflection.
      nu = length (alpha)+1;

      short_pv = pivot_vec(nu:na);
      q = V(:,jj);
      short_q = q(short_pv);

      if (norm (short_q) < eps1)
        ## Insignificant column; delete.
        nv = columns (V);
        if (jj != nv)
          [V(:,jj), V(:,nv)] = swap (V(:,jj), V(:,nv));
          ## FIXME: H columns should be swapped too.
          ##        Not done since Block Hessenberg structure is lost anyway.
        endif
        V = V(:,1:(nv-1));
        ## One less reflection.
        nu -= 1;
      else
        ## New householder reflection.
        if (pflg)
          ## Locate max magnitude element in short_q.
          asq = abs (short_q);
          maxv = max (asq);
          maxidx = find (asq == maxv, 1);
          pivot_idx = short_pv(maxidx);

          ## See if need to change the pivot list.
          if (pivot_idx != pivot_vec(nu))
            swapidx = maxidx + (nu-1);
            [pivot_vec(nu), pivot_vec(swapidx)] = ...
                swap (pivot_vec(nu), pivot_vec(swapidx));
          endif
        endif

        ## Isolate portion of vector for reflection.
        idx = pivot_vec(nu:na);
        jdx = pivot_vec(1:nu);

        [hv, av, z] = housh (q(idx), 1, 0);
        alpha(nu) = av;
        U(idx,nu) = hv;

        ## Reduce V per the reflection.
        V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
        if (iter > 1)
          ## FIXME: not done correctly for block case.
          H(nu,nu-1) = V(pivot_vec(nu),jj);
        endif

        ## Advance to next column of V.
        jj += 1;
      endif
    endwhile

    ## Check for oversize V (due to full rank).
    if ((columns (V) > na) && (length (alpha) == na))
      ## Trim to size.
      V = V(:,1:na);
    elseif (columns (V) > na)
      krylov_V = V;
      krylov_na = na;
      krylov_length_alpha = length (alpha);
      error ("krylov: this case should never happen; submit a bug report");
    endif

    if (columns (V) > 0)
      ## Construct next Q and multiply.
      Q = zeros (size (V));
      for kk = 1:columns (Q)
        Q(pivot_vec(nu-columns (Q)+kk),kk) = 1;
      endfor

      ## Apply Householder reflections.
      for ii = nu:-1:1
        idx = pivot_vec(ii:na);
        hv = U(idx,ii);
        av = alpha(ii);
        Q(idx,:) = Q(idx,:) - av*hv*(hv'*Q(idx,:));
      endfor
    endif

    ## Multiply to get new vector.
    V = A*Q;
    ## Project off of previous vectors.
    nu = length (alpha);
    for i = 1:nu
      hv = U(:,i);
      av = alpha(i);
      V -= av*hv*(hv'*V);
      H(i,nu-columns (V)+(1:columns (V))) = V(pivot_vec(i),:);
    endfor

  endwhile

  ## Back out complete U matrix.
  ## back out U matrix.
  j1 = columns (U);
  for i = j1:-1:1
    idx = pivot_vec(i:na);
    hv = U(idx,i);
    av = alpha(i);
    U(:,i) = zeros (na, 1);
    U(idx(1),i) = 1;
    U(idx,i:j1) = U(idx,i:j1)-av*hv*(hv'*U(idx,i:j1));
  endfor

  nu = length (alpha);
  Uret = U;
  if (max (max (abs (Uret(zidx,:)))) > 0)
    warning ("krylov: trivial null space corrupted; set pflg = 1 or eps1 > %e",
             eps1);
  endif

endfunction


function [a1, b1] = swap (a, b)

  a1 = b;
  b1 = a;

endfunction
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} linsolve (@var{A}, @var{b})
## @deftypefnx {} {@var{x} =} linsolve (@var{A}, @var{b}, @var{opts})
## @deftypefnx {} {[@var{x}, @var{R}] =} linsolve (@dots{})
## Solve the linear system @code{A*x = b}.
##
## With no options, this function is equivalent to the left division operator
## @w{(@code{x = A \ b})} or the matrix-left-divide function
## @w{(@code{x = mldivide (A, b)})}.
##
## Octave ordinarily examines the properties of the matrix @var{A} and chooses
## a solver that best matches the matrix.  By passing a structure @var{opts}
## to @code{linsolve} you can inform Octave directly about the matrix @var{A}.
## In this case Octave will skip the matrix examination and proceed directly
## to solving the linear system.
##
## @strong{Warning:} If the matrix @var{A} does not have the properties listed
## in the @var{opts} structure then the result will not be accurate AND no
## warning will be given.  When in doubt, let Octave examine the matrix and
## choose the appropriate solver as this step takes little time and the result
## is cached so that it is only done once per linear system.
##
## Possible @var{opts} fields (set value to true/false):
##
## @table @asis
## @item LT
##   @var{A} is lower triangular
##
## @item UT
##   @var{A} is upper triangular
##
## @item UHESS
##   @var{A} is upper Hessenberg (currently makes no difference)
##
## @item SYM
##   @var{A} is symmetric or complex Hermitian (currently makes no difference)
##
## @item POSDEF
##   @var{A} is positive definite
##
## @item RECT
##   @var{A} is general rectangular (currently makes no difference)
##
## @item TRANSA
##   Solve @code{A'*x = b} if true rather than @code{A*x = b}
## @end table
##
## The optional second output @var{R} is the inverse condition number of
## @var{A} (zero if matrix is singular).
## @seealso{mldivide, matrix_type, rcond}
## @end deftypefn

function [x, R] = linsolve (A, b, opts)

  if (nargin < 2)
    print_usage ();
  endif

  if (! (isnumeric (A) && isnumeric (b)))
    error ("linsolve: A and B must be numeric");
  endif

  trans_A = false;

  ## Process any opts
  if (nargin > 2)
    if (! isstruct (opts))
      error ("linsolve: OPTS must be a structure");
    endif
    if (isfield (opts, "TRANSA") && opts.TRANSA)
      trans_A = true;
    endif
    if (isfield (opts, "POSDEF") && opts.POSDEF)
      A = matrix_type (A, "positive definite");
    endif
    if (isfield (opts, "LT") && opts.LT)
      A = matrix_type (A, "lower");
    elseif (isfield (opts, "UT") && opts.UT)
      A = matrix_type (A, "upper");
    endif
  endif

  ## This way is faster as the transpose is not calculated in Octave,
  ## but forwarded as a flag option to BLAS.
  if (trans_A)
    x = A' \ b;
  else
    x = A \ b;
  endif

  if (nargout > 1)
    if (issquare (A))
      R = rcond (A);
    else
      R = 0;
    endif
  endif

endfunction


%!test
%! n = 10;
%! A = rand (n);
%! x = rand (n, 1);
%! b = A * x;
%! assert (linsolve (A, b), A \ b);
%! assert (linsolve (A, b, struct ()), A \ b);

%!test
%! n = 10;
%! A = triu (gallery ("condex", n));
%! x = rand (n, 1);
%! b = A' * x;
%! opts.UT = true;
%! opts.TRANSA = true;
%! assert (linsolve (A, b, opts), A' \ b);

%!error <Invalid call> linsolve ()
%!error <Invalid call> linsolve (1)
%!error linsolve (1,2,3)
%!error <A and B must be numeric> linsolve ({1},2)
%!error <A and B must be numeric> linsolve (1,{2})
%!error <OPTS must be a structure> linsolve (1,2,3)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{s} =} logm (@var{A})
## @deftypefnx {} {@var{s} =} logm (@var{A}, @var{opt_iters})
## @deftypefnx {} {[@var{s}, @var{iters}] =} logm (@dots{})
## Compute the matrix logarithm of the square matrix @var{A}.
##
## The implementation utilizes a Pad@'e approximant and the identity
##
## @example
## logm (@var{A}) = 2^k * logm (@var{A}^(1 / 2^k))
## @end example
##
## The optional input @var{opt_iters} is the maximum number of square roots
## to compute and defaults to 100.
##
## The optional output @var{iters} is the number of square roots actually
## computed.
## @seealso{expm, sqrtm}
## @end deftypefn

## Reference: N. J. Higham, Functions of Matrices: Theory and Computation
##            (SIAM, 2008.)
##

## Author: N. J. Higham
## Author: Richard T. Guy <guyrt7@wfu.edu>

function [s, iters] = logm (A, opt_iters = 100)

  if (nargin == 0)
    print_usage ();
  endif

  if (! issquare (A))
    error ("logm: A must be a square matrix");
  endif

  if (isscalar (A))
    s = log (A);
    return;
  elseif (isdiag (A))
    s = diag (log (diag (A)));
    return;
  endif

  [u, s] = schur (A);

  if (isreal (A))
    [u, s] = rsf2csf (u, s);
  endif

  eigv = diag (s);
  n = rows (A);
  tol = n * eps (max (abs (eigv)));
  real_neg_eigv = (real (eigv) < -tol) & (imag (eigv) <= tol);
  if (any (real_neg_eigv))
    warning ("Octave:logm:non-principal",
             "logm: principal matrix logarithm is not defined for matrices with negative eigenvalues; computing non-principal logarithm");
  endif

  real_eig = ! any (real_neg_eigv);

  if (max (abs (triu (s,1))(:)) < tol)
    ## Will run for Hermitian matrices as Schur decomposition is diagonal.
    ## This way is faster and more accurate but only works on a diagonal matrix.
    logeigv = log (eigv);
    logeigv(isinf (logeigv)) = -log (realmax ());
    s = u * diag (logeigv) * u';
    iters = 0;
  else
    k = 0;
    ## Algorithm 11.9 in "Function of matrices", by N. Higham
    theta = [0, 0, 1.61e-2, 5.38e-2, 1.13e-1, 1.86e-1, 2.6429608311114350e-1];
    p = 0;
    m = 7;
    while (k < opt_iters)
      tau = norm (s - eye (n), 1);
      if (tau <= theta (7))
        p += 1;
        j(1) = find (tau <= theta, 1);
        j(2) = find (tau / 2 <= theta, 1);
        if (j(1) - j(2) <= 1 || p == 2)
          m = j(1);
          break;
        endif
      endif
      k += 1;
      s = sqrtm (s);
    endwhile

    if (k >= opt_iters)
      warning ("logm: maximum number of square roots exceeded; results may still be accurate");
    endif

    s -= eye (n);

    if (m > 1)
      s = logm_pade_pf (s, m);
    endif

    s = 2^k * u * s * u';

    if (nargout == 2)
      iters = k;
    endif
  endif
  ## Remove small complex values (O(eps)) which may have entered calculation
  if (real_eig && isreal (A))
    s = real (s);
  endif

endfunction

################## ANCILLARY FUNCTIONS ################################
######  Taken from the mfttoolbox (GPL 3) by D. Higham.
######  Reference:
######      D. Higham, Functions of Matrices: Theory and Computation
######      (SIAM, 2008.).
#######################################################################

##LOGM_PADE_PF   Evaluate Pade approximant to matrix log by partial fractions.
##   Y = LOGM_PADE_PF(A,M) evaluates the [M/M] Pade approximation to
##   LOG(EYE(SIZE(A))+A) using a partial fraction expansion.

function s = logm_pade_pf (A, m)

  [nodes, wts] = gauss_legendre (m);
  ## Convert from [-1,1] to [0,1].
  nodes = (nodes+1)/2;
  wts /= 2;

  n = length (A);
  s = zeros (n);
  for j = 1:m
    s += wts(j)*(A/(eye (n) + nodes(j)*A));
  endfor

endfunction

######################################################################
## GAUSS_LEGENDRE  Nodes and weights for Gauss-Legendre quadrature.
##   [X,W] = GAUSS_LEGENDRE(N) computes the nodes X and weights W
##   for N-point Gauss-Legendre quadrature.

## Reference:
## G. H. Golub and J. H. Welsch, Calculation of Gauss quadrature
## rules, Math. Comp., 23(106):221-230, 1969.

function [x, w] = gauss_legendre (n)

  i = 1:n-1;
  v = i./sqrt ((2*i).^2-1);
  [V, D] = eig (diag (v, -1) + diag (v, 1));
  x = diag (D);
  w = 2*(V(1,:)'.^2);

endfunction


%!assert (norm (logm ([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5)
%!test
%! warning ("off", "Octave:logm:non-principal", "local");
%! assert (norm (expm (logm ([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5);
%!assert (logm ([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5)
%!assert (logm (10), log (10))
%!assert (full (logm (eye (3))), logm (full (eye (3))))
%!assert (full (logm (10*eye (3))), logm (full (10*eye (3))), 8*eps)
%!assert (logm (expm ([0 1i; -1i 0])), [0 1i; -1i 0], 10 * eps)
%!test <*60738>
%! A = [0.2510, 1.2808, -1.2252; ...
%!      0.2015, 1.0766, 0.5630; ...
%!      -1.9769, -1.0922, -0.5831];
%! if (ismac ())
%!   ## The math libraries on macOS seem to require larger tolerances
%!   tol = 60*eps;
%! else
%!   tol = 40*eps;
%! endif
%! warning ("off", "Octave:logm:non-principal", "local");
%! assert (expm (logm (A)), A, tol);
%!assert (expm (logm (eye (3))), eye (3));
%!assert (expm (logm (zeros (3))), zeros (3));

## Test input validation
%!error <Invalid call> logm ()
%!error <logm: A must be a square matrix> logm ([1 0;0 1; 2 2])
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} lscov (@var{A}, @var{b})
## @deftypefnx {} {@var{x} =} lscov (@var{A}, @var{b}, @var{V})
## @deftypefnx {} {@var{x} =} lscov (@var{A}, @var{b}, @var{V}, @var{alg})
## @deftypefnx {} {[@var{x}, @var{stdx}, @var{mse}, @var{S}] =} lscov (@dots{})
##
## Compute a generalized linear least squares fit.
##
## Estimate @var{x} under the model @var{b} = @var{A}@var{x} + @var{w}, where
## the noise @var{w} is assumed to follow a normal distribution with covariance
## matrix @math{{\sigma^2} V}.
##
## If the size of the coefficient matrix @var{A} is n-by-p, the size of the
## vector/array of constant terms @var{b} must be n-by-k.
##
## The optional input argument @var{V} may be an n-element vector of positive
## weights (inverse variances), or an n-by-n symmetric positive semi-definite
## matrix representing the covariance of @var{b}.  If @var{V} is not supplied,
## the ordinary least squares solution is returned.
##
## The @var{alg} input argument, a guidance on solution method to use, is
## currently ignored.
##
## Besides the least-squares estimate matrix @var{x} (p-by-k), the function
## also returns @var{stdx} (p-by-k), the error standard deviation of estimated
## @var{x}; @var{mse} (k-by-1), the estimated data error covariance scale
## factors (@math{\sigma^2}); and @var{S} (p-by-p, or p-by-p-by-k if k > 1),
## the error covariance of @var{x}.
##
## Reference: @nospell{Golub and Van Loan} (1996),
## @cite{Matrix Computations (3rd Ed.)}, Johns Hopkins, Section 5.6.3
##
## @seealso{ols, gls, lsqnonneg}
## @end deftypefn

function [x, stdx, mse, S] = lscov (A, b, V = [], alg)

  if (nargin < 2)
    print_usage ();
  endif

  if (rows (A) != rows (b))
    error ("lscov: A and B must have the same number of rows");
  endif


  if (nargin == 4)
    warning ("lscov: algorithm selection input ALG is not yet implemented, using default");
  endif

  n = rows (A);
  p = columns (A);
  k = columns (b);

  if (! isempty (V))

    if (isvector (V))
      ## n-element vector of inverse variances
      if (numel (V) != n)
        error ("lscov: vector V must have n (number of row in A) elements ");
      endif

      v = diag (sqrt (V));
      A = v * A;
      b = v * b;
    else
      ## n-by-n covariance matrix
      if (size (V) != [n, n])
        error ("lscov: matrix V must be square with the same number of rows as A");
      endif

      try
        ## Ordinarily V will be positive definite
        B = chol (V)';
      catch
        ## If V is only positive semi-definite, use its
        ## eigendecomposition to find a factor B such that V = B*B'
        [B, lambda] = eig (V);
        image_dims = (diag (lambda) > 0);
        B = B(:, image_dims) * sqrt (lambda(image_dims, image_dims));
      end_try_catch
      A = B \ A;
      b = B \ b;
    endif
  endif

  pinv_A = pinv (A);

  x = pinv_A * b;

  if (nargout > 1)
    dof = n - p;  # degrees of freedom remaining after fit
    SSE = sumsq (b - A * x);
    mse = SSE / dof;

    s = pinv_A * pinv_A';
    stdx = sqrt (diag (s) * mse);

    if (nargout > 3)
      if (k == 1)
        S = mse * s;
      else
        S = NaN (p, p, k);
        for i = 1:k
          S(:, :, i) = mse(i) * s;
        endfor
      endif
    endif
  endif

endfunction


%!test <49040>
%! ## Longley data from the NIST Statistical Reference Dataset
%! Z = [  60323    83.0   234289   2356     1590    107608  1947
%!        61122    88.5   259426   2325     1456    108632  1948
%!        60171    88.2   258054   3682     1616    109773  1949
%!        61187    89.5   284599   3351     1650    110929  1950
%!        63221    96.2   328975   2099     3099    112075  1951
%!        63639    98.1   346999   1932     3594    113270  1952
%!        64989    99.0   365385   1870     3547    115094  1953
%!        63761   100.0   363112   3578     3350    116219  1954
%!        66019   101.2   397469   2904     3048    117388  1955
%!        67857   104.6   419180   2822     2857    118734  1956
%!        68169   108.4   442769   2936     2798    120445  1957
%!        66513   110.8   444546   4681     2637    121950  1958
%!        68655   112.6   482704   3813     2552    123366  1959
%!        69564   114.2   502601   3931     2514    125368  1960
%!        69331   115.7   518173   4806     2572    127852  1961
%!        70551   116.9   554894   4007     2827    130081  1962 ];
%! ## Results certified by NIST using 500 digit arithmetic
%! ## b and standard error in b
%! V = [  -3482258.63459582         890420.383607373
%!         15.0618722713733         84.9149257747669
%!        -0.358191792925910E-01    0.334910077722432E-01
%!        -2.02022980381683         0.488399681651699
%!        -1.03322686717359         0.214274163161675
%!        -0.511041056535807E-01    0.226073200069370
%!         1829.15146461355         455.478499142212 ];
%! rsd =  304.854073561965;
%! y = Z(:,1); X = [ones(rows(Z),1), Z(:,2:end)];
%! alpha = 0.05;
%! [b, stdb, mse] = lscov (X, y);
%! assert (b, V(:,1), 3e-6);
%! assert (stdb, V(:,2), -1.e-5);
%! assert (sqrt (mse), rsd, -1E-6);

%!test
%! ## Adapted from example in Matlab documentation
%! x1 = [.2 .5 .6 .8 1.0 1.1]';
%! x2 = [.1 .3 .4 .9 1.1 1.4]';
%! X = [ones(size(x1)) x1 x2];
%! y = [.17 .26 .28 .23 .27 .34]';
%! [b, se_b, mse, S] = lscov(X, y);
%! assert (b, [0.1203 0.3284 -0.1312]', 1E-4);
%! assert (se_b, [0.0643 0.2267 0.1488]', 1E-4);
%! assert (mse, 0.0015, 1E-4);
%! assert (S, [0.0041 -0.0130 0.0075; -0.0130 0.0514 -0.0328; 0.0075 -0.0328 0.0221], 1E-4);
%! w = [1 1 1 1 1 .1]';
%! [bw, sew_b, msew] = lscov (X, y, w);
%! assert (bw, [0.1046 0.4614 -0.2621]', 1E-4);
%! assert (sew_b, [0.0309 0.1152 0.0814]', 1E-4);
%! assert (msew, 3.4741e-004, -1E-4);
%! V = .2*ones (length (x1)) + .8*diag (ones (size (x1)));
%! [bg, sew_b, mseg] = lscov (X, y, V);
%! assert (bg, [0.1203 0.3284 -0.1312]', 1E-4);
%! assert (sew_b, [0.0672 0.2267 0.1488]', 1E-4);
%! assert (mseg, 0.0019, 1E-4);
%! y2 = [y 2*y];
%! [b2, se_b2, mse2, S2] = lscov (X, y2);
%! assert (b2, [b 2*b], 2*eps);
%! assert (se_b2, [se_b 2*se_b], 2*eps);
%! assert (mse2, [mse 4*mse], eps);
%! assert (S2(:, :, 1), S, eps);
%! assert (S2(:, :, 2), 4*S, 2*eps);

%!test
%! ## Artificial example with positive semi-definite weight matrix
%! x = (0:0.2:2)';
%! y = round (100*sin (x) + 200*cos (x));
%! X = [ones(size(x)) sin(x) cos(x)];
%! V = eye (numel (x));
%! V(end, end-1) = V(end-1, end) = 1;
%! [b, seb, mseb, S] = lscov (X, y, V);
%! assert (b, [0 100 200]', 0.2);

## Test input validation
%!error <Invalid call> lscov ()
%!error <Invalid call> lscov (1)
%!error <A and B must have the same number of rows> lscov (ones (2,2),1)
%!warning <algorithm selection input ALG is not yet implemented>
%! lscov (1,1, [], "chol");
%!error <vector V must have n .* elements> lscov (1,2, [1, 2])
%!error <matrix V must be square> lscov (1,2, [1 2 3; 4 5 6])
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{nest} =} normest (@var{A})
## @deftypefnx {} {@var{nest} =} normest (@var{A}, @var{tol})
## @deftypefnx {} {[@var{nest}, @var{iter}] =} normest (@dots{})
## Estimate the 2-norm of the matrix @var{A} using a power series analysis.
##
## This is typically used for large matrices, where the cost of calculating
## @code{norm (@var{A})} is prohibitive and an approximation to the 2-norm is
## acceptable.
##
## @var{tol} is the tolerance to which the 2-norm is calculated.  By default
## @var{tol} is 1e-6.
##
## The optional output @var{iter} returns the number of iterations that were
## required for @code{normest} to converge.
## @seealso{normest1, norm, cond, condest}
## @end deftypefn

function [nest, iter] = normest (A, tol = 1e-6)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (A) || ndims (A) != 2)
    error ("normest: A must be a numeric 2-D matrix");
  endif

  if (! (isscalar (tol) && isreal (tol)))
    error ("normest: TOL must be a real scalar");
  endif

  if (! isfloat (A))
    A = double (A);
  endif

  tol = max (tol, eps (class (A)));
  ## Set random number generator to depend on target matrix
  v = rand ("state");
  rand ("state", full (trace (A)));
  ncols = columns (A);
  ## Randomize y to avoid bad guesses for important matrices.
  y = rand (ncols, 1);
  iter = 0;
  nest = 0;
  do
    n0 = nest;
    x = A * y;
    normx = norm (x);
    if (normx == 0)
      x = rand (ncols, 1);
    else
      x /= normx;
    endif
    y = A' * x;
    nest = norm (y);
    iter += 1;
  until (abs (nest - n0) <= tol * nest)

  rand ("state", v);    # restore state of random number generator

endfunction


%!test
%! A = toeplitz ([-2,1,0,0]);
%! assert (normest (A), norm (A), 1e-6);

%!test
%! A = rand (10);
%! assert (normest (A), norm (A), 1e-6);

## Test input validation
%!error <Invalid call> normest ()
%!error <A must be a numeric .* matrix> normest ([true true])
%!error <A must be .* 2-D matrix> normest (ones (3,3,3))
%!error <TOL must be a real scalar> normest (1, [1, 2])
%!error <TOL must be a real scalar> normest (1, 1+1i)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{nest} =} normest1 (@var{A})
## @deftypefnx {} {@var{nest} =} normest1 (@var{A}, @var{t})
## @deftypefnx {} {@var{nest} =} normest1 (@var{A}, @var{t}, @var{x0})
## @deftypefnx {} {@var{nest} =} normest1 (@var{Afun}, @var{t}, @var{x0}, @var{p1}, @var{p2}, @dots{})
## @deftypefnx {} {[@var{nest}, @var{v}] =} normest1 (@var{A}, @dots{})
## @deftypefnx {} {[@var{nest}, @var{v}, @var{w}] =} normest1 (@var{A}, @dots{})
## @deftypefnx {} {[@var{nest}, @var{v}, @var{w}, @var{iter}] =} normest1 (@var{A}, @dots{})
## Estimate the 1-norm of the matrix @var{A} using a block algorithm.
##
## @code{normest1} is best for large sparse matrices where only an estimate of
## the norm is required.  For small to medium sized matrices, consider using
## @code{norm (@var{A}, 1)}.  In addition, @code{normest1} can be used for the
## estimate of the 1-norm of a linear operator @var{A} when matrix-vector
## products @code{@var{A} * @var{x}} and @code{@var{A}' * @var{x}} can be
## cheaply computed.  In this case, instead of the matrix @var{A}, a function
## @code{@var{Afun} (@var{flag}, @var{x})} is used; it must return:
##
## @itemize @bullet
## @item
## the dimension @var{n} of @var{A}, if @var{flag} is @qcode{"dim"}
##
## @item
## true if @var{A} is a real operator, if @var{flag} is @qcode{"real"}
##
## @item
## the result @code{@var{A} * @var{x}}, if @var{flag} is @qcode{"notransp"}
##
## @item
## the result @code{@var{A}' * @var{x}}, if @var{flag} is @qcode{"transp"}
## @end itemize
##
## A typical case is @var{A} defined by @code{@var{b} ^ @var{m}}, in which the
## result @code{@var{A} * @var{x}} can be computed without even forming
## explicitly @code{@var{b} ^ @var{m}} by:
##
## @example
## @group
## @var{y} = @var{x};
## for @var{i} = 1:@var{m}
##   @var{y} = @var{b} * @var{y};
## endfor
## @end group
## @end example
##
## The parameters @var{p1}, @var{p2}, @dots{} are arguments of
## @code{@var{Afun} (@var{flag}, @var{x}, @var{p1}, @var{p2}, @dots{})}.
##
## The default value for @var{t} is 2.  The algorithm requires matrix-matrix
## products with sizes @var{n} x @var{n} and @var{n} x @var{t}.
##
## The initial matrix @var{x0} should have columns of unit 1-norm.  The default
## initial matrix @var{x0} has the first column
## @code{ones (@var{n}, 1) / @var{n}} and, if @var{t} > 1, the remaining
## columns with random elements @code{-1 / @var{n}}, @code{1 / @var{n}},
## divided by @var{n}.
##
## On output, @var{nest} is the desired estimate, @var{v} and @var{w}
## are vectors such that @code{@var{w} = @var{A} * @var{v}}, with
## @code{norm (@var{w}, 1)} = @code{@var{c} * norm (@var{v}, 1)}.  @var{iter}
## contains in @code{@var{iter}(1)} the number of iterations (the maximum is
## hardcoded to 5) and in @code{@var{iter}(2)} the total number of products
## @code{@var{A} * @var{x}} or @code{@var{A}' * @var{x}} performed by the
## algorithm.
##
## Algorithm Note: @code{normest1} uses random numbers during evaluation.
## Therefore, if consistent results are required, the @qcode{"state"} of the
## random generator should be fixed before invoking @code{normest1}.
##
## Reference: @nospell{N. J. Higham and F. Tisseur},
## @cite{A block algorithm for matrix 1-norm estimation, with and
## application to 1-norm @nospell{pseudospectra}},
## @nospell{SIAM J. Matrix Anal.@: Appl.@:},
## pp.@: 1185--1201, Vol 21, No.@: 4, 2000.
##
## @seealso{normest, norm, cond, condest}
## @end deftypefn

## Ideally, we would set t and X to their default values but Matlab
## compatibility would require we set the default even when they are empty.
function [nest, v, w, iter] = normest1 (A, t = [], x0 = [], varargin)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (t))
    t = 2;
  endif

  ## FIXME: t < 0 should print trace information
  if (isnumeric (A) && issquare (A))
    Aismat = true;
    Aisreal = isreal (A);
    n = rows (A);
    if (n <= 4 || t == n)
      ## small input, compute directly
      [nest, idx] = max (sum (abs (A), 1), [] , 2);
      v = zeros (n, 1);
      v(idx) = 1;
      w = A(:, idx);
      ## Matlab incompatible on purpose.  Matlab returns iter as a row vector
      ## for this special case, but a column vector in all other cases.
      ## This is obviously a bug in Matlab that we don't reproduce.
      iter = [0; 1];
      return;
    endif
  elseif (is_function_handle (A))
    Aismat = false;
    Aisreal = A ("real", [], varargin{:});
    n = A ("dim", [], varargin{:});
    Afun = @(x) A ("notransp", x, varargin{:});
    A1fun = @(x) A ("transp", x, varargin{:});
  else
    error ("normest1: A must be a square matrix or a function handle");
  endif

  t = min (t, n);

  if (isempty (x0))
    X = [ones(n, 1), sign(2 * rand(n, t - 1) - 1)];
    i = 2;
    imax = min (t, 2^(n-1));
    ## There are at most 2^(n-1) unparallel columns, see later.
    while (i <= imax)
      if (any (abs (X(:,i)' * X(:,1:i-1)) == n))
        ## column i is parallel to a column 1:i-1.  Change it.
        X(:,i) = sign (2 * rand (n, 1) - 1);
      else
        i++;
      endif
    endwhile
    X /= n;
  else
    if (columns (x0) < t)
      error ("normest1: X0 must have %d columns", t);
    endif
    X = x0;
  endif

  itmax = 5;
  idx_hist = zeros (n, 1);
  nest_old = 0;
  idx = zeros (n, 1);
  S = zeros (n, t);
  iter = [0; 0];
  converged = false;
  while (! converged && (iter(1) < itmax))
    iter(1)++;
    if (Aismat)
      Y = A * X;
    else
      Y = Afun (X);
    endif
    iter(2)++;
    [nest, j] = max (sum (abs (Y), 1), [], 2);
    if ((nest > nest_old) || (iter(1) == 2))
      idx_best = idx(j);
      w = Y(:, j);  # there is an error in Algorithm 2.4
    endif
    if (nest <= nest_old && iter(1) >= 2)  # (1) of Algorithm 2.4
      nest = nest_old;
      break;  # while
    endif
    nest_old = nest;
    Sold = S;
    S = sign (Y);
    S(S==0) = 1;
    possible_break = false;
    if (Aisreal)
      ## test parallel (only real case)
      if (all (any (abs (Sold' * S) == n)))  # (2) of Algorithm 2.4
        ## all columns of S parallel to a column of Sold, exit
        possible_break = true;
        converged = true;
      else
        if (t > 1)
          ## at least two columns of S are not parallel
          i = 1;
          ## The maximum number of unparallel columns of length n with
          ## entries {-1,1} is 2^(n-1).  n of them are already in Sold.
          imax = min (t, 2 ^ (n - 1) - n);
          while (i <= imax)
            if (any (abs (S(:,i)' * S(:,1:i-1)) == n)
                || any (abs (S(:,i)' * Sold) == n))
              ## i-th column of S is parallel to a previous column
              ## or to a column of Sold.  Change it.
              S(:,i) = sign (2*rand (n, 1)-1);
            else
              i++;
            endif
          endwhile
        endif
      endif
    endif
    if (! possible_break)
      if (Aismat)
        Z = A' * S;
      else
        Z = A1fun (S);  # (3) of Algorithm 2.4
      endif
      iter(2)++;
      h = max (abs (Z), [], 2);
      idx = (1:n)';
      if (iter(1) >= 2 && (max (h, [], 1) == h(idx_best)))  # (4) of Alg. 2.4
        break;  # while
      endif
      [h, idx] = sort (h, "descend");
      if (t > 1)
       if (all (idx_hist(idx(1:t)))) # (5) of Algorithm 2.4
          break;  # while
        endif
        idx = idx(! idx_hist(idx));
        ## length(idx) could be less than t, especially if t is not << n.
        ## This is not considered in point (5) of Algorithm 2.4.
        tmax = min (numel (idx), t);
        idx = idx(1:tmax);
      else
        tmax = 1;
      endif
      X = zeros (n, tmax);
      X(sub2ind (size (X), idx(1:tmax), (1:tmax)')) = 1;
      idx_hist(idx(1:tmax)) = 1;
    endif
  endwhile
  v = zeros (n, 1);
  v(idx_best) = 1;

endfunction


%!function z = afun_A (flag, x, A, n)
%!  switch (flag)
%!  case {"dim"}
%!    z = n;
%!  case {"real"}
%!    z = isreal (A);
%!  case {"transp"}
%!    z = A' * x;
%!  case {"notransp"}
%!    z = A * x;
%!  endswitch
%!endfunction
%!function z = afun_A_P (flag, x, A, m)
%!  switch (flag)
%!  case "dim"
%!    z = length (A);
%!  case "real"
%!    z = isreal (A);
%!  case "transp"
%!    z = x; for i = 1:m, z = A' * z;, endfor
%!  case "notransp"
%!    z = x; for i = 1:m, z = A * z;, endfor
%!  endswitch
%!endfunction

%!test
%! A = reshape ((1:16)-8, 4, 4);
%! assert (normest1 (A), norm (A, 1), eps);

## test t=1
%!test
%! A = rand (4); # for positive matrices always work
%! assert (normest1 (A, 1), norm (A,1), 2 * eps);

## test t=3
%!test
%! A = [-0.21825   0.16598   0.19388   0.75297
%!      -1.47732   0.78443  -1.04254   0.42240
%!       1.39857  -0.34046   2.28617   0.68089
%!       0.31205   1.50529  -0.75804  -1.22476];
%! X = [1,1,-1;1,1,1;1,1,-1;1,-1,-1]/3;
%! assert (normest1 (A, 3, X), norm (A, 1), 2 * eps);

## test Afun
%!test
%! A = rand (10);
%! n = length (A);
%! Afun = @(flag, x) afun_A (flag, x, A, n);
%! assert (normest1 (Afun), norm (A, 1), 2 * eps);

## test Afun with parameters
%!test
%! A = rand (10);
%! assert (normest1 (@afun_A_P, [], [], A, 3), norm (A ^ 3, 1), 1000 * eps);

## test output
%!test
%! A = reshape (1:16,4,4);
%! [nest, v, w, iter] = normest1 (A);
%! assert (norm (w, 1), nest * norm (v, 1), eps);

## test output
%!test
%! A = rand (100);
%! A(A <= 1/3) = -1;
%! A(A > 1/3 & A <= 2/3) = 0;
%! A(A > 2/3) = 1;
%! [nest, v, w, iter] = normest1 (A, 10);
%! assert (w, A * v, eps);

%!test
%! A = rand (5);
%! nest = normest1 (A, 6);
%! assert (nest, norm (A,1), eps);

%!test
%! A = rand (5);
%! nest = normest1 (A, 2, ones (5, 2) / 5);
%! assert (nest, norm (A,1), eps);

%!test
%! N = 10;
%! A = ones (N);
%! [nm1, v1, w1] = normest1 (A);
%! [nminf, vinf, winf] = normest1 (A', 6);
%! assert (nm1, N, -2*eps);
%! assert (nminf, N, -2*eps);
%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);

%!test
%! N = 5;
%! A = hilb (N);
%! [nm1, v1, w1] = normest1 (A);
%! [nminf, vinf, winf] = normest1 (A', 6);
%! assert (nm1, norm (A, 1), -2*eps);
%! assert (nminf, norm (A, inf), -2*eps);
%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);

## Only likely to be within a factor of 10.
%!test
%! old_state = rand ("state");
%! unwind_protect
%!   rand ("state", 42);  # Initialize to guarantee reproducible results
%!   N = 100;
%!   A = rand (N);
%!   [nm1, v1, w1] = normest1 (A);
%!   [nminf, vinf, winf] = normest1 (A', 6);
%!   assert (nm1, norm (A, 1), -.1);
%!   assert (nminf, norm (A, inf), -.1);
%!   assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
%!   assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
%! unwind_protect_cleanup
%!   rand ("state", old_state);
%! end_unwind_protect

## Check ITER is always a column vector.
%!test
%! [~, ~, ~, it] = normest1 (rand (3), 3);
%! assert (iscolumn (it));
%! [~, ~, ~, it] = normest1 (rand (50), 20);
%! assert (iscolumn (it));

## Test input validation
%!error <Invalid call> normest1 ()
%!error <A must be a square matrix or a function handle> normest1 ({1})
%!error <A must be a square matrix> normest1 ([1 2])
%!error <X0 must have 2 columns> normest1 (magic (5), :, [1])
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{Z} =} null (@var{A})
## @deftypefnx {} {@var{Z} =} null (@var{A}, @var{tol})
## Return an orthonormal basis @var{Z} of the null space of @var{A}.
##
## The dimension of the null space @var{Z} is taken as the number of singular
## values of @var{A} not greater than @var{tol}.  If the argument @var{tol}
## is missing, it is computed as
##
## @example
## max (size (@var{A})) * max (svd (@var{A}, 0)) * eps
## @end example
## @seealso{orth, svd}
## @end deftypefn

function Z = null (A, tol)

  if (nargin < 1)
    print_usage ();
  elseif (nargin == 2 && strcmp (tol, "r"))
    error ("null: option for rational not yet implemented");
  endif

  [~, S, V] = svd (A, 0);  # Use economy-sized svd if possible.

  if (isempty (A))
    ## In case of A = [], zeros (0,X), zeros (X,0) Matlab R2020b seems to
    ## simply return the nullspace "V" of the svd-decomposition (bug #59630).
    Z = V;
  else
    out_cls = class (V);

    ## Extract column vector from Diagonal Matrix which depends on size
    if (rows (S) > 1)
      s = diag (S);
    else
      s = S(1);
    endif
    if (nargin == 1)
      tol = max (size (A)) * s(1) * eps (out_cls);
    endif
    rank = sum (s > tol);

    cols = columns (A);
    if (rank < cols)
      Z = V(:, rank+1:cols);
      Z(abs (Z) < eps (out_cls)) = 0;
    else
      Z = zeros (cols, 0, out_cls);
    endif
  endif

endfunction


## Exact tests
%!test
%! A = {
%!   [], [];
%!   zeros(1,0), [];
%!   zeros(4,0), [];
%!   zeros(0,1), 1;
%!   zeros(0,4), eye(4);
%!   0, 1;
%!   1, zeros(1,0);
%!   [1 0; 0 1], zeros(2,0);
%!   [1 0; 1 0], [0 1]';
%! };
%! for i = 1:rows (A)
%!   assert (null (A{i,1}), A{i,2});
%!   assert (null (single (A{i,1})), single (A{i,2}));
%! endfor

## Inexact tests
%!test
%! A = {
%!   [1 1; 0 0], [-1/sqrt(2) 1/sqrt(2)]';
%! };
%! for i = 1:rows (A)
%!   assert (null (A{i,1}), A{i,2}, eps);
%!   assert (null (single (A{i,1})), single (A{i,2}), eps);
%! endfor

## Tests with tolerance input
%!test
%! tol = 1e-4;
%! A = {
%!   @(e) [1 0; 0 tol-e], [0 1]';
%!   @(e) [1 0; 0 tol+e], zeros(2,0);
%! };
%! for i = 1:rows (A)
%!   assert (null (A{i,1}(eps ("double")), tol), A{i,2});
%!   assert (null (single (A{i,1}(eps ("single"))), tol), single (A{i,2}));
%! endfor

## Input corner cases
%!assert (null (uint8 ([])), [])

## Test input validation
%!error <Invalid call> null ()
%!error <rational not yet implemented> null (1, 'r')
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{beta}, @var{sigma}, @var{r}] =} ols (@var{y}, @var{x})
## Ordinary least squares (OLS) estimation.
##
## OLS applies to the multivariate model
## @tex
## $@var{y} = @var{x}\,@var{b} + @var{e}$
## @end tex
## @ifnottex
## @w{@math{@var{y} = @var{x}*@var{b} + @var{e}}}
## @end ifnottex
## where
## @tex
## $@var{y}$ is a $t \times p$ matrix, $@var{x}$ is a $t \times k$ matrix,
## $@var{b}$ is a $k \times p$ matrix, and $@var{e}$ is a $t \times p$ matrix.
## @end tex
## @ifnottex
## @math{@var{y}} is a @math{t}-by-@math{p} matrix, @math{@var{x}} is a
## @math{t}-by-@math{k} matrix, @var{b} is a @math{k}-by-@math{p} matrix, and
## @var{e} is a @math{t}-by-@math{p} matrix.
## @end ifnottex
##
## Each row of @var{y} is a @math{p}-variate observation in which each column
## represents a variable.  Likewise, the rows of @var{x} represent
## @math{k}-variate observations or possibly designed values.  Furthermore,
## the collection of observations @var{x} must be of adequate rank, @math{k},
## otherwise @var{b} cannot be uniquely estimated.
##
## The observation errors, @var{e}, are assumed to originate from an
## underlying @math{p}-variate distribution with zero mean and
## @math{p}-by-@math{p} covariance matrix @var{S}, both constant conditioned
## on @var{x}.  Furthermore, the matrix @var{S} is constant with respect to
## each observation such that
## @tex
## $\bar{@var{e}} = 0$ and cov(vec(@var{e})) =  kron(@var{s},@var{I}).
## @end tex
## @ifnottex
## @code{mean (@var{e}) = 0} and
## @code{cov (vec (@var{e})) = kron (@var{s}, @var{I})}.
## @end ifnottex
## (For cases
## that don't meet this criteria, such as autocorrelated errors, see
## generalized least squares, gls, for more efficient estimations.)
##
## The return values @var{beta}, @var{sigma}, and @var{r} are defined as
## follows.
##
## @table @var
## @item beta
## The OLS estimator for matrix @var{b}.
## @tex
## @var{beta} is calculated directly via $(@var{x}^T@var{x})^{-1} @var{x}^T
## @var{y}$ if the matrix $@var{x}^T@var{x}$ is of full rank.
## @end tex
## @ifnottex
## @var{beta} is calculated directly via
## @code{inv (@var{x}'*@var{x}) * @var{x}' * @var{y}} if the matrix
## @code{@var{x}'*@var{x}} is of full rank.
## @end ifnottex
## Otherwise, @code{@var{beta} = pinv (@var{x}) * @var{y}} where
## @code{pinv (@var{x})} denotes the pseudoinverse of @var{x}.
##
## @item sigma
## The OLS estimator for the matrix @var{s},
##
## @example
## @group
## @var{sigma} = (@var{y}-@var{x}*@var{beta})' * (@var{y}-@var{x}*@var{beta}) / (@math{t}-rank(@var{x}))
## @end group
## @end example
##
## @item r
## The matrix of OLS residuals, @code{@var{r} = @var{y} - @var{x}*@var{beta}}.
## @end table
## @seealso{gls, pinv}
## @end deftypefn

function [beta, sigma, r] = ols (y, x)

  if (nargin != 2)
    print_usage ();
  endif

  if (! (isnumeric (x) && isnumeric (y)))
    error ("ols: X and Y must be numeric matrices or vectors");
  endif

  if (ndims (x) != 2 || ndims (y) != 2)
    error ("ols: X and Y must be 2-D matrices or vectors");
  endif

  [nr, nc] = size (x);
  [ry, cy] = size (y);
  if (nr != ry)
    error ("ols: number of rows of X and Y must be equal");
  endif

  if (isinteger (x))
    x = double (x);
  endif
  if (isinteger (y))
    y = double (y);
  endif

  ## Start of algorithm
  z = x' * x;
  [u, p] = chol (z);

  if (p)
    beta = pinv (x) * y;
  else
    beta = u \ (u' \ (x' * y));
  endif

  if (isargout (2) || isargout (3))
    r = y - x * beta;
  endif
  if (isargout (2))

    ## z is of full rank, avoid the SVD in rnk
    if (p == 0)
      rnk = columns (z);
    else
      rnk = rank (z);
    endif

    sigma = r' * r / (nr - rnk);
  endif

endfunction


%!test
%! x = [1:5]';
%! y = 3*x + 2;
%! x = [x, ones(5,1)];
%! assert (ols (y,x), [3; 2], 50*eps);

%!test
%! x = [1, 2; 3, 4];
%! y = [1; 2];
%! [b, s, r] = ols (x, y);
%! assert (b, [1.4, 2], 2*eps);
%! assert (s, [0.2, 0; 0, 0], 2*eps);
%! assert (r, [-0.4, 0; 0.2, 0], 2*eps);

%!test
%! x = [1, 2; 3, 4];
%! y = [1; 2];
%! [b, s] = ols (x, y);
%! assert (b, [1.4, 2], 2*eps);
%! assert (s, [0.2, 0; 0, 0], 2*eps);

%!test
%! x = [1, 2; 3, 4];
%! y = [1; 2];
%! b = ols (x, y);
%! assert (b, [1.4, 2], 2*eps);

## Test input validation
%!error <Invalid call> ols ()
%!error <Invalid call> ols (1)
%!error ols ([true, true], [1, 2])
%!error ols ([1, 2], [true, true])
%!error ols (ones (2,2,2), ones (2,2))
%!error ols (ones (2,2), ones (2,2,2))
%!error ols (ones (1,2), ones (2,2))
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{lambda} =} ordeig (@var{A})
## @deftypefnx {} {@var{lambda} =} ordeig (@var{A}, @var{B})
## Return the eigenvalues of quasi-triangular matrices in their order of
## appearance in the matrix @var{A}.
##
## The quasi-triangular matrix @var{A} is usually the result of a Schur
## factorization.  If called with a second input @var{B} then the generalized
## eigenvalues of the pair @var{A}, @var{B} are returned in the order of
## appearance of the matrix @code{@var{A}-@var{lambda}*@var{B}}.  The pair
## @var{A}, @var{B} is usually the result of a QZ decomposition.
##
## @seealso{ordschur, ordqz, eig, schur, qz}
## @end deftypefn

function lambda = ordeig (A, B)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (A) || ! issquare (A))
    error ("ordeig: A must be a square matrix");
  endif

  n = length (A);

  if (nargin == 1)
    B = eye (n);
    if (isreal (A))
      if (! is_quasitri (A))
        error ("ordeig: A must be quasi-triangular (i.e., upper block triangular with 1x1 or 2x2 blocks on the diagonal)");
      endif
    else
      if (! istriu (A))
        error ("ordeig: A must be upper-triangular when it is complex");
      endif
    endif
  else
    if (! isnumeric (B) || ! issquare (B))
      error ("ordeig: B must be a square matrix");
    elseif (length (B) != n)
      error ("ordeig: A and B must be the same size");
    endif
    if (isreal (A) && isreal (B))
      if (! is_quasitri (A) || ! is_quasitri (B))
        error ("ordeig: A and B must be quasi-triangular (i.e., upper block triangular with 1x1 or 2x2 blocks on the diagonal)");
      endif
    else
      if (! istriu (A) || ! istriu (B))
        error ("ordeig: A and B must both be upper-triangular if either is complex");
      endif
    endif
  endif

  ## Start of algorithm
  lambda = zeros (n, 1);

  i = 1;
  while (i <= n)
    if (i == n || (A(i+1,i) == 0 && B(i+1,i) == 0))
      lambda(i) = A(i,i) / B(i,i);
    else
      a = B(i,i) * B(i+1,i+1);
      b = - (A(i,i) * B(i+1,i+1) + A(i+1,i+1) * B(i,i));
      c = A(i,i) * A(i+1,i+1) - ...
          (A(i,i+1) - B(i,i+1)) * (A(i+1,i) - B(i+1,i));
      if (b > 0)
        lambda(i) = 2*c / (-b - sqrt (b^2 - 4*a*c));
        i += 1;
        lambda(i) = (-b - sqrt (b^2 - 4*a*c)) / 2 / a;
      else
        lambda(i) = (-b + sqrt (b^2 - 4*a*c)) / 2 / a;
        i += 1;
        lambda(i) = 2*c / (-b + sqrt (b^2 - 4*a*c));
      endif
    endif
    i += 1;
  endwhile

endfunction

## Check whether a matrix is quasi-triangular
function retval = is_quasitri (A)

  if (length (A) <= 2)
    retval = true;
  else
    v = diag (A, -1) != 0;
    retval = (all (tril (A, -2)(:) == 0) && all (v(1:end-1) + v(2:end) < 2));
  endif

endfunction


%!test
%! A = toeplitz ([0, 1, 0, 0], [0, -1, 0, 0]);
%! T = schur (A);
%! lambda = ordeig (T);
%! assert (lambda, [1.61803i; -1.61803i; 0.61803i; -0.61803i], 1e-4);

%!test
%! A = toeplitz ([0, 1, 0, 0], [0, -1, 0, 0]);
%! B = toeplitz ([0, 0, 0, 1], [0, -1, 0, 2]);
%! [AA, BB] = qz (A, B);
%! assert (isreal (AA) && isreal (BB));
%! lambda = ordeig (AA, BB);
%! assert (lambda, [0.5+0.86603i; 0.5-0.86603i; i; -i], 1e-4);
%! [AA, BB] = qz (complex (A), complex (B));
%! assert (iscomplex (AA) && iscomplex (BB));
%! lambda = ordeig (AA, BB);
%! assert (lambda, diag (AA) ./ diag (BB));

## Check trivial 1x1 case
%!test <*55779>
%! lambda = ordeig ([6], [2]);
%! assert (lambda, 3);

## Test input validation
%!error <Invalid call> ordeig ()
%!error <A must be a square matrix> ordeig ('a')
%!error <A must be a square matrix> ordeig ([1, 2, 3])
%!error <A must be quasi-triangular> ordeig (magic (3))
%!error <A must be upper-triangular> ordeig ([1, 0; i, 1])
%!error <B must be a square matrix> ordeig (1, 'a')
%!error <B must be a square matrix> ordeig (1, [1, 2])
%!error <A and B must be the same size> ordeig (1, ones (2,2))
%!error <A and B must be quasi-triangular>
%! ordeig (triu (magic (3)), magic (3))
%!error <A and B must both be upper-triangular>
%! ordeig ([1, 1; 0, 1], [1, 0; i, 1])
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} orth (@var{A})
## @deftypefnx {} {} orth (@var{A}, @var{tol})
## Return an orthonormal basis of the range space of @var{A}.
##
## The dimension of the range space is taken as the number of singular values
## of @var{A} greater than @var{tol}.  If the argument @var{tol} is missing, it
## is computed as
##
## @example
## max (size (@var{A})) * max (svd (@var{A})) * eps
## @end example
## @seealso{null}
## @end deftypefn

function retval = orth (A, tol)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (A))
    retval = [];
    return;
  endif

  [U, S, V] = svd (A);

  [rows, cols] = size (A);

  [S_nr, S_nc] = size (S);

  if (S_nr == 1 || S_nc == 1)
    s = S(1);
  else
    s = diag (S);
  endif

  if (nargin == 1)
    if (isa (A, "single"))
      tol = max (size (A)) * s (1) * eps ("single");
    else
      tol = max (size (A)) * s (1) * eps;
    endif
  endif

  rank = sum (s > tol);

  if (rank > 0)
    retval = -U(:, 1:rank);
  else
    retval = zeros (rows, 0);
  endif

endfunction


%!test
%! for i = 1:20
%!   A = rand (10, 10);
%!   V = orth (A);
%!   if (det (A) != 0)
%!     assert (V'*V, eye (10), 100*eps);
%!   endif
%! endfor
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{G}, @var{y}] =} planerot (@var{x})
## Compute the Givens rotation matrix for the two-element column vector
## @var{x}.
##
## @tex
## The Givens matrix is a $2\times 2$ orthogonal matrix
## $$
##  G = \left[\matrix{c & s\cr -s'& c\cr}\right]
## $$
## such that
## $$
##  G \left[\matrix{x(1)\cr x(2)}\right] = \left[\matrix{\ast\cr 0}\right]
## $$
## @end tex
## @ifnottex
## The Givens matrix is a 2-by-2 orthogonal matrix
##
## @example
## @group
## @var{G} = [ @var{c} , @var{s}
##      -@var{s}', @var{c}]
## @end group
## @end example
##
## @noindent
## such that
##
## @example
## @var{y} = @var{G} * [@var{x}(1); @var{x}(2)] @equiv{} [*; 0]
## @end example
##
## @end ifnottex
##
## Note: The Givens matrix represents a counterclockwise rotation of a 2-D
## plane and can be used to introduce zeros into a matrix prior to complete
## factorization.
## @seealso{givens, qr}
## @end deftypefn

function [G, y] = planerot (x)

  if (nargin < 1)
    print_usage ();
  elseif (! (isvector (x) && numel (x) == 2))
    error ("planerot: X must be a 2-element vector");
  endif

  G = givens (x(1), x(2));
  y = G * x(:);

endfunction


%!test
%! x = [3 4];
%! [g y] = planerot (x);
%! assert (g, [x(1) x(2); -x(2) x(1)] / sqrt (x(1)^2 + x(2)^2), 2e-8);
%! assert (y(2), 0, 2e-8);

## Test input validation
%!error <Invalid call> planerot ()
%!error <X must be a 2-element vector> planerot (ones (2,2))
%!error <X must be a 2-element vector> planerot ([0 0 0])
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{aa}, @var{bb}, @var{q}, @var{z}] =} qzhess (@var{A}, @var{B})
## Compute the Hessenberg-triangular decomposition of the matrix pencil
## @code{(@var{A}, @var{B})}, returning
## @code{@var{aa} = @var{q} * @var{A} * @var{z}},
## @code{@var{bb} = @var{q} * @var{B} * @var{z}}, with @var{q} and @var{z}
## orthogonal.
##
## For example:
##
## @example
## @group
## [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
##   @result{} aa =
##       -3.02244  -4.41741
##        0.92998   0.69749
##   @result{} bb =
##       -8.60233  -9.99730
##        0.00000  -0.23250
##   @result{} q =
##       -0.58124  -0.81373
##       -0.81373   0.58124
##   @result{} z =
##      Diagonal Matrix
##        1   0
##        0   1
## @end group
## @end example
##
## The Hessenberg-triangular decomposition is the first step in
## @nospell{Moler and Stewart's} QZ@tie{}decomposition algorithm.
##
## Algorithm taken from @nospell{Golub and Van Loan},
## @cite{Matrix Computations, 2nd edition}.
##
## @seealso{lu, chol, hess, qr, qz, schur, svd}
## @end deftypefn

function [aa, bb, q, z] = qzhess (A, B)

  if (nargin != 2)
    print_usage ();
  endif

  [na, ma] = size (A);
  [nb, mb] = size (B);
  if (na != ma || na != nb || nb != mb)
    error ("qzhess: incompatible dimensions");
  endif

  ## Reduce to hessenberg-triangular form.

  [q, bb] = qr (B);
  aa = q' * A;
  q = q';
  z = eye (na);
  for j = 1:(na-2)
    for i = na:-1:(j+2)

      ## disp (["zero out aa(", num2str(i), ",", num2str(j), ")"])

      rot = givens (aa (i-1, j), aa (i, j));
      aa((i-1):i, :) = rot *aa((i-1):i, :);
      bb((i-1):i, :) = rot *bb((i-1):i, :);
       q((i-1):i, :) = rot * q((i-1):i, :);

      ## disp (["now zero out bb(", num2str(i), ",", num2str(i-1), ")"])

      rot = givens (bb (i, i), bb (i, i-1))';
      bb(:, (i-1):i) = bb(:, (i-1):i) * rot';
      aa(:, (i-1):i) = aa(:, (i-1):i) * rot';
       z(:, (i-1):i) =  z(:, (i-1):i) * rot';

    endfor
  endfor

  bb(2, 1) = 0.0;
  for i = 3:na
    bb (i, 1:(i-1)) = zeros (1, i-1);
    aa (i, 1:(i-2)) = zeros (1, i-2);
  endfor

endfunction


%!test
%! a = [1 2 1 3;
%!      2 5 3 2;
%!      5 5 1 0;
%!      4 0 3 2];
%! b = [0 4 2 1;
%!      2 3 1 1;
%!      1 0 2 1;
%!      2 5 3 2];
%! mask = [0 0 0 0;
%!         0 0 0 0;
%!         1 0 0 0;
%!         1 1 0 0];
%! [aa, bb, q, z] = qzhess (a, b);
%! assert (inv (q) - q', zeros (4), 2e-8);
%! assert (inv (z) - z', zeros (4), 2e-8);
%! assert (q * a * z, aa, 2e-8);
%! assert (aa .* mask, zeros (4), 2e-8);
%! assert (q * b * z, bb, 2e-8);
%! assert (bb .* mask, zeros (4), 2e-8);

%!test
%! a = [1 2 3 4 5;
%!      3 2 3 1 0;
%!      4 3 2 1 1;
%!      0 1 0 1 0;
%!      3 2 1 0 5];
%! b = [5 0 4 0 1;
%!      1 1 1 2 5;
%!      0 3 2 1 0;
%!      4 3 0 3 5;
%!      2 1 2 1 3];
%! mask = [0 0 0 0 0;
%!         0 0 0 0 0;
%!         1 0 0 0 0;
%!         1 1 0 0 0;
%!         1 1 1 0 0];
%! [aa, bb, q, z] = qzhess (a, b);
%! assert (inv (q) - q', zeros (5), 2e-8);
%! assert (inv (z) - z', zeros (5), 2e-8);
%! assert (q * a * z, aa, 2e-8);
%! assert (aa .* mask, zeros (5), 2e-8);
%! assert (q * b * z, bb, 2e-8);
%! assert (bb .* mask, zeros (5), 2e-8);

## Test input validation
%!error <Invalid call> qzhess ()
%!error <Invalid call> qzhess (1)
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} rank (@var{A})
## @deftypefnx {} {} rank (@var{A}, @var{tol})
## Compute the rank of matrix @var{A}, using the singular value decomposition.
##
## The rank is taken to be the number of singular values of @var{A} that are
## greater than the specified tolerance @var{tol}.  If the second argument is
## omitted, it is taken to be
##
## @example
## tol = max (size (@var{A})) * sigma(1) * eps;
## @end example
##
## @noindent
## where @code{eps} is machine precision and @code{sigma(1)} is the largest
## singular value of @var{A}.
##
## The rank of a matrix is the number of linearly independent rows or columns
## and equals the dimension of the row and column space.  The function
## @code{orth} may be used to compute an orthonormal basis of the column space.
##
## For testing if a system @code{@var{A}*@var{x} = @var{b}} of linear equations
## is solvable, one can use
##
## @example
## rank (@var{A}) == rank ([@var{A} @var{b}])
## @end example
##
## In this case, @code{@var{x} = @var{A} \ @var{b}} finds a particular solution
## @var{x}.  The general solution is @var{x} plus the null space of matrix
## @var{A}.  The function @code{null} may be used to compute a basis of the
## null space.
##
## Example:
##
## @example
## @group
## A = [1 2 3
##      4 5 6
##      7 8 9];
## rank (A)
##   @result{} 2
## @end group
## @end example
##
## @noindent
## In this example, the number of linearly independent rows is only 2 because
## the final row is a linear combination of the first two rows:
##
## @example
## A(3,:) == -A(1,:) + 2 * A(2,:)
## @end example
##
## @seealso{null, orth, sprank, svd, eps}
## @end deftypefn

function retval = rank (A, tol)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    sigma = svd (A);
    if (isempty (sigma))
      tolerance = 0;
    else
      if (isa (A, "single"))
        tolerance = max (size (A)) * sigma (1) * eps ("single");
      else
        tolerance = max (size (A)) * sigma (1) * eps;
      endif
    endif
  else
    sigma = svd (A);
    tolerance = tol;
  endif

  retval = sum (sigma > tolerance);

endfunction


%!test
%! A = [1 2 3 4 5 6 7;
%!      4 5 6 7 8 9 12;
%!      1 2 3.1 4 5 6 7;
%!      2 3 4 5 6 7 8;
%!      3 4 5 6 7 8 9;
%!      4 5 6 7 8 9 10;
%!      5 6 7 8 9 10 11];
%! assert (rank (A), 4);

%!test
%! A = [1 2 3 4 5 6 7;
%!      4 5 6 7 8 9 12;
%!      1 2 3.0000001 4 5 6 7;
%!      4 5 6 7 8 9 12.00001;
%!      3 4 5 6 7 8 9;
%!      4 5 6 7 8 9 10;
%!      5 6 7 8 9 10 11];
%! assert (rank (A), 4);

%!test
%! A = [1 2 3 4 5 6 7;
%!      4 5 6 7 8 9 12;
%!      1 2 3 4 5 6 7;
%!      4 5 6 7 8 9 12.00001;
%!      3 4 5 6 7 8 9;
%!      4 5 6 7 8 9 10;
%!      5 6 7 8 9 10 11];
%! assert (rank (A), 3);

%!test
%! A = [1 2 3 4 5 6 7;
%!      4 5 6 7 8 9 12;
%!      1 2 3 4 5 6 7;
%!      4 5 6 7 8 9 12;
%!      3 4 5 6 7 8 9;
%!      4 5 6 7 8 9 10;
%!      5 6 7 8 9 10 11];
%! assert (rank (A), 3);

%!test
%! A = eye (100);
%! assert (rank (A), 100);

%!assert (rank ([]), 0)
%!assert (rank ([1:9]), 1)
%!assert (rank ([1:9]'), 1)

%!test
%! A = [1, 2, 3; 1, 2.001, 3; 1, 2, 3.0000001];
%! assert (rank (A), 3);
%! assert (rank (A,0.0009), 1);
%! assert (rank (A,0.0006), 2);
%! assert (rank (A,0.00000002), 3);
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} rref (@var{A})
## @deftypefnx {} {} rref (@var{A}, @var{tol})
## @deftypefnx {} {[@var{r}, @var{k}] =} rref (@dots{})
## Return the reduced row echelon form of @var{A}.
##
## @var{tol} defaults to
## @code{eps * max (size (@var{A})) * norm (@var{A}, inf)}.
##
## The optional return argument @var{k} contains the vector of
## "bound variables", which are those columns on which elimination has been
## performed.
##
## @end deftypefn

function [A, k] = rref (A, tol)

  if (nargin < 1)
    print_usage ();
  endif

  if (ndims (A) > 2)
    error ("rref: A must be a 2-dimensional matrix");
  endif

  [rows, cols] = size (A);

  if (nargin < 2)
    if (isa (A, "single"))
      tol = eps ("single") * max (rows, cols) * norm (A, inf ("single"));
    else
      tol = eps * max (rows, cols) * norm (A, inf);
    endif
  endif

  used = zeros (1, cols);
  r = 1;
  for c = 1:cols
    ## Find the pivot row
    [m, pivot] = max (abs (A(r:rows,c)));
    pivot = r + pivot - 1;

    if (m <= tol)
      ## Skip column c, making sure the approximately zero terms are
      ## actually zero.
      A(r:rows, c) = zeros (rows-r+1, 1);
    else
      ## keep track of bound variables
      used(1, c) = 1;

      ## Swap current row and pivot row
      A([pivot, r], c:cols) = A([r, pivot], c:cols);

      ## Normalize pivot row
      A(r, c:cols) = A(r, c:cols) / A(r, c);

      ## Eliminate the current column
      ridx = [1:r-1, r+1:rows];
      A(ridx, c:cols) = A(ridx, c:cols) - A(ridx, c) * A(r, c:cols);

      ## Check if done
      if (r++ == rows)
        break;
      endif
    endif
  endfor
  k = find (used);

endfunction


%!test
%! a = [1];
%! [r k] = rref (a);
%! assert (r, [1], 2e-8);
%! assert (k, [1], 2e-8);

%!test
%! a = [1 3; 4 5];
%! [r k] = rref (a);
%! assert (rank (a), rank (r), 2e-8);
%! assert (r, eye (2), 2e-8);
%! assert (k == [1, 2] || k == [2, 1]);

%!test
%! a = [1 3; 4 5; 7 9];
%! [r k] = rref (a);
%! assert (rank (a), rank (r), 2e-8);
%! assert (r, eye (3)(:,1:2), 2e-8);
%! assert (k, [1 2], 2e-8);

%!test
%! a = [1 2 3; 2 4 6; 7 2 0];
%! [r k] = rref (a);
%! assert (rank (a), rank (r), 2e-8);
%! assert (r, [1 0 (3-7/2); 0 1 (7/4); 0 0 0], 2e-8);
%! assert (k, [1 2], 2e-8);

%!test
%! a = [1 2 1; 2 4 2.01; 2 4 2.1];
%! tol = 0.02;
%! [r k] = rref (a, tol);
%! assert (rank (a, tol), rank (r, tol), 2e-8);
%! tol = 0.2;
%! [r k] = rref (a, tol);
%! assert (rank (a, tol), rank (r, tol), 2e-8);

## Test input validation
%!error <Invalid call> rref ()
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{angle} =} subspace (@var{A}, @var{B})
## Determine the largest principal angle between two subspaces
## spanned by the columns of matrices @var{A} and @var{B}.
## @end deftypefn

## Reference:
## Andrew V. Knyazev, Merico E. Argentati:
## Principal Angles between Subspaces in an A-Based Scalar Product:
## Algorithms and Perturbation Estimates.
## SIAM Journal on Scientific Computing, Vol. 23 no. 6, pp. 2008-2040
##
## other texts are also around...

function ang = subspace (A, B)

  if (nargin != 2)
    print_usage ();
  elseif (ndims (A) != 2 || ndims (B) != 2)
    error ("subspace: A and B must be 2-dimensional arrays");
  elseif (rows (A) != rows (B))
    error ("subspace: column dimensions of A and B must match");
  endif

  A = orth (A);
  B = orth (B);
  c = A'*B;
  scos = min (svd (c));
  if (scos^2 > 1/2)
    if (columns (A) >= columns (B))
      c = B - A*c;
    else
      c = A - B*c';
    endif
    ssin = max (svd (c));
    ang = asin (min (ssin, 1));
  else
    ang = acos (scos);
  endif

endfunction


%!assert (subspace (1, 1), 0)
%!assert (subspace ([1, 0]', [1, 1; 0, 1]'), 0, 3*eps)
%!assert (subspace ([1, 0, 1]', [1, 1, 0; 1, -1, 0]'), pi/4, 3*eps)
%!assert (subspace ([1 5 0 0; -3 2 0 0]', [0 0 4 2; 0 0 4 3]'), pi/2)
%!assert (subspace ([1 1 1 1; 1 2 3 4]', [1 -1 -1 1]'), pi/2)

%!test
%! ## For small angle between subspaces
%! theta = pi/200;
%! Ry = [cos(theta), 0, sin(theta);0, 1, 0;-sin(theta), 0, cos(theta)];
%! a = Ry*[3*e, 0, 0]';
%! b = [1, 1, 0; 1, -1, 0]';
%! assert (theta, subspace (a, b), eps);
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} trace (@var{A})
## Compute the trace of @var{A}, the sum of the elements along the main
## diagonal.
##
## The implementation is straightforward: @code{sum (diag (@var{A}))}.
## @seealso{eig}
## @end deftypefn

function y = trace (A)

  if (nargin < 1)
    print_usage ();
  endif

  if (ndims (A) > 2)
    error ("trace: only valid on 2-D objects");
  elseif (isempty (A))
    y = 0;
  elseif (isvector (A))
    y = A(1);
  else
    y = sum (diag (A));
  endif

endfunction


%!assert (trace ([1, 2; 3, 4]), 5)
%!assert (trace ([1, 2; 3, 4; 5, 6]), 5)
%!assert (trace ([1, 3, 5; 2, 4, 6]), 5)
%!assert (trace ([]), 0)
%!assert (trace (rand (1,0)), 0)
%!assert (trace ([3:10]), 3)

%!error <Invalid call> trace ()
%!error <only valid on 2-D objects> trace (reshape (1:9,[1,3,3]))
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} vech (@var{x})
## Return the vector obtained by eliminating all superdiagonal elements of
## the square matrix @var{x} and stacking the result one column above the
## other.
##
## This has uses in matrix calculus where the underlying matrix is symmetric
## and it would be pointless to keep values above the main diagonal.
## @seealso{vec}
## @end deftypefn

## See Magnus and Neudecker (1988), Matrix differential calculus with
## applications in statistics and econometrics.

## Author KH <Kurt.Hornik@wu-wien.ac.at>

function v = vech (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! issquare (x))
    error ("vech: X must be square");
  endif

  n = rows (x);
  slices = cellslices (x(:), (1:n) + n*(0:n-1), n*(1:n));
  v = vertcat (slices{:});

endfunction


%!assert (vech ([1, 2, 3; 4, 5, 6; 7, 8, 9]), [1; 4; 7; 5; 8; 9])

%!error <Invalid call> vech ()
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{n} =} vecnorm (@var{A})
## @deftypefnx {} {@var{n} =} vecnorm (@var{A}, @var{p})
## @deftypefnx {} {@var{n} =} vecnorm (@var{A}, @var{p}, @var{dim})
## Return the vector p-norm of the elements of array @var{A} along dimension
## @var{dim}.
##
## The p-norm of a vector is defined as
##
## @tex
## $$ {\Vert A \Vert}_p  = \left[ \sum_{i=1}^N {| A_i |}^p \right] ^ {1/p} $$
## @end tex
## @ifnottex
##
## @example
## @var{p-norm} (@var{A}, @var{p}) = sum (abs (@var{A}) .^ @var{p})) ^ (1/@var{p})
## @end example
##
## @end ifnottex
## The input @var{p} must be a positive scalar.  If omitted it defaults to 2
## (Euclidean norm or distance).  Other special values of @var{p} are 1
## (Manhattan norm, sum of absolute values) and @code{Inf} (absolute value of
## largest element).
##
## The input @var{dim} specifies the dimension of the array on which the
## function operates and must be a positive integer.  If omitted the first
## non-singleton dimension is used.
##
## @seealso{norm}
## @end deftypefn

function n = vecnorm (A, p = 2, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (A))
    error ("vecnorm: A must be numeric");
  endif

  if (! (isscalar (p) && isreal (p) && p > 0))
    error ("vecnorm: P must be positive real scalar or Inf");
  endif

  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (size (A) > 1, 1)) || (dim = 1);
  elseif (! (isscalar (dim) && isindex (dim)))
    error ("vecnorm: DIM must be a positive integer");
  endif

  ## Calculate norm using the value of p to accelerate special cases
  switch (p)
    case {1}
      n = sum (abs (A), dim);

    case {2}
      n = sqrt (sumsq (A, dim));

    case {Inf}
      n = max (abs (A), [], dim);

    otherwise
      if (rem (p,2) == 0)
        ## Even index such as 2,4,6 are specifically accelerated in math
        ## libraries.  Beyond 6, it doesn't matter which method is used.
        if (iscomplex (A))
          n = (sum ((real (A).^2 + imag (A).^2) .^ (p/2), dim)) .^ (1 / p);
        else
          n = (sum (A.^2 .^ (p/2), dim)) .^ (1 / p);
        endif
      else
        n = (sum (abs (A) .^ p, dim)) .^ (1 / p);
      endif

  endswitch

endfunction


%!test
%! A = [0 1 2; 3 4 5];
%! c = vecnorm (A);
%! r = vecnorm (A, 2, 2);
%! i = vecnorm (A, Inf);
%! assert (c, [3.0000, 4.1231, 5.3852], 1e-4);
%! assert (r, [2.2361; 7.0711], 1e-4);
%! assert (i, [3, 4, 5]);
%!test
%! A = [1, 2];
%! assert (vecnorm (A), 2.2361, 1e-4);
%!test
%! A(:, :, 1) = [1, 2];
%! A(:, :, 2) = [3, 4];
%! A(:, :, 3) = [5, 6];
%! ret(:, :, 1) = 2.2361;
%! ret(:, :, 2) = 5;
%! ret(:, :, 3) = 7.8102;
%! assert (vecnorm (A), ret, 1e-4);

## Test input validation
%!error <Invalid call> vecnorm ()
%!error <A must be numeric> vecnorm ({1})
%!error <P must be positive real scalar> vecnorm (1, [1 2])
%!error <P must be positive real scalar> vecnorm (1, i)
%!error <P must be positive real scalar> vecnorm (1, -1)
%!error <P must be positive real scalar> vecnorm (1, 0)
%!error <DIM must be a positive integer> vecnorm (1, 2, [1 2])
%!error <DIM must be a positive integer> vecnorm (1, 2, -1)
%!error <DIM must be a positive integer> vecnorm (1, 2, 0)
%!error <DIM must be a positive integer> vecnorm (1, 2, 1.5)
encoding=utf-8
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} bug_report ()
## Display information about how to submit bug reports for Octave.
## @end deftypefn

function bug_report ()

  disp (" ");
  disp ("  Bug reports play an essential role in making Octave");
  disp ("  reliable.  Please use the Octave bug tracker at");
  disp (" ");
  disp ("    https://bugs.octave.org");
  disp (" ");
  disp ("  to report problems.");
  disp (" ");
  disp ("  Please also read the bug reporting guidelines at");
  disp (" ");
  disp ("    https://www.octave.org/bugs.html");
  disp (" ");
  disp ("  to learn how to submit useful bug reports that will");
  disp ("  help the Octave community diagnose and fix the problem");
  disp ("  quickly and efficiently.");
  disp (" ");

endfunction


## Mark file as being tested.  No real test needed for this function.
%!assert (1)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} bunzip2 (@var{bzfile})
## @deftypefnx {} {} bunzip2 (@var{bzfile}, @var{dir})
## @deftypefnx {} {@var{filelist} =} bunzip2 (@dots{})
## Unpack the bzip2 archive @var{bzfile}.
##
## If @var{dir} is specified the files are unpacked in this directory rather
## than the one where @var{bzfile} is located.
##
## The optional output @var{filelist} is a list of the uncompressed files.
## @seealso{bzip2, unpack, gunzip, unzip, untar}
## @end deftypefn

function filelist = bunzip2 (bzfile, dir = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (dir) && ischar (bzfile))
    dir = fileparts (bzfile);
  endif

  if (nargout > 0)
    filelist = unpack (bzfile, dir, "bz2");
  else
    unpack (bzfile, dir, "bz2");
  endif

endfunction


## Tests for this m-file are located in bzip2.m
## Remove from test statistics
%!assert (1)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} cast (@var{val}, "@var{type}")
## @deftypefnx {} {} cast (@var{val}, "@var{like}", @var{var})
## Convert @var{val} to data type @var{type}.
##
## The input @var{val} may be a scalar, vector, or matrix of a class that is
## convertible to the target class (see below).
##
## If a variable @var{var} is specified after @qcode{"like"}, @var{val} is
## converted to the same data type and sparsity attribute.  If @var{var} is
## complex, @var{val} will be complex, too.
##
## @var{var} may be and @var{type} may name any of the following built-in
## numeric classes:
##
## @example
## @group
## "double"
## "single"
## "logical"
## "char"
## "int8"
## "int16"
## "int32"
## "int64"
## "uint8"
## "uint16"
## "uint32"
## "uint64"
## @end group
## @end example
##
## The value @var{val} may be modified to fit within the range of the new type.
##
## Examples:
##
## @example
## @group
## cast (-5, "uint8")
##    @result{} 0
## cast (300, "int8")
##    @result{} 127
## @end group
## @end example
##
## Programming Note: This function relies on the object @var{val} having a
## conversion method named @var{type}.  User-defined classes may implement only
## a subset of the full list of types shown above.  In that case, it may be
## necessary to call cast twice in order to reach the desired type.
## For example, the conversion to double is nearly always implemented, but
## the conversion to uint8 might not be.  In that case, the following code will
## work:
##
## @example
## cast (cast (@var{user_defined_val}, "double"), "uint8")
## @end example
##
## @seealso{typecast, int8, uint8, int16, uint16, int32, uint32, int64, uint64,
## double, single, logical, char, class, typeinfo}
## @end deftypefn

function retval = cast (val, type, var)

  if (nargin < 2 || nargin > 3)
    print_usage ();
  endif

  if (! ischar (type))
    error ("cast: TYPE must be a string");
  endif

  if (strcmp (type, "like"))
    is_like = true;
    type = class (var);
  else
    is_like = false;
  endif

  if ((! is_like && nargin != 2) || (is_like && nargin != 3))
    print_usage ();
  endif

  if (! isnumeric (val) && ! islogical (val) && ! ischar (val))
    error ("cast: type conversion from '%s' is not supported", class (val));
  endif

  if (! any (strcmp (type, {"int8"; "uint8"; "int16"; "uint16"; "int32";
                            "uint32"; "int64"; "uint64"; "double"; "single";
                            "logical"; "char"})))
    error ("cast: type conversion to '%s' is not supported", type);
  endif

  retval = feval (type, val);

  if (is_like)
    if (issparse (var) && ! issparse (retval))
      ## retval is of the same type as var, so it must be convertible to sparse
      retval = sparse (retval);
    elseif (! issparse (var) && issparse (retval))
      retval = full (retval);
    endif
    if (iscomplex (var) || iscomplex (val))
      retval = complex (retval);
    endif
  endif

endfunction


%!assert (cast (single (2.5), "double"), 2.5)
%!assert (cast (2.5, "single"), single (2.5))
%!assert (cast ([5 0 -5], "logical"), [true false true])
%!assert (cast ([65 66 67], "char"), "ABC")
%!assert (cast ([-2.5 1.1 2.5], "int8"), int8 ([-3 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "uint8"), uint8 ([0 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "int16"), int16 ([-3 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "uint16"), uint16 ([0 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "int32"), int32 ([-3 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "uint32"), uint32 ([0 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "int64"), int64 ([-3 1 3]))
%!assert (cast ([-2.5 1.1 2.5], "uint64"), uint64 ([0 1 3]))
%!assert (cast (1, "like", 2), 1)
%!assert (cast (1, "like", 2i), complex (1))
%!assert (cast (1, "like", speye (2)), sparse (1))
%!assert (cast (1, "like", sparse (2i)), complex (sparse (1)))
%!assert (cast (single (1), "like", speye (2)), sparse (1))
%!assert (cast (sparse (1), "like", 2), 1)
%!assert (cast (sparse (1), "like", 2i), complex (1))
%!assert (cast (complex (1), "like", 2), complex (1))
%!assert (cast (complex (1), "like", single (2)), complex (single (1)))
%!assert (cast ("a", "like", "octave"), "a")
%!assert (cast ("a", "like", 1i), complex (97))

## Test input validation
%!error <Invalid call> cast ()
%!error <Invalid call> cast (1)
%!error <Invalid call> cast (1, "double", 2)
%!error <TYPE must be a string> cast (1, {"foobar"})
%!error <type conversion from .* not supported> cast ({}, "double");
%!error <type conversion from .* not supported> cast (struct (), "double")
%!error <type conversion to .* not supported> cast (1, "foobar")
%!error <type conversion to .* not supported> cast (1, "cell")
%!error <type conversion to .* not supported> cast (1, "like", {})
%!error <type conversion to .* not supported> cast (1, "like", struct ())
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} citation
## @deftypefnx {} {} citation @var{package}
## Display instructions for citing GNU Octave or its packages in publications.
##
## When called without an argument, display information on how to cite the core
## GNU Octave system.
##
## When given a package name @var{package}, display information on citing the
## specific named package.  Note that some packages may not yet have
## instructions on how to cite them.
##
## The GNU Octave developers and its active community of package authors have
## invested a lot of time and effort in creating GNU Octave as it is today.
## Please give credit where credit is due and cite GNU Octave and its packages
## when you use them.
##
## @end deftypefn

## Author: Carn Draug <carandraug+dev@gmail.com>
## Idea and documentation from R's citation() (also under GPL)

function citation (package = "octave")

  ## function takes care of validating PACKAGE input
  display_info_file ("citation", package, "CITATION");

endfunction


## Test input validation
%!error <citation: PACKAGE must be a string> citation (1)
%!error <citation: package .* is not installed>
%! citation ("__NOT_A_VALID_PKG_NAME__");
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} clearvars
## @deftypefnx {} {} clearvars @var{pattern} @dots{}
## @deftypefnx {} {} clearvars -regexp @var{pattern} @dots{}
## @deftypefnx {} {} clearvars @dots{} -except @var{pattern} @dots{}
## @deftypefnx {} {} clearvars @dots{} -except -regexp @var{pattern} @dots{}
## @deftypefnx {} {} clearvars -global @dots{}
## Delete the variables matching the given @var{pattern}s from memory.
##
## The @var{pattern} may contain the following special characters:
##
## @table @code
## @item ?
## Match any single character.
##
## @item *
## Match zero or more characters.
##
## @item [ @var{list} ]
## Match the list of characters specified by @var{list}.  If the first
## character is @code{!} or @code{^}, match all characters except those
## specified by @var{list}.  For example, the pattern @code{[a-zA-Z]} will
## match all lowercase and uppercase alphabetic characters.
## @end table
##
## If the @option{-regexp} option is given then subsequent patterns are treated
## as regular expressions and any matches will be cleared.
##
## If the @option{-except} option is given then subsequent patterns select
## variables that will @strong{not} be cleared.
##
## If the @option{-global} option is given then all patterns will be applied
## to global variables rather than local variables.
##
## When called with no arguments, @code{clearvars} deletes all local variables.
##
## Example Code:
##
## Clear all variables starting with @qcode{'x'} and the specific variable
## @qcode{"foobar"}
##
## @example
## clearvars x* foobar
## @end example
##
## Clear the specific variable @qcode{"foobar"} and use regular expressions to
## clear all variables starting with @qcode{'x'} or @qcode{'y'}.
##
## @example
## clearvars foobar -regexp ^x ^y
## @end example
##
## Clear all variables except for @qcode{"foobar"}
##
## @example
## clearvars -except foobar
## @end example
##
## Clear all variables beginning with @qcode{"foo"}, except for those ending
## in @qcode{"bar"}
##
## @example
## clearvars foo* -except -regexp bar$
## @end example
##
## @seealso{clear, who, whos, exist}
## @end deftypefn

function clearvars (varargin)

  numvar = 0;
  global_mode = false;
  except_mode = false;
  regexp_mode = false;

  ## Parse arguments
  for cellarg = varargin
    arg = cellarg{1};

    ## Parse options
    if (strcmp (arg, "-global"))
      if (numvar > 0)
        error ("clearvars: '-global' must be the first option when present");
      endif
      global_mode = true;
      continue;
    elseif (strcmp (arg, "-except"))
      if (except_mode)
        error ("clearvars: '-except' may only be specified once");
      endif
      except_mode = true;
      regexp_mode = false;
      continue;
    elseif (strcmp (arg, "-regexp"))
      regexp_mode = true;
      continue;
    endif

    ## Parse patterns
    numvar += 1;
    vars(numvar).except = except_mode;
    if (! regexp_mode)
      vars(numvar).var_name = [ '\<' regexptranslate("wildcard", arg) '\>' ];
    else
      vars(numvar).var_name = arg;
    endif

  endfor

  if (global_mode)
    varlist = evalin ("caller", "who ('global')");
  else
    varlist = evalin ("caller", "who ()");
  endif

  ## evalin will cause the automatic creation of 'ans' variable (bug #53339).
  ## Determine if it needs to be removed at the end of the function.
  clear_ans = ! any (strcmp (varlist, "ans"));

  if (numvar == 0 || all ([vars.except]))
    ## For wildcard, select all variables in list
    idx_clear = true (numel (varlist), 1);
  else
    ptn = strjoin ({ vars(! [vars.except]).var_name }, '|');
    idx_clear = ! cellfun (@isempty, regexp (varlist, ptn));
  endif

  if (numvar > 0 && any ([vars.except]))
    ptn = strjoin ({ vars([vars.except]).var_name }, '|');
    idx_except = ! cellfun (@isempty, regexp (varlist, ptn));
    idx_clear(idx_except) = false;
  endif

  varlist = varlist(idx_clear);
  names = strjoin (varlist, "', '");

  if (! isempty (names))
    if (global_mode)
      evalin ("caller", ["clear ('-global', '", names, "')"]);
    else
      evalin ("caller", ["clear ('", names, "')"]);
    endif
  endif

  ## Clean up automatic variable "ans" if necessary
  if (clear_ans)
    evalin ("caller", "clear ('ans')");
  endif

endfunction


## Tests must be done in a function namespace;
## Otherwise, they interfere with the BIST environment itself.
%!function __test_local_vars__ ()
%!  global x y z
%!  a = 1; b = 2; c = 3;
%!  assert (all (ismember ({"a"; "b"; "c"}, who ())));
%!  ## Test 0-argument form
%!  clearvars
%!  assert (isempty (who ()));
%!
%!  a = 1; a2 = 2; a33 = 3;
%!  ## Test special wildcard pattern
%!  clearvars a?3
%!  assert (isempty (who ("a33")));
%!
%!  a33 = 3;
%!  ## Test -regexp option
%!  clearvars -regexp 2 3$
%!  assert (who ("a*"), {"a"});
%!
%!  a = 1; a2 = 2; a33 = 3;
%!  ## Test -except option
%!  clearvars a* -except a33
%!  assert (who ("a", "a2", "a33"), {"a33"});
%!
%!  ## Test that non-regexp patterns only select full words
%!  clearvars a3
%!  assert (who ("a33"), {"a33"});
%!endfunction

%!function __test_global_vars__ ()
%!  global x y z
%!  a = 1; b = 2; c = 3;
%!  assert (all (ismember ({"x"; "y"; "z"}, who ("global"))));
%!  clearvars -global
%!  assert (isempty (who ("global")));
%!
%!  global x y z
%!  clearvars -global -regexp ^y
%!  assert (! any (strcmp ("y", who ("global"))));
%!endfunction

## Run BIST test functions
%!test __test_local_vars__ ();
%!test __test_global_vars__ ();

## Test input validation
%!error <'-global' must be the first option> clearvars ("ans", "-global")
%!error <'-except' may only be specified once> clearvars ("-except", "-except")

%!test
%!  clear -global x y z;  # cleanup after test
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} compare_versions (@var{v1}, @var{v2}, @var{operator})
## Compare two version strings using the given @var{operator}.
##
## This function assumes that versions @var{v1} and @var{v2} are arbitrarily
## long strings made of numeric and period characters possibly followed by an
## arbitrary string (e.g., @qcode{"1.2.3"}, @qcode{"0.3"}, @qcode{"0.1.2+"},
## or @qcode{"1.2.3.4-test1"}).
##
## The version is first split into numeric and character portions and then
## the parts are padded to be the same length (i.e., @qcode{"1.1"} would be
## padded to be @qcode{"1.1.0"} when being compared with @qcode{"1.1.1"}, and
## separately, the character parts of the strings are padded with nulls).
##
## The operator can be any logical operator from the set
##
## @itemize @bullet
## @item
## @qcode{"=="}
## equal
##
## @item
## @qcode{"<"}
## less than
##
## @item
## @qcode{"<="}
## less than or equal to
##
## @item
## @qcode{">"}
## greater than
##
## @item
## @qcode{">="}
## greater than or equal to
##
## @item @qcode{"!="}, @qcode{"~="}
## not equal
##
## @end itemize
##
## Note that version @qcode{"1.1-test2"} will compare as greater than
## @qcode{"1.1-test10"}.  Also, since the numeric part is compared first,
## @qcode{"a"} compares less than @qcode{"1a"} because the second string
## starts with a numeric part even though @code{double ("a")} is greater than
## @code{double ("1").}
## @end deftypefn

function out = compare_versions (v1, v2, operator)

  if (nargin != 3)
    print_usage ();
  endif

  ## Make sure that the version numbers are valid.
  if (! (ischar (v1) && ischar (v2)))
    error ("compare_versions: version numbers V1 and V2 must be strings");
  elseif (rows (v1) != 1 || rows (v2) != 1)
    error ("compare_versions: version numbers V1 and V2 must be a single row");
  endif

  ## check and make sure that the operator is valid
  if (! ischar (operator))
    error ("compare_versions: OPERATOR must be a string");
  elseif (numel (operator) > 2)
    error ("compare_versions: OPERATOR must be 1 or 2 characters long");
  endif

  ## trim off any character data that is not part of a normal version number
  v1firstchar = find (! (isdigit (v1) | v1 == "."), 1);
  v2firstchar = find (! (isdigit (v2) | v2 == "."), 1);

  if (isempty (v1firstchar))
    v1c = "";
    v1nochar = v1;
  else
    v1c = v1(v1firstchar:end);
    v1nochar = v1(1:v1firstchar-1);
  endif
  if (isempty (v2firstchar))
    v2c = "";
    v2nochar = v2;
  else
    v2c = v2(v2firstchar:end);
    v2nochar = v2(1:v2firstchar-1);
  endif

  v1n = str2double (ostrsplit (v1nochar, ".")');
  if (isnan (v1n))
    v1n = [];
  endif
  v2n = str2double (ostrsplit (v2nochar, ".")');
  if (isnan (v2n))
    v2n = [];
  endif

  if (isempty (v1n) && isempty (v1c))
    error ("compare_versions: version string V1 is not valid: %s", v1);
  elseif (isempty (v2n) && isempty (v2c))
    error ("compare_versions: version string V2 is not valid: %s", v2);
  endif

  ## Assume any additional elements would be 0 if one is longer than the other.
  maxnumlen = max ([length(v1n) length(v2n)]);
  v1n(end+1:maxnumlen) = 0;
  v2n(end+1:maxnumlen) = 0;

  ## Assume any additional character elements would be 0,
  ## if one is longer than the other.
  maxcharlen = max ([length(v1c), length(v2c)]);
  v1c(end+1:maxcharlen) = "\0";
  v2c(end+1:maxcharlen) = "\0";

  ## Determine the operator.
  equal_op = any (operator == "=");
  not_op = any (operator == "!" | operator == "~");
  lt_op = any (operator == "<");
  gt_op = any (operator == ">");

  ## Make sure that we don't have conflicting operators.
  if (gt_op && lt_op)
    error ("compare_versions: OPERATOR cannot contain both greater and less than symbols");
  elseif ((gt_op || lt_op) && not_op)
    error ("compare_versions: OPERATOR cannot contain not and greater than or less than symbols");
  elseif (strcmp (operator, "="))
    error ('compare_versions: equality OPERATOR is "==", not "="');
  elseif (! (equal_op || not_op || lt_op || gt_op))
    error ("compare_versions: no valid OPERATOR specified");
  endif

  ## Compare the versions (making sure that they're the same shape)
  vcmp = v1n(:) - v2n(:);
  vcmp = [vcmp; (v1c - v2c)(:)];
  if (lt_op)
    ## so that we only need to check for the output being greater than 1
    vcmp = -vcmp;
  endif
  firstdiff = find (vcmp, 1);

  if (isempty (firstdiff))
    ## They're equal.
    out = equal_op;
  elseif (lt_op || gt_op)
    ## They're correctly less than or greater than.
    out = (vcmp(firstdiff) > 0);
  else
    ## They're not correctly less than or greater than, and they're not equal.
    out = false;
  endif

  ## Reverse the output if not is given.
  if (not_op)
    out = ! out;
  endif

endfunction


## tests
## test both equality symbols
## test arbitrarily long equality
%!assert (compare_versions ("1.1.0.0.0", "1.1", "=="), true)
%!assert (compare_versions ("1", "1.1", "<"), true)
%!assert (compare_versions ("1.1", "1.1", "<="), true)
%!assert (compare_versions ("1.1", "1.1.1", "<="), true)
%!assert (compare_versions ("1.23", "1.24", "=<"), true)
## test different length numbers
%!assert (compare_versions ("23.2000", "23.1", ">"), true)
%!assert (compare_versions ("0.0.2", "0.0.1", ">="), true)
%!assert (compare_versions ("0.2", "0.0.100", "=>"), true)
%!assert (compare_versions ("0.1", "0.2", "!="), true)
%!assert (compare_versions ("0.1", "0.2", "~="), true)

## test alphanumeric strings
%!assert (compare_versions ("1a", "1b", "<"), true)
%!assert (compare_versions ("a", "1", "<"), true)
%!assert (compare_versions ("1a", "1b", ">"), false)
%!assert (compare_versions ("a", "1", ">"), false)
%!assert (compare_versions ("1.1.0a", "1.1.0b", "=="), false)
%!assert (compare_versions ("1.1.0a", "1.1.0b", "!="), true)
%!assert (compare_versions ("1.1.0test", "1.1.0b", "=="), false)
%!assert (compare_versions ("1.1.0test", "1.1.0test", "=="), true)

## make sure that it won't just give true output
%!assert (compare_versions ("1", "0", "=="), false)
## test arbitrarily long equality
%!assert (compare_versions ("1.1.1.0.0", "1.1", "=="), false)
%!assert (compare_versions ("1.1", "1", "<"), false)
%!assert (compare_versions ("2", "1.1", "<="), false)
%!assert (compare_versions ("1.1.1", "1.1", "<="), false)
%!assert (compare_versions ("1.25", "1.24", "=<"), false)
## test different length numbers
%!assert (compare_versions ("23.2", "23.100", ">"), false)
%!assert (compare_versions ("0.0.0.2", "0.0.1", ">="), false)
%!assert (compare_versions ("0.0.20", "0.10.2", "=>"), false)
%!assert (compare_versions ("0.1", "0.1", "!="), false)
%!assert (compare_versions ("0.1", "0.1", "~="), false)

## Test input validation
%!error <Invalid call> compare_versions ()
%!error <Invalid call> compare_versions (1)
%!error <Invalid call> compare_versions (1,2)
%!error <V1 and V2 must be strings> compare_versions (0.1, "0.1", "==")
%!error <V1 and V2 must be strings> compare_versions ("0.1", 0.1, "==")
%!error <V1 and V2 must be a single row> compare_versions (["0";".";"1"], "0.1", "==")
%!error <V1 and V2 must be a single row> compare_versions ("0.1", ["0";".";"1"], "==")
%!error <OPERATOR must be a string> compare_versions ("0.1", "0.1", 1)
%!error <OPERATOR must be 1 or 2> compare_versions ("0.1", "0.1", "==>")
%!error <V1 is not valid> compare_versions (".", "0.1", "==")
%!error <V2 is not valid> compare_versions ("0.1", ".", "==")

%!error <cannot contain both greater and less than> compare_versions ("0.1", "0.1", "<>")
%!error <cannot contain not and greater than> compare_versions ("0.1", "0.1", "!>")
%!error <cannot contain not and greater than> compare_versions ("0.1", "0.1", "!<")
%!error <equality OPERATOR is "=="> compare_versions ("0.1", "0.1", "=")
%!error <no valid OPERATOR> compare_versions ("0.1", "0.1", "aa")
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} computer ()
## @deftypefnx {} {@var{comp} =} computer ()
## @deftypefnx {} {[@var{comp}, @var{maxsize}] =} computer ()
## @deftypefnx {} {[@var{comp}, @var{maxsize}, @var{endian}] =} computer ()
## @deftypefnx {} {@var{arch} =} computer ("arch")
## Print or return a string of the form @var{cpu}-@var{vendor}-@var{os} that
## identifies the type of computer that Octave is running on.
##
## If invoked with an output argument, the value is returned instead of
## printed.  For example:
##
## @example
## @group
## computer ()
##    @print{} x86_64-pc-linux-gnu
##
## mycomp = computer ()
##    @result{} mycomp = x86_64-pc-linux-gnu
## @end group
## @end example
##
## If two output arguments are requested, also return the maximum number of
## elements for an array.  This will depend on whether Octave has been
## compiled with 32-bit or 64-bit index vectors.
##
## If three output arguments are requested, also return the byte order of the
## current system as a character (@qcode{"B"} for big-endian or @qcode{"L"}
## for little-endian).
##
## If the argument @qcode{"arch"} is specified, return a string indicating the
## architecture of the computer on which Octave is running.
##
## Results may be different if Octave was invoked with the --traditional
## option.
## @seealso{isunix, ismac, ispc}
## @end deftypefn

function [comp, maxsize, endian] = computer (arch)

  if (nargin == 1 && ! strcmpi (arch, "arch"))
    error ('computer: "arch" is only valid argument');
  endif

  canonical_host_type = __octave_config_info__ ("canonical_host_type");
  traditional = __traditional__ ();
  enable_64 = __octave_config_info__ ("ENABLE_64");
  host_parts = ostrsplit (canonical_host_type, "-");

  if (nargin == 0)

    host = "";
    if (traditional && enable_64)
      if (ismac ())
        host = "MACI64";
      elseif (ispc ())
        host = "PCWIN64";
      elseif (strcmp ([host_parts{3} "-" host_parts{1}], "linux-x86_64"))
        host = "GLNXA64";
      endif
    endif
    if (isempty (host))
      host = canonical_host_type;
    elseif (strcmp (host, "unknown"))
      host = "Hi Dave, I'm a HAL-9000";
    endif

    if (nargout == 0)
      disp (host);
    else
      comp = host;
      if (nargout > 1)
        if (enable_64)
          if (traditional)
            maxsize = 2^48-1;
          else
            maxsize = 2^63-1;
          endif
        else
          maxsize = 2^31-1;
        endif
      endif
      if (nargout > 2)
        if (__octave_config_info__ ("words_big_endian"))
          endian = "B";
        elseif (__octave_config_info__ ("words_little_endian"))
          endian = "L";
        else
          endian = "?";
        endif
      endif
    endif

  else

    ## "arch" case.
    comp = "";
    if (traditional && enable_64)
      if (ismac ())
        comp = "maci64";
      elseif (ispc ())
        comp = "win64";
      elseif (strcmp ([host_parts{3} "-" host_parts{1}], "linux-x86_64"))
        comp = "glnxa64";
      endif
    endif
    if (isempty (comp))
      comp = [host_parts{3} "-" host_parts{1}];
      if (numel (host_parts) == 4)
        comp = [host_parts{4} "-" comp];
      endif
    endif

  endif

endfunction


%!assert (ischar (computer ()))
%!assert (computer (), __octave_config_info__ ("canonical_host_type"))
%!assert (ischar (computer ("arch")))

%!error computer (1,2)
%!error <"arch" is only valid argument> computer ("xyz")
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} copyfile @var{f1} @var{f2}
## @deftypefnx {} {} copyfile @var{f1} @var{f2} f
## @deftypefnx {} {} copyfile (@var{f1}, @var{f2})
## @deftypefnx {} {} copyfile (@var{f1}, @var{f2}, 'f')
## @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} copyfile (@dots{})
## Copy the source file(s) or directory @var{f1} to the destination @var{f2}.
##
## The name @var{f1} may contain globbing patterns, or may be a cell array of
## strings.  If @var{f1} expands to multiple filenames, @var{f2} must be a
## directory.
##
## When the force flag @qcode{'f'} is given any existing files will be
## overwritten without prompting.
##
## If successful, @var{status} is logical 1, and @var{msg}, @var{msgid} are
## empty character strings ("").  Otherwise, @var{status} is logical 0,
## @var{msg} contains a system-dependent error message, and @var{msgid}
## contains a unique message identifier.  Note that the status code is exactly
## opposite that of the @code{system} command.
## @seealso{movefile, rename, unlink, delete, glob}
## @end deftypefn

function [status, msg, msgid] = copyfile (f1, f2, force)

  if (nargin < 2)
    print_usage ();
  endif

  max_cmd_line = 1024;
  sts = true;
  msg = "";
  msgid = "";

  ## FIXME: Maybe use the same method as in ls to allow users control
  ##        over the command that is executed.

  if (ispc () && ! isunix ()
      && isempty (file_in_path (getenv ("PATH"), "cp.exe")))
    ## Windows.
    cmd = "cmd /C xcopy /E";
    cmd_force_flag = "/Y";
  else
    cmd = "cp -r";
    cmd_force_flag = "-f";
  endif

  ## Input type check.
  if (ischar (f1))
    f1 = cellstr (f1);
  elseif (! iscellstr (f1))
    error ("copyfile: F1 must be a string or a cell array of strings");
  endif
  if (! ischar (f2))
    error ("copyfile: F2 must be a string");
  endif

  if (nargin == 3 && strcmp (force, "f"))
    cmd = [cmd " " cmd_force_flag];
  endif

  ## If f1 has more than 1 element then f2 must be a directory
  isdir = isfolder (f2);
  if (numel (f1) > 1 && ! isdir)
    if (nargout == 0)
      error ("copyfile: when copying multiple files, F2 must be a directory");
    else
      status = false;
      msg = "when copying multiple files, F2 must be a directory";
      msgid = "copyfile";
      return;
    endif
  endif

  ## Protect the filename(s).
  if (ispc ())
    f1 = __wglob__ (f1);
  else
    f1 = glob (f1);
  endif
  if (isempty (f1))
    if (nargout == 0)
      error ("copyfile: no files to move");
    else
      status = false;
      msg = "no files to move";
      msgid = "copyfile";
      return;
    endif
  endif
  p1 = sprintf ('"%s" ', f1{:});
  p2 = tilde_expand (f2);

  if (isdir && length (p1) > max_cmd_line)
    l2 = length (p2) + length (cmd) + 6;
    while (! isempty (f1))
      p1 = sprintf ('"%s" ', f1{1});
      f1(1) = [];
      while (! isempty (f1)
             && (length (p1) + length (f1{1}) + l2 < max_cmd_line))
        p1 = sprintf ('%s"%s" ', p1, f1{1});
        f1(1) = [];
      endwhile

      if (ispc () && ! isunix ()
          && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
        p1 = strrep (p1, '\', '/');
        p2 = strrep (p2, '\', '/');
      endif

      ## Copy the files.
      [err, msg] = system (sprintf ('%s %s"%s"', cmd, p1, p2));
      if (err != 0)
        sts = false;
        msgid = "copyfile";
        break;
      endif
    endwhile
  else
    if (ispc () && ! isunix ()
        && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
      p1 = strrep (p1, '\', '/');
      p2 = strrep (p2, '\', '/');
    endif

    ## Copy the files.
    [err, msg] = system (sprintf ('%s %s"%s"', cmd, p1, p2));
    if (err != 0)
      sts = false;
      msgid = "copyfile";
    endif
  endif

  if (nargout == 0)
    if (! sts)
      error ("copyfile: operation failed: %s", msg);
    endif
  else
    status = sts;
  endif

endfunction


%!test
%! unwind_protect
%!   f1 = tempname ();
%!   tmp_var = pi;
%!   save (f1, "tmp_var");
%!   f2 = tempname ();
%!   assert (copyfile (f1, f2));
%!   assert (exist (f2, "file"));
%!   fid = fopen (f1, "rb");
%!   assert (fid >= 0);
%!   orig_data = fread (fid);
%!   fclose (fid);
%!   fid = fopen (f2, "rb");
%!   assert (fid >= 0);
%!   new_data = fread (fid);
%!   fclose (fid);
%!   if (orig_data != new_data)
%!     error ("copied file not equal to original file!");
%!   endif
%! unwind_protect_cleanup
%!   delete (f1);
%!   delete (f2);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> copyfile ()
%!error <Invalid call> copyfile (1)
%!error <F1 must be a string> copyfile (1, "foobar")
%!error <F2 must be a string> copyfile ("foobar", 1)
%!error <F2 must be a directory> copyfile ({"a", "b"}, "%_NOT_A_DIR_%")
%!error <no files to move> copyfile ("%_NOT_A_FILENAME1_%", "%_NOT_A_FILENAME2_%")
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} delete (@var{file})
## @deftypefnx {} {} delete (@var{file1}, @var{file2}, @dots{})
## @deftypefnx {} {} delete (@var{handle})
## Delete the named file or graphics handle.
##
## @var{file} may contain globbing patterns such as @samp{*}.  Multiple files
## to be deleted may be specified in the same function call.
##
## @var{handle} may be a scalar or vector of graphic handles to delete.
##
## Programming Note: Deleting graphics objects is the proper way to remove
## features from a plot without clearing the entire figure.
## @seealso{clf, cla, unlink, rmdir}
## @end deftypefn

function delete (varargin)

  if (nargin == 0)
    print_usage ();
  endif

  if (iscellstr (varargin))
    for arg = varargin
      if (ispc ())
        files = __wglob__ (arg{1});
      else
        files = glob (arg{1});
      endif
      if (isempty (files))
        warning ("Octave:delete:no-such-file", ...
                 "delete: no such file: %s", arg{1});
      endif
      for i = 1:length (files)
        file = files{i};
        [err, msg] = unlink (file);
        if (err)
          warning ("Octave:delete:unlink-error", ...
                   "delete: %s: %s", file, msg);
        endif
      endfor
    endfor

  elseif (isscalar (varargin) && all (ishghandle (varargin{1}(:))))
    ## Delete a graphics object.
    __go_delete__ (varargin{1});

  else
    error ("Octave:delete:unsupported-object", ...
           "delete: first argument must be a filename or graphics handle");
  endif

endfunction


%!test
%! unwind_protect
%!   file = tempname ();
%!   tmp_var = pi;
%!   save (file, "tmp_var");
%!   assert (exist (file, "file"));
%!   delete (file);
%!   assert (! exist (file, "file"));
%! unwind_protect_cleanup
%!   sts = unlink (file);
%! end_unwind_protect

%!test
%! unwind_protect
%!   hf = figure ("visible", "off");
%!   hl = plot (1:10);
%!   assert (get (gca, "children"), hl);
%!   delete (hl);
%!   assert (get (gca, "children"), zeros (0,1));
%! unwind_protect_cleanup
%!   close (hf);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> delete ()
%!error <first argument must be a filename> delete (struct ())
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dir
## @deftypefnx {} {} dir (@var{directory})
## @deftypefnx {} {[@var{list}] =} dir (@var{directory})
## Display file listing for directory @var{directory}.
##
## If @var{directory} is not specified then list the present working directory.
##
## If a return value is requested, return a structure array with the fields
##
## @table @asis
## @item name
## File or directory name.
##
## @item folder
## Location of file or directory
##
## @item date
## Timestamp of file modification (string value).
##
## @item bytes
## File size in bytes.
##
## @item isdir
## True if name is a directory.
##
## @item datenum
## Timestamp of file modification as serial date number (double).
##
## @item statinfo
## Information structure returned from @code{stat}.
## @end table
##
## If @var{directory} is a filename, rather than a directory, then return
## information about the named file.  @var{directory} may also be a list rather
## than a single directory or file.
##
## @var{directory} is subject to shell expansion if it contains any wildcard
## characters @samp{*}, @samp{?}, @samp{[]}.  If these wildcard characters are
## escaped with a backslash @samp{\} (e.g., @samp{\*}) on a POSIX platform,
## then they are not treated as wildcards, but as the corresponding literal
## character.  On Windows, it is not possible to escape wildcard characters
## because backslash @samp{\} is treated as a file separator.  On Windows, use
## @code{ls} for file or folder names that contain characters that would be
## treated as wildcards by @code{dir}.
##
## Note that for symbolic links, @code{dir} returns information about the
## file that the symbolic link points to rather than the link itself.  However,
## if the link points to a nonexistent file, @code{dir} returns information
## about the link.
## @seealso{ls, readdir, glob, what, stat, lstat}
## @end deftypefn

## FIXME: This is quite slow for large directories.
##        Perhaps it should be converted to C++?

function retval = dir (directory = ".")

  if (! ischar (directory))
    error ("dir: DIRECTORY argument must be a string");
  endif

  ## Prep the retval.
  info = struct (zeros (0, 1),
           {"name", "folder" "date", "bytes", "isdir", "datenum", "statinfo"});

  if (strcmp (directory, "*"))
    directory = ".";
  endif
  if (strcmp (directory, "."))
    flst = {"."};
    nf = 1;
    dir_has_wildcard = false;
  else
    flst = __wglob__ (directory);
    nf = numel (flst);
    dir_has_wildcard = any (directory == '*');  # See Bug #58976.
  endif

  ## Determine the file list for the case where a single directory is specified.
  if (nf == 1)
    fn = flst{1};
    [st, err, msg] = stat (fn);
    if (err < 0)
      warning ("dir: 'stat (%s)' failed: %s", fn, msg);
      nf = 0;
    elseif (S_ISDIR (st.mode) && ! dir_has_wildcard)
      flst = readdir (flst{1});
      nf = numel (flst);
      flst = strcat ([fn filesep], flst);
    endif
  endif

  if (nf > 0)

    fs = regexptranslate ("escape", filesep ("all"));
    re = sprintf ('(^.+)[%s]([^%s.]*)([.][^%s]*)?$', fs, fs, fs);
    last_dir = last_absdir = "";
    info(nf,1).name = "";  # pre-declare size of struct array

    ## Collect results.
    cnt = 0;
    for i = 1:nf
      fn = flst{i};
      [st, err, msg] = lstat (fn);
      if (err < 0)
        warning ("dir: 'lstat (%s)' failed: %s", fn, msg);
        continue;
      else
        ## If we are looking at a link that points to something,
        ## return info about the target of the link, otherwise, return
        ## info about the link itself.
        if (S_ISLNK (st.mode))
          [xst, err] = stat (fn);
          if (! err)
            st = xst;
          endif
        endif
        tmpdir = regexprep (fn, re, '$1');
        if (is_same_file (fn, tmpdir))
          ## regexrep failed to match, no directory component.
          no_dir = true;
        else
          no_dir = false;
        endif
        fn = regexprep (fn, re, '$2$3');
        info(++cnt).name = fn;
        if (no_dir && ! strcmp (fn, "."))
          tmpdir = ".";
        endif
        if (! is_same_file (last_dir, tmpdir))
          ## Caching mechanism to speed up function
          last_dir = tmpdir;
          if (ispc () && strncmp (last_dir, '\\', 2))
            ## Windows UNC network file name is used as is
            last_absdir = last_dir;
          else
            last_absdir = canonicalize_file_name (last_dir);
          endif
        endif
        info(cnt).folder = last_absdir;
        lt = localtime (st.mtime);
        info(cnt).date = strftime ("%d-%b-%Y %T", lt);
        info(cnt).bytes = st.size;
        info(cnt).isdir = S_ISDIR (st.mode);
        info(cnt).datenum = [lt.year + 1900, lt.mon + 1, lt.mday, ...
                             lt.hour, lt.min, lt.sec];
        info(cnt).statinfo = st;
      endif
    endfor
    info((cnt+1):end) = [];  # remove any unused entries
    ## A lot of gymnastics in order to call datenum just once.  2x speed up.
    dvec = [info.datenum]([[1:6:end]', [2:6:end]', [3:6:end]', ...
                           [4:6:end]', [5:6:end]', [6:6:end]']);
    dnum = datenum (dvec);
    ctmp = mat2cell (dnum, ones (cnt,1), 1);
    [info.datenum] = ctmp{:};
  endif

  ## Return the output arguments.
  if (nargout > 0)
    ## Return the requested structure.
    retval = info;
  elseif (numel (info) > 0)
    ## Print the structure to the screen.
    printf ("%s", list_in_columns ({info.name}));
  else
    warning ("dir: nonexistent directory '%s'", directory);
  endif

endfunction


%!test
%! orig_dir = pwd ();
%! tmp_dir = tempname ();
%! unwind_protect
%!   assert (mkdir (tmp_dir));
%!   chdir (tmp_dir);
%!   fclose (fopen ("f1", "w"));
%!   list = dir ();
%!   assert (isstruct (list) && ! isempty (list));
%!   assert (fieldnames (list),
%!           {"name"; "folder"; "date"; "bytes"; "isdir"; "datenum"; "statinfo"});
%!
%!   if (isunix ())
%!     idx = find (strcmp ({list.name}, "."), 1);
%!     assert ({list(idx:idx+1).name}, {".", ".."});
%!     assert ([list(idx:idx+1).isdir], [true true]);
%!   endif
%!
%!   ## test that specifying a filename works the same as using a directory.
%!   found = find (! [list.isdir], 1);
%!   if (! isempty (found))
%!     list2 = dir (fullfile (list(found).folder, list(found).name));
%!     assert (list(found), list2);
%!   endif
%! unwind_protect_cleanup
%!   chdir (orig_dir);
%!   confirm_recursive_rmdir (false, "local");
%!   if (exist (tmp_dir))
%!     sts = rmdir (tmp_dir, "s");
%!   endif
%! end_unwind_protect

%!test <*58976>
%! orig_dir = pwd ();
%! tmp_dir = tempname ();
%! unwind_protect
%!   assert (mkdir (tmp_dir));
%!   assert (mkdir (fullfile (tmp_dir, "dir1")));
%!   assert (mkdir (fullfile (tmp_dir, "dir2")));
%!   chdir (fullfile (tmp_dir, "dir1"));
%!   fclose (fopen ("f1", "w"));
%!   chdir (tmp_dir);
%!
%!   ## Wildcard with multiple matches lists directories
%!   list = dir (fullfile (tmp_dir, "dir*"));
%!   assert (numel (list) == 2);
%!   assert ({list.name}, {"dir1", "dir2"});
%!
%!   ## Wildcard with single match lists directories
%!   assert (rmdir (fullfile (tmp_dir, "dir2")));
%!   list = dir (fullfile (tmp_dir, "dir*"));
%!   assert (numel (list) == 1);
%!   assert ({list.name}, {"dir1"});
%!
%!   ## No wildcard returns listing of directory contents
%!   list = dir (fullfile (tmp_dir, "dir1"));
%!   assert (any (strcmp ({list.name}, "f1")));
%! unwind_protect_cleanup
%!   chdir (orig_dir);
%!   confirm_recursive_rmdir (false, "local");
%!   if (exist (tmp_dir))
%!     sts = rmdir (tmp_dir, "s");
%!   endif
%! end_unwind_protect

%!test <*57666>
%! orig_dir = pwd ();
%! tmp_dir = tempname ();
%! unwind_protect
%!   assert (mkdir (tmp_dir));
%!   list = dir (tmp_dir);
%!   assert (list(1).name, ".");
%!   assert (list(1).folder, canonicalize_file_name (tmp_dir));
%! unwind_protect_cleanup
%!   if (exist (tmp_dir))
%!     sts = rmdir (tmp_dir);
%!   endif
%! end_unwind_protect

## Test input validation
%!error <DIRECTORY argument must be a string> dir (1)
%!warning <nonexistent directory> dir ("_%UNLIKELY_DIR_NAME%_");
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dos ("@var{command}")
## @deftypefnx {} {@var{status} =} dos ("@var{command}")
## @deftypefnx {} {[@var{status}, @var{text}] =} dos ("@var{command"})
## @deftypefnx {} {[@dots{}] =} dos ("@var{command}", "-echo")
## Execute a system command if running under a Windows-like operating system,
## otherwise do nothing.
##
## Octave waits for the external command to finish before returning the exit
## status of the program in @var{status} and any output in @var{text}.
##
## When called with no output argument, or the @qcode{"-echo"} argument is
## given, then @var{text} is also sent to standard output.
## @seealso{unix, system, isunix, ismac, ispc}
## @end deftypefn

function [status, text] = dos (command, echo_arg)

  if (nargin < 1)
    print_usage ();
  endif

  status = 1;
  text = "";

  ## FIXME: Should this be ispc ()?  There may be an issue with MinGW
  if (! isunix ())
    [status, text] = system (command);
    if (nargin > 1 || nargout == 0)
      printf ("%s\n", text);
    endif
  endif

endfunction


%!test
%! cmd = ls_command ();
%! [status, output] = dos (cmd);
%!
%! if (ispc () && ! isunix ())
%!   [status, output] = dos (cmd);
%!   assert (status, 0);
%!   assert (ischar (output));
%!   assert (! isempty (output));
%! else
%!   assert (status, 1);
%!   assert (output, "");
%! endif

## Test input validation
%!error <Invalid call> dos ()
%!error dos (1, 2, 3)
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} edit @var{name}
## @deftypefnx {} {} edit @var{field} @var{value}
## @deftypefnx {} {@var{value} =} edit ("get", @var{field})
## @deftypefnx {} {@var{value} =} edit ("get", "all")
## Edit the named function, or change editor settings.
##
## If @code{edit} is called with the name of a file or function as its
## argument it will be opened in the text editor defined by @env{EDITOR}.
##
## @itemize @bullet
## @item
## If the function @var{name} is available in a file on your path, then it
## will be opened in the editor.  If no file is found, then the m-file
## variant, ending with @qcode{".m"}, will be considered.  If still no file is
## found, then variants with a leading @qcode{"@@"} and then with both a
## leading @qcode{"@@"} and trailing @qcode{".m"} will be considered.
##
## @item
## If @var{name} is the name of a command-line function, then an m-file will
## be created to contain that function along with its current definition.
##
## @item
## If @code{@var{name}.cc} is specified, then it will search for
## @file{@var{name}.cc} in the path and open it in the editor.  If the file is
## not found, then a new @file{.cc} file will be created.  If @var{name}
## happens to be an m-file or command-line function, then the text of that
## function will be inserted into the .cc file as a comment.
##
## @item
## If @file{@var{name}.ext} is on your path then it will be edited, otherwise
## the editor will be started with @file{@var{name}.ext} in the current
## directory as the filename.
##
## @strong{Warning:} You may need to clear @var{name} before the new definition
## is available.  If you are editing a .cc file, you will need to execute
## @code{mkoctfile @file{@var{name}.cc}} before the definition will be
## available.
## @end itemize
##
## If @code{edit} is called with @var{field} and @var{value} variables, the
## value of the control field @var{field} will be set to @var{value}.
##
## If an output argument is requested and the first input argument is
## @code{get} then @code{edit} will return the value of the control field
## @var{field}.  If the control field does not exist, edit will return a
## structure containing all fields and values.  Thus, @code{edit ("get",
## @qcode{"all"})} returns a complete control structure.
##
## The following control fields are used:
##
## @table @samp
## @item author
## This is the name to put after the "## Author:" field of new functions.  By
## default it guesses from the @code{gecos} field of the password database.
##
## @item email
## This is the e-mail address to list after the name in the author field.  By
## default it guesses @code{<$LOGNAME@@$HOSTNAME>}, and if @code{$HOSTNAME}
## is not defined it uses @code{uname -n}.  You probably want to override
## this.  Be sure to use the format @code{@email{user@@host}}.
##
## @item license
##
## @table @samp
## @item gpl
## GNU General Public License (default).
##
## @item bsd
## BSD-style license without advertising clause.
##
## @item pd
## Public domain.
##
## @item "text"
## Your own default copyright and license.
## @end table
##
## Unless you specify @samp{pd}, edit will prepend the copyright statement
## with "Copyright (C) YYYY Author".
##
## @item mode
## This value determines whether the editor should be started in async mode
## (editor is started in the background and Octave continues) or sync mode
## (Octave waits until the editor exits).  Set it to @qcode{"sync"} to start
## the editor in sync mode.  The default is @qcode{"async"}
## (@pxref{XREFsystem,,@code{system}}).
##
## @item editinplace
## Determines whether files should be edited in place, without regard to
## whether they are modifiable or not.  The default is @code{true}.
## Set it to @code{false} to have read-only function files automatically
## copied to @samp{home}, if it exists, when editing them.
##
## @item home
## This value indicates a directory that system m-files should be copied into
## before opening them in the editor.  The intent is that this directory is
## also in the path, so that the edited copy of a system function file shadows
## the original.  This setting only has an effect when @samp{editinplace} is
## set to @code{false}.  The default is the empty matrix (@code{[]}), which
## means it is not used.  The default in previous versions of Octave was
## @file{~/octave}.
## @end table
## @seealso{EDITOR, path}
## @end deftypefn

## Original version by Paul Kienzle distributed as free software in the
## public domain.

function retval = edit (varargin)

  ## Pick up globals or default them.

  persistent FUNCTION = struct ("HOME", [],
                                "AUTHOR", default_user(1),
                                "EMAIL", [],
                                "LICENSE", "GPL",
                                "MODE", "async",
                                "EDITINPLACE", true);
  ## Make sure the stateval variables survive "clear functions".
  mlock ();

  ## Get default editor every time in case the user has changed it
  FUNCTION.EDITOR = [EDITOR() " %s"];

  if (nargin == 1)
    ## User has supplied one arg, this can be a single filename
    ## or a cell array of strings containing multiple files to be opened
    if (iscellstr (varargin{1}))
      ## If first arg is a cell array of strings,
      ## it becomes the list of files to be edited
      editfilelist = varargin{1};
    elseif (ischar (varargin{1}))
      ## If first arg is a string, create a cell array of strings
      ## of length 1 (by copying the input cell array)
      editfilelist = varargin(1);
    else
      error ("edit: file NAME must be a string or cell array of strings");
    endif
  elseif (nargin == 2)
    ## User has supplied two arguments, these could be two filenames,
    ## or a combination of editor state name and new value for that state,
    ## so first check for the various states
    statevar = varargin{1};
    stateval = varargin{2};
    switch (toupper (statevar))
      case "EDITOR"
        error ("Octave:deprecated-function",
               "The EDITOR option of edit has been removed.  Use EDITOR() directly.");
      case "HOME"
        FUNCTION.HOME = stateval;
        return;
      case "AUTHOR"
        FUNCTION.AUTHOR = stateval;
        return;
      case "EMAIL"
        FUNCTION.EMAIL = stateval;
        return;
      case "LICENSE"
        FUNCTION.LICENSE = stateval;
        return;
      case "MODE"
        if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
          FUNCTION.MODE = stateval;
        else
          error ("edit: MODE must be sync or async");
        endif
        return;
      case "EDITINPLACE"
        if (ischar (stateval))
          if (strcmpi (stateval, "true"))
            stateval = true;
          elseif (strcmpi (stateval, "false"))
            stateval = false;
          else
            stateval = eval (stateval);
          endif
        endif
        FUNCTION.EDITINPLACE = stateval;
        return;
      case "GET"
        if (isfield (FUNCTION, toupper (stateval)))
          retval = FUNCTION.(toupper (stateval));
        else
          retval = FUNCTION;
        endif
        return;
      otherwise
        ## If none of the states match, assume both inputs are actually
        ## filenames to be opened.
        editfilelist = varargin;
    endswitch
  elseif (nargin > 2)
    if (iscellstr (varargin))
      editfilelist = varargin;
    else
      error ("edit: if supplying more than one input all inputs must be strings containing field names to open");
    endif
  endif

  ## Only use the legacy "HOME" directory if the user explicitly configured
  ## it and if the directory exists.  In previous versions of Octave, HOME
  ## was ~/octave by default and edited functions were copied into ~/octave.
  ## Now 'edit_file_in_place' should be true by default unless the user
  ## opts in by setting "EDITINPLACE" to false and "HOME" to a directory.
  edit_file_in_place = (FUNCTION.EDITINPLACE || isempty (FUNCTION.HOME)
                        || ! isfolder (FUNCTION.HOME));

  ## Start the editor without a file if no file is given.
  if (nargin == 0)
    if (! edit_file_in_place && ! strcmp (FUNCTION.HOME, "."))
      curr_dir = pwd ();
      unwind_protect
        chdir (FUNCTION.HOME);
        do_edit (FUNCTION.EDITOR, "", FUNCTION.MODE);
      unwind_protect_cleanup
        chdir (curr_dir);
      end_unwind_protect
    else
      do_edit (FUNCTION.EDITOR, "", FUNCTION.MODE);
    endif
    return;
  endif

  if (numel (editfilelist) > 1)

    ## Call edit on each of the files in the list if there are more than 1
    for i = 1:numel (editfilelist)
      edit (editfilelist{i});
    endfor

  else

    ## Only one filename was supplied, get it from the cell array
    file = tilde_expand (editfilelist{1});

    ## Check whether the user is trying to edit a builtin or compiled function.
    switch (exist (file))
      case {3, 5}
        error ("edit: unable to edit a built-in or compiled function");
    endswitch

    ## Checks for whether the file is
    ## absolute or relative should be handled inside file_in_loadpath.
    ## That way, it will be possible to look up files correctly given
    ## partial path information.  For example, you should be able to
    ## edit a particular overloaded function by doing any one of
    ##
    ##   edit classname/foo
    ##   edit classname/foo.m
    ##   edit @classname/foo
    ##   edit @classname/foo.m
    ##
    ## This functionality is needed for other functions as well (at least
    ## help and type; there may be more).  So the place to fix that is in
    ## file_in_loadpath, possibly with some help from the load_path class.

    ## The code below includes a portion that serves as a place-holder for
    ## the changes suggested above.

    ## Create list of explicit and implicit filenames.
    filelist = {file};
    ## If file has no extension, add file.m and file.cc to the list.
    idx = rindex (file, ".");
    if (idx == 0)
      if (isempty (regexp (file, '\.m$')))
        ## No ".m" at the end of the file, add to the list.
        filelist(end+1) = [file ".m"];
      endif
      if (isempty (regexp (file, '\.cc$')))
        ## No ".cc" at the end of the file, add to the list.
        filelist(end+1) = [file ".cc"];
      endif
    endif

    ## If the file includes a path, it may be an overloaded function.
    if (! index (file, "@") && strchr (file, '/\'))
      ## No "@" at the beginning of the file, add to the list.
      numfiles = numel (filelist);
      for n = 1:numfiles
        filelist(n+numfiles) = ["@" filelist{n}];
      endfor
    endif

    ## Search the entire path for the 1st instance of a file in the list.
    fileandpath = "";
    for n = 1:numel (filelist)
      filetoedit = file_in_loadpath (filelist{n});
      if (! isempty (filetoedit))
        ## The path is explicitly included.
        fileandpath = filetoedit;
        break;
      endif
    endfor

    if (! isempty (fileandpath))
      ## If the file exists, then edit it.
      if (edit_file_in_place)
        ## Edit in place even if it is protected.
        do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
        return;
      else
        ## If the file is modifiable in place then edit it,
        ## otherwise make a copy in HOME and then edit it.
        fid = fopen (fileandpath, "r+t");
        if (fid < 0)
          from = fileandpath;
          [~, fname, ext] = fileparts (from);
          fileandpath = fullfile (tilde_expand (FUNCTION.HOME), [fname, ext]);
          [status, msg] = copyfile (from, fileandpath, 1);
          if (status == 0)
            error (msg);
          endif
        else
          fclose (fid);
        endif
        do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
        return;
      endif
    endif

    ## If editing a new file, prompt for creation if GUI is running
    if (isguirunning ())
      if (! __event_manager_edit_file__ (file, "prompt"))
        return;
      endif
    endif

    ## If editing a new file that is neither an m-file nor an oct-file,
    ## just edit it.
    ## If in gui-mode, create it before or editor would prompt again.
    fileandpath = file;
    idx = rindex (file, ".");
    if (idx)
      name = file(1:idx-1);
      ext = file(idx+1:end);
    else
      name = file;
      ext = "";
    endif
    if (! any (strcmp (ext, {"cc", "m"})))
      ## Some unknown file.  Create and open it or just open it.
      if (isempty (ext))
        fileandpath = [fileandpath ".m"];  # Add .m extension per default
      endif
      if (isguirunning ())
        ## Write the initial file (if there is anything to write)
        ## Give user the opportunity to change the file extension
        fileandpath = uiputfile (fileandpath);
        if (! ischar (fileandpath))
          return;  # Cancel Button pressed
        endif
        fid = fopen (fileandpath, "wt");
        if (fid < 0)
          error ("edit: could not create %s", fileandpath);
        endif
        fclose (fid);
      endif
      do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
      return;
    endif

    ## The file doesn't exist in path so
    ## create it, put in the function template, and edit it.

    ## Guess the email name if it was not given.
    if (isempty (FUNCTION.EMAIL))
      host = getenv ("HOSTNAME");
      if (isempty (host) && ispc ())
        host = getenv ("COMPUTERNAME");
      endif
      if (isempty (host))
        [~, host] = system ("uname -n");
        ## trim newline from end of hostname
        if (! isempty (host))
          host = host(1:end-1);
        endif
      endif
      if (isempty (host))
        FUNCTION.EMAIL = " ";
      else
        FUNCTION.EMAIL = ["<" default_user(0) "@" host ">"];
      endif
    endif

    ## Fill in the revision string.
    now = localtime (time);
    revs = ["Created: " strftime("%Y-%m-%d",now)];

    ## Fill in the copyright string.
    copyright = [strftime("Copyright (C) %Y ",now) FUNCTION.AUTHOR];

    ## Fill in the author tag field.
    author = ["Author: " FUNCTION.AUTHOR " " FUNCTION.EMAIL];

    ## Fill in the header.
    uclicense = toupper (FUNCTION.LICENSE);
    switch (uclicense)
      case "GPL"
        head = cstrcat (copyright, "\n\n", "\
This program is free software: you can redistribute it and/or modify\n\
it under the terms of the GNU General Public License as published by\n\
the Free Software Foundation, either version 3 of the License, or\n\
(at your option) any later version.\n\
\n\
This program is distributed in the hope that it will be useful,\n\
but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
GNU General Public License for more details.\n\
\n\
You should have received a copy of the GNU General Public License\n\
along with this program.  If not, see <https://www.gnu.org/licenses/>.\
");
        tail = [author, "\n", revs];

      case "BSD"
        head = cstrcat (copyright, "\n\n", "\
This program is free software: redistribution and use in source and\n\
binary forms, with or without modification, are permitted provided that\n\
the following conditions are met:\n\
1. Redistributions of source code must retain the above copyright\n\
   notice, this list of conditions and the following disclaimer.\n\
2. Redistributions in binary form must reproduce the above copyright\n\
   notice, this list of conditions and the following disclaimer in the\n\
   documentation and/or other materials provided with the distribution.\n\
\n\
THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n\
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n\
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
SUCH DAMAGE.\
");
        tail = [author, "\n", revs];

      case "PD"
        head = "";
        tail = [author, "\n", revs, "\n\n", ...
                "This program is granted to the public domain."];

      otherwise
        head = "";
        tail = [copyright, "\n\n", FUNCTION.LICENSE, "\n", author, "\n", revs];
    endswitch

    ## Generate the function template.
    [~, basename] = fileparts (name);
    exists = exist (name);
    switch (ext)
      case {"cc", "C", "cpp"}
        if (isempty (head))
          comment = ["/*\n\n", tail, "\n\n*/\n\n"];
        else
          comment = ["/*\n\n", head, "\n\n", tail, "\n\n*/\n\n"];
        endif
        ## If we are shadowing an m-file, paste the code for the m-file.
        if (any (exists == [2, 103]))
          code = ['\ ', strrep(type(name){1}, "\n", "\n// ")];
        else
          code = " ";
        endif
        body = ["#include <octave/oct.h>\n\n"             ...
                "DEFUN_DLD(" basename ", args, nargout,\n"...
                "          \"-*- texinfo -*-\\n\\\n"      ...
                "@deftypefn {} {@var{retval} =} " basename...
                " (@var{input1}, @var{input2})\\n\\\n"    ...
                "@seealso{}\\n\\\n@end deftypefn\")\n{\n" ...
                "  octave_value_list retval;\n"           ...
                "  int nargin = args.length ();\n\n"      ...
                code, "\n  return retval;\n}\n"];

        text = [comment, body];
      case "m"
        ## If we are editing a function defined on the fly, paste the code.
        if (any (exists == [2, 103]))
          body = type (name){1};
        else
          body = ["function retval = " basename " (input1, input2)\n\n" ...
                  "endfunction\n"];
        endif
        if (isempty (head))
          comment = ["## -*- texinfo -*-\n## @deftypefn {} " ...
                     "{@var{retval} =} " basename                          ...
                     " (@var{input1}, @var{input2})\n##\n"                 ...
                     "## @seealso{}\n## @end deftypefn\n\n"                ...
                     "## " strrep(tail, "\n", "\n## ") "\n\n"];
        else
          comment = ["## " strrep(head,"\n","\n## ") "\n\n"                ...
                     "## -*- texinfo -*-\n## @deftypefn {} " ...
                     "{@var{retval} =} " basename                          ...
                     " (@var{input1}, @var{input2})\n##\n"                 ...
                     "## @seealso{}\n## @end deftypefn\n\n"                ...
                     "## " strrep(tail, "\n", "\n## ") "\n\n"];
        endif
        comment = strrep (comment, " \n", "\n");
        text = [comment, body];
    endswitch

    ## Write the initial file (if there is anything to write)
    fid = fopen (fileandpath, "wt");
    if (fid < 0)
      error ("edit: could not create %s", fileandpath);
    endif
    fputs (fid, text);
    fclose (fid);

    do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);

  endif

endfunction

## Return the name associated with the current user ID.
##
## If LONG_FORM is 1, return the full name.  This will be the
## default author.  Otherwise return the login name.
## login@host will be the default email address.

function retval = default_user (long_form)

  ent = getpwuid (getuid);
  if (! isstruct (ent))
    retval = getenv ("USER");
    if (isempty (retval))
      retval = getenv ("USERNAME");
    endif
  elseif (long_form)
    retval = ent.gecos;
    pos = strfind (retval, ",");
    if (! isempty (pos))
      retval = retval(1:pos(1)-1);
    endif
  else
    retval = ent.name;
  endif

endfunction

function do_edit (editor, file, mode)

  if (isguirunning ())
    __event_manager_edit_file__ (file);
  else
    system (sprintf (undo_string_escapes (editor), ['"' file '"']), [], mode);
  endif

endfunction


%!test
%! s.home = edit ("get", "home");
%! s.author = edit ("get", "author");
%! s.email = edit ("get", "email");
%! s.license = edit ("get", "license");
%! s.editinplace = edit ("get", "editinplace");
%! s.mode = edit ("get", "mode");
%! edit home none
%! edit author none
%! edit email none
%! edit license none
%! edit ("editinplace", ! s.editinplace);
%! if (s.mode(1) == "a")
%!   edit mode sync
%! else
%!   edit mode async
%! endif
%! edit ("home", s.home);
%! edit ("author", s.author);
%! edit ("email", s.email);
%! edit ("license", s.license);
%! edit ("editinplace", s.editinplace);
%! edit ("mode", s.mode);
%! assert (edit ("get", "home"), s.home);
%! assert (edit ("get", "author"), s.author);
%! assert (edit ("get", "email"), s.email);
%! assert (edit ("get", "license"), s.license);
%! assert (edit ("get", "editinplace"), s.editinplace);
%! assert (edit ("get", "mode"), s.mode);
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
## Return a cell array of strings with the names of the fields in the specified
## input.
##
## When the input is a structure @var{struct}, the @var{names} are the elements
## of the structure.
##
## When the input is an Octave object @var{obj}, the @var{names} are the public
## properties of the object.
##
## When the input is a Java object @var{javaobj} or a string containing the
## name of a Java class @var{javaclassname}, the @var{names} are the public
## fields (data members) of the object or class.
## @seealso{numfields, isfield, orderfields, struct, properties}
## @end deftypefn

function names = fieldnames (obj)

  if (nargin < 1)
    print_usage ();
  endif

  if (isstruct (obj))
    names = __fieldnames__ (obj);
  elseif (isobject (obj))
    try
      names = properties (obj);      # classdef object
    catch
      names = __fieldnames__ (obj);  # @class object
    end_try_catch
  elseif (isjava (obj) || ischar (obj))
    ## FIXME: Function prototype that accepts java obj exists, but doesn't
    ##        work if obj is java.lang.String.  Convert obj to classname.
    ## FIXME: this is now working for objects whose class is in the dynamic
    ##        classpath but will continue to fail if such classnames are used
    ##        instead (see bug #42710).
    if (isa (obj, "java.lang.String"))
      obj = class (obj);
    endif
    names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
    names = ostrsplit (names_str, ';');
  else
    error ("fieldnames: Invalid input argument");
  endif

endfunction


## Test preservation of fieldname order
%!test
%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
%! assert (fieldnames (x), {"d"; "a"; "b"; "c"});

## Test empty structure
%!test
%! s = struct ();
%! assert (fieldnames (s), cell (0, 1));

## Test classdef object
%!test
%! m = containers.Map ();
%! f = fieldnames (m);
%! assert (f, {"Count"; "KeyType"; "ValueType"; "map"; "numeric_keys"});

## Test old-style @class object
%!test
%! obj = ftp ();
%! f = fieldnames (obj);
%! assert (f, {"host"; "username"; "password"; "curlhandle"});

## Test Java classname by passing classname
%!testif HAVE_JAVA; usejava ("jvm")
%! names = fieldnames ("java.lang.Double");
%! assert (any (strcmp (names, "MAX_VALUE")));

## Test Java classname by passing java object
%!testif HAVE_JAVA; usejava ("jvm")
%! names = fieldnames (javaObject ("java.lang.Double", 10));
%! assert (any (strcmp (names, "MAX_VALUE")));
%! assert (all (ismember ({"POSITIVE_INFINITY", "NEGATIVE_INFINITY", ...
%!                         "NaN", "MAX_VALUE", "MIN_NORMAL", "MIN_VALUE", ...
%!                         "MAX_EXPONENT", "MIN_EXPONENT", "SIZE", "TYPE"},
%!                        names)));

%!testif HAVE_JAVA; usejava ("jvm")
%! names = fieldnames (javaObject ("java.lang.String", "Hello"));
%! assert (any (strcmp (names, "CASE_INSENSITIVE_ORDER")));
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} fileattrib ()
## @deftypefnx {} {} fileattrib (@var{file})
## @deftypefnx {} {[@var{status}, @var{attrib}] =} fileattrib (@dots{})
## @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} fileattrib (@dots{})
## Report attribute information about @var{file}.
##
## If no file or directory is specified, report information about the present
## working directory.
##
## If successful, the output is a structure with the following fields:
##
## @table @code
## @item Name
## Full name of @var{file}.
##
## @item archive
## True if @var{file} is an archive (Windows).
##
## @item system
## True if @var{file} is a system file (Windows).
##
## @item hidden
## True if @var{file} is a hidden file (Windows).
##
## @item directory
## True if @var{file} is a directory.
##
## @item  UserRead
## @itemx GroupRead
## @itemx OtherRead
## True if the user (group; other users) has read permission for @var{file}.
##
## @item  UserWrite
## @itemx GroupWrite
## @itemx OtherWrite
## True if the user (group; other users) has write permission for @var{file}.
##
## @item  UserExecute
## @itemx GroupExecute
## @itemx OtherExecute
## True if the user (group; other users) has execute permission for @var{file}.
## @end table
##
## If an attribute does not apply (e.g., archive on a Unix system) then the
## field is set to NaN.
##
## If @var{file} contains globbing characters, information about all matching
## files is returned in a structure array.
##
## If outputs are requested, the first is @var{status} which takes the value 1
## when the operation was successful, and 0 otherwise.  The second output
## contains the structure described above (@var{attrib}) if the operation was
## successful; otherwise, the second output is a system-dependent error message
## (@var{msg}).  The third output is an empty string ("") when the operation
## was successful, or a unique message identifier (@var{msgid}) in the case of
## failure.
## @seealso{stat, glob}
## @end deftypefn

function [status, msg, msgid] = fileattrib (file = ".")

  if (! ischar (file))
    error ("fileattrib: FILE must be a string");
  endif

  sts = 1;
  msg = "";
  msgid = "";

  if (ispc ())
    files = __wglob__ (file);
  else
    files = glob (file);
  endif
  if (isempty (files))
    files = {file};
  endif
  nfiles = numel (files);

  for i = [nfiles, 1:nfiles-1]  # first time in loop extends the struct array
    [info, err, msg] = stat (files{i});
    if (! err)
      r(i).Name = canonicalize_file_name (files{i});

      if (isunix ())
        r(i).archive = NaN;
        r(i).system = NaN;
        r(i).hidden = NaN;
      else
        [~, attrib] = dos (sprintf ('attrib "%s"', r(i).Name));
        ## DOS never returns error status so have to check it indirectly
        if (! isempty (strfind (attrib, " -")))
          sts = 0;
          break;
        endif
        attrib = regexprep (attrib, '\S+:.*', "");
        r(i).archive = any (attrib == "A");
        r(i).system = any (attrib == "S");
        r(i).hidden = any (attrib == "H");
      endif

      r(i).directory = S_ISDIR (info.mode);

      modestr = info.modestr;
      r(i).UserRead = (modestr(2) == "r");
      r(i).UserWrite = (modestr(3) == "w");
      r(i).UserExecute = (modestr(4) == "x");
      if (isunix ())
        r(i).GroupRead = (modestr(5) == "r");
        r(i).GroupWrite = (modestr(6) == "w");
        r(i).GroupExecute = (modestr(7) == "x");
        r(i).OtherRead = (modestr(8) == "r");
        r(i).OtherWrite = (modestr(9) == "w");
        r(i).OtherExecute = (modestr(10) == "x");
      else
        r(i).GroupRead = NaN;
        r(i).GroupWrite = NaN;
        r(i).GroupExecute = NaN;
        r(i).OtherRead = NaN;
        r(i).OtherWrite = NaN;
        r(i).OtherExecute = NaN;
      endif
    else
      sts = 0;
      break;
    endif
  endfor

  if (nargout == 0)
    if (! sts)
      error ("fileattrib: operation failed");
    endif
    status = r;
  else
    status = sts;
    if (! sts)
      if (isempty (msg))
        msg = "operation failed";
      endif
      msgid = "fileattrib";
    else
      msg = r;
    endif
  endif

endfunction


%!test
%! def_tmpdir = canonicalize_file_name (P_tmpdir ());
%! while (length (def_tmpdir) > 2 && strfind (filesep ("all"), def_tmpdir(end)))
%!   def_tmpdir(end) = [];
%! endwhile
%! [status, attr] = fileattrib (P_tmpdir ());
%! assert (status);
%! assert (isstruct (attr));
%! assert (numfields (attr), 14);
%! assert (attr.Name, def_tmpdir);
%! assert (attr.directory);
%! if (ispc ())
%!   assert (! isnan (attr.archive));
%! else
%!   assert (isnan (attr.archive));
%! endif
%! assert (attr.UserRead);
%! if (ispc ())
%!   assert (isnan (attr.GroupRead));
%! else
%!   assert (! isnan (attr.GroupRead));
%! endif

%!error fileattrib (1, 2)
%!error <FILE must be a string> fileattrib (1)
########################################################################
##
## Copyright (C) 2003-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{dir}, @var{name}, @var{ext}] =} fileparts (@var{filename})
## Return the directory, name, and extension components of @var{filename}.
##
## The input @var{filename} is a string which is parsed.  There is no attempt
## to check whether the filename or directory specified actually exists.
## @seealso{fullfile, filesep}
## @end deftypefn

function [dir, name, ext] = fileparts (filename)

  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (filename) || rows (filename) > 1)
    error ("fileparts: FILENAME must be a single string");
  endif

  ds = strchr (filename, filesep ("all"), 1, "last");
  if (isempty (ds))
    ds = 0;
  endif
  es = rindex (filename, ".");
  ## These can be the same if they are both 0 (no dir or ext).
  if (es <= ds)
    es = length (filename)+1;
  endif

  if (ds == 0)
    dir = "";
  elseif (ds == 1)
    dir = filename(1);
  else
    dir = filename(1:ds-1);
  endif

  name = filename(ds+1:es-1);
  if (isempty (name))
    name = "";
  endif

  if (es > 0 && es <= length (filename))
    ext = filename(es:end);
  else
    ext = "";
  endif

endfunction


%!test
%! [d, n, e] = fileparts ("file");
%! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ""));

%!test
%! [d, n, e] = fileparts ("file.ext");
%! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts ("/file.ext");
%! assert (strcmp (d, "/") && strcmp (n, "file") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts ("dir/file.ext");
%! assert (strcmp (d, "dir") && strcmp (n, "file") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts ("./file.ext");
%! assert (strcmp (d, ".") && strcmp (n, "file") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts ("d1/d2/file.ext");
%! assert (strcmp (d, "d1/d2") && strcmp (n, "file") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts ("/d1/d2/file.ext");
%! assert (strcmp (d, "/d1/d2") && strcmp (n, "file") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts ("/.ext");
%! assert (strcmp (d, "/") && strcmp (n, "") && strcmp (e, ".ext"));

%!test
%! [d, n, e] = fileparts (".ext");
%! assert (strcmp (d, "") && strcmp (n, "") && strcmp (e, ".ext"));

## Test input validation
%!error <Invalid call> fileparts ()
%!error <FILENAME must be a single string> fileparts (1)
%!error <FILENAME must be a single string> fileparts (["a"; "b"])
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{filename} =} fullfile (@var{dir1}, @var{dir2}, @dots{}, @var{file})
## Build complete filename from separate parts.
##
## The function joins any number of path components intelligently.  The return
## value is the concatenation of each component with exactly one file separator
## between each part of the path and at most one leading and/or trailing file
## separator.
##
## The input arguments might be strings or cell strings.  Any input arguments
## that are cell strings must contain one single string or must be equal in
## size.  In that case, the function returns a cell string of filepaths of the
## same dimensions as the input cell strings, e.g.:
##
## @example
## @group
## fullfile ("/home/username", "data", @{"f1.csv", "f2.csv", "f3.csv"@})
##   @result{}
##       @{
##         [1,1] = /home/username/data/f1.csv
##         [1,2] = /home/username/data/f2.csv
##         [1,3] = /home/username/data/f3.csv
##       @}
## @end group
## @end example
##
## On Windows systems, while forward slash file separators do work, they are
## replaced by backslashes.  In addition, drive letters are stripped of leading
## file separators to obtain a valid file path.
##
## Note: @code{fullfile} does not perform any validation of the resulting full
## filename.
## @seealso{fileparts, filesep}
## @end deftypefn

function filename = fullfile (varargin)

  ## remove empty arguments
  varargin(cellfun (@isempty, varargin)) = [];

  if (isempty (varargin))
    ## return early for all empty or no input
    filename = "";
    return;
  endif

  ## check input type
  is_cellstr = cellfun (@iscellstr, varargin);
  if (! all (is_cellstr | cellfun (@ischar, varargin)))
    error ("fullfile: input must either be strings or cell strings");
  endif

  ## convert regular strings to cell strings
  varargin(! is_cellstr) = num2cell (varargin(! is_cellstr));

  ## check if input size matches
  if (numel (varargin) > 1 && common_size (varargin{:}) != 0)
    error ("fullfile: cell string input must be scalar or of the same size");
  endif

  fs = filesep ();

  if (ispc ())
    ## replace forward slashes with backslashes
    varargin = cellfun (@(x) strrep (x, "/", fs), varargin,
                        "UniformOutput", false);

    ## Strip fileseps preceeding drive letters
    varargin{1} = regexprep (varargin{1}, '\\*([a-zA-Z]:\\*)', "$1");

    unc = strncmp (varargin{1}, '\\', 2);
  endif

  ## insert file separator between elements
  varargin(2,:) = {fs};
  varargin{end} = "";

  filename = strcat (varargin{:});

  ## remove multiplicate file separators
  filename = regexprep (filename, [undo_string_escapes(fs), "*"], fs);

  if (ispc ())
    ## prepend removed file separator for UNC paths
    filename(unc) = strcat (fs, filename(unc));
  endif

  if (! any (is_cellstr))
    filename = filename{1};
  endif

endfunction


%!shared fs, fsx, xfs, fsxfs, xfsy, xfsyfs
%! fs = filesep ();
%! fsx = [fs, "x"];
%! xfs = ["x", fs];
%! fsxfs = [fs, "x", fs];
%! xfsy = ["x", fs, "y"];
%! xfsyfs = ["x", fs, "y", fs];

%!assert (fullfile (""), "")
%!assert (fullfile ("", ""), "")
%!assert (fullfile (fs), fs)
%!assert (fullfile ("", fs), fs)
%!assert (fullfile (fs, ""), fs)
%!assert (fullfile ("", fs), fs)
%!assert (fullfile ("x"), "x")
%!assert (fullfile ("", "x"), "x")
%!assert (fullfile ("x", ""), "x")
%!assert (fullfile ("", "x", ""), "x")
%!assert (fullfile ("x", "y"), xfsy)
%!assert (fullfile ("x", "", "y"), xfsy)
%!assert (fullfile ("x", "", "y", ""), xfsy)
%!assert (fullfile ("", "x", "", "y", ""), xfsy)
%!assert (fullfile (fs), fs)
%!assert (fullfile (fs, "x"), fsx)
%!assert (fullfile (fs, xfs), fsxfs)
%!assert (fullfile (fsx, fs), fsxfs)
%!assert (fullfile (fs, "x", fs), fsxfs)

%!assert (fullfile ("x/", "/", "/", "y", "/", "/"), xfsyfs)
%!assert (fullfile ("/", "x/", "/", "/", "y", "/", "/"), [fs, xfsyfs])
%!assert (fullfile ("/x/", "/", "/", "y", "/", "/"), [fs, xfsyfs])

## different on purpose so that "fullfile (c{:})" works for empty c
%!assert (fullfile (), "")

%!assert (fullfile ("x", "y", {"c", "d"}), {[xfsyfs, "c"], [xfsyfs, "d"]})
%!assert (fullfile ({"folder1", "folder2"}, "sub", {"f1.m", "f2.m"}), ...
%!        {["folder1", fs, "sub", fs, "f1.m"], ...
%!         ["folder2", fs, "sub", fs, "f2.m"]});

## Windows specific - drive letters and file sep type
%!testif ; ispc ()
%! assert (fullfile ('\/\/\//A:/\/\', "x/", "/", "/", "y", "/", "/"), ...
%!         ['A:\' xfsyfs]);

## *nix specific - double backslash
%!testif ; ! ispc ()
%! assert (fullfile (fs, fs), fs);

## Windows specific - UNC path
%!testif ; ispc ()
%! assert (fullfile ({'\/\//server1', 'C:', '\\server2\/'}, ...
%!                   "x/", "/", "/", "y", "/", "/"), ...
%!         {['\\server1\', xfsyfs], ['C:\', xfsyfs], ['\\server2\', xfsyfs]});

## Windows specific - drive letters and file sep type, cell array
%!testif ; ispc ()
%! tmp = fullfile ({'\\\/B:\//', 'A://c', '\\\C:/g/h/i/j\/'});
%! assert (tmp{1}, 'B:\');
%! assert (tmp{2}, 'A:\c');
%! assert (tmp{3}, 'C:\g\h\i\j\');

%!error <strings or cell strings> fullfile (1)
%!error <strings or cell strings> fullfile ({1})
%!error <same size> fullfile ({"a", "b"}, {"a", "b", "c"})
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{val} =} getfield (@var{s}, @var{field})
## @deftypefnx {} {@var{val} =} getfield (@var{s}, @var{sidx1}, @var{field1}, @var{fidx1}, @dots{})
## Get the value of the field named @var{field} from a structure or nested
## structure @var{s}.
##
## If @var{s} is a structure array then @var{sidx} selects an element of the
## structure array, @var{field} specifies the field name of the selected
## element, and @var{fidx} selects which element of the field (in the case of
## an array or cell array).  For a more complete description of the syntax,
## @pxref{XREFsetfield,,@code{setfield}}.
##
## @seealso{setfield, rmfield, orderfields, isfield, fieldnames, isstruct,
## struct}
## @end deftypefn

function val = getfield (s, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  subs = varargin;
  flds = cellfun ("isclass", subs, "char");
  idxs = cellfun ("isclass", subs, "cell");
  if (! all (flds | idxs))
    error ("getfield: invalid index");
  endif

  typs = merge (flds, {"."}, {"()"});
  val = subsref (s, struct ("type", typs, "subs", subs));

endfunction


%!test
%! x.a = "hello";
%! assert (getfield (x, "a"), "hello");
%!test
%! ss(1,2).fd(3).b(1,4) = 5;
%! assert (getfield (ss,{1,2},"fd",{3},"b", {1,4}), 5);

## Test input validation
%!error <Invalid call> getfield ()
%!error <Invalid call> getfield (1)
%!error <invalid index> getfield (1,2)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} grabcode (@var{url})
## @deftypefnx {} {} grabcode (@var{filename})
## @deftypefnx {} {@var{code_str} =} grabcode (@dots{})
##
## Grab the code from a report created by the @code{publish} function.
##
## The grabbed code inside the published report must be enclosed by the
## strings @samp{##### SOURCE BEGIN #####} and @samp{##### SOURCE END #####}.
## The @code{publish} function creates this format automatically.
##
## If no return value is requested the code is saved to a temporary file and
## opened in the default editor.  NOTE: The temporary file must be saved under
## a new or the code will be lost.
##
## If an output is requested the grabbed code will be returned as string
## @var{code_str}.
##
## Example:
##
## @example
## @group
## publish ("my_script.m");
## grabcode ("html/my_script.html");
## @end group
## @end example
##
## The example above publishes @file{my_script.m} to the default location
## @file{html/my_script.html}.  Next, the published Octave script is grabbed to
## edit its content in a new temporary file.
##
## @seealso{publish}
## @end deftypefn

function code_str = grabcode (url)

  if (nargin < 1)
    print_usage ();
  endif

  if (exist (url) == 2)
    ## URL is a local file
    oct_code = fileread (url);
  else
    ## Otherwise, try to read remote URL
    [oct_code, success, message] = urlread (url);
    if (! success)
      error (["grabcode: " message]);
    endif
  endif

  ## Extract relevant part
  oct_code = regexp (oct_code, ...
    '##### SOURCE BEGIN #####\n(.*)##### SOURCE END #####', "once", "tokens");
  oct_code = oct_code{1};

  if (nargout == 1)
    code_str = oct_code;
  else
    ## Open temporary file in editor
    fname = [tempname() ".m"];
    fid = fopen (fname, "w");
    if (fid < 0)
      error ("grabcode: could not open temporary file");
    endif
    fprintf (fid, "%s", oct_code);
    fclose (fid);
    edit (fname);
    warndlg (["grabcode: Make sure to save the temporary file\n\n\t", ...
              fname, "\n\nto a location of your choice. ", ...
              "Otherwise all grabbed code will be lost!"]);
  endif

endfunction


## Test input validation
%!error <Invalid call> grabcode ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} gunzip (@var{gzfile})
## @deftypefnx {} {} gunzip (@var{gzfile}, @var{dir})
## @deftypefnx {} {@var{filelist} =} gunzip (@dots{})
## Unpack the gzip archive @var{gzfile}.
##
## If @var{gzfile} is a directory, all gzfiles in the directory will be
## recursively unpacked.
##
## If @var{dir} is specified the files are unpacked in this directory rather
## than the one where @var{gzfile} is located.
##
## The optional output @var{filelist} is a list of the uncompressed files.
## @seealso{gzip, unpack, bunzip2, unzip, untar}
## @end deftypefn

function filelist = gunzip (gzfile, dir = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (dir) && ischar (gzfile))
    dir = fileparts (gzfile);
  endif

  if (nargout > 0)
    filelist = unpack (gzfile, dir, "gz");
  else
    unpack (gzfile, dir, "gz");
  endif

endfunction


## Tests for this m-file are located in gzip.m
## Remove from test statistics
%!assert (1)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} info ()
## Display contact information for the GNU Octave community.
## @end deftypefn

function info ()

  printf ("\n\
  Additional information about GNU Octave is available at\n\
  https://www.octave.org\n\
\n\
  Links to the mailing list and other resources for getting help with\n\
  Octave are available at\n\
  https://www.octave.org/support.html\n\
\n\
  The Octave Wiki has user-generated content on a variety of subjects\n\
  including installation and is available at\n\
  https://wiki.octave.org\n\
\n\
  Additional functionality can be enabled by using packages from\n\
  the Octave Forge project, which may be found at\n\
  https://octave.sourceforge.io\n\
\n\
  Report bugs to the bug tracker at\n\
  https://bugs.octave.org\n\
  But first, please read the guidelines to writing a helpful report at\n\
  https://www.octave.org/bugs.html\n");

endfunction


## Mark file as being tested.  No real test needed for a documentation .m file
%!assert (1)
########################################################################
##
## Copyright (C) 2011-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

classdef inputParser < handle

  ## -*- texinfo -*-
  ## @deftypefn {} {@var{p} =} inputParser ()
  ## Create object @var{p} of the inputParser class.
  ##
  ## This class is designed to allow easy parsing of function arguments.  The
  ## class supports four types of arguments:
  ##
  ## @enumerate
  ## @item mandatory (see @code{addRequired});
  ##
  ## @item optional (see @code{addOptional});
  ##
  ## @item named (see @code{addParameter});
  ##
  ## @item switch (see @code{addSwitch}).
  ## @end enumerate
  ##
  ## After defining the function API with these methods, the supplied arguments
  ## can be parsed with the @code{parse} method and the parsing results
  ## accessed with the @code{Results} accessor.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.Parameters
  ## Return list of parameter names already defined.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.Results
  ## Return structure with argument names as fieldnames and corresponding
  ## values.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.Unmatched
  ## Return structure similar to @code{Results}, but for unmatched parameters.
  ## See the @code{KeepUnmatched} property.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.UsingDefaults
  ## Return cell array with the names of arguments that are using default
  ## values.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.CaseSensitive = @var{boolean}
  ## Set whether matching of argument names should be case sensitive.  Defaults
  ## to false.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.FunctionName = @var{name}
  ## Set function name to be used in error messages; Defaults to empty string.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.KeepUnmatched = @var{boolean}
  ## Set whether an error should be given for non-defined arguments.  Defaults
  ## to false.  If set to true, the extra arguments can be accessed through
  ## @code{Unmatched} after the @code{parse} method.  Note that since
  ## @code{Switch} and @code{Parameter} arguments can be mixed, it is
  ## not possible to know the unmatched type.  If argument is found unmatched
  ## it is assumed to be of the @code{Parameter} type and it is expected to
  ## be followed by a value.
  ## @end deftypefn
  ##
  ## @deftypefn {} {} inputParser.StructExpand = @var{boolean}
  ## Set whether a structure can be passed to the function instead of
  ## parameter/value pairs.  Defaults to true.
  ##
  ## The following example shows how to use this class:
  ##
  ## @example
  ## function check (varargin)
  ## @c The next two comments need to be indented by one for alignment
  ##   p = inputParser ();                      # create object
  ##   p.FunctionName = "check";                # set function name
  ##   p.addRequired ("pack", @@ischar);         # mandatory argument
  ##   p.addOptional ("path", pwd(), @@ischar);  # optional argument
  ##
  ##   ## create a function handle to anonymous functions for validators
  ##   val_mat = @@(x) isvector (x) && all (x <= 1) && all (x >= 0);
  ##   p.addOptional ("mat", [0 0], val_mat);
  ##
  ##   ## create two arguments of type "Parameter"
  ##   val_type = @@(x) any (strcmp (x, @{"linear", "quadratic"@}));
  ##   p.addParameter ("type", "linear", val_type);
  ##   val_verb = @@(x) any (strcmp (x, @{"low", "medium", "high"@}));
  ##   p.addParameter ("tolerance", "low", val_verb);
  ##
  ##   ## create a switch type of argument
  ##   p.addSwitch ("verbose");
  ##
  ##   p.parse (varargin@{:@});  # Run created parser on inputs
  ##
  ##   ## the rest of the function can access inputs by using p.Results.
  ##   ## for example, get the tolerance input with p.Results.tolerance
  ## endfunction
  ## @end example
  ##
  ## @example
  ## @group
  ## check ("mech");           # valid, use defaults for other arguments
  ## check ();                 # error, one argument is mandatory
  ## check (1);                # error, since ! ischar
  ## check ("mech", "~/dev");  # valid, use defaults for other arguments
  ##
  ## check ("mech", "~/dev", [0 1 0 0], "type", "linear");  # valid
  ##
  ## ## following is also valid.  Note how the Switch argument type can
  ## ## be mixed into or before the Parameter argument type (but it
  ## ## must still appear after any Optional argument).
  ## check ("mech", "~/dev", [0 1 0 0], "verbose", "tolerance", "high");
  ##
  ## ## following returns an error since not all optional arguments,
  ## ## 'path' and 'mat', were given before the named argument 'type'.
  ## check ("mech", "~/dev", "type", "linear");
  ## @end group
  ## @end example
  ##
  ## @emph{Note 1}: A function can have any mixture of the four API types but
  ## they must appear in a specific order.  @code{Required} arguments must be
  ## first and can be followed by any @code{Optional} arguments.  Only
  ## the @code{Parameter} and @code{Switch} arguments may be mixed
  ## together and they must appear at the end.
  ##
  ## @emph{Note 2}: If both @code{Optional} and @code{Parameter} arguments
  ## are mixed in a function API then once a string Optional argument fails to
  ## validate it will be considered the end of the @code{Optional}
  ## arguments.  The remaining arguments will be compared against any
  ## @code{Parameter} or @code{Switch} arguments.
  ##
  ## @seealso{nargin, validateattributes, validatestring, varargin}
  ## @end deftypefn

  properties
    ## FIXME: set input checking for these properties
    CaseSensitive = false;
    FunctionName  = "";
    KeepUnmatched = false;
    PartialMatching = false; # FIXME: unimplemented (and default should be true)
    StructExpand    = true;
  endproperties

  properties (SetAccess = protected)
    Parameters    = cell ();
    Results       = struct ();
    Unmatched     = struct ();
    UsingDefaults = cell ();
  endproperties

  properties (Access = protected)
    ## Since Required and Optional are ordered, they get a cell array of
    ## structs with the fields "name", "def" (default), and "val" (validator).
    Required = cell ();
    Optional = cell ();
    ## Parameter and Switch are unordered so we have a struct whose fieldnames
    ## are the argname, and values are a struct with fields "def" and "val"
    Parameter = struct ();
    Switch    = struct ();

    ## List of Parameter and Switch names to ease searches
    ParameterNames = cell ();
    SwitchNames    = cell ();

    ## When checking for fieldnames in a Case Insensitive way, this variable
    ## holds the correct identifier for the last searched named using the
    ## is_argname method.
    last_name = "";
  endproperties

  properties (Access = protected, Constant = true)
    ## Default validator, always returns scalar true.
    def_val = @(~) true;
  endproperties

  methods

    function set.PartialMatching (this, val)
      if (val)
        error ("inputParser: PartialMatching is not yet implemented");
      endif
    endfunction

    function addRequired (this, name, val = inputParser.def_val)

      ## -*- texinfo -*-
      ## @deftypefn  {} {} addRequired (@var{argname})
      ## @deftypefnx {} {} addRequired (@var{argname}, @var{validator})
      ## Add new mandatory argument to the object @var{parser} of inputParser
      ## class.  This method belongs to the inputParser class and implements
      ## an ordered arguments type of API.
      ##
      ## @var{argname} must be a string with the name of the new argument.  The
      ## order in which new arguments are added with @code{addrequired},
      ## represents the expected order of arguments.
      ##
      ## @var{validator} is an optional function handle to validate the given
      ## values for the argument with name @var{argname}.  Alternatively, a
      ## function name can be used.
      ##
      ## See @code{help inputParser} for examples.
      ##
      ## @emph{Note}: this can be used together with the other type of
      ## arguments but it must be the first (see @code{@@inputParser}).
      ##
      ## @end deftypefn

      if (nargin < 2)
        print_usage ();
      elseif (numel (this.Optional) || numfields (this.Parameter)
              || numfields (this.Switch))
        error (["inputParser.addRequired: can't have a Required argument " ...
                "after Optional, Parameter, or Switch"]);
      endif
      this.validate_name ("Required", name);
      this.Required{end+1} = struct ("name", name, "val", val);
    endfunction

    function addOptional (this, name, def, val = inputParser.def_val)

      ## -*- texinfo -*-
      ## @deftypefn  {} {} addOptional (@var{argname}, @var{default})
      ## @deftypefnx {} {} addOptional (@var{argname}, @var{default}, @var{validator})
      ## Add new optional argument to the object @var{parser} of the class
      ## inputParser to implement an ordered arguments type of API
      ##
      ## @var{argname} must be a string with the name of the new argument.  The
      ## order in which new arguments are added with @code{addOptional},
      ## represents the expected order of arguments.
      ##
      ## @var{default} will be the value used when the argument is not
      ## specified.
      ##
      ## @var{validator} is an optional anonymous function to validate the
      ## given values for the argument with name @var{argname}.  Alternatively,
      ## a function name can be used.
      ##
      ## See @code{help inputParser} for examples.
      ##
      ## @emph{Note}: if a string argument does not validate, it will be
      ## considered a ParamValue key.  If an optional argument is not given a
      ## validator, anything will be valid, and so any string will be
      ## considered will be the value of the optional argument (in @sc{matlab},
      ## if no validator is given and argument is a string it will also be
      ## considered a ParamValue key).
      ##
      ## @end deftypefn

      if (nargin < 3)
        print_usage ();
      elseif (numfields (this.Parameter) || numfields (this.Switch))
        error (["inputParser.Optional: can't have Optional arguments " ...
                "after Parameter or Switch"]);
      endif
      this.validate_name ("Optional", name);
      if (iscell (def))
        def = {def};
      endif
      this.Optional{end+1} = struct ("name", name, "def", def, "val", val);
    endfunction

    function addParamValue (this, name, def, val = inputParser.def_val)

      ## -*- texinfo -*-
      ## @deftypefn  {} {} addParamValue (@var{argname}, @var{default})
      ## @deftypefnx {} {} addParamValue (@var{argname}, @var{default}, @var{validator})
      ## Add new parameter to the object @var{parser} of the class inputParser
      ## to implement a name/value pair type of API.
      ##
      ## This is an alias for @code{addParameter} method without the
      ## @qcode{"PartialMatchPriority"} option.  See it for the help text.
      ##
      ## @end deftypefn

      if (nargin < 3)
        print_usage ();
      endif
      this.addParameter (name, def, val);
    endfunction

    function addParameter (this, name, def, varargin)

      ## -*- texinfo -*-
      ## @deftypefn  {} {} addParameter (@var{argname}, @var{default})
      ## @deftypefnx {} {} addParameter (@var{argname}, @var{default}, @var{validator})
      ## Add new parameter to the object @var{parser} of the class inputParser
      ## to implement a name/value pair type of API.
      ##
      ## @var{argname} must be a string with the name of the new parameter.
      ##
      ## @var{default} will be the value used when the parameter is not
      ## specified.
      ##
      ## @var{validator} is an optional function handle to validate the given
      ## values for the parameter with name @var{argname}.  Alternatively, a
      ## function name can be used.
      ##
      ## See @code{help inputParser} for examples.
      ##
      ## @end deftypefn

      if (nargin < 3 || nargin > 6)
        print_usage ();
      endif

      n_opt = numel (varargin);

      if (n_opt == 0 || n_opt == 2)
        val = inputParser.def_val;
      else # n_opt is 1 or 3
        val = varargin{1};
      endif

      if (n_opt == 0 || n_opt == 1)
        match_priority = 1;
      else # n_opt is 2 or 3
        if (! strcmpi (varargin{end-1}, "PartialMatchPriority"))
          error ("inputParser.addParameter: unrecognized option");
        endif
        match_priority = varargin{end};
        validateattributes (match_priority, {"numeric"}, {"positive", "integer"},
                            "inputParser.addParameter",
                            "PartialMatchPriority");
      endif

      this.validate_name ("Parameter", name);
      this.Parameter.(name).def = def;
      this.Parameter.(name).val = val;
    endfunction

    function addSwitch (this, name)

      ## -*- texinfo -*-
      ## @deftypefn {} {} addSwitch (@var{argname})
      ## Add new switch type of argument to the object @var{parser} of
      ## inputParser class.
      ##
      ## This method belongs to the inputParser class and implements a switch
      ## arguments type of API.
      ##
      ## @var{argname} must be a string with the name of the new argument.
      ## Arguments of this type can be specified at the end, after
      ## @code{Required} and @code{Optional}, and mixed between the
      ## @code{Parameter}.  They default to false.  If one of the arguments
      ## supplied is a string like @var{argname}, then after parsing the value
      ## of @var{parse}.Results.@var{argname} will be true.
      ##
      ## See @code{help inputParser} for examples.
      ##
      ## @end deftypefn

      if (nargin != 2)
        print_usage ();
      endif
      this.validate_name ("Switch", name);
      this.Switch.(name).def = false;
    endfunction

    function parse (this, varargin)

      ## -*- texinfo -*-
      ## @deftypefn {} {} parse (@var{varargin})
      ## Parses and validates list of arguments according to object
      ## @var{parser} of the class inputParser.
      ##
      ## After parsing, the results can be accessed with the @code{Results}
      ## accessor.  See @code{help inputParser} for a more complete
      ## description.
      ##
      ## @end deftypefn

      this.Results = struct ();
      this.Unmatched = struct ();
      this.UsingDefaults = cell ();
      if (numel (varargin) < numel (this.Required))
        if (this.FunctionName)
          print_usage (this.FunctionName);
        else
          this.error ("inputParser.parse: not enough input arguments");
        endif
      endif
      pnargin = numel (varargin);

      this.ParameterNames = fieldnames (this.Parameter);
      this.SwitchNames    = fieldnames (this.Switch);

      ## Evaluate the Required arguments first
      nReq = numel (this.Required);
      for idx = 1:nReq
        req = this.Required{idx};
        this.validate_arg (req.name, req.val, varargin{idx});
      endfor

      vidx = nReq;  # current index in varargin

      ## Search for a list of Optional arguments
      idx  = 0;     # current index on the array of Optional
      nOpt = numel (this.Optional);
      while (vidx < pnargin && idx < nOpt)
        opt = this.Optional{++idx};
        in  = varargin{++vidx};
        if ((this.is_argname ("Parameter", in) && vidx < pnargin)
            || this.is_argname ("Switch", in))
          ## This looks like an optional parameter/value pair or a
          ## switch, not an positional option.  This does mean that
          ## positional options cannot be strings named like parameter
          ## keys.  See bug #50752.
          idx -= 1;
          vidx -= 1;
          break;
        endif
        try
          valid_option = opt.val (in);
        catch
          valid_option = false;
        end_try_catch
        if (! valid_option)
          ## If it does not match there's two options:
          ##    1) input is actually wrong and we should error;
          ##    2) it's a Parameter or Switch name and we should use
          ##       the default for the rest;
          ##    3) it's a struct with the Parameter pairs.
          if (ischar (in) || (this.StructExpand && isstruct (in)
                              && isscalar (in)))
            idx -= 1;
            vidx -= 1;
            break;
          else
            this.error (sprintf (["failed validation of %s\n", ...
                                  "Validation function: %s"],
                                 toupper (opt.name), disp (opt.val)));
          endif
        endif
        this.Results.(opt.name) = in;
      endwhile

      ## Fill in with defaults of missing Optional
      while (idx++ < nOpt)
        opt = this.Optional{idx};
        this.UsingDefaults{end+1} = opt.name;
        this.Results.(opt.name) = opt.def;
      endwhile

      ## Search unordered Options (Switch and Parameter)
      while (vidx++ < pnargin)
        name = varargin{vidx};

        if (this.StructExpand && isstruct (name) && isscalar (name))
          expanded_options = [fieldnames(name) struct2cell(name)]'(:);
          if (isempty (expanded_options))
            continue;  # empty, continue to next argument
          endif
          n_new_args = numel (expanded_options) -1;
          pnargin += n_new_args;
          varargin(vidx+n_new_args+1:pnargin) = varargin(vidx+1:end);
          varargin(vidx:vidx+n_new_args) = expanded_options;
          name = varargin{vidx};
        endif

        if (! ischar (name))
          this.error ("non-string for Parameter name or Switch");
        endif

        if (this.is_argname ("Parameter", name))
          if (vidx++ > pnargin)
            this.error (sprintf ("no matching value for option '%s'",
                                 toupper (name)));
          endif
          this.validate_arg (this.last_name,
                             this.Parameter.(this.last_name).val,
                             varargin{vidx});
        elseif (this.is_argname ("Switch", name))
          this.Results.(this.last_name) = true;
        else
          if (vidx++ < pnargin && this.KeepUnmatched)
            this.Unmatched.(name) = varargin{vidx};
          else
            this.error (sprintf ("argument '%s' is not a valid parameter",
                                 toupper (name)));
          endif
        endif
      endwhile
      ## Add them to the UsingDefaults list
      this.add_missing ("Parameter");
      this.add_missing ("Switch");

    endfunction

    function disp (this)

      if (nargin != 1)
        print_usage ();
      endif
      printf ("inputParser object with properties:\n\n");
      b2s = @(x) ifelse (any (x), "true", "false");
      printf (["   CaseSensitive   : %s\n   FunctionName    : %s\n" ...
               "   KeepUnmatched   : %s\n   PartialMatching : %s\n" ...
               "   StructExpand    : %s\n\n"],
               b2s (this.CaseSensitive), b2s (this.FunctionName),
               b2s (this.KeepUnmatched), b2s (this.PartialMatching),
               b2s (this.StructExpand));
      printf ("Defined parameters:\n\n   {%s}\n",
              strjoin (this.Parameters, ", "));

    endfunction

  endmethods

  methods (Access = private)

    function validate_name (this, type, name)

      if (! isvarname (name))
        error ("inputParser.add%s: NAME is an invalid identifier", method);
      elseif (any (strcmpi (this.Parameters, name)))
        ## Even if CaseSensitive is "on", we still shouldn't allow
        ## two args with the same name.
        error ("inputParser.add%s: argname '%s' has already been specified",
               type, name);
      endif
      this.Parameters{end+1} = name;

    endfunction

    function validate_arg (this, name, val, in)

      ## Checking "nargout (val)" doesn't work for builtin functions.
      ## So, we need to use this nested try-catch construct.
      err = sprintf ('Checked with "%s"', func2str (val));
      try
        ok = val (in);
      catch exception
        if (strcmp (exception.identifier, "Octave:invalid-fun-call"))
          ## check if function also fails when called without output argument
          try
            val (in);
            ok = true;
          catch exception
            ok = false;
            err = exception.message;
          end_try_catch
        else
          ok = false;
          err = exception.message;
        endif
      end_try_catch
      if (! ok)
        this.error (sprintf ("failed validation of %s. %s",
                             toupper (name), err));
      endif
      this.Results.(name) = in;

    endfunction

    function r = is_argname (this, type, name)

      r = ischar (name) && isrow (name);
      if (r)
        if (this.CaseSensitive)
          r = isfield (this.(type), name);
          if (r)
            this.last_name = name;
          endif
        else
          fnames = this.([type "Names"]);
          l = strcmpi (name, fnames);
          r = any (l(:));
          if (r)
            this.last_name = fnames{l};
          endif
        endif
      endif

    endfunction

    function add_missing (this, type)

      unmatched = setdiff (fieldnames (this.(type)), fieldnames (this.Results));
      for namec = unmatched(:)'
        name = namec{1};
        this.UsingDefaults{end+1} = name;
        this.Results.(name) = this.(type).(name).def;
      endfor

    endfunction

    function error (this, msg)

      where = "";
      if (this.FunctionName)
        where = [this.FunctionName ": "];
      endif
      error ("%s%s", where, msg);

    endfunction

  endmethods

endclassdef


%!function p = create_p ()
%!  p = inputParser ();
%!  p.CaseSensitive = true;
%!  p.addRequired ("req1", @(x) ischar (x));
%!  p.addOptional ("op1", "val", @(x) any (strcmp (x, {"val", "foo"})));
%!  p.addOptional ("op2", 78, @(x) x > 50);
%!  p.addSwitch ("verbose");
%!  p.addParameter ("line", "tree", @(x) any (strcmp (x, {"tree", "circle"})));
%!endfunction

## check normal use, only required are given
%!test
%! p = create_p ();
%! p.parse ("file");
%! r = p.Results;
%! assert (r.req1, "file");
%! assert (sort (p.UsingDefaults), sort ({"op1", "op2", "verbose", "line"}));
%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
%!         {"file", "val", 78,    false,     "tree"});

## check normal use, but give values different than defaults
%!test
%! p = create_p ();
%! p.parse ("file", "foo", 80, "line", "circle", "verbose");
%! r = p.Results;
%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
%!         {"file", "foo", 80,    true,      "circle"});

## check optional is skipped and considered Parameter if unvalidated string
%!test
%! p = create_p ();
%! p.parse ("file", "line", "circle");
%! r = p.Results;
%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
%!         {"file", "val", 78,    false,     "circle"});

## check case insensitivity
%!test
%! p = create_p ();
%!  p.CaseSensitive = false;
%! p.parse ("file", "foo", 80, "LiNE", "circle", "vERbOSe");
%! r = p.Results;
%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
%!         {"file", "foo", 80,    true,      "circle"});

## check KeepUnmatched
%!test
%! p = create_p ();
%! p.KeepUnmatched = true;
%! p.parse ("file", "foo", 80, "line", "circle", "verbose", "extra", 50);
%! assert (p.Unmatched.extra, 50);

## check error when missing required
%!error <not enough input arguments>
%! p = create_p ();
%! p.parse ();

## check error when given required does not validate
%!error <failed validation of >
%! p = create_p ();
%! p.parse (50);

## check error when given optional does not validate
%!error <is not a valid parameter>
%! p = create_p ();
%! p.parse ("file", "no-val");

## check error when given Parameter does not validate
%!error <failed validation of >
%! p = create_p ();
%! p.parse ("file", "foo", 51, "line", "round");

## check alternative method (obj, ...) API
%!function p2 = create_p2 ();
%!  p2 = inputParser ();
%!  addRequired (p2, "req1", @(x) ischar (x));
%!  addOptional (p2, "op1", "val", @(x) any (strcmp (x, {"val", "foo"})));
%!  addOptional (p2, "op2", 78, @(x) x > 50);
%!  addSwitch (p2, "verbose");
%!  addParameter (p2, "line", "tree", @(x) any (strcmp (x, {"tree", "circle"})));
%!endfunction

## check normal use, only required are given
%!test
%! p2 = create_p2 ();
%! parse (p2, "file");
%! r = p2.Results;
%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
%!         {"file", "val", 78,    false,     "tree"});
%! assert (sort (p2.UsingDefaults), sort ({"op1", "op2", "verbose", "line"}));

## check normal use, but give values different than defaults
%!test
%! p2 = create_p2 ();
%! parse (p2, "file", "foo", 80, "line", "circle", "verbose");
%! r = p2.Results;
%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
%!         {"file", "foo", 80,    true,      "circle"});

## We must not perform validation of default values
%!test <*45837>
%! p = inputParser ();
%! p.addParameter ("Dir", [], @ischar);
%! p.parse ();
%! assert (p.Results.Dir, []);

%!test
%! p = inputParser ();
%! p.addParameter ("positive", -1, @(x) x > 5);
%! p.parse ();
%! assert (p.Results.positive, -1);

## Throw an error on validation of optional argument to check that it
## is caught without preventing continuation into param/value pairs.
%!test
%! p = inputParser ();
%! p.addOptional ("err", "foo", @error);
%! p.addParameter ("not_err", "bar", @ischar);
%! p.parse ("not_err", "qux");
%! assert (p.Results.err, "foo");
%! assert (p.Results.not_err, "qux");

## With more Parameters to test StructExpand
%!function p3 = create_p3 ();
%!  p3 = inputParser ();
%!  addOptional (p3, "op1", "val", @(x) any (strcmp (x, {"val", "foo"})));
%!  addOptional (p3, "op2", 78, @(x) x > 50);
%!  addSwitch (p3, "verbose");
%!  addParameter (p3, "line", "tree", @(x) any (strcmp (x, {"tree", "circle"})));
%!  addParameter (p3, "color", "red", @(x) any (strcmp (x, {"red", "green"})));
%!  addParameter (p3, "style", "tt", @(x) any (strcmp (x, {"tt", "f", "i"})));
%!endfunction

## Test StructExpand
%!test
%! p3 = create_p3 ();
%! p3.parse (struct ("line", "circle", "color", "green"));
%! assert (p3.Results, struct ("op1", "val", "op2", 78, "verbose", false,
%!                             "line", "circle", "color", "green",
%!                             "style", "tt"))

%!test
%! p3 = create_p3 ();
%! p3.parse (struct ("line", "circle", "color", "green"), "line", "tree");
%! assert (p3.Results.line, "tree");
%! p3.parse ("line", "tree", struct ("line", "circle", "color", "green"));
%! assert (p3.Results.line, "circle");

%!test # unmatched parameters with StructExpand
%! p3 = create_p3 ();
%! p3.KeepUnmatched = true;
%! p3.parse (struct ("line", "circle", "color", "green", "bar", "baz"));
%! assert (p3.Unmatched.bar, "baz");

## The validation for the second optional argument throws an error with
## a struct so check that we can handle it.
%!test
%! p3 = create_p3 ();
%! p3.parse ("foo", struct ("color", "green"), "line", "tree");
%! assert (p3.Results.op1, "foo");
%! assert (p3.Results.line, "tree");
%! assert (p3.Results.color, "green");
%! assert (p3.Results.verbose, false);


## Some simple tests for addParamValue since all the other ones use add
## addParameter but they use the same codepath.
%!test
%! p = inputParser ();
%! addParameter (p, "line", "tree", @(x) any (strcmp (x, {"tree", "circle"})));
%! addParameter (p, "color", "red", @(x) any (strcmp (x, {"red", "green"})));
%! p.parse ("line", "circle");
%! assert ({p.Results.line, p.Results.color}, {"circle", "red"});

%!test
%! p = inputParser ();
%! p.addParameter ("foo", "bar", @ischar);
%! p.parse ();
%! assert (p.Results, struct ("foo", "bar"));
%! p.parse ("foo", "qux");
%! assert (p.Results, struct ("foo", "qux"));

## This behaviour means that a positional option can never be a string
## that is the name of a parameter key.  This is required for Matlab
## compatibility.
%!test <*50752>
%! p = inputParser ();
%! p.addOptional ("op1", "val");
%! p.addParameter ("line", "tree");
%! p.parse ("line", "circle");
%! assert (p.Results, struct ("op1", "val", "line", "circle"));
%!
%! p = inputParser ();
%! p.addOptional ("op1", "val1");
%! p.addOptional ("op2", "val2");
%! p.addParameter ("line", "tree");
%! p.parse ("line", "circle");
%! assert (p.Results.op1, "val1");
%! assert (p.Results.op2, "val2");
%! assert (p.Results.line, "circle");
%!
%! ## If there's enough arguments to fill the positional options and
%! ## param/key, it still skips positional options.
%! p = inputParser ();
%! p.addOptional ("op1", "val1");
%! p.addOptional ("op2", "val2");
%! p.addParameter ("line", "tree");
%! p.parse ("line", "circle", "line", "rectangle");
%! assert (p.Results, struct ("op1", "val1", "op2", "val2",
%!                            "line", "rectangle"))
%!
%! ## Even if the key/param fails validation, it does not backtrack to
%! ## check if the values are valid positional options.
%! p = inputParser ();
%! p.addOptional ("op1", "val1", @ischar);
%! p.addOptional ("op2", "val2", @isnumeric);
%! p.addParameter ("line", "circle", @ischar);
%! fail ('p.parse ("line", 89)', "failed validation of LINE")
%!
%! p = inputParser ();
%! p.addOptional ("op1", "val1");
%! p.addParamValue ("line", "circle", @ischar);
%! fail ('p.parse ("line", "line", 89)',
%!       "non-string for Parameter name or Switch")

%!test <*50752>
%! ## This fails in Matlab but works in Octave.  It is a bug there
%! ## that we do not replicate.
%! p = inputParser ();
%! p.addOptional ("op1", "val1");
%! p.addParameter ("line", "circle");
%! p.parse ("line");
%! assert (p.Results, struct ("op1", "line", "line", "circle"));

%!test <*50752>
%! p = inputParser ();
%! p.addOptional ("op1", "val1");
%! p.addSwitch ("line");
%! p.parse ("line");
%! assert (p.Results.op1, "val1");
%! assert (p.Results.line, true);

%!test
%! p = inputParser ();
%! p.addParameter ("a", []);
%! p.addParameter ("b", []);
%! p.parse ("a", 1);
%! p.parse ("b", 1);
%! assert (p.Results, struct ("a", [], "b", 1));
%! assert (p.UsingDefaults, {"a"});

%!test
%! p = inputParser ();
%! p.addParameter ("b", []);
%! p.KeepUnmatched = true;
%! p.parse ("a", 1);
%! p.parse ("b", 1);
%! assert (p.Results, struct ("b", 1));
%! assert (p.Unmatched, struct ());

## Test for patch #9241
%!error <failed validation of A.*ischar>
%! p = inputParser ();
%! p.addParameter ("a", [], @ischar);
%! p.parse ("a", 1);

%!test <*58112>
%! p = inputParser ();
%! p.addRequired ("first");
%! p.addOptional ("second", []);
%! p.parse (1, {"test", 1, 2, 3});
%! r = p.Results;
%! assert (r.first, 1);
%! assert (r.second, {"test", 1, 2, 3});

%!test <*62639>
%! p = inputParser ();
%! p.addOptional ("opt", {});
%! p.parse ();
%! r = p.Results;
%! assert (r.opt, {});
%! p.parse ("x");
%! r = p.Results;
%! assert (r.opt, "x");

%!test <*62639>
%! p = inputParser ();
%! p.addOptional ("opt", {1,2,3});
%! p.parse ();
%! r = p.Results;
%! assert (r.opt, {1,2,3});
%! p.parse ("x");
%! r = p.Results;
%! assert (r.opt, "x");
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################
##
## Original version by Paul Kienzle distributed as free software in the
## public domain.

## -*- texinfo -*-
## @deftypefn  {} {} inputname (@var{n})
## @deftypefnx {} {} inputname (@var{n}, @var{ids_only})
## Return the name of the @var{n}-th argument to the calling function.
##
## If the argument is not a simple variable name, return an empty string.
## Examples which will return @qcode{""} are numbers (@code{5.1}),
## expressions (@code{@var{y}/2}), and cell or structure indexing
## (@code{@var{c}@{1@}} or @code{@var{s}.@var{field}}).
##
## @code{inputname} is only useful within a function.  When used at the command
## line or within a script it always returns an empty string.
##
## By default, return an empty string if the @var{n}-th argument is not a valid
## variable name.  If the optional argument @var{ids_only} is false, return the
## text of the argument even if it is not a valid variable name.  This is an
## Octave extension that allows the programmer to view exactly how the function
## was invoked even when the inputs are complex expressions.
## @seealso{nargin, narginchk}
## @end deftypefn

## FIXME: Actually, it probably *isn't* worth fixing, but there are small
## differences between Octave and Matlab.
##
## 1) When called from the top-level or a script, Matlab throws an error
##
##   inputname (1)   % at command prompt
##   % Octave returns "", Matlab throws an error
##
## 2) cell or struct indexing causes all further names to be returned as ""
##
##   c = {'a', 'b'}
##   y = 1; z = 2;
##   func (c, y, z)
##   % inputname() would return 'c', 'y', 'z' for the inputs.
##   func (c{1}, y, z)
##   % inputname() would return '', '', '' for the inputs.
##
## 3) If inputname is not called from a function, Matlab walks up the stack
##    until it finds some valid code and then works from there.  This could
##    be relevant for mex files or anonymous functions.
##
##   f = @(x) inputname (x);
##   a = 1:4;
##   arrayfun (fn, a, 'uniformoutput', false)
##   % output is {'fn', 'a', '', ''}

function name = inputname (n, ids_only = true)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isscalar (n) || ! isindex (n))
    error ("inputname: N must be a scalar index");
  endif

  try
    name = evalin ("caller", sprintf ("__varval__ ('.argn.'){%d}", n));
  catch
    name = "";
    return;
  end_try_catch

  ## For compatibility with Matlab, return empty string if argument name is
  ## not a valid identifier.
  if (ids_only && ! isvarname (name))
    name = "";
  elseif (ids_only)
    ## More complicated checking is required to verify name (bug #59103).
    ## NAME may be text, like "Inf", which is an acceptable variable name
    ## that passes isvarname(), but that does not mean it is an actual
    ## variable name, rather than a function or IEEE number.
    try
      v = evalin ("caller",
                  sprintf ("evalin ('caller', '__varval__ (\"%s\")')", name));
    catch
      name = "";
    end_try_catch
  endif

endfunction


%!function name = __iname1__ (arg1, arg2, arg3)
%!  name = inputname (1);
%!endfunction

%!function name = __iname1_ID__ (arg1, arg2, arg3)
%!  name = inputname (1, false);
%!endfunction

%!function name = __iname2__ (arg1, arg2, arg3)
%!  name = inputname (2);
%!endfunction

%!function names = __iname3__ (arg1, arg2, arg3)
%!  names = cell (1, 3);
%!  for i = 1:3
%!    names{i} = inputname (i);
%!  endfor
%!endfunction

%!test
%! assert (__iname1__ ('xvar'), "");
%! xvar = 1;
%! assert (__iname1__ (xvar), "xvar");

%!test
%! xvar = 1;  yvar = 2;
%! assert (__iname2__ (xvar), "");
%! assert (__iname2__ (xvar, yvar), "yvar");

%!test
%! xvar = 1;  yvar = 2;
%! assert (__iname3__ (xvar), {"xvar", "", ""});
%! assert (__iname3__ (xvar, yvar), {"xvar", "yvar", ""});
%! assert (__iname3__ (xvar, 3, yvar), {"xvar", "", "yvar"});

## Test numbers, expressions, indexing operations
%!test
%! assert (__iname1__ (1.0), "");
%! x = 1;
%! assert (__iname1__ (x / 2), "");
%! assert (__iname1__ (Inf), "");

%!test
%! assert (__iname1_ID__ (1.0), "1.0");
%! x = 1;
%! assert (__iname1_ID__ (x / 2), "x / 2");
%! assert (__iname1_ID__ (Inf), "Inf");

%!error <Invalid call> inputname ()
%!error <N must be a scalar> inputname (ones (2,2))
%!error <N must be a scalar index> inputname (-1)
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isdeployed ()
## Return true if the current program has been compiled and is running
## separately from the Octave interpreter and false if it is running in
## the Octave interpreter.
##
## Currently, this function always returns false in Octave.
## @end deftypefn

function retval = isdeployed ()
  retval = false;
endfunction


%!assert (isdeployed (), false)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{tf} =} isfile (@var{f})
## Return true if @var{f} is a regular file and false otherwise.
##
## If @var{f} is a cell array of strings, @var{tf} is a logical array of the
## same size.
## @seealso{isfolder, exist, stat, is_absolute_filename,
## is_rooted_relative_filename}
## @end deftypefn

function retval = isfile (f)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (ischar (f) || iscellstr (f)))
    error ("isfile: F must be a string or cell array of strings");
  endif

  f = cellstr (f);
  retval = false (size (f));
  for i = 1:numel (f)
    [info, err] = stat (f{i});
    retval(i) = (! err && S_ISREG (info.mode));
  endfor

endfunction


%!shared mfile
%! mfile = which ("isfile");

%!assert (isfile (mfile))
%!assert (! isfile (tempdir ()))
%!assert (isfile ({mfile, pwd()}), [true, false])
%!assert (isfile ({mfile; pwd()}), [true; false])

%!test
%! unwind_protect
%!   tmp = tempname ();
%!   [d, n] = fileparts (tmp);
%!   assert (! isfile (tmp));
%!   save ("-text", tmp, "tmp");  # cheap way to create a file
%!   assert (isfile (tmp));
%!   addpath (d);
%!   assert (! isfile (n));
%! unwind_protect_cleanup
%!   try, unlink (tmp); end_try_catch
%!   try, rmpath (d); end_try_catch
%! end_unwind_protect

## Test input validation
%!error <Invalid call> isfile ()
%!error isfile ("a", "b")
%!error <F must be a string> isfile (1.0)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{tf} =} isfolder (@var{f})
## Return true if @var{f} is a directory and false otherwise.
##
## If @var{f} is a cell array of strings, @var{tf} is a logical array of the
## same size.
## @seealso{isfile, exist, stat, is_absolute_filename,
## is_rooted_relative_filename}
## @end deftypefn

function retval = isfolder (f)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (ischar (f) || iscellstr (f)))
    error ("isfolder: F must be a string or cell array of strings");
  endif

  f = cellstr (f);
  retval = false (size (f));
  for i = 1:numel (f)
    [info, err] = stat (f{i});
    retval(i) = (! err && S_ISDIR (info.mode));
  endfor

endfunction


%!assert (isfolder (pwd ()))
%!assert (! isfolder (tempname ()))
%!assert (! isfolder (which ("isfolder")))
%!assert (isfolder ( {pwd(), tempname()}), [true, false])
%!assert (isfolder ( {pwd(); tempname()}), [true; false])

%!test
%! unwind_protect
%!   tmp = tempname ();
%!   [d, n] = fileparts (tmp);
%!   assert (! isfolder (tmp));
%!   mkdir (tmp);
%!   assert (isfolder (tmp));
%!   assert (! isfolder (n));
%!   addpath (d);
%!   assert (! isfolder (n));
%! unwind_protect_cleanup
%!   sts = rmdir (tmp);
%!   rmpath (d);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> isfolder ()
%!error isfolder ("a", "b")
%!error <F must be a string> isfolder (1.0)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} ismac ()
## Return true if Octave is running on a Mac OS X system and false otherwise.
## @seealso{isunix, ispc}
## @end deftypefn

function retval = ismac ()

  retval = __octave_config_info__ ("mac");

endfunction


%!assert (islogical (ismac ()))
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} ismethod (@var{obj}, @var{method})
## @deftypefnx {} {} ismethod (@var{class_name}, @var{method})
## Return true if the string @var{method} is a valid method of the object
## @var{obj} or of the class @var{clsname}.
## @seealso{isprop, isobject, isjava, methods}
## @end deftypefn

function retval = ismethod (obj, method)

  if (nargin != 2)
    print_usage ();
  endif

  if (! (ischar (obj) || isobject (obj) || isjava (obj)))
    error ("ismethod: first argument must be object or class name");
  endif

  if (! ischar (method))
    error ("ismethod: METHOD must be a string");
  endif

  method_list = methods (obj);

  retval = ismember (method, method_list);

endfunction


%!testif HAVE_JAVA; usejava ("jvm")
%! assert (ismethod (javaObject ("java.lang.String", "Yo"), "hashCode"));

%!assert (ismethod (ftp (), "ascii"))
%!assert (ismethod (inputParser (), "addRequired"))
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} ispc ()
## Return true if Octave is running on a Windows system and false otherwise.
## @seealso{isunix, ismac}
## @end deftypefn

function retval = ispc ()

  retval = __octave_config_info__ ("windows");

endfunction


%!assert (islogical (ispc ()))
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isunix ()
## Return true if Octave is running on a Unix-like system and false otherwise.
## @seealso{ismac, ispc}
## @end deftypefn

function retval = isunix ()

  retval = __octave_config_info__ ("unix");

endfunction


%!assert (islogical (isunix ()))
########################################################################
##
## Copyright (C) 2021-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

classdef jupyter_notebook < handle

  ## -*- texinfo -*-
  ## @deftypefn  {} {@var{notebook} =} jupyter_notebook (@var{notebook_filename})
  ## @deftypefnx {} {@var{notebook} =} jupyter_notebook (@var{notebook_filename}, @var{options})
  ##
  ## Run and fill the Jupyter Notebook in file @var{notebook_filename} from
  ## within GNU Octave.
  ##
  ## Both text and graphical Octave outputs are supported.
  ##
  ## This class has a public property @code{notebook} which is a structure
  ## representing the JSON-decoded Jupyter Notebook.  This property is
  ## intentionally public to enable advanced notebook manipulations.
  ##
  ## Note: Jupyter Notebook versions (@code{nbformat}) lower than 4.0 are not
  ## supported.
  ##
  ## The optional second argument @var{options} is a struct with fields:
  ##
  ## @itemize @bullet
  ## @item
  ## @code{tmpdir} to set the temporary working directory.
  ## @end itemize
  ##
  ## @code{%plot} magic is supported with the following settings:
  ##
  ## @itemize @bullet
  ## @item
  ## "%plot -f <format>" or "%plot --format <format>": specifies the
  ## image storage format.  Supported formats are:
  ##
  ## @itemize @minus
  ## @item
  ## PNG (default)
  ##
  ## @item SVG
  ## (Note: If SVG images do not appear in the notebook, it is most likely
  ## related to Jupyter Notebook security mechanisms and explicitly "trusting"
  ## them will be necessary).
  ##
  ## @item
  ## JPG
  ## @end itemize
  ##
  ## @item
  ## "%plot -r <number>" or "%plot --resolution <number>": specifies the
  ## image resolution.
  ##
  ## @item
  ## "%plot -w <number>" or "%plot --width <number>": specifies the
  ## image width.
  ##
  ## @item
  ## "%plot -h <number>" or "%plot --height <number>": specifies the
  ## image height.
  ## @end itemize
  ##
  ## Examples:
  ##
  ## @example
  ## @group
  ## ## Run all cells and generate the filled notebook
  ##
  ## ## Instantiate an object from a notebook file
  ## notebook = jupyter_notebook ("myNotebook.ipynb");
  ## ## Run the code and embed the results in the @code{notebook} property
  ## notebook.run_all ();
  ## ## Generate a new notebook by overwriting the original notebook
  ## notebook.generate_notebook ("myNotebook.ipynb");
  ## @end group
  ##
  ## @group
  ## ## Run just the second cell and generate the filled notebook
  ##
  ## ## Instantiate an object from a notebook file
  ## notebook = jupyter_notebook ("myNotebook.ipynb");
  ## ## Run the code and embed the results in the @code{notebook} property
  ## notebook.run (2)
  ## ## Generate a new notebook in a new file
  ## notebook.generate_notebook ("myNewNotebook.ipynb");
  ## @end group
  ##
  ## @group
  ## ## Generate an Octave script from a notebook
  ##
  ## ## Instantiate an object from a notebook file
  ## notebook = jupyter_notebook ("myNotebook.ipynb");
  ## ## Generate the Octave script
  ## notebook.generate_octave_script ("jup_script.m");
  ## @end group
  ## @end example
  ##
  ## @seealso{jsondecode, jsonencode}
  ## @end deftypefn

  properties

    notebook = struct ();

  endproperties

  properties (Access = "private")

    context = struct ("ans", "");

    ## Note: This name needs to be stored in a property because it is
    ## set in the constructor but used in some other methods.  However,
    ## we want to defer calling tempname() until immediately before
    ## calling mkdir().  The temporary directory currently created and
    ## deleted in the constructor and the name is reset to the empty
    ## string when the directory is deleted.  Another possible
    ## implementation might be to generate the name and create the
    ## temporary directory here, then delete it in the class destructor.

    tmpdir = "";

  endproperties

  methods

    function obj = jupyter_notebook (notebook_filename, options)

      if (nargin < 1)
        print_usage ();
      endif

      if (! (ischar (notebook_filename) && isrow (notebook_filename)))
        error ("jupyter_notebook: NOTEBOOK_FILENAME must be a string");
      endif

      ## Validate options if present.
      if (nargin == 2 && ! isstruct (options))
        error ("jupyter_notebook: OPTIONS must be a struct");
      endif
      if (nargin == 2 && isfield (options, "tmpdir"))
        obj.tmpdir = options.tmpdir;
      endif

      obj.notebook = jsondecode (fileread (notebook_filename),
                                 "makeValidName", false);

      ## Validate the notebook's format according to nbformat: 4.0
      if (! all (isfield (obj.notebook,
                          {"metadata", "nbformat", "nbformat_minor", "cells"})))
        error ("jupyter_notebook: invalid format for Jupyter notebooks");
      endif

      ## Issue a warning if the format is lower than 4.0.
      if (obj.notebook.nbformat < 4)
        warning (["jupyter_notebook: nbformat versions lower than 4.0 are ", ...
                  "not supported"]);
      endif

      ## Handle the case of only one cell.
      ## Make "obj.notebook.cells" a cell of structs to match the format.
      if (numel (obj.notebook.cells) == 1)
        obj.notebook.cells = {obj.notebook.cells};
      endif

      ## Handle the case where the cells have the same keys.
      ## Make "obj.notebook.cells" a cell of structs, instead of struct array,
      ## to unify the indexing method.
      if (isstruct (obj.notebook.cells))
        obj.notebook.cells = num2cell (obj.notebook.cells);
      endif

      for i = 1:numel (obj.notebook.cells)
        nbcell = obj.notebook.cells{i};
        if (! isfield (nbcell, "source"))
          error ('jupyter_notebook: cells must contain a "source" field');
        endif

        if (! isfield (nbcell, "cell_type"))
          error ('jupyter_notebook: cells must contain a "cell_type" field');
        endif

        ## Handle null JSON values which are decoded into empty arrays.
        if (isfield (nbcell, "execution_count")
            && numel (nbcell.execution_count) == 0)
          obj.notebook.cells{i}.execution_count = 1;
        endif

        ## Handle the case of only one output in the cell.
        ## Make the outputs of the cell a cell of structs to match the format.
        if (isfield (nbcell, "outputs") && numel (nbcell.outputs) == 1)
          obj.notebook.cells{i}.outputs = {obj.notebook.cells{i}.outputs};
        endif
      endfor

    endfunction


    function generate_octave_script (obj, script_filename)

      ## -*- texinfo -*-
      ## @deftypefn {} {} generate_octave_script (@var{script_filename})
      ##
      ## Write an Octave script that has the contents of the Jupyter Notebook
      ## stored in the @code{notebook} attribute to @var{script_filename}.
      ##
      ## Non-code cells are generated as block comments.
      ##
      ## See @code{help jupyter_notebook} for examples.
      ##
      ## @seealso{jupyter_notebook}
      ## @end deftypefn

      if (nargin != 2)
        print_usage ();
      endif

      if (! (ischar (script_filename) && isrow (script_filename)))
        error ("jupyter_notebook: SCRIPT_FILENAME must be a string");
      endif

      fid = fopen (script_filename, "w");

      for i = 1:numel (obj.notebook.cells)
        nbcell = obj.notebook.cells{i};
        is_markdown = strcmp (nbcell.cell_type, "markdown");

        if (is_markdown)
          fputs (fid, "\n#{\n");
        endif

        for k = 1:numel (nbcell.source)
          fputs (fid, nbcell.source{k});
        endfor

        if (is_markdown)
          fputs (fid, "\n#}\n");
        endif
        fputs (fid, "\n");
      endfor
      fclose (fid);

    endfunction


    function generate_notebook (obj, notebook_filename)

      ## -*- texinfo -*-
      ## @deftypefn {} {} generate_notebook (@var{notebook_filename})
      ##
      ## Write the Jupyter Notebook stored in the @code{notebook}
      ## attribute to @var{notebook_filename}.
      ##
      ## The @code{notebook} attribute is encoded to JSON text.
      ##
      ## See @code{help jupyter_notebook} for examples.
      ##
      ## @seealso{jupyter_notebook}
      ## @end deftypefn

      if (nargin != 2)
        print_usage ();
      endif

      if (! (ischar (notebook_filename) && isrow (notebook_filename)))
        error ("jupyter_notebook: NOTEBOOK_FILENAME must be a string");
      endif

      fid = fopen (notebook_filename, "w");

      fputs (fid, jsonencode (obj.notebook,
                              "ConvertInfAndNaN", false,
                              "PrettyPrint", true));

      fclose (fid);

    endfunction


    function run (obj, cell_index)

      ## -*- texinfo -*-
      ## @deftypefn {} {} run (@var{cell_index})
      ##
      ## Run the Jupyter Notebook cell with index @var{cell_index}
      ## and eventually replace previous output cells in the object.
      ##
      ## The first Jupyter Notebook cell has the index 1.
      ##
      ## Note: The code evaluation of the Jupyter Notebook cells is done
      ## in a separate Jupyter Notebook context.  Thus, currently open
      ## figures and workspace variables won't be affected by executing
      ## this function.  However, current workspace variables cannot be
      ## accessed either.
      ##
      ## See @code{help jupyter_notebook} for examples.
      ##
      ## @seealso{jupyter_notebook}
      ## @end deftypefn

      if (nargin != 2)
        print_usage ();
      endif

      if (! (isscalar (cell_index) && isindex (cell_index)))
        error ("jupyter_notebook: CELL_INDEX must be a scalar positive integer");
      endif

      if (cell_index > numel (obj.notebook.cells))
        error ("jupyter_notebook: CELL_INDEX is out of bound");
      endif

      nbcell = obj.notebook.cells{cell_index};

      if (! strcmp (nbcell.cell_type, "code"))
        return;
      endif

      ## Remove previous outputs.
      obj.notebook.cells{cell_index}.outputs = {};

      if (isempty (nbcell.source))
        return;
      endif

      ## Default values for printOptions.
      printOptions.imageFormat = "png";
      printOptions.resolution = "0";

      ## The default width and height in Jupyter notebook
      printOptions.width = "640";
      printOptions.height = "480";

      ## Parse "plot magic" commands.
      ## https://github.com/Calysto/metakernel/blob/master/metakernel/magics/README.md#plot
      for j = 1 : numel (nbcell.source)
        if (strncmpi (nbcell.source{j}, "%plot", 5))
          magics = strsplit (strtrim (nbcell.source{j}));
          for i = 1 : numel (magics)
            if (any (strcmp (magics{i}, {"-f", "--format"}))
                && (i < numel (magics)))
              printOptions.imageFormat = magics{i+1};
            endif
            if (any (strcmp (magics{i}, {"-r", "--resolution"}))
                && (i < numel (magics)))
              printOptions.resolution = magics{i+1};
            endif
            if (any (strcmp (magics{i}, {"-w", "--width"}))
                && (i < numel (magics)))
              printOptions.width = magics{i+1};
            endif
            if (any (strcmp (magics{i}, {"-h", "--height"}))
                && (i < numel (magics)))
              printOptions.height = magics{i+1};
            endif
          endfor
        endif
      endfor

      ## Remember previously opened figures.
      fig_ids = findall (groot, "type", "figure");

      ## Create a new figure, if there are existing plots.
      if (! isempty (fig_ids))
        newFig = figure ();
      endif

      stream_output = struct ("name", "stdout", "output_type", "stream");

      output_lines = obj.evalCode (strjoin (nbcell.source));

      if (! isempty (output_lines))
        stream_output.text = {output_lines};
      endif

      if (isfield (stream_output, "text"))
        obj.notebook.cells{cell_index}.outputs{end+1} = stream_output;
      endif

      ## If there are existing plots and newFig is empty, delete it.
      if (exist ("newFig") && isempty (get (newFig, "children")))
        delete (newFig);
      endif

      ## Check for newly created figures.
      fig_ids_new = setdiff (findall (groot, "type", "figure"), fig_ids);

      if (! isempty (fig_ids_new))
        if (! isempty (obj.tmpdir) && exist (obj.tmpdir, "dir"))
          ## Delete open figures before raising the error.
          delete (fig_ids_new);
          error (["JupyterNotebook: temporary directory %s exists.  ", ...
                  "Please remove it manually."], obj.tmpdir);
        endif

        if (isempty (obj.tmpdir))
          obj.tmpdir = tempname ();
          clear_tmpdir_property = true;
        else
          clear_tmpdir_property = false;
        endif
        [status, msg] = mkdir (obj.tmpdir);
        if (status == 0)
          ## Delete open figures before raising the error.
          delete (fig_ids_new);
          error (["jupyter_notebook: cannot create a temporary directory. ", ...
                  msg]);
        endif

        ## FIXME: Maybe it would be better for these cleanup actions to
        ## happen in an onCleanup object or unwind_protect block so that
        ## they will be executed no matter how we exit this function?

        for i = 1:numel (fig_ids_new)
          figure (fig_ids_new(i), "visible", "off");
          obj.embedImage (cell_index, fig_ids_new(i), printOptions);
          delete (fig_ids_new(i));
        endfor

        [status, msg] = rmdir (obj.tmpdir);
        if (status == 0)
          error (["jupyter_notebook: cannot delete the temporary ", ...
                  "directory. ", msg]);
        endif
        if (clear_tmpdir_property)
          obj.tmpdir = "";
        endif
      endif

    endfunction


    function run_all (obj)

      ## -*- texinfo -*-
      ## @deftypefn {} {} run_all ()
      ##
      ## Run all Jupyter Notebook cells and eventually replace previous
      ## output cells in the object.
      ##
      ## Note: The code evaluation of the Jupyter Notebook cells is done
      ## in a separate Jupyter Notebook context.  Thus, currently open
      ## figures and workspace variables won't be affected by executing
      ## this function.  However, current workspace variables cannot be
      ## accessed either.
      ##
      ## See @code{help jupyter_notebook} for examples.
      ##
      ## @seealso{jupyter_notebook}
      ## @end deftypefn

      if (nargin != 1)
        print_usage ();
      endif

      for i = 1:numel (obj.notebook.cells)
        obj.run (i);
      endfor

    endfunction

  endmethods


  methods (Access = "private")

    function retval = evalCode (__obj__, __code__)

      ## Evaluate the code string "__code__" using "evalc".
      ## Before the code is evaluated, the previous notebook context is
      ## loaded from "__obj__" and the new context is saved to that struct.

      if (nargin != 2)
        print_usage ();
      endif

      if (isempty (__code__))
        retval = [];
        return;
      endif

      if (! (ischar (__code__) && isrow (__code__)))
        error ("jupyter_notebook: CODE must be a string");
      endif

      __obj__.loadContext ();

      ## Add a statement to detect the value of the variable "ans"
      __code__ = [__code__, "\nans"];

      retval = strtrim (evalc (__code__, ["printf (\"error: \"); ", ...
                                          "printf (lasterror.message)"]));

      ## Handle the "ans" variable in the context.
      start_index = rindex (retval, "ans =") + 6;
      if (start_index > 6)
        if (start_index <= length (retval))
          end_index = start_index;
          ## FIXME: loops are slow.
          idx = find (retval(start_index+1:end) == "\n", 1);
          if (idx)
            end_index = start_index + idx;
          else
            end_index = length (retval);
          endif
          __obj__.context.ans = retval(start_index:end_index);
        else
          end_index = length (retval);
          __obj__.context.ans = "";
        endif

        ## Delete the output of the additional statement if the execution
        ## is completed with no errors.
        if (end_index == length (retval))
          ## Remove the extra new line if there are other outputs with
          ## the "ans" statement output
          if (start_index == 7)
            start_index = 1;
          else
            start_index -= 7;
          endif
          retval(start_index:end_index) = "";
        endif
      endif

      __obj__.saveContext ();

    endfunction


    function saveContext (obj)

      ## Save the context in private "obj" attribute.

      ## Handle the "ans" variable in the context.
      obj.context = struct ("ans", obj.context.ans);

      forbidden_var_names = {"__code__", "__obj__", "ans"};

      ## Get variable names.
      var_names = {evalin("caller", "whos").name};

      ## Store all variables to context.
      for i = 1:numel (var_names)
        if (! any (strcmp (var_names{i}, forbidden_var_names)))
          obj.context.(var_names{i}) = evalin ("caller", var_names{i});
        endif
      endfor

    endfunction


    function loadContext (obj)

      ## Load the context from private "obj" attribute.
      for [val, key] = obj.context
        assignin ("caller", key, val);
      endfor

    endfunction


    function embedImage (obj, cell_index, figHandle, printOptions)

      ## Embed images in the notebook.
      ##
      ## To support a new format:
      ## 1. Create a new function that embeds the new format
      ##    (e.g. embed_svg_image).
      ## 2. Add a new case to the switch-statement below.

      if (isempty (get (figHandle, "children")))
        error_text = {"The figure is empty!"};
        obj.addErrorOutput (cell_index, "The figure is empty!");
        return;
      endif

      ## Check if the resolution is correct
      if (isempty (str2num (printOptions.resolution)))
        obj.addErrorOutput (cell_index,
                            "A number is required for resolution, not a string");
        return;
      endif

      ## Check if the width is correct
      if (isempty (str2num (printOptions.width)))
        obj.addErrorOutput (cell_index,
                            "A number is required for width, not a string");
        return;
      endif

      ## Check if the height is correct
      if (isempty (str2num (printOptions.height)))
        obj.addErrorOutput (cell_index,
                            "A number is required for height, not a string");
        return;
      endif

      switch (lower (printOptions.imageFormat))
        case "png"
          display_output = obj.embed_png_jpg_image (figHandle,
                                                    printOptions, "png");
        case "jpg"
          display_output = obj.embed_png_jpg_image (figHandle,
                                                    printOptions, "jpg");
        case "svg"
          display_output = obj.embed_svg_image (figHandle, printOptions);
        otherwise
          obj.addErrorOutput (cell_index, ["Cannot embed the \'", ...
                                           printOptions.imageFormat, ...
                                           "\' image format\n"]);
          return;
      endswitch

      obj.notebook.cells{cell_index}.outputs{end+1} = display_output;

    endfunction


    function dstruct = embed_png_jpg_image (obj, figHandle, printOptions, fmt)

      if (strcmp (fmt, "png"))
        mime = "image/png";
      else
        mime = "image/jpeg";
      endif

      image_path = fullfile (obj.tmpdir, ["temp." fmt]);
      print (figHandle, image_path, ["-d" fmt],
             ["-r" printOptions.resolution]);

      dstruct.output_type = "display_data";
      dstruct.metadata.(mime).width  = printOptions.width;
      dstruct.metadata.(mime).height = printOptions.height;
      dstruct.data.("text/plain") = {"<IPython.core.display.Image object>"};
      dstruct.data.(mime) = base64_encode (uint8 (fileread (image_path)));

      delete (image_path);

    endfunction


    function dstruct = embed_svg_image (obj, figHandle, printOptions)

      image_path = fullfile (obj.tmpdir, "temp.svg");
      print (figHandle, image_path, "-dsvg", ["-r" printOptions.resolution]);

      dstruct.output_type = "display_data";
      dstruct.metadata = struct ();
      dstruct.data.("text/plain") = {"<IPython.core.display.SVG object>"};
      dstruct.data.("image/svg+xml") = strsplit (fileread (image_path), "\n");

      ## FIXME: The following is a workaround until we can properly print
      ##        SVG images in the right width and height.
      ## Detect the <svg> tag; it is either the first or the second item.
      if (strncmpi (dstruct.data.("image/svg+xml"){1}, "<svg", 4))
        i = 1;
      else
        i = 2;
      endif

      ## Embed the width and height in the image itself
      svg_tag = dstruct.data.("image/svg+xml"){i};
      svg_tag = regexprep (svg_tag, 'width=".*?"',
                           ['width="' printOptions.width 'px"']);
      svg_tag = regexprep (svg_tag, 'height=".*?"',
                           ['height="' printOptions.height 'px"']);
      dstruct.data.("image/svg+xml"){i} = svg_tag;

      delete (image_path);

    endfunction


    function addErrorOutput (obj, cell_index, error_msg)

      stream_output.name        = "stderr";
      stream_output.output_type = "stream";
      stream_output.text        = {error_msg};
      obj.notebook.cells{cell_index}.outputs{end+1} = stream_output;

    endfunction

  endmethods

endclassdef


## Note: Functional BIST tests are located in the 'test/jupyter-notebook'
##       directory.

## Test input validation
%!error <Invalid call> jupyter_notebook ()
%!error <NOTEBOOK_FILENAME must be a string> jupyter_notebook (1)
%!error <NOTEBOOK_FILENAME must be a string> jupyter_notebook (['a';'b'])
%!error <OPTIONS must be a struct> jupyter_notebook ("fname", 1)
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} license
## @deftypefnx {} {} license inuse
## @deftypefnx {} {} license inuse @var{feature}
## @deftypefnx {} {} license ("inuse")
## @deftypefnx {} {@var{retval} =} license ("inuse")
## @deftypefnx {} {@var{retval} =} license ("test", @var{feature})
## @deftypefnx {} {@var{retval} =} license ("checkout", @var{feature})
## @deftypefnx {} {[@var{retval}, @var{errmsg}] =} license ("checkout", @var{feature})
## Get license information for Octave and Octave packages.
##
## GNU Octave is free software distributed under the GNU General Public
## License (GPL), and a license manager makes no sense.  This function is
## provided only for @sc{matlab} compatibility.
##
## When called with no extra input arguments, it returns the Octave license,
## otherwise the first input defines the operation mode and must be one of
## the following strings: @code{inuse}, @code{test}, and @code{checkout}.
## The optional @var{feature} argument can either be @qcode{"octave"} (core),
## or an Octave package.
##
## @table @asis
## @item @qcode{"inuse"}
## Returns a list of loaded features, i.e., octave and the list of loaded
## packages.  If an output is requested, it returns a struct array with
## the fields @qcode{"feature"}, and @qcode{"user"}.
##
## @item @qcode{"test"}
## Return true if the specified @var{feature} is installed, false otherwise.
##
## An optional third argument @qcode{"enable"} or @qcode{"disable"} is
## accepted but ignored.
##
## @item @qcode{"checkout"}
## Return true if the specified @var{feature} is installed, false otherwise.
## An optional second output will have an error message if a package is not
## installed.
##
## @end table
##
## @seealso{pkg, ver, version}
## @end deftypefn

function [retval, errmsg] = license (cmd, feature, toggle)

  if (nargin == 0)
    ## then only give information about Octave core
    retval = "GNU General Public License";
    return;
  endif

  [features, loaded] = get_all_features ();

  switch (tolower (cmd))
    case "inuse"
      features = features(loaded);

      if (nargin > 1)
        features = features(strcmp (features, feature));
      endif
      if (nargout == 0)
        printf ("%s\n", features{:});
      else
        retval = struct ("feature", features, "user", get_username ());
      endif

    case "test"
      if (nargin < 2)
        print_usage ();
      endif

      if (nargin > 2)
        ## We ignore the toggle argument because... what's the point?  We
        ## don't need a license management system on Octave.  This function
        ## will return true, even if anyone tries to disable a license.
        switch (tolower (toggle))
          case "enable"   # do nothing
          case "disable"  # do nothing
          otherwise       error ("license: TOGGLE must be enable or disable");
        endswitch
      endif

      retval = any (strcmp (features, feature));

    case "checkout"
      ## I guess we could have the checkout command load packages but it's not
      ## really the same thing.  The closest we have is simply to check if
      ## there is a package with the feature name, and give an error if not.

      if (nargin != 2)
        print_usage ();
      endif

      retval = any (strcmp (features, feature));
      errmsg = "";

      if (! retval)
        errmsg = ['No package named "' feature '" installed'];
      endif

    otherwise
      print_usage ();
  endswitch

endfunction

function username = get_username ()

  pw = getpwuid (getuid ());
  if (isstruct (pw))
    username = pw.name;
  else
    username = "octave_user";
  endif

endfunction

function [features, loaded] = get_all_features ()
  pkg_list = pkg ("list");
  features = {"octave", ...
              cellfun(@(x) x.name, pkg_list, "uniformoutput", false){:}};
  loaded = [true, cellfun(@(x) x.loaded, pkg_list)];
endfunction


%!assert (license (), "GNU General Public License")
%!assert ((license ("inuse", "octave")).feature, "octave")

%!shared list
%!test
%! list = pkg ("list");
%! for idx = 1: numel (list)
%!   name = list{idx}.name;
%!   if (list{idx}.loaded);
%!     assert ((license ("inuse", name)).feature, name);
%!   else
%!     rv = license ("inuse", name);
%!     assert (isstruct (rv));
%!     assert (all (isfield (rv, {"feature", "user"})));
%!   endif
%! endfor

%!assert (license ("test", "octave"), true)
%!assert (license ("test", "not_a_valid package name"), false)

%!test
%! for idx = 1: numel (list)
%!   assert (license ("test", list{idx}.name), true);
%! endfor

%!assert (license ("checkout", "octave"), true)

%!test
%! [s, e] = license ("checkout", "NOT_A_PACKAGE");
%! assert (e, 'No package named "NOT_A_PACKAGE" installed');

## Test input validation
%!error license ("not_inuse")
%!error license ("not_test", "octave", "enable")
%!error <TOGGLE must be enable or disable> license ("test", "octave", "invalid_toggle")
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} list_primes ()
## @deftypefnx {} {} list_primes (@var{n})
## List the first @var{n} primes.
##
## If @var{n} is unspecified, the first 25 primes are listed.
## @seealso{primes, isprime}
## @end deftypefn

function retval = list_primes (n = 25)

  if (! isreal (n) || ! isscalar (n))
    error ("list_primes: N must be a real scalar");
  endif

  n = floor (n);

  if (n < 1)
    retval = [];
    return;
  elseif (n == 1)
    retval = 2;
    return;
  endif

  list = primes (n * log (5 * n));
  if (numel (list) < n)
    ## Algorithm tested up to n=10,000 without failure.
    error ("list_primes: Algorithm failed.  Try primes (n*log (6*n))(1:n)");
  endif

  retval = list(1:n);

endfunction


%!assert (list_primes (), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, ...
%!                         43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
%!assert (list_primes (5), [2, 3, 5, 7, 11])

%!assert (list_primes (0), [])
%!assert (list_primes (1), [2])

## Test input validation
%!error <N must be a real scalar> list_primes (i)
%!error <N must be a real scalar> list_primes ([1 2])
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{b} =} loadobj (@var{a})
## Method of a class to manipulate an object after loading it from a file.
##
## The function @code{loadobj} is called when the object @var{a} is loaded
## using the @code{load} function.  An example of the use of @code{saveobj}
## might be to add fields to an object that don't make sense to be saved.
## For example:
##
## @example
## @group
## function b = loadobj (a)
##   b = a;
##   b.addmissingfield = addfield (b);
## endfunction
## @end group
## @end example
##
## @seealso{saveobj, class}
## @end deftypefn

function b = loadobj (a)
  error ('loadobj: not defined for class "%s"', class (a));
endfunction
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} ls
## @deftypefnx {} {} ls @var{filenames}
## @deftypefnx {} {} ls @var{options}
## @deftypefnx {} {} ls @var{options} @var{filenames}
## @deftypefnx {} {@var{list} =} ls (@dots{})
##
## List directory contents.
##
## The @code{ls} function forwards to the @code{ls} command if it is available.
## It falls back to calling the native operating system's directory listing
## command.  Available @var{options} may vary from system to system.
##
## Filenames are subject to shell expansion if they contain any wildcard
## characters @samp{*}, @samp{?}, @samp{[]}.  If these wildcard characters are
## escaped with a backslash @samp{\} (e.g., @samp{\*}) then they are not
## treated as wildcards, but instead as the corresponding literal character.
##
## If the optional output @var{list} is requested then @code{ls} returns a
## character array with one row for each file/directory name.
##
## Example usage on a UNIX-like system:
##
## @example
## @group
## ls -l
##      @print{} total 12
##      @print{} -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
##      @print{} -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m
## @end group
## @end example
##
## @seealso{dir, readdir, glob, what, stat, filesep, ls_command}
## @end deftypefn

function retval = ls (varargin)

  if (! iscellstr (varargin))
    error ("ls: all arguments must be character strings");
  endif

  ls_cmd = ls_command ();

  if (nargin > 0)
    args = tilde_expand (varargin);

    if (ispc () && ! isunix ())
      if (strncmp (ls_cmd, "ls", 2))
        ## Replace backslashes with forward slashes (unless they escape a
        ## wildcard character)
        args = regexprep (args, '\\(?![*?\[\]])', '/');
        ## Enclose paths, potentially having spaces, in double quotes:
        args = strcat ('"', args, '"');
        ## Exclude glob patterns and escaped characters from quoted part of
        ## FILENAMES string
        args = regexprep (args, '(?<!\\)([*?])', '"$1"');
        args = regexprep (args, '(?<!\\)\[', '"[');
        args = regexprep (args, '(?<!\\)\]', ']"');
        args = regexprep (args, '(\\.)', '"$1"');
      else
        idx = ! strncmp (args, '/', 1);
        ## Enclose paths, potentially having spaces, in double quotes:
        args(idx) = strcat ('"', args(idx), '"');
        ## shell (cmd.exe) on MinGW uses '^' as escape character
        args = regexprep (args, '([^\w.*?])', '^$1');
      endif
    else
      ## Escape any special characters in filename
      args = regexprep (args, '(?<!\\)([^][\w.*?-\\])', '\\$1');
      ## Undo escaped spaces following command args
      ## Only used for command form where single str contains many args.
      ## Example: list = ls ("-l /usr/bin")
      args = regexprep (args, '(-\w+)(?:\\ )+', '$1 ');
    endif

    args = sprintf ("%s ", args{:});
  else
    args = "";
  endif

  if (nargout > 0 && strncmp (ls_cmd, "ls", 2))
    args = ["-1 ", args];
  endif

  cmd = [ls_cmd, " ", args];

  if (page_screen_output () || nargout > 0)
    [status, output] = system (cmd);

    if (status != 0)
      error ("ls: command exited abnormally with status %d\n", status);
    elseif (nargout == 0)
      puts (output);
    else
      retval = strvcat (regexp (output, "[\r\n]+", "split"){:});
    endif
  else
    ## Just let the output flow if the pager is off.  That way the
    ## output from things like "ls -R /" will show up immediately and
    ## we won't have to buffer all the output.
    system (cmd);
  endif

endfunction


%!test
%! list = ls ();
%! assert (ischar (list));
%! assert (! isempty (list));

%!test
%! if (isunix ())
%!   list = ls ("/");
%!   list = (list')(:)';   # transform to a single row vector
%!   assert (! isempty (strfind (list, "sbin")));
%!   list2 = ls ("-l /");
%!   list2 = (list2')(:)';   # transform to a single row vector
%!   assert (! isempty (strfind (list2, "sbin")));
%!   assert (rows (list) == rows (list2));
%! endif

%!error <all arguments must be character strings> ls (1)
## Test below is valid, but produces confusing output on screen
%!#error <command exited abnormally> ls ("-!")
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{val} =} ls_command ()
## @deftypefnx {} {@var{old_val} =} ls_command (@var{new_val})
## Query or set the shell command used by Octave's @code{ls} command.
## @seealso{ls}
## @end deftypefn

function old_val = ls_command (new_val)

  persistent __ls_command__;

  if (isempty (__ls_command__))
    ## MinGW uses different ls_command
    if (ispc () && ! isunix ()
        && system ("where ls", true))
      __ls_command__ = "dir /D";
    else
      __ls_command__ = "ls -C";
    endif
  endif

  if (nargin == 0 || nargin == 1)

    old_val = __ls_command__;

    if (nargin == 1)
      if (! ischar (new_val))
        error ("ls_command: argument must be a character string");
      endif

      __ls_command__ = new_val;
    endif

  endif

endfunction


%!test
%! cmd = ls_command ();
%! assert (ischar (cmd));
%! if (ispc () && ! isunix () && system ("where ls", true))
%!   assert (cmd(1:3), "dir");
%! else
%!   assert (cmd(1:2), "ls");
%! endif

%!error <argument must be a character string> ls_command (123)
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} memory ()
## @deftypefnx {} {[@var{userdata}, @var{systemdata}] =} memory ()
## Display or return information about the memory usage of Octave.
##
## If the function is called without output arguments, a table with an overview
## of the current memory consumption is displayed.
##
## The output argument @var{userdata} is a structure with the following fields
## containing data for the Octave process:
##
## @table @code
## @item MaxPossibleArrayBytes
## Maximum size for an array to be allocated.  Be aware that this includes
## @emph{all} physical memory and swap space.  Allocating that amount of memory
## might result in system instability, data corruption, and/or file system
## corruption.  Note that depending on the platform (32-bit systems), the
## largest contiguous memory block might further limit the maximum possible
## allocatable array.  This check is not currently implemented.
##
## @item MemAvailableAllArrays
## The total size of available memory in bytes.
##
## @item ram_available_all_arrays
## The maximum size for an array that can be allocated in physical memory
## (excluding swap space).  Note that depending on the platform (32-bit
## systems), the largest contiguous memory block might further limit the
## maximum possible allocatable array.  This check is not currently
## implemented.
##
## @item  MemUsedMATLAB
## @itemx mem_used_octave
## The memory (including swap space) currently used by Octave in bytes.
##
## @item ram_used_octave
## The physical memory (excluding swap space) currently used by Octave in
## bytes.
##
## @end table
##
## The output argument @var{systemdata} is a nested structure with the
## following fields containing information about the system's memory:
##
## @table @code
## @item PhysicalMemory.Available
## The currently available physical memory in bytes.
##
## @item PhysicalMemory.Total
## The total physical memory in bytes.
##
## @item SystemMemory.Available
## The currently available memory (including swap space) in bytes.
##
## @item SystemMemory.Total
## The total memory (including swap space) in bytes.
##
## @item VirtualAddressSpace.Available
## The currently available virtual address space in bytes.
##
## @item VirtualAddressSpace.Total
## The total virtual address space in bytes.
##
## @end table
##
## Example #1 : print formatted table of memory usage
##
## @example
## @group
## memory ()
## @result{}
## System    RAM: 3934008 KiB,  swap: 4087804 KiB
## Octave    RAM:  170596 KiB,  virt: 1347944 KiB
## Free      RAM: 1954940 KiB,  swap: 4087804 KiB
## Available RAM: 2451948 KiB, total: 6042744 KiB
## @end group
## @end example
##
## Example #2 : return structs with memory usage information
##
## @example
## @group
## [userdata, systemdata] = memory ()
## @result{}
##  userdata =
##
##    scalar structure containing the fields:
##
##      MaxPossibleArrayBytes = 6.1622e+09
##      MemAvailableAllArrays = 6.1622e+09
##      ram_available_all_arrays = 2.4883e+09
##      MemUsedMATLAB = 1.3825e+09
##      mem_used_octave = 1.3825e+09
##      ram_used_octave = 1.7824e+08
##
##  systemdata =
##
##    scalar structure containing the fields:
##
##      PhysicalMemory =
##
##        scalar structure containing the fields:
##
##          Available = 2.4954e+09
##          Total = 4.0284e+09
##
##      SystemMemory =
##
##        scalar structure containing the fields:
##
##          Available = 6.6813e+09
##          Total = 8.2143e+09
##
##      VirtualAddressSpace =
##
##        scalar structure containing the fields:
##
##          Available = 2.8147e+14
##          Total = 2.8147e+14
## @end group
## @end example
##
## Programming Note: This function is implemented for Linux and Windows only.
##
## @seealso{computer, getpid, getrusage, nproc, uname}
## @end deftypefn

function [userdata, systemdata] = memory ()

  if ((! isunix () || ismac ()) && ! ispc ())
    if (nargout > 0)
      error ("memory: function not yet implemented for this architecture");
    else
      warning ("memory: function not yet implemented for this architecture");
    endif
    return;
  endif

  kiB = 1024;
  [architecture, bits] = computer ();

  if (isunix () && ! ismac ())
    ## Read values from pseudofiles
    [status, meminfo] = lmemory ();

    ## FIXME: Query the actual size of the user address space,
    ##        e.g., with getrlimit (RLIMIT_AS, rlp)
    if (log2 (bits) > 32)
      ## 64-bit platform
      address_space = 2^48;  # 256 TiB
    else
      ## 32-bit platform
      address_space = 3 * 2^30;  # 3 GiB
    endif

    total_ram = meminfo.MemTotal * kiB;
    total_swap = meminfo.SwapTotal * kiB;
    free_ram = meminfo.MemFree * kiB;
    if (isfield (meminfo, "MemAvailable"))
      available_ram = meminfo.MemAvailable * kiB;
    else
      ## On kernels from before 2014 MemAvailable is not present.
      ## This is a rough estimate that can be used instead.
      available_ram = (meminfo.MemFree + meminfo.Cached) * kiB;
    endif
    free_swap = meminfo.SwapFree * kiB;
    used_ram = status.VmRSS * kiB;
    used_virtual = status.VmSize * kiB;
    avail_virtual = address_space - used_virtual;

  elseif (ispc ())
    [proc, sys] = __wmemory__ ();

    total_ram = sys.TotalPhys;
    total_swap = sys.TotalPageFile;
    available_ram = sys.AvailPhys;
    free_swap = sys.AvailPageFile;
    used_ram = proc.WorkingSetSize;
    used_virtual = proc.WorkingSetSize + proc.PagefileUsage;
    avail_virtual = sys.AvailVirtual;
    address_space = sys.TotalVirtual;

  endif

  available = min (available_ram + free_swap, avail_virtual);
  ram_available = min (available_ram, avail_virtual);

  ## FIXME: On 32-bit systems, the largest possible array is limited by the
  ##        largest contiguous block in memory.
  user.MaxPossibleArrayBytes = available;
  user.MemAvailableAllArrays = available;
  user.ram_available_all_arrays = ram_available;
  user.MemUsedMATLAB = used_virtual;  # For compatibility
  user.mem_used_octave = used_virtual;
  user.ram_used_octave = used_ram;

  syst.PhysicalMemory.Available = available_ram;
  syst.PhysicalMemory.Total = total_ram;
  syst.SystemMemory.Available = available_ram + free_swap;
  syst.SystemMemory.Total = total_ram + total_swap;
  syst.VirtualAddressSpace.Available = avail_virtual;
  syst.VirtualAddressSpace.Total = address_space;

  if (nargout)
    userdata = user;
    systemdata = syst;
  else
    unitsize = kiB;
    unitname = 'kiB';
    disp (sprintf ("Octave is running on %s", architecture))
    disp (sprintf ("System    RAM: %9.0f %s,  swap: %9.0f %s",
                   round (syst.PhysicalMemory.Total / unitsize), unitname,
                   round (total_swap / unitsize), unitname ))
    disp (sprintf ("Octave    RAM: %9.0f %s,  virt: %9.0f %s",
                   round (user.ram_used_octave / unitsize), unitname,
                   round (user.mem_used_octave / unitsize), unitname))
    if (isunix ())
      ## The concept of free vs. available RAM doesn't seem to exist on Windows
      disp (sprintf ("Free      RAM: %9.0f %s,  swap: %9.0f %s",
                     round (free_ram / unitsize), unitname,
                     round (free_swap / unitsize), unitname))
    endif
    disp (sprintf ("Available RAM: %9.0f %s, total: %9.0f %s",
                   round (user.ram_available_all_arrays / unitsize), unitname,
                   round (user.MemAvailableAllArrays / unitsize), unitname))
  endif

endfunction

function [status, meminfo] = lmemory ()

  ## Read pseudo files to gather memory information on Linux

  ## Read the proc/self/status pseudofile.
  ## See https://linuxwiki.de/proc/pid#A.2Fproc.2Fpid.2Fstatus.
  ## It contains a variable number of lines with name-value pairs.

  f = fopen ("/proc/self/status");
  buffer = textscan (f, "%s %s", "delimiter", ':\n');
  fclose (f);
  for i = 1:rows (buffer{1})
    status.(buffer{1}{i}) = textscan (buffer{2}{i}){1};
  endfor

  ## Read the /proc/meminfo pseudofile
  ## see https://linuxwiki.de/proc/meminfo
  ## It contains a variable number of lines with name-value pairs.

  f = fopen ("/proc/meminfo");
  buffer = textscan (f, "%s %s", "delimiter", ':\n');
  fclose (f);
  for i = 1:rows (buffer{1})
    meminfo.(buffer{1}{i}) = textscan (buffer{2}{i}){1};
  endfor

endfunction


%!testif ; (isunix () && ! ismac ()) || ispc ()
%! [user, syst] = memory ();
%! assert (user.mem_used_octave > 0);
%! assert (user.ram_used_octave <= user.mem_used_octave);
%! assert (user.mem_used_octave < syst.SystemMemory.Total);
%! assert (user.MemAvailableAllArrays <= syst.SystemMemory.Available);

%!testif ; (! isunix () || ismac ()) && ! ispc ()
%! fail ("[user] = memory ()",
%!       "function not yet implemented for this architecture");
%! fail ("memory ()", "warning",
%!       "function not yet implemented for this architecture");
########################################################################
##
## Copyright (C) 1993-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{choice} =} menu (@var{title}, @var{opt1}, @dots{})
## @deftypefnx {} {@var{choice} =} menu (@var{title}, @{@var{opt1}, @dots{}@})
## Display a menu with heading @var{title} and options @var{opt1}, @dots{},
## and wait for user input.
##
## If the GUI is running, the menu is displayed graphically using
## @code{listdlg}.  Otherwise, the title and menu options are printed on the
## console.
##
## @var{title} is a string and the options may be input as individual strings
## or as a cell array of strings.
##
## The return value @var{choice} is the number of the option selected by the
## user counting from 1.  If the user aborts the dialog or makes an invalid
## selection then 0 is returned.
##
## This function is useful for interactive programs.  There is no limit to the
## number of options that may be passed in, but it may be confusing to present
## more than will fit easily on one screen.
## @seealso{input, listdlg}
## @end deftypefn

function choice = menu (title, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  if (! ischar (title))
    error ("menu: TITLE must be a string");
  elseif (nargin > 2 && ! iscellstr (varargin))
    error ("menu: All OPTIONS must be strings");
  elseif (! ischar (varargin{1}) && ! iscellstr (varargin{1}))
    error ("menu: OPTIONS must be string or cell array of strings");
  endif

  if (__event_manager_enabled__ ())  # GUI menu
    [choice, ok] = listdlg ("Name", "menu", "PromptString", title,
                            "ListString", varargin, "SelectionMode", "Single");
    if (! ok)
      choice = 0;
    endif
  else  # console menu
    ## Force pending output to appear before the menu.
    fflush (stdout);

    ## Don't send the menu through the pager as that can cause major confusion.
    page_screen_output (false, "local");

    if (! isempty (title))
      printf ("%s\n", title);
    endif

    ## Handle case where choices are given as a cell array
    if (iscellstr (varargin{1}))
      varargin = varargin{1};
    endif

    nopt = numel (varargin);
    for i = 1:nopt
      printf ("  [%2d] %s\n", i, varargin{i});
    endfor
    printf ("\n");

    s = input ("Select a number: ", "s");
    choice = sscanf (s, "%d");

    if (! isscalar (choice) || choice < 1 || choice > nopt)
      warning ("menu: input invalid or out of range\n");
      choice = 0;
    endif
  endif

endfunction


## Test input validation
%!error <Invalid call> menu ()
%!error <Invalid call> menu ("title")
%!error <TITLE must be a string> menu (1, "opt1")
%!error <All OPTIONS must be strings> menu ("title", "opt1", 1)
%!error <OPTIONS must be string or cell array of strings> menu ("title", 1)
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} methods (@var{obj})
## @deftypefnx {} {} methods ("@var{classname}")
## @deftypefnx {} {} methods (@dots{}, "-full")
## @deftypefnx {} {@var{mtds} =} methods (@dots{})
## List the names of the public methods for the object @var{obj} or the
## named class @var{classname}.
##
## @var{obj} may be an Octave class object or a Java object.
## @var{classname} may be the name of an Octave class or a Java class.
##
## If the optional argument @qcode{"-full"} is given then Octave returns
## full method signatures which include output type, name of method,
## and the number and type of inputs.
##
## When called with no output arguments, @code{methods} prints the list of
## method names to the screen.  Otherwise, the output argument @var{mtds}
## contains the list in a cell array of strings.
## @seealso{ismethod, properties, fieldnames}
## @end deftypefn

function mtds = methods (obj, fullopt)

  if (nargin < 1)
    print_usage ();
  endif

  havesigs = false;
  showsigs = false;
  if (nargin == 2)
    if (! strcmp (fullopt, "-full"))
      error ("methods: invalid option");
    endif
    showsigs = true;
  endif

  if (isobject (obj))
    ## Call internal C++ function for Octave objects
    mtds_list = __methods__ (obj);
  elseif (ischar (obj))
    ## Could be a classname for an Octave class or Java class.
    ## Try Octave class first.
    mtds_list = __methods__ (obj);
    if (isempty (mtds_list))
      mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", obj);
      mtds_list = ostrsplit (mtds_str, ';');
      mtds_list = mtds_list(:);  # return a column vector for compatibility
      havesigs = true;
    endif
  elseif (isjava (obj))
    ## If obj is a String or a subclass of String, then get the methods of its
    ## class name, not the methods of the class that may be named by the
    ## content of the string.
    if (isa (obj, "java.lang.String"))
      klass = class (obj);
      mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", klass);
    else
      mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", obj);
    endif
    mtds_list = strsplit (mtds_str, ';');
    mtds_list = mtds_list(:);  # return a column vector for compatibility
    havesigs = true;
  else
    error ("methods: invalid input argument");
  endif

  if (havesigs && ! showsigs)
    ## Extract only the method name for ordinary class methods, delete the
    ## return type and the argument list.
    mtds_list = regexprep (mtds_list, '^(?:[^(]+) (\w+) ?\(.*$', '$1');

    ## Extract only the class name for class constructors, delete the optional
    ## "org.example." package prefix and the argument list.
    mtds_list = regexprep (mtds_list, '^(?:[\.\w]+\.)?(\w+) ?\(.*$', '$1');

    mtds_list = unique (mtds_list);
  else
    ## Delete the "org.example." package prefix if present.
    mtds_list = regexprep (mtds_list, '^(?:[\.\w]+\.)(\w+ ?\(.*)$', '$1');
  endif

  if (nargout == 0)
    classname = ifelse (ischar (obj), obj, class (obj));
    printf ("Methods for class %s:\n", classname);
    disp (list_in_columns (mtds_list));
  else
    mtds = mtds_list;
  endif

endfunction


## test old-style @classname
%!test
%! mtds = methods ("ftp");
%! assert (mtds{1}, "ascii");

## test Java classname
%!testif HAVE_JAVA; usejava ("jvm")
%! mtds = methods ("java.lang.Double");
%! search = strfind (mtds, "valueOf");
%! assert (! isempty ([search{:}]));

## test Java classname with -full prototypes
%!testif HAVE_JAVA; usejava ("jvm")
%! mtds = methods ("java.lang.Double", "-full");
%! search = strfind (mtds, "java.lang.Double valueOf");
%! assert (! isempty ([search{:}]));

## test that methods does the right thing when passed a String object
%!testif HAVE_JAVA; usejava ("jvm") <*48758>
%! object = javaObject ("java.lang.String", "java.lang.Integer");
%! assert (methods (object), methods ("java.lang.String"));

## test classdef classname
%!assert (methods ("inputParser"),
%!        {"addOptional"; "addParamValue"; "addParameter";
%!         "addRequired"; "addSwitch"; "add_missing"; "delete";
%!         "disp"; "error"; "is_argname"; "parse"; "validate_arg";
%!         "validate_name"});

## Test input validation
%!error <Invalid call> methods ()
%!error methods ("a", "b", "c")
%!error <invalid option> methods ("ftp", "option1")
%!error <invalid input argument> methods (1)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} mex [-options] file @dots{}
## @deftypefnx {} {@code{status} =} mex (@dots{})
## Compile source code written in C, C++, or Fortran, to a MEX file.
##
## @var{status} is the return status of the @code{mkoctfile} function.
##
## If the compilation fails, and the output argument is not requested,
## an error is raised.  If the programmer requests @var{status}, however,
## Octave will merely issue a warning and it is the programmer's responsibility
## to verify the command was successful.
##
## This is equivalent to @code{mkoctfile --mex [-options] file}.
##
## @seealso{mkoctfile, mexext}
## @end deftypefn

function status = mex (varargin)

  [out, sts] = mkoctfile ("--mex", varargin{:});

  if (! isempty (out))
    printf ("%s", out);
  endif
  if (nargout > 0)
    status = sts;
  else
    if (sts != 0)
      error ("mex: building exited with failure status\n");
    endif
  endif

endfunction


## Remove from test statistics.  All real tests are in mkoctfile.
%!assert (1)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mexext ()
## Return the filename extension used for MEX files.
## @seealso{mex}
## @end deftypefn

function retval = mexext ()
  retval = "mex";
endfunction


%!assert (mexext (), "mex")
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} mkdir @var{dirname}
## @deftypefnx {} {} mkdir @var{parent} @var{dirname}
## @deftypefnx {} {} mkdir (@var{dirname})
## @deftypefnx {} {} mkdir (@var{parent}, @var{dirname})
## @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@dots{})
## Create a directory named @var{dirname} in the directory @var{parent},
## creating any intermediate directories if necessary.
##
## If @var{dirname} is a relative path, and no @var{parent} directory is
## specified, then the present working directory is used.
##
## If successful, @var{status} is logical 1, and @var{msg}, @var{msgid} are
## empty character strings ("").  Otherwise, @var{status} is logical 0,
## @var{msg} contains a system-dependent error message, and @var{msgid}
## contains a unique message identifier.  Note that the status code is exactly
## opposite that of the @code{system} command.
##
## When creating a directory permissions will be set to
## @w{@code{0777 - UMASK}}.
##
## @seealso{rmdir, pwd, cd, umask}
## @end deftypefn

## There is/was a bug in gnulib's mkdir-p module under Windows.
## This file is a workaround until that is fixed and the fix incorporated
## into Octave.

function [status, msg, msgid] = mkdir (parent, dirname)

  if (nargin < 1)
    print_usage ();
  endif

  parent = tilde_expand (parent);

  if (nargin == 1)
    dirname = parent;
  else
    dirname = fullfile (parent, dirname);
  endif

  dirname = make_absolute_filename (dirname);

  ## Move leading directory names from dirname to parent
  [parent, dirname, ext] = fileparts (dirname);

  [sts, msg, msgid] = mkdir_recur (parent, [dirname, ext]);

  if (nargout == 0)
    if (! sts)
      error ("mkdir: operation failed: %s", msg);
    elseif (strcmp (msg, "directory exists"))
      warning ("mkdir: directory exists\n");
    endif
  else
    status = sts;
  endif

endfunction

## Recursively make directories until parent/dirname can be created.
function [status, msg, msgid] = mkdir_recur (parent, dirname)

  status = true;

  if (isempty (parent))
    error ("mkdir: invalid PARENT");
  endif

  if (! isfolder (parent))
    [grandparent, name, ext] = fileparts (parent);
    [status, msg, msgid] = mkdir_recur (grandparent, [name, ext]);
  endif

  if (status)
    [status, msg, msgid] = __mkdir__ (parent, dirname);
  endif

endfunction


%!test
%! dir1 = tempname ();
%! dir2 = "%_unlikely_name_%";
%! dir = fullfile (dir1, dir2);
%! unwind_protect
%!   status = mkdir (dir);
%!   assert (status);
%!   assert (isfolder (dir));
%! unwind_protect_cleanup
%!   confirm_recursive_rmdir (false, "local");
%!   sts = rmdir (dir1, "s");
%! end_unwind_protect

%!test <*53031>
%! HOME = getenv ("HOME");
%! tmp_dir = tempname ();
%! unwind_protect
%!   mkdir (tmp_dir);
%!   setenv ("HOME", tmp_dir);
%!   status = mkdir ("~/subdir");
%!   assert (status);
%!   assert (isfolder (fullfile (tmp_dir, "subdir")));
%! unwind_protect_cleanup
%!   sts = rmdir (fullfile (tmp_dir, "subdir"));
%!   sts = rmdir (tmp_dir);
%!   if (isempty (HOME))
%!     unsetenv ("HOME");
%!   else
%!     setenv ("HOME", HOME);
%!   endif
%! end_unwind_protect

## Test input validation
%!error <Invalid call> mkdir ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} mkoctfile [-options] file @dots{}
## @deftypefnx {} {[@var{output}, @var{status}] =} mkoctfile (@dots{})
##
## The @code{mkoctfile} function compiles source code written in C, C++, or
## Fortran.  Depending on the options used with @code{mkoctfile}, the
## compiled code can be called within Octave or can be used as a stand-alone
## application.
##
## @code{mkoctfile} can be called from the shell prompt or from the Octave
## prompt.  Calling it from the Octave prompt simply delegates the call to
## the shell prompt.  Any output is stored in the @var{output} variable and
## the exit status in the @var{status} variable.  If called with no outputs
## and the compilation fails then Octave will emit an error.  If the programmer
## requests @var{output} or @var{status}, however, Octave will merely issue
## a warning and it is the programmer's responsibility to verify the command
## was successful.
##
## @code{mkoctfile} accepts the following options, all of which are optional
## except for the filename of the code you wish to compile:
##
## @table @samp
## @item -I DIR
## Add the include directory DIR to compile commands.
##
## @item -D DEF
## Add the definition DEF to the compiler call.
##
## @item -l LIB
## Add the library LIB to the link command.
##
## @item -L DIR
## Add the library directory DIR to the link command.
##
## @item  -M
## @itemx --depend
## Generate dependency files (.d) for C and C++ source files.
##
## @item -R DIR
## Add the run-time path to the link command.
##
## @item @nospell{-Wl,@dots{}}
## Pass options to the linker like @nospell{"-Wl,-rpath=@dots{}"}.
## The quotes are needed since commas are interpreted as command
## separators.
##
## @item -W@dots{}
## Pass options to the assembler like @nospell{"-Wa,OPTION"}.
##
## @item -c
## Compile but do not link.
##
## @item -g
## Enable debugging options for compilers.
##
## @item  -o FILE
## @itemx --output FILE
## Output filename.  Default extension is @file{.oct} (or @file{.mex} if
## @samp{--mex} is specified) unless linking a stand-alone executable.
##
## @item  -p VAR
## @itemx --print VAR
## Print configuration variable VAR@.  There are three categories of
## variables:
##
## Octave configuration variables that users may override with environment
## variables.  These are used in commands that @code{mkoctfile} executes.
##
## @example
##    ALL_CFLAGS                  INCLUDEDIR
##    ALL_CXXFLAGS                LAPACK_LIBS
##    ALL_FFLAGS                  LDFLAGS
##    ALL_LDFLAGS                 LD_STATIC_FLAG
##    BLAS_LIBS                   LFLAGS
##    CC                          LIBDIR
##    CFLAGS                      LIBOCTAVE
##    CPICFLAG                    LIBOCTINTERP
##    CPPFLAGS                    OCTAVE_LINK_OPTS
##    CXX                         OCTINCLUDEDIR
##    CXXFLAGS                    OCTAVE_LIBS
##    CXXLD                       OCTAVE_LINK_DEPS
##    CXXPICFLAG                  OCTLIBDIR
##    DL_LDFLAGS                  OCT_LINK_DEPS
##    F77                         OCT_LINK_OPTS
##    F77_INTEGER8_FLAG           RDYNAMIC_FLAG
##    FFLAGS                      SPECIAL_MATH_LIB
##    FPICFLAG                    XTRA_CFLAGS
##    INCFLAGS                    XTRA_CXXFLAGS
## @end example
##
## Octave configuration variables as above, but currently unused by
## @code{mkoctfile}.
##
## @example
## @group
##    AR
##    DEPEND_EXTRA_SED_PATTERN
##    DEPEND_FLAGS
##    FFTW3F_LDFLAGS
##    FFTW3F_LIBS
##    FFTW3_LDFLAGS
##    FFTW3_LIBS
##    FFTW_LIBS
##    FLIBS
##    LIBS
##    RANLIB
##    READLINE_LIBS
## @end group
## @end example
##
## Octave configuration variables that are provided for informational
## purposes only.  Except for @samp{OCTAVE_HOME} and @samp{OCTAVE_EXEC_HOME},
## users may not override these variables.
##
## If @w{@env{OCTAVE_HOME}} or @w{@env{OCTAVE_EXEC_HOME}} are set in the
## environment, then other variables are adjusted accordingly with
## @w{@env{OCTAVE_HOME}} or @w{@env{OCTAVE_EXEC_HOME}} substituted for the
## original value of the directory specified by the @option{--prefix} or
## @option{--exec-prefix} options that were used when Octave was configured.
##
## @example
## @group
##    API_VERSION                 LOCALFCNFILEDIR
##    ARCHLIBDIR                  LOCALOCTFILEDIR
##    BINDIR                      LOCALSTARTUPFILEDIR
##    CANONICAL_HOST_TYPE         LOCALVERARCHLIBDIR
##    DATADIR                     LOCALVERFCNFILEDIR
##    DATAROOTDIR                 LOCALVEROCTFILEDIR
##    DEFAULT_PAGER               MAN1DIR
##    EXEC_PREFIX                 MAN1EXT
##    EXEEXT                      MANDIR
##    FCNFILEDIR                  OCTAVE_EXEC_HOME
##    IMAGEDIR                    OCTAVE_HOME
##    INFODIR                     OCTAVE_VERSION
##    INFOFILE                    OCTDATADIR
##    LIBEXECDIR                  OCTDOCDIR
##    LOCALAPIARCHLIBDIR          OCTFILEDIR
##    LOCALAPIFCNFILEDIR          OCTFONTSDIR
##    LOCALAPIOCTFILEDIR          STARTUPFILEDIR
##    LOCALARCHLIBDIR
## @end group
## @end example
##
## @item --link-stand-alone
## Link a stand-alone executable file.
##
## @item --mex
## Assume creation of a MEX file.  Set the default output extension to
## @file{.mex}.
##
## @item  -s
## @itemx --strip
## Strip the output file.
##
## @item  -v
## @itemx --verbose
## Echo commands as they are executed.
##
## @item file
## The file to compile or link.  Recognized file types are:
##
## @example
## @group
##    .c    C source
##    .cc   C++ source
##    .cp   C++ source
##    .cpp  C++ source
##    .CPP  C++ source
##    .cxx  C++ source
##    .c++  C++ source
##    .C    C++ source
##    .f    Fortran source (fixed form)
##    .F    Fortran source (fixed form)
##    .f90  Fortran source (free form)
##    .F90  Fortran source (free form)
##    .o    object file
##    .a    library file
## @end group
## @end example
##
## @end table
## @end deftypefn

function [output, status] = mkoctfile (varargin)

  bindir = __octave_config_info__ ("bindir");
  ext = __octave_config_info__ ("EXEEXT");

  shell_script = fullfile (bindir,
                           sprintf ("mkoctfile-%s%s", OCTAVE_VERSION, ext));

  if (! exist (shell_script, "file"))
    __gripe_missing_component__ ("mkoctfile", "mkoctfile");
  endif

  cmd = ['"' shell_script '"'];
  for i = 1:nargin
    cmd = [cmd ' "' varargin{i} '"'];
  endfor

  [sts, out] = system (cmd);

  if (nargout > 0)
    [output, status] = deal (strtrim (out), sts);
    if (sts != 0)
      warning ("mkoctfile: building exited with failure status\n");
    endif
  else
    printf ("%s", out);
    if (sts != 0)
      error ("mkoctfile: building exited with failure status\n");
    endif
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} movefile @var{f1}
## @deftypefnx {} {} movefile @var{f1} @var{f2}
## @deftypefnx {} {} movefile @var{f1} @var{f2} f
## @deftypefnx {} {} movefile (@var{f1})
## @deftypefnx {} {} movefile (@var{f1}, @var{f2})
## @deftypefnx {} {} movefile (@var{f1}, @var{f2}, 'f')
## @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} movefile (@dots{})
## Move the source file or directory @var{f1} to the destination @var{f2}.
##
## The name @var{f1} may contain globbing patterns, or may be a cell array of
## strings.  If @var{f1} expands to multiple filenames, @var{f2} must be a
## directory.
##
## If no destination @var{f2} is specified then the destination is the present
## working directory.  If @var{f2} is a filename then @var{f1} is renamed to
## @var{f2}.
##
## When the force flag @qcode{'f'} is given any existing files will be
## overwritten without prompting.
##
## If successful, @var{status} is logical 1, and @var{msg}, @var{msgid} are
## empty character strings ("").  Otherwise, @var{status} is logical 0,
## @var{msg} contains a system-dependent error message, and @var{msgid}
## contains a unique message identifier.  Note that the status code is exactly
## opposite that of the @code{system} command.
## @seealso{rename, copyfile, unlink, delete, glob}
## @end deftypefn

function [status, msg, msgid] = movefile (f1, f2, force)

  if (nargin < 1)
    print_usage ();
  endif

  max_cmd_line = 1024;
  sts = true;
  msg = "";
  msgid = "";

  ## FIXME: maybe use the same method as in ls to allow users control
  ##        over the command that is executed.

  if (ispc () && ! isunix ()
      && isempty (file_in_path (getenv ("PATH"), "mv.exe")))
    ## Windows.
    cmd = "cmd /C move";
    cmd_force_flag = "/Y";
  else
    cmd = "mv";
    cmd_force_flag = "-f";
  endif

  ## Input type check.
  if (ischar (f1))
    f1 = cellstr (f1);
  elseif (! iscellstr (f1))
    error ("copyfile: F1 must be a string or a cell array of strings");
  endif

  if (nargin == 1)
    f2 = pwd ();
  elseif (! ischar (f2))
    error ("movefile: F2 must be a string");
  endif

  if (nargin == 3 && strcmp (force, "f"))
    cmd = [cmd " " cmd_force_flag];
  endif

  ## If f1 has more than 1 element f2 must be a directory
  isdir = isfolder (f2);
  if (numel (f1) > 1 && ! isdir)
    if (nargout == 0)
      error ("movefile: when copying multiple files, F2 must be a directory");
    else
      status = false;
      msg = "when copying multiple files, F2 must be a directory";
      msgid = "movefile";
      return;
    endif
  endif

  ## Protect the filename(s).
  if (ispc ())
    f1 = __wglob__ (f1);
  else
    f1 = glob (f1);
  endif
  if (isempty (f1))
    if (nargout == 0)
      error ("movefile: no files to move");
    else
      status = false;
      msg = "no files to move";
      msgid = "movefile";
      return;
    endif
  endif
  p1 = sprintf ('"%s" ', f1{:});
  p2 = tilde_expand (f2);

  if (isdir && length (p1) > max_cmd_line)
    l2 = length (p2) + length (cmd) + 6;
    while (! isempty (f1))
      p1 = sprintf ('"%s" ', f1{1});
      f1(1) = [];
      while (! isempty (f1)
             && (length (p1) + length (f1{1}) + l2 < max_cmd_line))
        p1 = sprintf ('%s"%s" ', p1, f1{1});
        f1(1) = [];
      endwhile

      if (ispc () && ! isunix ()
          && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
        p1 = strrep (p1, '\', '/');
        p2 = strrep (p2, '\', '/');
      endif

      ## Close old file(s) in editor
      __event_manager_file_remove__ (p1, p2);
      ## Move the file(s).
      [err, msg] = system (sprintf ('%s %s "%s"', cmd, p1, p2));
      if (err != 0)
        sts = false;
        msgid = "movefile";
      endif
      ## Load new file(s) in editor
      __event_manager_file_renamed__ (sts);
    endwhile
  else
    if (ispc () && ! isunix ()
        && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
      p1 = strrep (p1, '\', '/');
      p2 = strrep (p2, '\', '/');
    endif

    ## Close old file(s) in editor
    __event_manager_file_remove__ (p1, p2);
    ## Move the file(s).
    [err, msg] = system (sprintf ('%s %s "%s"', cmd, p1, p2));
    if (err != 0)
      sts = false;
      msgid = "movefile";
    endif
    ## Load new file(s) in editor
    __event_manager_file_renamed__ (sts);
  endif

  if (nargout == 0)
    if (! sts)
      error ("movefile: operation failed: %s", msg);
    endif
  else
    status = sts;
  endif

endfunction


%!test
%! unwind_protect
%!   f1 = tempname ();
%!   tmp_var = pi;
%!   save (f1, "tmp_var");
%!   fid = fopen (f1, "rb");
%!   assert (fid >= 0);
%!   orig_data = fread (fid);
%!   fclose (fid);
%!   f2 = tempname ();
%!   assert (movefile (f1, f2));
%!   assert (! exist (f1, "file"));
%!   assert (exist (f2, "file"));
%!   fid = fopen (f2, "rb");
%!   assert (fid >= 0);
%!   new_data = fread (fid);
%!   fclose (fid);
%!   if (orig_data != new_data)
%!     error ("moved file not equal to original file!");
%!   endif
%! unwind_protect_cleanup
%!   delete (f2);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> movefile ()
%!error <F1 must be a string> movefile (1, "foobar")
%!error <F2 must be a string> movefile ("foobar", 1)
%!error <F2 must be a directory> movefile ({"a", "b"}, "%_NOT_A_DIR_%")
%!error <no files to move> movefile ("%_NOT_A_FILENAME1_%", "%_NOT_A_FILENAME2_%")
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeFinite (@var{x})
##
## Require that input @var{x} is finite.
##
## Raise an error if any element of the input @var{x} is not finite, as
## determined by @code{isfinite (x)}.
##
## @seealso{mustBeNonNan, isfinite}
## @end deftypefn

function mustBeFinite (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = isfinite (x(:));
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    error ("%s must be finite; found %d non-finite elements: indexes %s",
           label, numel (bad_idx), mat2str (bad_idx));
  endif

endfunction


%!test
%! mustBeFinite ([]);
%! mustBeFinite (42);
%! mustBeFinite (-100:.1:100);
%! mustBeFinite (int32 (42));

%!error <Invalid call> mustBeFinite ()
%!error <found 1 non-finite> mustBeFinite (Inf)
%!error <indexes 4> mustBeFinite ([1 2 3 Inf])
%!error <indexes 1> mustBeFinite ([-Inf -1 0 1])
%!error <indexes 1> mustBeFinite ([NaN -1])
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeGreaterThan (@var{x}, @var{c})
##
## Require that input @var{x} is greater than @var{c}.
##
## Raise an error if any element of the input @var{x} is not greater than
## @var{c}, as determined by @code{@var{x} > @var{c}}.
##
## @seealso{mustBeGreaterThanOrEqual, mustBeLessThan, gt}
## @end deftypefn

function mustBeGreaterThan (x, c)

  if (nargin != 2)
    print_usage ();
  endif

  tf = (x > c)(:);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be greater than %f; found %d elements that were not: values %s", ...
                        label, c, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be greater than %f; found %d elements that were not: indexes %s", ...
                        label, c, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeGreaterThan (42, 0);
%! mustBeGreaterThan (Inf, 9999);

%!error <Invalid call> mustBeGreaterThan ()
%!error <Invalid call> mustBeGreaterThan (1)
%!error <called with too many inputs> mustBeGreaterThan (1, 2, 3)
%!error <input must be greater than 42> mustBeGreaterThan (42, 42)
%!error <found 1 elements that were not> mustBeGreaterThan (Inf, Inf)
%!error <must be greater than 0> mustBeGreaterThan (NaN, 0)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeGreaterThanOrEqual (@var{x}, @var{c})
##
## Require that input @var{x} is greater than or equal to @var{c}.
##
## Raise an error if any element of the input @var{x} is not greater than
## or equal to @var{c}, as determined by @code{@var{x} >= @var{c}}.
##
## @seealso{mustBeGreaterThan, mustBeLessThanOrEqual, ge}
## @end deftypefn

function mustBeGreaterThanOrEqual (x, c)

  if (nargin != 2)
    print_usage ();
  endif

  tf = (x >= c)(:);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be greater than or equal to %f; found %d elements that were not: values %s", ...
                        label, c, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be greater than or equal to %f; found %d elements that were not: indexes %s", ...
                        label, c, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeGreaterThanOrEqual (42, 0);
%! mustBeGreaterThanOrEqual (Inf, 9999);
%! mustBeGreaterThanOrEqual (42, 42);
%! mustBeGreaterThanOrEqual (Inf, Inf);

%!error <Invalid call> mustBeGreaterThanOrEqual ()
%!error <Invalid call> mustBeGreaterThanOrEqual (1)
%!error <called with too many inputs> mustBeGreaterThanOrEqual (1, 2, 3)
%!error <must be greater than or equal to 2> mustBeGreaterThanOrEqual (1, 2)
%!error <must be greater than or equal to 0> mustBeGreaterThanOrEqual (NaN, 0)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeInteger (@var{x})
##
## Require that input @var{x} is integer-valued (but not necessarily
## integer-typed).
##
## Raise an error if any element of the input @var{x} is not a finite,
## real, integer-valued numeric value, as determined by various checks.
##
## @seealso{mustBeNumeric}
## @end deftypefn

function mustBeInteger (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (isinteger (x) || islogical (x))
    return;
  endif

  but = [];
  if (! isnumeric (x))
    but = sprintf ("it was non-numeric (found a %s)", class (x));
  elseif (! isreal (x))
    but = "it was complex";
  elseif (any (! isfinite (x)))
    but = "there were non-finite values";
  elseif (any (x != fix (x)))
    but = "it had fractional values in some elements";
  endif

  if (! isempty (but))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    error ("%s must be integer-valued; but %s", label, but);
  endif

endfunction


%!test
%! mustBeInteger ([]);
%! mustBeInteger (42);
%! mustBeInteger (1:1000);
%! mustBeInteger (int32 (42));
%! mustBeInteger (true);

%!error <Invalid call> mustBeInteger ()
%!error <it was non-numeric> mustBeInteger ("Hello World")
%!error <it was complex> mustBeInteger ([1, 2i])
%!error <there were non-finite values> mustBeInteger (Inf)
%!error <there were non-finite values> mustBeInteger (NaN)
%!error <it had fractional values> mustBeInteger ([1 2 3 4.4])
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeLessThan (@var{x}, @var{c})
##
## Require that input @var{x} is less than @var{c}.
##
## Raise an error if any element of the input @var{x} is not less than
## @var{c}, as determined by @code{@var{x} < @var{c}}.
##
## @seealso{mustBeLessThanOrEqual, mustBeGreaterThan, lt}
## @end deftypefn

function mustBeLessThan (x, c)

  if (nargin != 2)
    print_usage ();
  endif

  tf = (x < c)(:);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be less than %f; found %d elements that were not: values %s", ...
                        label, c, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be less than %f; found %d elements that were not: indexes %s", ...
                        label, c, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeLessThan (0, 1);
%! mustBeLessThan (-Inf, 42);
%! mustBeLessThan (42, Inf);
%! mustBeLessThan (1:41, 42);

%!error <Invalid call> mustBeLessThan ()
%!error <Invalid call> mustBeLessThan (1)
%!error <called with too many inputs> mustBeLessThan (1, 2, 3)
%!error <must be less than 0> mustBeLessThan (1, 0)
%!error <must be less than 1> mustBeLessThan (1, 1)
%!error <must be less than Inf> mustBeLessThan (Inf, Inf)
%!error <must be less than 42> mustBeLessThan (1:42, 42)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeLessThanOrEqual (@var{x}, @var{c})
##
## Require that input is less than or equal to a given value.
##
## Raise an error if any element of the input @var{x} is not less than
## or equal to @var{c}, as determined by @code{@var{x} <= @var{c}}.
##
## @seealso{mustBeLessThan, mustBeGreaterThanOrEqual, le}
## @end deftypefn

function mustBeLessThanOrEqual (x, c)

  if (nargin != 2)
    print_usage ();
  endif

  tf = (x <= c)(:);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be less than or equal to %f; found %d elements that were not: values %s", ...
                        label, c, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be less than or equal to %f; found %d elements that were not: indexes %s", ...
                        label, c, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeLessThanOrEqual (0, 1);
%! mustBeLessThanOrEqual (-Inf, 42);
%! mustBeLessThanOrEqual (42, Inf);
%! mustBeLessThanOrEqual (1:41, 42);
%! mustBeLessThanOrEqual (1:42, 42);
%! mustBeLessThanOrEqual (1, 1);
%! mustBeLessThanOrEqual (Inf, Inf);

%!error <Invalid call> mustBeLessThanOrEqual ()
%!error <Invalid call> mustBeLessThanOrEqual (1)
%!error <called with too many inputs> mustBeLessThanOrEqual (1, 2, 3)
%!error <must be less than or equal to 0> mustBeLessThanOrEqual (1, 0)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeMember (@var{x}, @var{valid})
##
## Require that input @var{x} is a member of a set of given valid values.
##
## Raise an error if any element of the input @var{x} is not a member
## of the set @var{valid}, as determined by @code{ismember (@var{x})}.
##
## Programming Note: char inputs may behave strangely because of the
## interaction between chars and cellstrings when calling @code{ismember} on
## them.  But it will probably "do what you mean" if you just use it naturally.
## To guarantee operation, convert all char arrays to cellstrings with
## @code{cellstr}.
##
## @seealso{mustBeNonempty, ismember}
## @end deftypefn

function mustBeMember (x, valid)

  if (nargin != 2)
    print_usage ();
  endif

  tf = ! (ismember (x, valid))(:);
  if (any (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    n_bad = numel (find (tf));
    ## FIXME: Fancy inclusion of bad_val & valid values in the error message.
    ##        Probably use mat2str() in a try/catch for that.
    error ("%s must be one of the specified valid values; found %d elements that were not", ...
           label, n_bad);
  endif

endfunction


%!test
%! mustBeMember (42, 38:50);
%! mustBeMember ("foo", {"foo", "bar", "baz"});
%! mustBeMember (38:42, 37:43);
%! mustBeMember ({"foo","bar"}, {"foo", "bar", "baz"});

%!error <Invalid call> mustBeMember ()
%!error <Invalid call> mustBeMember (1)
%!error <called with too many inputs> mustBeMember (1, 2, 3)
%!error <found 1 elements> mustBeMember ([1, 42], 1:5)
%!error <found 1 elements> mustBeMember ("nope", {"foo", "bar", "baz"})
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNegative (@var{x})
##
## Require that input @var{x} is negative.
##
## Raise an error if any element of the input @var{x} is not negative, as
## determined by @code{@var{x} < 0}.
##
## @seealso{mustBeNonnegative}
## @end deftypefn

function mustBeNegative (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = (x < 0)(:);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be negative; found %d elements that were not: values %s", ...
                        label, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be negative; found %d elements that were not: indexes %s", ...
                        label, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeNegative ([]);
%! mustBeNegative (-42);
%! mustBeNegative (-10:-2);

%!error <Invalid call> mustBeNegative ()
%!error <found 1 elements> mustBeNegative ([-1, 42])
%!error <found 6 elements> mustBeNegative (-5:5)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNonNan (@var{x})
##
## Require that input @var{x} is non-@code{NaN}.
##
## Raise an error if any element of the input @var{x} is @code{NaN}, as
## determined by @code{isnan (@var{x})}.
##
## @seealso{mustBeFinite, mustBeNonempty, isnan}
## @end deftypefn

function mustBeNonNan (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = isnan (x(:));
  if (any (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (tf);
    errmsg = sprintf ("%s must be non-NaN; found %d elements that were not: indexes %s", ...
                      label, numel (bad_idx), mat2str (bad_idx));
    error (errmsg);
  endif

endfunction


%!test
%! mustBeNonNan (42);
%! mustBeNonNan ("foo");
%! mustBeNonNan (1:10);
%! mustBeNonNan (Inf);
%! mustBeNonNan (-Inf);

%!error <Invalid call> mustBeNonNan ()
%!error <must be non-NaN> mustBeNonNan (NaN)
%!error <input must be non-NaN> mustBeNonNan ([1 2 3 NaN])
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNonempty (@var{x})
##
## Require that input @var{x} is nonempty.
##
## Raise an error if the input @var{x} is empty, as determined by
## @code{isempty (@var{x})}.
##
## @seealso{mustBeMember, mustBeNonzero, isempty}
## @end deftypefn

function mustBeNonempty (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (x))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    error ("%s must not be empty", label);
  endif

endfunction


%!test
%! mustBeNonempty (42);
%! mustBeNonempty ("Hello");
%! mustBeNonempty (Inf);
%! mustBeNonempty (NaN);

%!error <Invalid call> mustBeNonempty ()
%!error <input must not be empty> mustBeNonempty ([])
%!error <input must not be empty> mustBeNonempty ('')
%!error <input must not be empty> mustBeNonempty (reshape ([], [0 3 3 3]))
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNonnegative (@var{x})
##
## Require that input @var{x} is not negative.
##
## Raise an error if any element of the input @var{x} is negative, as
## determined by @code{@var{x} >= 0}.
##
## @seealso{mustBeNonzero, mustBePositive}
## @end deftypefn

function mustBeNonnegative (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = (x(:) >= 0);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be non-negative; found %d elements that were not: values %s", ...
                        label, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be non-negative; found %d elements that were not: indexes %s", ...
                        label, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeNonnegative (0);
%! mustBeNonnegative (1);
%! mustBeNonnegative (123.456);
%! mustBeNonnegative (Inf);
%! mustBeNonnegative (0:10);
%! mustBeNonnegative (eps);

%!error <Invalid call> mustBeNonnegative ()
%!error <input must be non-negative> mustBeNonnegative (-1)
%!error <found 1 elements> mustBeNonnegative ([0 1 2 3 -4])
%!error <input must be non-negative> mustBeNonnegative (-Inf)
%!error <must be non-negative> mustBeNonnegative (NaN)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNonpositive (@var{x})
##
## Require that input @var{x} is not positive.
##
## Raise an error if any element of the input @var{x} is positive, as
## determined by @code{@var{x} <= 0}.
##
## @seealso{mustBeNegative, mustBeNonzero}
## @end deftypefn

function mustBeNonpositive (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = (x(:) <= 0);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be non-positive; found %d elements that were not: values %s", ...
                        label, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be non-positive; found %d elements that were not: indexes %s", ...
                        label, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBeNonpositive (0);
%! mustBeNonpositive (-1);
%! mustBeNonpositive (-5:-1);
%! mustBeNonpositive (-Inf);

%!error <Invalid call> mustBeNonpositive ()
%!error <must be non-positive> mustBeNonpositive (1)
%!error <found 2 elements> mustBeNonpositive (-10:2)
%!error <must be non-positive> mustBeNonpositive (NaN)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNonsparse (@var{x})
##
## Require that input @var{x} is not sparse.
##
## Raise an error if the input @var{x} is sparse, as determined by
## @code{issparse (@var{x})}.
##
## @seealso{issparse}
## @end deftypefn

function mustBeNonsparse (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (issparse (x))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    error ("%s must be nonsparse", label);
  endif

endfunction


%!test
%! mustBeNonsparse ([]);
%! mustBeNonsparse (42);
%! mustBeNonsparse (1:100);
%! mustBeNonsparse ("Hello World");

%!error <Invalid call> mustBeNonsparse ()
%!error <input must be nonsparse> mustBeNonsparse (sparse (42))
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNonzero (@var{x})
##
## Require that input @var{x} is not zero.
##
## Raise an error if any element of the input @var{x} is zero, as determined
## by @code{@var{x} == 0}.
##
## @seealso{mustBeNonnegative, mustBePositive}
## @end deftypefn

function mustBeNonzero (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = (x(:) == 0);
  if (any (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (tf);
    errmsg = sprintf ("%s must be non-zero; found %d elements that were zero: indexes %s", ...
                      label, numel (bad_idx), mat2str (bad_idx));
    error (errmsg);
  endif

endfunction


%!test
%! mustBeNonzero (1);
%! mustBeNonzero (-1);
%! mustBeNonzero ([-5:-1 1:5]);
%! mustBeNonzero (Inf);
%! mustBeNonzero (-Inf);
%! mustBeNonzero (NaN);
%! mustBeNonzero (eps);

%!error <Invalid call> mustBeNonzero ()
%!error <found 1 elements> mustBeNonzero (-10:10)
%!error <found 2 elements> mustBeNonzero ([-1, 0, 0, 1])
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNumeric (@var{x})
##
## Require that input @var{x} is numeric.
##
## Raise an error if the input @var{x} is not numeric, as determined by
## @code{isnumeric (@var{x})}.
##
## @seealso{mustBeNumericOrLogical, isnumeric}
## @end deftypefn

function mustBeNumeric (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    error ("%s must be numeric; found a %s", label, class (x));
  endif

endfunction


%!test
%! mustBeNumeric ([]);
%! mustBeNumeric (42);
%! mustBeNumeric (int32 (42));
%! mustBeNumeric (NaN);

%!error <Invalid call> mustBeNumeric ()
%!error <found a char> mustBeNumeric ("foo")
%!error <found a logical> mustBeNumeric (true)
%!error <found a struct> mustBeNumeric (struct ())
%!error <found a cell> mustBeNumeric (cell ())
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeNumericOrLogical (@var{x})
##
## Require that input @var{x} is numeric or logical.
##
## Raise an error if the input @var{x} is not numeric or logical, as
## determined by @code{isnumeric (@var{x}) || islogical (@var{x})}.
##
## @seealso{mustBeNumeric, isnumeric, islogical}
## @end deftypefn

function mustBeNumericOrLogical (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    error ("%s must be numeric or logical; found a %s", label, class (x));
  endif

endfunction


%!test
%! mustBeNumericOrLogical ([]);
%! mustBeNumericOrLogical (true);
%! mustBeNumericOrLogical (false);
%! mustBeNumericOrLogical (42);
%! mustBeNumericOrLogical (int32 (42));

%!error <Invalid call> mustBeNumericOrLogical ()
%!error <found a char> mustBeNumericOrLogical ("foo")
%!error <found a struct> mustBeNumericOrLogical (struct ())
%!error <found a cell> mustBeNumericOrLogical (cell ())
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBePositive (@var{x})
##
## Require that input @var{x} is positive.
##
## Raise an error if any element of the input @var{x} is not positive, as
## determined by @code{@var{x} > 0}.
##
## @seealso{mustBeNonnegative, mustBeNonzero}
## @end deftypefn

function mustBePositive (x)

  if (nargin < 1)
    print_usage ();
  endif

  tf = (x(:) > 0);
  if (! all (tf))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    bad_idx = find (! tf);
    try
      bad_val = x(bad_idx);
      errmsg = sprintf ("%s must be positive; found %d elements that were not: values %s", ...
                        label, numel (bad_idx), mat2str (bad_val));
    catch
      errmsg = sprintf ("%s must be positive; found %d elements that were not: indexes %s", ...
                        label, numel (bad_idx), mat2str (bad_idx));
    end_try_catch
    error (errmsg);
  endif

endfunction


%!test
%! mustBePositive (1);
%! mustBePositive (123.456);
%! mustBePositive (Inf);
%! mustBePositive (eps);

%!error <Invalid call> mustBePositive ()
%!error <found 1 elements> mustBePositive (0)
%!error <found 1 elements> mustBePositive (0:10)
%!error <found 2 elements> mustBePositive ([-1 -2])
%!error <found 2 elements> mustBePositive ([0 1 2 3 -4])
%!error <found 1 elements> mustBePositive (-Inf)
%!error <found 1 elements> mustBePositive (NaN)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} mustBeReal (@var{x})
##
## Require that input @var{x} is real.
##
## Raise an error if the input @var{x} is not real, as determined by
## @code{isreal (@var{x})}.
##
## @seealso{mustBeFinite, mustBeNonNan, isreal}
## @end deftypefn

function mustBeReal (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isreal (x))
    label = inputname (1);
    if (isempty (label))
      label = "input";
    endif
    error ("%s must be real", label);
  endif

endfunction


%!test
%! mustBeReal ([]);
%! mustBeReal (42);
%! mustBeReal (Inf);
%! mustBeReal (NaN);
%! mustBeReal (1:100);
%! mustBeReal (int32 (42));

%!error <Invalid call> mustBeReal ()
%!error <must be real> mustBeReal (i)
%!error <input must be real> mustBeReal (2 + i)
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{c} =} namedargs2cell (@var{s})
## Create a cell array of field name/value pairs from a scalar structure.
##
## Example:
##
## @example
## @group
## @c doctest: +SKIP
## s.Name = "Peter";
## s.Height = 185;
## s.Age = 42;
##
## c = namedargs2cell (s)
##   @result{} @{ "Name", "Peter", "Height", 185, "Age", 42 @}
## @end group
## @end example
##
## @seealso{struct2cell}
## @end deftypefn

function c = namedargs2cell (s)

  if (nargin < 1)
    print_usage ();
  elseif (! isstruct (s) || ! isscalar (s))
    error ("namedargs2cell: S must be a scalar structure");
  endif

  c = reshape ([fieldnames(s), struct2cell(s)].', 1, []);

endfunction


%!test
%! data = { "Name", "Peter", "Height", 185, "Age", 42};
%! s = struct (data{:});
%! c = namedargs2cell (s);
%! assert (isequal (c, data));

## Test input validation
%!error <Invalid call> namedargs2cell ()
%!error <called with too many inputs> namedargs2cell (1, 2)
%!error <S must be a scalar structure> namedargs2cell (true)
%!error <S must be a scalar structure> namedargs2cell (struct ("name", {1, 2}))
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} namelengthmax ()
## Return the @sc{matlab} compatible maximum variable name length.
##
## Octave is capable of storing strings up to @math{2^{31} - 1} in length.
## However for @sc{matlab} compatibility all variable, function, and structure
## field names should be shorter than the length returned by
## @code{namelengthmax}.  In particular, variables stored to a @sc{matlab} file
## format (@file{*.mat}) will have their names truncated to this length.
## @end deftypefn

function n = namelengthmax ()
  n = 63;
endfunction


%!assert (namelengthmax (), 63)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{msgstr} =} nargchk (@var{minargs}, @var{maxargs}, @var{nargs})
## @deftypefnx {} {@var{msgstr} =} nargchk (@var{minargs}, @var{maxargs}, @var{nargs}, "string")
## @deftypefnx {} {@var{msgstruct} =} nargchk (@var{minargs}, @var{maxargs}, @var{nargs}, "struct")
## Return an appropriate error message string (or structure) if the number of
## inputs requested is invalid.
##
## This is useful for checking to see that the number of input arguments
## supplied to a function is within an acceptable range.
##
## @strong{Caution}: @code{nargchk} is scheduled for deprecation.  Use
## @code{narginchk} in all new code.
## @seealso{narginchk, nargoutchk, error, nargin, nargout}
## @end deftypefn

function msg = nargchk (minargs, maxargs, nargs, outtype = "string")

  if (nargin < 3)
    print_usage ();
  elseif (minargs > maxargs)
    error ("nargchk: MINARGS must be <= MAXARGS");
  elseif (! any (strcmpi (outtype, {"string", "struct"})))
    error ('nargchk: output type must be either "string" or "struct"');
  elseif (! (isscalar (minargs) && isscalar (maxargs) && isscalar (nargs)))
    error ("nargchk: MINARGS, MAXARGS, and NARGS must be scalars");
  endif

  msg = struct ("message", "", "identifier", "");
  if (nargs < minargs)
    msg.message = "not enough input arguments";
    msg.identifier = "Octave:nargchk:not-enough-inputs";
  elseif (nargs > maxargs)
    msg.message = "too many input arguments";
    msg.identifier = "Octave:nargchk:too-many-inputs";
  endif

  if (strcmpi (outtype, "string"))
    msg = msg.message;
  elseif (isempty (msg.message))
    ## Compatibility: Matlab returns a 0x1 empty struct when nargchk passes
    msg = resize (msg, 0, 1);
  endif

endfunction


## Tests
%!shared stnul, stmin, stmax
%! stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
%! stmin = struct ("message", "not enough input arguments",
%!                 "identifier", "Octave:nargchk:not-enough-inputs");
%! stmax = struct ("message", "too many input arguments",
%!                 "identifier", "Octave:nargchk:too-many-inputs");
%!assert (nargchk (0, 1, 0), "")
%!assert (nargchk (0, 1, 1), "")
%!assert (nargchk (1, 1, 0), "not enough input arguments")
%!assert (nargchk (0, 1, 2), "too many input arguments")
%!assert (nargchk (0, 1, 2, "string"), "too many input arguments")
## Struct outputs
%!assert (nargchk (0, 1, 0, "struct"), stnul)
%!assert (nargchk (0, 1, 1, "struct"), stnul)
%!assert (nargchk (1, 1, 0, "struct"), stmin)
%!assert (nargchk (0, 1, 2, "struct"), stmax)
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} narginchk (@var{minargs}, @var{maxargs})
## Check for correct number of input arguments.
##
## Generate an error message if the number of arguments in the calling function
## is outside the range @var{minargs} and @var{maxargs}.  Otherwise, do
## nothing.
##
## Both @var{minargs} and @var{maxargs} must be scalar numeric values.  Zero,
## Inf, and negative values are all allowed, and @var{minargs} and
## @var{maxargs} may be equal.
##
## Note that this function evaluates @code{nargin} on the caller.
##
## @seealso{nargoutchk, error, nargout, nargin}
## @end deftypefn

function narginchk (minargs, maxargs)

  if (nargin != 2)
    print_usage ();
  elseif (! isnumeric (minargs) || ! isscalar (minargs))
    error ("narginchk: MINARGS must be a numeric scalar");
  elseif (! isnumeric (maxargs) || ! isscalar (maxargs))
    error ("narginchk: MAXARGS must be a numeric scalar");
  elseif (minargs > maxargs)
    error ("narginchk: MINARGS cannot be larger than MAXARGS");
  endif

  args = evalin ("caller", "nargin;");

  if (args < minargs)
    error ("narginchk: not enough input arguments");
  elseif (args > maxargs)
    error ("narginchk: too many input arguments");
  endif

endfunction


%!function f (nargs, varargin)
%! narginchk (nargs(1), nargs(2));
%!endfunction

%!error <too many input arguments> f([0,0])
%!error <not enough input arguments> f([3, 3], 1)

%!test
%! f([1,1]);
%!test
%! f([1,5], 2, 3, 4, 5);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} nargoutchk (@var{minargs}, @var{maxargs})
## @deftypefnx {} {@var{msgstr} =} nargoutchk (@var{minargs}, @var{maxargs}, @var{nargs})
## @deftypefnx {} {@var{msgstr} =} nargoutchk (@var{minargs}, @var{maxargs}, @var{nargs}, "string")
## @deftypefnx {} {@var{msgstruct} =} nargoutchk (@var{minargs}, @var{maxargs}, @var{nargs}, "struct")
## Check for correct number of output arguments.
##
## In the first form, return an error if the number of arguments is not between
## @var{minargs} and @var{maxargs}.  Otherwise, do nothing.  Note that this
## function evaluates the value of @code{nargout} on the caller so its value
## must have not been tampered with.
##
## Both @var{minargs} and @var{maxargs} must be numeric scalars.  Zero, Inf,
## and negative are all valid, and they can have the same value.
##
## For backwards compatibility, the other forms return an appropriate error
## message string (or structure) if the number of outputs requested is
## invalid.
##
## This is useful for checking to that the number of output arguments supplied
## to a function is within an acceptable range.
## @seealso{narginchk, error, nargout, nargin}
## @end deftypefn

function msg = nargoutchk (minargs, maxargs, nargs, outtype)

  ## before matlab's 2011b, nargoutchk would return an error message (just the
  ## message in a string).  With 2011b, it no longer returns anything, it
  ## simply gives an error if the args number is incorrect.
  ## To try to keep compatibility with both versions, check nargout and nargin
  ## to guess if the caller is expecting a value (old syntax)
  ## or none (new syntax).

  if (nargout == 1 && (nargin == 3 || nargin == 4))

    if (minargs > maxargs)
      error ("nargoutchk: MINARGS must be <= MAXARGS");
    elseif (nargin == 3)
      outtype = "string";
    elseif (! any (strcmpi (outtype, {"string" "struct"})))
      error ("nargoutchk: output type must be either string or struct");
    elseif (! (isscalar (minargs) && isscalar (maxargs) && isscalar (nargs)))
      error ("nargoutchk: MINARGS, MAXARGS, and NARGS must be scalars");
    endif

    msg = struct ("message", "", "identifier", "");
    if (nargs < minargs)
      msg.message = "not enough output arguments";
      msg.identifier = "Octave:nargoutchk:not-enough-outputs";
    elseif (nargs > maxargs)
      msg.message = "too many output arguments";
      msg.identifier = "Octave:nargoutchk:too-many-outputs";
    endif

    if (strcmpi (outtype, "string"))
      msg = msg.message;
    elseif (isempty (msg.message))
      ## Compatibility: Matlab returns a 0x1 empty struct when nargoutchk passes
      msg = resize (msg, 0, 1);
    endif

  elseif (nargout == 0 && nargin == 2)

    if (! isnumeric (minargs) || ! isscalar (minargs))
      error ("nargoutchk: MINARGS must be a numeric scalar");
    elseif (! isnumeric (maxargs) || ! isscalar (maxargs))
      error ("nargoutchk: MAXARGS must be a numeric scalar");
    elseif (minargs > maxargs)
      error ("nargoutchk: MINARGS cannot be larger than MAXARGS");
    endif

    args = evalin ("caller", "nargout;");

    if (args < minargs)
      error ("nargoutchk: Not enough output arguments");
    elseif (args > maxargs)
      error ("nargoutchk: Too many output arguments");
    endif

  else
    print_usage ();
  endif

endfunction


%!shared stnul, stmin, stmax
%! stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
%! stmin = struct ("message", "not enough output arguments",
%!                 "identifier", "Octave:nargoutchk:not-enough-outputs");
%! stmax = struct ("message", "too many output arguments",
%!                 "identifier", "Octave:nargoutchk:too-many-outputs");
%!assert (nargoutchk (0, 1, 0), "")
%!assert (nargoutchk (0, 1, 1), "")
%!assert (nargoutchk (1, 1, 0), "not enough output arguments")
%!assert (nargoutchk (0, 1, 2), "too many output arguments")
%!assert (nargoutchk (0, 1, 2, "string"), "too many output arguments")
## Struct outputs
%!assert (nargoutchk (0, 1, 0, "struct"), stnul)
%!assert (nargoutchk (0, 1, 1, "struct"), stnul)
%!assert (nargoutchk (1, 1, 0, "struct"), stmin)
%!assert (nargoutchk (0, 1, 2, "struct"), stmax)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} news
## @deftypefnx {} {} news @var{package}
## Display the current NEWS file for Octave or an installed package.
##
## When called without an argument, display the NEWS file for Octave.
##
## When given a package name @var{package}, display the current NEWS file for
## that package.
## @seealso{ver, pkg}
## @end deftypefn

function news (package = "octave")

  ## function takes care of validating PACKAGE input
  display_info_file ("news", package, "NEWS");

endfunction


%!error <news: PACKAGE must be a string> news (1)
%!error <news: package .* is not installed> news ("__NOT_A_VALID_PKG_NAME__")
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} nthargout (@var{n}, @var{func}, @dots{})
## @deftypefnx {} {} nthargout (@var{n}, @var{ntot}, @var{func}, @dots{})
## Return the @var{n}th output argument of the function specified by the
## function handle or string @var{func}.
##
## Any additional arguments are passed directly to @var{func}.  The total
## number of arguments to call @var{func} with can be passed in @var{ntot}; by
## default @var{ntot} is @var{n}.  The input @var{n} can also be a vector of
## indices of the output, in which case the output will be a cell array of the
## requested output arguments.
##
## The intended use @code{nthargout} is to avoid intermediate variables.  For
## example, when finding the indices of the maximum entry of a matrix, the
## following two compositions of nthargout
##
## @example
## @group
## @var{m} = magic (5);
## cell2mat (nthargout ([1, 2], @@ind2sub, size (@var{m}),
##                      nthargout (2, @@max, @var{m}(:))))
## @result{} 5   3
## @end group
## @end example
##
## @noindent
## are completely equivalent to the following lines:
##
## @example
## @group
## @var{m} = magic (5);
## [~, idx] = max (@var{M}(:));
## [i, j] = ind2sub (size (@var{m}), idx);
## [i, j]
## @result{} 5   3
## @end group
## @end example
##
## It can also be helpful to have all output arguments in a single cell in the
## following manner:
##
## @example
## @var{USV} = nthargout ([1:3], @@svd, hilb (5));
## @end example
##
## @seealso{nargin, nargout, varargin, varargout, isargout}
## @end deftypefn

function out = nthargout (n, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  if (is_function_handle (varargin{1}) || ischar (varargin{1}))
    ntot = max (n(:));
    func = varargin{1};
    args = varargin(2:end);
  elseif (isnumeric (varargin{1})
          && (is_function_handle (varargin{2}) || ischar (varargin{2})))
    ntot = varargin{1};
    func = varargin{2};
    args = varargin(3:end);
  else
    print_usage ();
  endif

  if (any (n != fix (n))  || ntot != fix (ntot) || any (n <= 0) || ntot <= 0)
    error ("nthargout: N and NTOT must consist of positive integers");
  endif

  outargs = cell (1, ntot);

  try
    [outargs{:}] = feval (func, args{:});
    if (numel (n) > 1)
      out = outargs(n);
    else
      out = outargs{n};
    endif
  catch
    err = lasterr ();
    if (strfind ("some elements undefined in return list", err))
      error ("nthargout: Too many output arguments: %d", ntot);
    else
      error (err);
    endif
  end_try_catch

endfunction


%!shared m
%! m = magic (5);
%!assert (nthargout ([1,2], @ind2sub, size (m), nthargout (2, @max, m(:))),
%!        {5,3})
%!assert (nthargout (3, @find, m(m>20)), [23, 24, 25, 21, 22]')
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} open @var{file}
## @deftypefnx {} {@var{output} =} open (@var{file})
## Open the file @var{file} in Octave or in an external application based on
## the file type as determined by the filename extension.
##
## By default, recognized file types are
##
## @table @code
## @item .m
## Open file in the editor.  No @var{output} value is returned.
##
## @item  .mat
## @itemx octave-workspace
## Open the data file with @code{load}.  If no return value @var{output}
## is requested, variables are loaded in the base workspace.  Otherwise
## @var{output} will be a structure containing loaded data.
## @xref{XREFload,,load function}.
##
## @item .ofig
## Open the figure with @code{hgload}.
## @xref{XREFhgload,,hgload function}.
##
## @item .fig, .ofig
## Load the figure
##
## @item .exe
## Execute the program (on Windows systems only).  No @var{output} value
## is returned.
## @end table
##
## Custom file extensions may also be handled if a function @code{openxxx},
## where @code{xxx} is the extension, is found in the load path.  The function
## must accept the file name as input.  For example, in order to load
## @nospell{@qcode{".dat"}} data files in the base workspace, as is done by
## default for @qcode{".mat"} files, one may define
## @nospell{@qcode{"opendat.m"}} with the following contents:
##
## @example
## @group
## function retval = opendat (fname)
##   evalin ("base", sprintf ("load ('%s');", fname));
## endfunction
## @end group
## @end example
##
## Other file types are opened in the appropriate external application.
## @end deftypefn

function output = open (file)

  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (file))
    error ("open: FILE must be a string");
  endif

  if (! exist (file, "file"))
    error ("open: unable to find file %s", file);
  endif

  file = make_absolute_filename (tilde_expand (file));

  [~, fname, ext] = fileparts (file);

  if (! isempty (ext)
      && any (exist (["open" tolower(ext(2:end))]) == [2 3 5 103]))
    try
      openfcn = ["open" tolower(ext(2:end))];
      if (nargout > 0)
        output = feval (openfcn, file);
      else
        feval (openfcn, file);
      endif
    catch
      error ("open: %s", lasterr);
    end_try_catch
  elseif (strcmpi (ext, ".m"))
    edit (file);
  elseif (strcmpi (ext, ".mat") || strcmp (fname, "octave-workspace"))
    if (nargout > 0)
      output = load (file);
    else
      evalin ("base", sprintf ("load ('%s');", file));
    endif
  elseif (strcmpi (ext, ".ofig"))
    if (nargout > 0)
      output = openfig (file);
    else
      openfig (file);
    endif
  elseif (any (strcmpi (ext, {".mdl", ".slx", ".prj"})))
    error ("open: opening file type '%s' is not supported", ext);
  elseif (strcmpi (ext, ".exe"))
    if (ispc ())
      dos (file);
    else
      error ("open: executing .exe files is only supported on Windows systems");
    endif
  else
    __open_with_system_app__ (file);
  endif

endfunction


## Test input validation
%!error <Invalid call> open ()
%!error open ("abc", "def")
%!error <FILE must be a string> open (1)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{sout} =} orderfields (@var{s1})
## @deftypefnx {} {@var{sout} =} orderfields (@var{s1}, @var{s2})
## @deftypefnx {} {@var{sout} =} orderfields (@var{s1}, @{@var{cellstr}@})
## @deftypefnx {} {@var{sout} =} orderfields (@var{s1}, @var{p})
## @deftypefnx {} {[@var{sout}, @var{p}] =} orderfields (@dots{})
## Return a @emph{copy} of @var{s1} with fields arranged alphabetically, or as
## specified by the second input.
##
## Given one input struct @var{s1}, arrange field names alphabetically.
##
## If a second struct argument is given, arrange field names in @var{s1} as
## they appear in @var{s2}.  The second argument may also specify the order
## in a cell array of strings @var{cellstr}.  The second argument may also
## be a permutation vector.
##
## The optional second output argument @var{p} is the permutation vector which
## converts the original name order to the new name order.
##
## Examples:
##
## @example
## @group
## s = struct ("d", 4, "b", 2, "a", 1, "c", 3);
## t1 = orderfields (s)
##   @result{} t1 =
##        scalar structure containing the fields:
##          a =  1
##          b =  2
##          c =  3
##          d =  4
## @end group
## @end example
##
## @example
## @group
## t = struct ("d", @{@}, "c", @{@}, "b", @{@}, "a", @{@});
## t2 = orderfields (s, t)
##   @result{} t2 =
##        scalar structure containing the fields:
##          d =  4
##          c =  3
##          b =  2
##          a =  1
## @end group
## @end example
##
## @example
## @group
## t3 = orderfields (s, [3, 2, 4, 1])
##   @result{} t3 =
##        scalar structure containing the fields:
##          a =  1
##          b =  2
##          c =  3
##          d =  4
## @end group
## @end example
##
## @example
## @group
## [t4, p] = orderfields (s, @{"d", "c", "b", "a"@})
##   @result{} t4 =
##        scalar structure containing the fields:
##          d =  4
##          c =  3
##          b =  2
##          a =  1
##      p =
##         1
##         4
##         2
##         3
## @end group
## @end example
##
## @seealso{fieldnames, getfield, setfield, rmfield, isfield, isstruct, struct}
## @end deftypefn

function [sout, p] = orderfields (s1, s2)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isstruct (s1))
    error ("orderfields: S1 must be a struct");
  endif

  names = fieldnames (s1);

  if (nargin == 1)
    ## One structure: return the fields in alphabetical order.
    [~, p] = sort (names);
  elseif (nargin == 2)

    if (isstruct (s2))
      ## Two structures: return the fields in the order of s2.
      names2 = fieldnames (s2);
      [ns1, idx1] = sort (names);
      [ns2, idx2] = sort (names2);
      if (! isequal (ns1, ns2))
        error ("orderfields: structures S1 and S2 do not have the same fields");
      endif
      p = eye (numel (idx2))(idx2,:).' * idx1;

    elseif (iscellstr (s2))
      ## A structure and a list of fields: order by the list of fields.
      names2 = s2(:);
      [ns1, idx1] = sort (names);
      [ns2, idx2] = sort (names2);
      if (! isequal (ns1, ns2))
        error ("orderfields: CELLSTR list does not match structure fields");
      endif
      p = eye (numel (idx2))(idx2,:).' * idx1;

    elseif (isnumeric (s2))
      ## A structure and a permutation vector: permute the order of s1.
      p = s2(:);
      if (! isequal (sort (p), (1:numel (names)).'))
        error ("orderfields: invalid permutation vector P");
      endif

    else
      error ("orderfields: second argument must be structure, cellstr, or permutation vector");
    endif
  endif

  ## Permute the names in the structure.
  names = names(p);
  C = struct2cell (s1);
  C = C(p,:);
  sout = cell2struct (C, names);
  ## Inherit dimensions.
  sout = reshape (sout, size (s1));

endfunction


%!shared a, b, c
%! a = struct ("C", {1, 2}, "A", {3, 4}, "B", {5, 6});
%! b = struct ("A", 1, "B", 2, "C", 3);
%! c = struct ("B", {7, 8}, "C", 9, "A", 10);
%!test
%! x = orderfields (b, a);
%! assert (fieldnames (x), {"C"; "A"; "B"});
%! assert (x.A, 1);
%! assert (x.B, 2);
%! assert (x.C, 3);
%!test
%! [x, p] = orderfields (b, [3 2 1]);
%! assert (fieldnames (x), {"C"; "B"; "A"});
%! assert (p, [3; 2; 1]);
%! assert (x.A, 1);
%! assert (x.B, 2);
%! assert (x.C, 3);
%!test
%! x = orderfields (b, {"B", "C", "A"});
%! assert (fieldnames (x), {"B"; "C"; "A"});
%! assert (x.A, 1);
%! assert (x.B, 2);
%! assert (x.C, 3);
%!test
%! x(1:2) = orderfields (c, {"C", "A", "B"});
%! assert (fieldnames (x), {"C"; "A"; "B"});
%! assert (x(2).A, 10);
%! assert (x(2).B, 8);
%! assert (x(2).C, 9);

%!test
%! aa.x = {1, 2};
%! aa.y = 3;
%! aa(2).x = {4, 5};
%! bb.y = {6, 7};
%! bb.x = 8;
%! aa(2) = orderfields (bb, aa);
%! assert (aa(2).x, 8);
%! assert (aa(2).y{1}, 6);

## Corner case of empty struct
%!assert <*40224> (orderfields (struct ()), struct ())
%!test
%! s(2,2).a = 1;
%! s(1,1).b = 2;
%! s = resize (s, [1 0]);
%! s2 = orderfields (s, {"b", "a"});
%! assert (fieldnames (s2), {"b"; "a"});
%! assert (size_equal (s, s2));

## Test input validation
%!error <Invalid call> orderfields ()
%!error <S1 must be a struct> orderfields (1)
%!error <S1 and S2 do not have the same fields>
%! s1.a = 1;
%! s2.b = 2;
%! orderfields (s1, s2);
%!error <CELLSTR list does not match structure fields>
%! s1.a = 1;
%! orderfields (s1, {"b"});
%!error <invalid permutation vector P>
%! s1.a = 1;
%! orderfields (s1, [2 1]);
%!error <invalid permutation vector P>
%! s1.a = 1;
%! orderfields (s1, ones (2,2));
%!error <second argument must be structure, cellstr, or permutation vector>
%! s1.a = 1;
%! orderfields (s1, "foobar");
########################################################################
##
## Copyright (C) 1999-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} pack ()
## Consolidate workspace memory in @sc{matlab}.
##
## This function is provided for compatibility, but does nothing in Octave.
## @seealso{clear}
## @end deftypefn

function pack ()

endfunction


## No test needed for empty function
%!assert (1)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{reg}, @var{prop}] =} parseparams (@var{params})
## @deftypefnx {} {[@var{reg}, @var{var1}, @dots{}] =} parseparams (@var{params}, @var{name1}, @var{default1}, @dots{})
## Return in @var{reg} the cell elements of @var{param} up to the first
## string element and in @var{prop} all remaining elements beginning with the
## first string element.
##
## For example:
##
## @example
## @group
## [reg, prop] = parseparams (@{1, 2, "linewidth", 10@})
## reg =
## @{
##   [1,1] = 1
##   [1,2] = 2
## @}
## prop =
## @{
##   [1,1] = linewidth
##   [1,2] = 10
## @}
## @end group
## @end example
##
## The parseparams function may be used to separate regular numeric arguments
## from additional arguments given as property/value pairs of the
## @var{varargin} cell array.
##
## In the second form of the call, available options are specified directly
## with their default values given as name-value pairs.  If @var{params} do
## not form name-value pairs, or if an option occurs that does not match any
## of the available options, an error occurs.
##
## When called from an m-file function, the error is prefixed with the name
## of the caller function.
##
## The matching of options is case-insensitive.
##
## @seealso{varargin, inputParser}
## @end deftypefn

function [reg, varargout] = parseparams (params, varargin)

  strs = cellfun ("isclass", params, "char");
  i = find (strs, 1);
  if (i)
    reg = params(1:i-1);
    prop = params(i:end);
  else
    reg = params;
    prop = {};
  endif

  if (nargin == 1)
    varargout = {prop};
  else
    names = varargin(1:2:end);
    defaults = varargin(2:2:end);
    if (! size_equal (names, defaults))
      error ("parseparams: needs odd number of arguments");
    endif
    [names, sidx] = sort (toupper (names));

    varargout = defaults;
    if (i)
      ## Let's parse the properties.
      pnames = prop(1:2:end);
      values = prop(2:2:end);
      if (! size_equal (pnames, values) || ! all (strs(i:2:end)))
        error_as_caller ("options must be given as name-value pairs");
      endif
      idx = lookup (names, toupper (pnames), "m");
      if (! all (idx))
        error_as_caller ("unrecognized option: %s", pnames{find (idx == 0, 1)});
      else
        varargout(sidx(idx)) = values;
      endif
    endif
  endif

endfunction

function error_as_caller (msg, varargin)
  stack = dbstack (1); # omit me
  fname = stack(min (2, end)).name;
  error ([fname, ": ", msg], varargin{:});
endfunction


%!test
%! [reg, prop] = parseparams ({1, 2, "linewidth", 10});
%! assert (reg, {[1], [2]});
%! assert (prop, {"linewidth", 10});
%!test
%! [reg, prop] = parseparams ({1, 2, 3});
%! assert (reg, {[1], [2], [3]});
%! assert (isempty (prop));
%!test
%! [reg, prop] = parseparams ({"prop1", "val1"});
%! assert (isempty (reg));
%! assert (prop, {"prop1", "val1"});
%!test
%! [reg, prop1] = parseparams ({"linewidth", 5}, "linewidth", 10);
%! assert (isempty (reg));
%! assert (prop1, 5);
%!test <*58533>
%! [foo, bar1, bar2] = parseparams ({ 0, "model", 1, "N", 2},"model", 4, "N", 5, "d", 6);
%! assert (foo, {0});
%! assert (bar1, 1);
%! assert (bar2, 2);

%!error <needs odd number of arguments> parseparams ({1}, "linewidth")
%!error <must be given as name-value pairs> parseparams ({1, "color"}, "linewidth", 5)
%!error <unrecognized option: color> parseparams ({1, "color", 5}, "linewidth", 5)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{output} =} perl (@var{scriptfile})
## @deftypefnx {} {@var{output} =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
## @deftypefnx {} {[@var{output}, @var{status}] =} perl (@dots{})
## Invoke Perl script @var{scriptfile}, possibly with a list of command line
## arguments.
##
## Return output in @var{output} and optional status in @var{status}.  If
## @var{scriptfile} is not an absolute filename it is searched for in the
## current directory and then in the Octave loadpath.
## @seealso{system, python}
## @end deftypefn

function [output, status] = perl (scriptfile = "-e ''", varargin)

  ## VARARGIN is initialized to {}(1x0) if no additional arguments are
  ## supplied, so there is no need to check for it, or provide an
  ## initial value in the argument list of the function definition.

  if (ischar (scriptfile)
      && (   (nargin == 1 && ! isempty (scriptfile))
          || (nargin != 1 && iscellstr (varargin))))
    if (! strcmp (scriptfile(1:2), "-e"))
      ## Attempt to find file in loadpath.  No effect for absolute filenames.
      scriptfile = file_in_loadpath (scriptfile);
    endif

    [status, output] = system (["perl " scriptfile ...
                                sprintf(" %s", varargin{:})]);
  else
    error ("perl: invalid arguments");
  endif

endfunction


%!error <invalid arguments> perl (123)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{outstr} =} __publish_html_output__ (@var{type}, @var{varargin})
##
## Internal function.
##
## The first input argument @var{type} defines the required strings
## (@samp{str}) or cell-strings (@samp{cstr}) in @var{varargin} in order
## to produce HTML output.
##
## @var{type} is one of
##
## @itemize @bullet
## @item
## @samp{output_file_extension} ()
##
## @item
## @samp{header} (title_str, intro_str, toc_cstr)
##
## @item
## @samp{footer} ()
##
## @item
## @samp{code} (str)
##
## @item
## @samp{code_output} (str)
##
## @item
## @samp{section} (str)
##
## @item
## @samp{preformatted_code} (str)
##
## @item
## @samp{preformatted_text} (str)
##
## @item
## @samp{bulleted_list} (cstr)
##
## @item
## @samp{numbered_list} (cstr)
##
## @item
## @samp{graphic} (str)
##
## @item
## @samp{html} (str)
##
## @item
## @samp{latex} (str)
##
## @item
## @samp{text} (str)
##
## @item
## @samp{blockmath} (str)
##
## @item
## @samp{inlinemath} (str)
##
## @item
## @samp{bold} (str)
##
## @item
## @samp{italic} (str)
##
## @item
## @samp{monospaced} (str)
##
## @item
## @samp{link} (url_str, url_str, str)
##
## @item
## @samp{TM} ()
##
## @item
## @samp{R} ()
##
## @item
## @samp{escape_special_chars} (str)
## @end itemize
## @end deftypefn

function outstr = __publish_html_output__ (type, varargin)
  outstr = feval (["do_" type], varargin{:});
endfunction

function outstr = do_output_file_extension ()
  outstr = ".html";
endfunction

function outstr = do_header (title_str, intro_str, toc_cstr)

  mathjax_str = sprintf ("%s\n",
"<script>",
"MathJax = {",
"  tex: {",
"    inlineMath: [['$','$'], ['\\\\(','\\\\)']],",
"    tags: 'all'",
"  }",
"};",
"</script>",
'<script type="text/javascript" async ',
'src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">',
"</script>");

  stylesheet_str = sprintf ("%s\n",
"<style>",
"body > * {",
"  max-width: 42em;",
"}",
"body {",
'  font-family: "Roboto Condensed", sans-serif;',
"  padding-left: 7.5em;",
"  padding-right: 7.5em;",
"}",
"pre, code {",
"  max-width: 50em;",
"  font-family: monospace;",
"}",
"pre.oct-code {",
"  border: 1px solid Grey;",
"  padding: 5px;",
"}",
"pre.oct-code-output {",
"  margin-left: 2em;",
"}",
"span.comment {",
"  color: ForestGreen;",
"}",...
"span.keyword {",
"  color: Blue;",
"}",...
"span.string {",
"  color: DarkOrchid;",
"}",...
"footer {",
"  margin-top: 2em;",
"  font-size: 80%;",
"}",
"a, a:visited {",
"  color: Blue;",
"}",
"h2 {",
'  font-family: "Roboto Condensed", serif;',
"  margin-top: 1.5em;",
"}",
"h2 a, h2 a:visited {",
"  color: Black;",
"}",
"</style>");

  outstr = sprintf ("%s\n",
"<!DOCTYPE html>",
"<html>",
"<head>",
'<meta charset="UTF-8">',
["<title>" title_str "</title>"],
mathjax_str,
stylesheet_str,
"</head>",
"<body>",
["<h1>" title_str "</h1>"],
intro_str);

  if (! isempty (toc_cstr))
    for i = 1:numel (toc_cstr)
      toc_cstr{i} = do_link (["#node" sprintf("%d", i)], toc_cstr{i});
    endfor
    outstr = [outstr, "<h2>Contents</h2>", do_bulleted_list(toc_cstr)];
  endif

  ## Reset section counter
  do_section ();

endfunction

function outstr = do_footer (m_source_str)

  outstr = sprintf ("%s\n",
"",
"<footer>",
"<hr>",
['<a href="https://www.octave.org">Published with GNU Octave ' version() '</a>'],
"</footer>",
"<!--",
"##### SOURCE BEGIN #####",
m_source_str,
"##### SOURCE END #####",
"-->",
"</body>",
"</html>");

endfunction

function outstr = do_code (str)
  outstr = ["\n", '<pre class="oct-code">' syntax_highlight(str) "</pre>\n"];
endfunction

function outstr = do_code_output (str)
  str = do_escape_special_chars (str);
  outstr = ["\n", '<pre class="oct-code-output">' str "</pre>\n"];
endfunction

function outstr = do_section (varargin)
  persistent counter = 1;

  if (nargin == 0)
    outstr = "";
    counter = 1;
    return;
  endif

  outstr = ['<h2><a id="node' sprintf("%d", counter) '">', ...
            varargin{1}, ...
            "</a></h2>"];

  counter++;

endfunction

function outstr = do_preformatted_code (str)
  outstr = ["\n", '<pre class="pre-code">' syntax_highlight(str) "</pre>\n"];
endfunction

function outstr = do_preformatted_text (str)
  str = do_escape_special_chars (str);
  outstr = ["\n", '<pre class="pre-text">' str "</pre>\n"];
endfunction

function outstr = do_bulleted_list (cstr)

  outstr = "\n<ul>\n";
  for i = 1:numel (cstr)
    outstr = [outstr, "<li>" cstr{i} "</li>\n"];
  endfor
  outstr = [outstr, "</ul>\n"];

endfunction

function outstr = do_numbered_list (cstr)

  outstr = "\n<ol>\n";
  for i = 1:numel (cstr)
    outstr = [outstr, "<li>" cstr{i} "</li>\n"];
  endfor
  outstr = [outstr, "</ol>\n"];

endfunction

function outstr = do_graphic (str)
  outstr = ['<img src="' str '" alt="' str '">'];
endfunction

function outstr = do_html (str)
  outstr = ["\n" str "\n"];
endfunction

function outstr = do_latex (str)
  outstr = "";
endfunction

function outstr = do_link (url_str, str)
  outstr = ['<a href="' url_str '">' str "</a>"];
endfunction

function outstr = do_text (str)
  outstr = ["\n<p>" str "</p>\n"];
endfunction

function outstr = do_blockmath (str)
  outstr = ["$$" str "$$"];
endfunction

function outstr = do_inlinemath (str)
  outstr = ["$" str "$"];
endfunction

function outstr = do_bold (str)
  outstr = ["<b>" str "</b>"];
endfunction

function outstr = do_italic (str)
  outstr = ["<i>" str "</i>"];
endfunction

function outstr = do_monospaced (str)
  outstr = ["<code>" str "</code>"];
endfunction

function outstr = do_TM ()
  outstr = "&trade;";
endfunction

function outstr = do_R ()
  outstr = "&reg;";
endfunction

function str = do_escape_special_chars (str)
  str = regexprep (str, '&', '&amp;');
  str = regexprep (str, '<', '&lt;');
  str = regexprep (str, '>', '&gt;');
  ## str = regexprep (str, '"', '&quot;'); ## MATLAB R2017a compatibility.
endfunction

## SYNTAX_HIGHLIGHT: A primitive parser to highlight syntax via <span> tags.
## FIXME: Needs to be replaced by a better solution.
function outstr = syntax_highlight (str)

  str = do_escape_special_chars (str);
  outstr = "";
  placeholder_cstr = {};
  i = 1;
  plh = 0;

  while (i <= numel (str))
    ## Block comment
    if (any (strncmp (str(i:end), {"%{", "#{"}, 2)))
      plh_str = ['<span class="comment">', str(i:i+1)];
      i += 2;
      while (i <= numel (str)
             && ! (any (strncmp (str(i:end), {"%}", "#}"}, 2))))
        plh_str = [plh_str, str(i)];
        i += 1;
      endwhile
      if (i < numel (str))
        plh_str = [plh_str, str(i:i+1), "</span>"];
        i += 2;
      else
        plh_str = [plh_str, "</span>"];
      endif
      plh += 1;
      placeholder_cstr{plh} = plh_str;
      outstr = [outstr, " PUBLISHPLACEHOLDER", sprintf("%d", plh), " "];
    ## Line comment
    elseif (str(i) == "#" || str(i) == "%")
      plh_str = '<span class="comment">';
      idx = find (str(i:end) == "\n", 1);
      if (isempty (idx))
        plh_str = [plh_str, str(i:end)];
        i = numel (str) + 1;
      else
        plh_str = [plh_str, str(i:i+idx-2)];
        i += idx;
      endif
      plh_str = [plh_str, "</span>\n"];
      plh += 1;
      placeholder_cstr{plh} = plh_str;
      outstr = [outstr, " PUBLISHPLACEHOLDER", sprintf("%d", plh), " "];
    ## Single quoted string
    elseif (str(i) == "'")
      plh_str = "<span class=\"string\">'";
      i += 1;
      while (i <= numel (str))
        ## Ignore escaped string terminations
        if (strncmp (str(i:end), "''", 2))
          plh_str = [plh_str, "''"];
          i += 2;
        ## Is char a string termination?
        elseif (str(i) == "'")
          plh_str = [plh_str, "'"];
          i += 1;
          break;
        ## Is string terminated by line break?
        elseif (str(i) == "\n")
          break;
        ## String content
        else
          plh_str = [plh_str, str(i)];
          i += 1;
        endif
      endwhile
      plh_str = [plh_str, "</span>"];
      plh += 1;
      placeholder_cstr{plh} = plh_str;
      outstr = [outstr, " PUBLISHPLACEHOLDER", sprintf("%d", plh), " "];
    ## Double quoted string
    elseif (str(i) == '"')
      plh_str = '<span class="string">"';
      i += 1;
      while (i <= numel (str))
        ## Is char a string termination?
        if (str(i) == '"' && str(i-1) != '\')
          plh_str = [plh_str, '"'];
          i += 1;
          break;
        ## Is string terminated by line break?
        elseif (str(i) == "\n")
          break;
        ## String content
        else
          plh_str = [plh_str, str(i)];
          i += 1;
        endif
      endwhile
      plh_str = [plh_str, "</span>"];
      plh += 1;
      placeholder_cstr{plh} = plh_str;
      outstr = [outstr, " PUBLISHPLACEHOLDER", sprintf("%d", plh), " "];
    else
      outstr = [outstr, str(i)];
      i += 1;
    endif
  endwhile

  persistent kword_ptn = strjoin (iskeyword (), '|');

  ## FIXME: remove hack for regexprep once bug #38149 is solved
  outstr = [" ", strrep(outstr, "\n", " \n "), " "];
  outstr = regexprep (outstr,
                      ['(\s)(' kword_ptn ')(\s|\()'],
                      ['$1<span class="keyword">$2</span>$3']);
  ## FIXME: remove hack for regexprep once bug #38149 is solved
  outstr = strrep (outstr(2:end-1), " \n ", "\n");

  ## Restore placeholders
  for i = plh:-1:1
    outstr = strrep (outstr, [" PUBLISHPLACEHOLDER", sprintf("%d", i), " "],
                             placeholder_cstr{i});
  endfor

endfunction
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{outstr} =} __publish_latex_output__ (@var{type}, @var{varargin})
##
## Internal function.
##
## The first input argument @var{type} defines the required strings
## (@samp{str}) or cell-strings (@samp{cstr}) in @var{varargin} in order
## to produce @LaTeX{} output.
##
## @var{type} is one of
##
## @itemize @bullet
## @item
## @samp{output_file_extension} ()
##
## @item
## @samp{header} (title_str, intro_str, toc_cstr)
##
## @item
## @samp{footer} ()
##
## @item
## @samp{code} (str)
##
## @item
## @samp{code_output} (str)
##
## @item
## @samp{section} (str)
##
## @item
## @samp{preformatted_code} (str)
##
## @item
## @samp{preformatted_text} (str)
##
## @item
## @samp{bulleted_list} (cstr)
##
## @item
## @samp{numbered_list} (cstr)
##
## @item
## @samp{graphic} (str)
##
## @item
## @samp{html} (str)
##
## @item
## @samp{latex} (str)
##
## @item
## @samp{text} (str)
##
## @item
## @samp{blockmath} (str)
##
## @item
## @samp{inlinemath} (str)
##
## @item
## @samp{bold} (str)
##
## @item
## @samp{italic} (str)
##
## @item
## @samp{monospaced} (str)
##
## @item
## @samp{link} (url_str, url_str, str)
##
## @item
## @samp{TM} ()
##
## @item
## @samp{R} ()
##
## @item
## @samp{escape_special_chars} (str)
## @end itemize
## @end deftypefn

function outstr = __publish_latex_output__ (type, varargin)
  outstr = feval (["do_" type], varargin{:});
endfunction

function outstr = do_output_file_extension ()
  outstr = ".tex";
endfunction

function outstr = do_header (title_str, intro_str, toc_cstr)

  publish_comment = sprintf ("%s\n",
"",
"",
"% This document was generated by the publish-function",
["% from GNU Octave " version()],
"");

  latex_preamble = sprintf ("%s\n",
"",
"",
'\documentclass[10pt]{article}',
'\usepackage{listings}',
'\usepackage{mathtools}',
'\usepackage{amssymb}',
'\usepackage{graphicx}',
'\usepackage{hyperref}',
'\usepackage{xcolor}',
'\usepackage{titlesec}',
'\usepackage[utf8]{inputenc}',
'\usepackage[T1]{fontenc}',
'\usepackage{lmodern}');

  ## "lstlisting" doesn't support multi-byte UTF-8 characters.
  ## Add substitution rules for some characters (commonly used in languages with
  ## Latin-based script).
  ## Set of substitions taken from:
  ## https://en.wikibooks.org/w/index.php?title=LaTeX/Source_Code_Listings&oldid=3815132#Encoding_issue
  ## FIXME: Any multi-byte UTF-8 character in a non-section comment without a
  ##        substitution rule will still cause an error.  This should be fixed
  ##        more generally, or a way how to work around this limitation should
  ##        be documented.
  listings_option = sprintf ("%s\n",
"",
"",
'\lstset{',
'language=Octave,',
'numbers=none,',
'frame=single,',
'tabsize=2,',
'showstringspaces=false,',
'breaklines=true,',
'inputencoding=utf8,',
'extendedchars=true,',
'literate=',
'  {}{{\''a}}1 {}{{\''e}}1 {}{{\''i}}1 {}{{\''o}}1 {}{{\''u}}1',
'  {}{{\''A}}1 {}{{\''E}}1 {}{{\''I}}1 {}{{\''O}}1 {}{{\''U}}1',
'  {}{{\`a}}1 {}{{\`e}}1 {}{{\`i}}1 {}{{\`o}}1 {}{{\`u}}1',
'  {}{{\`A}}1 {}{{\''E}}1 {}{{\`I}}1 {}{{\`O}}1 {}{{\`U}}1',
'  {}{{\"a}}1 {}{{\"e}}1 {}{{\"i}}1 {}{{\"o}}1 {}{{\"u}}1',
'  {}{{\"A}}1 {}{{\"E}}1 {}{{\"I}}1 {}{{\"O}}1 {}{{\"U}}1',
'  {}{{\^a}}1 {}{{\^e}}1 {}{{\^i}}1 {}{{\^o}}1 {}{{\^u}}1',
'  {}{{\^A}}1 {}{{\^E}}1 {}{{\^I}}1 {}{{\^O}}1 {}{{\^U}}1',
'  {}{{\~a}}1 {}{{\~e}}1 {}{{\~i}}1 {}{{\~o}}1 {}{{\~u}}1',
'  {}{{\~A}}1 {}{{\~E}}1 {}{{\~I}}1 {}{{\~O}}1 {}{{\~U}}1',
'  {}{{\oe}}1 {}{{\OE}}1 {}{{\ae}}1 {}{{\AE}}1 {}{{\ss}}1',
'  {}{{\H{u}}}1 {}{{\H{U}}}1 {}{{\H{o}}}1 {}{{\H{O}}}1',
'  {}{{\c c}}1 {}{{\c C}}1 {}{{\o}}1 {}{{\r a}}1 {}{{\r A}}1',
'  {}{{\euro}}1 {}{{\pounds}}1 {}{{\guillemotleft}}1',
'  {}{{\guillemotright}}1 {}{{\~n}}1 {}{{\~N}}1 {}{{?`}}1 {}{{!`}}1',
'}');

  latex_head = sprintf ("%s\n",
"",
"",
'\titleformat*{\section}{\Huge\bfseries}',
'\titleformat*{\subsection}{\large\bfseries}',
'\renewcommand{\contentsname}{\Large\bfseries Contents}',
'\setlength{\parindent}{0pt}',
"",
'\begin{document}',
"",
['{\Huge\section*{' title_str '}}'],
"",
'\tableofcontents',
'\vspace*{4em}',
"");

  outstr = [publish_comment, latex_preamble, listings_option, latex_head];

endfunction

function outstr = do_footer (m_source_str)
  outstr = ["\n\n" '\end{document}' "\n"];
endfunction

function outstr = do_code (str)
  outstr = ['\begin{lstlisting}' "\n", str, "\n" '\end{lstlisting}' "\n"];
endfunction

function outstr = do_code_output (str)
  outstr = sprintf ("%s\n",
'\begin{lstlisting}[language={},xleftmargin=5pt,frame=none]',
str,
'\end{lstlisting}');
endfunction

function outstr = do_section (str)
  outstr = sprintf ("%s\n",
"",
"",
'\phantomsection',
['\addcontentsline{toc}{section}{' str '}'],
['\subsection*{' str '}'],
"");
endfunction

function outstr = do_preformatted_code (str)
  outstr = sprintf ("%s\n",
'\begin{lstlisting}',
str,
'\end{lstlisting}');
endfunction

function outstr = do_preformatted_text (str)
  outstr = sprintf ("%s\n",
'\begin{lstlisting}[language={}]',
str,
'\end{lstlisting}');
endfunction

function outstr = do_bulleted_list (cstr)

  outstr = ["\n" '\begin{itemize}' "\n"];
  for i = 1:numel (cstr)
    outstr = [outstr, '\item ' cstr{i} "\n"];
  endfor
  outstr = [outstr, '\end{itemize}' "\n"];

endfunction

function outstr = do_numbered_list (cstr)

  outstr = ["\n" '\begin{enumerate}' "\n"];
  for i = 1:numel (cstr)
    outstr = [outstr, '\item ' cstr{i} "\n"];
  endfor
  outstr = [outstr, "\\end{enumerate}\n"];

endfunction

function outstr = do_graphic (str)
  outstr = sprintf ("%s\n",
'\begin{figure}[!ht]',
['\includegraphics[width=\textwidth]{' str '}'],
'\end{figure}');
endfunction

function outstr = do_html (str)
  outstr = "";
endfunction

function outstr = do_latex (str)
  outstr = ["\n" str "\n"];
endfunction

function outstr = do_link (url_str, str)
  outstr = ['\href{' url_str '}{' str '}'];
endfunction

function outstr = do_text (str)
  outstr = ["\n\n" str "\n\n"];
endfunction

function outstr = do_blockmath (str)
  outstr = ["$$" str "$$"];
endfunction

function outstr = do_inlinemath (str)
  outstr = ["$" str "$"];
endfunction

function outstr = do_bold (str)
  outstr = ['\textbf{' str '}'];
endfunction

function outstr = do_italic (str)
  outstr = ['\textit{' str '}'];
endfunction

function outstr = do_monospaced (str)
  outstr = ['\texttt{' str '}'];
endfunction

function outstr = do_TM ()
  outstr = '\texttrademark ';
endfunction

function outstr = do_R ()
  outstr = '\textregistered ';
endfunction

function str = do_escape_special_chars (str)

  ## Escape \, {, }, &, %, #, _, ~, ^, <, >
  str = regexprep (str, '\\', "\\ensuremath{\\backslash}");
  str = regexprep (str, '(?<!\\)(\{|\}|&|%|#|_)', '\\$1');
  ## Revert accidental {} replacements for backslashes
  str = strrep (str, '\ensuremath\{\backslash\}', '\ensuremath{\backslash}');
  str = regexprep (str, '(?<!\\)~', "\\ensuremath{\\tilde{\\;}}");
  str = regexprep (str, '(?<!\\)\^', "\\^{}");
  str = regexprep (str, '(?<!\\)<', "\\ensuremath{<}");
  str = regexprep (str, '(?<!\\)>', "\\ensuremath{>}");

endfunction
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{mingwpath} =} __w2mpth__ (@var{winpath})
## Convert a Windows-style relative or full path name to MinGW style.
##
## @strong{Caution:} __w2mpth__ does not check the validity of the path.
##
## Examples:
##
## @example
## @group
##   mpth = __w2mpth__ ('D:\full\path\to\file.dat')
##   @result{} '/D/full/path/to/file.dat'
## @end group
## @end example
##
## @example
## @group
##   mpth = __w2mpth__ ('relative\path\to\file.dat')
##   @result{} 'relative/path/to/file.dat'
## @end group
## @end example
##
## @end deftypefn

function mingwpath = __w2mpth__ (winpath)

  ## Check for platform
  if (! ispc)
    error ("__w2mpth__: function must only be called on Windows platforms\n");
  endif

  ## Replace backslash file separators by forward slashes
  mingwpath = strrep (winpath, '\', '/');
  ## Also treat drive letter but beware of relative filenames
  mingwpath = regexprep (mingwpath, '^([a-zA-Z]):', '/$1');

endfunction


## Use single quote strings for winpaths to cope with backslashes.
## These tests are commented out until a better place is found (bug #44581)
##%!test
##%! if (ispc)
##%!   assert (__w2mpth__ ('file.fil'), 'file.fil');
##%!   assert (__w2mpth__ ('\file.fil'), '/file.fil');
##%!   assert (__w2mpth__ ('G:\file.fil'), '/G/file.fil');
##%!   assert (__w2mpth__ ('r:\subdir\file.fil'), '/r/subdir/file.fil');
##%!   assert (__w2mpth__ ('relative\path\to\file.dat'),
##%!                       'relative/path/to/file.dat')
##%! endif
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## news() and citation() are very much alike.  They both do the same thing,
## just for different files.  This function does all the work.

function display_info_file (func, package, file)

  if (! ischar (package))
    error ("%s: PACKAGE must be a string", func);
  endif

  if (strcmpi (package, "octave"))
    octetcdir = __octave_config_info__ ("octetcdir");
    filepath  = fullfile (octetcdir, file);
  else
    installed = pkg ("list");
    names     = cellfun (@(x) x.name, installed, "UniformOutput", false);
    pos       = strcmpi (names, package);
    if (! any (pos))
      error ("%s: package '%s' is not installed", func, package);
    endif
    filepath = fullfile (installed{pos}.dir, "packinfo", file);
  endif

  if (! exist (filepath, "file"))
    if (strcmpi (package, "octave"))
      error ("%s: broken installation -- unable to locate %s file", func, file);
    else
      error ("%s: unable to locate %s file for package %s", func, file, package);
    endif
  endif

  fid = fopen (filepath, "r");
  while (ischar (line = fgets (fid)))
    puts (line);
  endwhile
  fclose (fid);

endfunction
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{out} =} tar_is_bsd ()
## True if the default tar command is BSD tar.
##
## Checks whether the default tar command (the one invoked when an un-prefixed
## @code{tar} is executed) is BSD tar or another tar.  Caches the results for
## performance.
##
## Returns true if the detected tar is BSD tar, and false otherwise.  Errors if
## @code{tar --version} does not succeed.
## @end deftypefn

function out = tar_is_bsd ()

  ## BSD tar needs to be handled differently from GNU tar
  persistent cache
  if (isempty (cache))
    [status, tar_ver_str] = system ("tar --version");
    if (status)
      error ("tar: Failed executing tar --version (status = %d)", status);
    endif
    cache = ! isempty (regexp (tar_ver_str, "bsdtar"));
  endif
  out = cache;

endfunction
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} publish (@var{file})
## @deftypefnx {} {} publish (@var{file}, @var{output_format})
## @deftypefnx {} {} publish (@var{file}, @var{option1}, @var{value1}, @dots{})
## @deftypefnx {} {} publish (@var{file}, @var{options})
## @deftypefnx {} {@var{output_file} =} publish (@var{file}, @dots{})
##
## Generate a report from the Octave script file @var{file} in one of several
## output formats.
##
## The generated reports interpret Publishing Markup in section comments, which
## is explained in detail in the GNU Octave manual.  Section comments are
## comment blocks that start with a line with double comment character.
##
## Assume the following example, using some Publishing Markup, to be the
## contents of the script file @file{pub_example.m}:
##
## @example
## @group
## ## Headline title
## #
## # Some *bold*, _italic_, or |monospaced| Text with
## # a <https://www.octave.org link to *GNU Octave*>.
## ##
##
## # "Real" Octave commands to be evaluated
## sombrero ()
##
## %% @sc{matlab} comment style ('%') is supported as well
## %
## % * Bulleted list item 1
## % * Bulleted list item 2
## %
## % # Numbered list item 1
## % # Numbered list item 2
## @end group
## @end example
##
## To publish this script file, type @code{publish ("pub_example.m")}.
##
## When called with one input argument, a HTML report is generated in a
## subdirectory @file{html} relative to the current working directory.  Any
## Octave commands in @file{pub_example.m} are evaluated in a separate context
## and any figures created while executing the script file are included in the
## report.
##
## Using @code{publish (@var{file}, @var{output_format})} is equivalent to the
## function call using a structure
##
## @example
## @group
## @var{options}.format = @var{output_format};
## publish (@var{file}, @var{options})
## @end group
## @end example
##
## @noindent
## which is described below.  The same holds for using option/value pairs
##
## @example
## @group
## @var{options}.@var{option1} = @var{value1};
## publish (@var{file}, @var{options})
## @end group
## @end example
##
## The structure @var{options} can have the following field names.  If a field
## name is not specified, the default value is used:
##
## @itemize @bullet
## @item
## @samp{format} --- Output format of the published script file, one of
##
## @samp{html} (default), @samp{doc}, @samp{latex}, @samp{ppt},
## @samp{pdf}, or @samp{xml}.
##
## The output formats @samp{doc}, @samp{ppt}, and @samp{xml} are not currently
## supported.  To generate a @samp{doc} report, open a generated @samp{html}
## report with your office suite.
##
## In Octave custom formats are supported by implementing all callback
## subfunctions in a function file named
## @samp{__publish_<custom format>_output__.m}.  To obtain a template for the
## HTML format type:
##
## @example
## @group
## edit (fullfile (fileparts (which ("publish")), ...
##       "private", "__publish_html_output__.m"))
## @end group
## @end example
##
## @item
## @samp{outputDir} --- Full path of the directory where the generated report
## will be located.  If no directory is given, the report is generated in a
## subdirectory @file{html} relative to the current working directory.
##
## @item
## @samp{stylesheet} --- Not supported, only for @sc{matlab} compatibility.
##
## @item
## @samp{createThumbnail} --- Not supported, only for @sc{matlab}
## compatibility.
##
## @item
## @samp{figureSnapMethod} --- Not supported, only for @sc{matlab}
## compatibility.
##
## @item
## @samp{imageFormat} --- Desired format for any images produced while
## evaluating the code.  The allowed image formats depend on the output format:
##
## @itemize @bullet
## @item @samp{html}, @samp{xml} --- @samp{png} (default), any image format
## supported by Octave
##
## @item @samp{latex} --- @samp{epsc2} (default), any image format supported by
## Octave
##
## @item @samp{pdf} --- @samp{jpg} (default) or @samp{bmp}, note @sc{matlab}
## uses  @samp{bmp} as default
##
## @item @samp{doc} or @samp{ppt} --- @samp{png} (default), @samp{jpg},
## @samp{bmp}, or @samp{tiff}
## @end itemize
##
## @item
## @samp{maxWidth} and @samp{maxHeight} --- Maximum width (height) of the
## produced images in pixels.  An empty value means no restriction.  Both
## values must be set in order for the option to work properly.
##
## @samp{[]} (default), integer value @geq{} 0
##
## @item
## @samp{useNewFigure} --- Use a new figure window for figures created by the
## evaluated code.  This avoids side effects with already opened figure
## windows.
##
## @samp{true} (default) or @samp{false}
##
## @item
## @samp{evalCode} --- Evaluate code of the Octave source file
##
## @samp{true} (default) or @samp{false}
##
## @item
## @samp{catchError} --- Catch errors while evaluating code and continue
##
## @samp{true} (default) or @samp{false}
##
## @item
## @samp{codeToEvaluate} --- Octave commands that should be evaluated prior to
## publishing the script file.  These Octave commands do not appear in the
## generated report.
##
## @item
## @samp{maxOutputLines} --- Maximum number of output lines from code
## evaluation which are included in output.
##
## @samp{Inf} (default) or integer value > 0
##
## @item
## @samp{showCode} --- Show the evaluated Octave commands in the generated
## report
##
## @samp{true} (default) or @samp{false}
## @end itemize
##
## The option output @var{output_file} is a string with path and file name
## of the generated report.
##
## @seealso{grabcode}
## @end deftypefn

function output_file = publish (file, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  if (exist (file, "file") != 2)
    error ("publish: FILE does not exist");
  endif

  ## Check file to be in Octave's load path
  [file_path, file_name, file_ext] = fileparts (file);
  if (isempty (file_path))
    file_path = pwd ();
  endif
  if (exist ([file_name, file_ext]) != 2)
    error (["publish: " file " is not in the load path"]);
  endif

  ## Check file extension and that file is an Octave script
  file_info = __which__ (file_name);
  if (! strcmp (file_ext, ".m") || ! strcmp (file_info.type, "script"))
    error ("publish: only script files can be published");
  endif

  ## Check file to be parsable
  __parse_file__ (file);

  ## Get structure with necessary options
  options = struct ();
  if (numel (varargin) == 1)
    ## Call: publish (file, format)
    if (ischar (varargin{1}))
      options.format = varargin{1};
    ## Call: publish (file, options)
    elseif (isstruct (varargin{1}))
      options = varargin{1};
    else
      error ("publish: second argument must be OUTPUT_FORMAT or OPTIONS");
    endif
  ## Call: publish (file, Name1, Value1, Name2, Value2, ...)
  elseif (rem (numel (varargin), 2) == 0
          && all (cellfun (@ischar, varargin(1:2:end))))
    options = cell2struct (varargin(2:2:end), varargin(1:2:end), 2);
  else
    error ("publish: invalid arguments");
  endif

  ## Validate options struct

  ## Options for the output
  if (! isfield (options, "format"))
    options.format = "html";
  else
    ## FIXME: Implement remaining formats
    if (any (strcmpi (options.format, {"doc", "ppt", "xml"})))
      error ('publish: Output format "%s" is not yet supported',
             options.format);
    endif
    ## Supported or custom output format
    supported_formats = {"html", "doc", "latex", "ppt", "xml", "pdf"};
    if (! any (strcmpi (options.format, supported_formats)))
      ## Check existence of custom formatter
      custom_formatter = ["__publish_", options.format, "_output__"];
      if (! exist (custom_formatter, "file"))
        error (['publish: Custom output format "%s" requires the ', ...
                "formatter function:\n\n\t%s\n\n\t", ...
                'See "help publish" for more information.'],
                options.format, custom_formatter);
      endif
    else
      options.format = validatestring (options.format, supported_formats);
    endif
  endif

  if (! isfield (options, "outputDir"))
    ## Matlab R2016a doc says default is "", but specifies to create a
    ## subdirectory named "html" in the current working directory.
    options.outputDir = fullfile (file_path, "html");
  elseif (! ischar (options.outputDir))
    error ("publish: OUTPUTDIR must be a string");
  endif

  if (! isfield (options, "stylesheet"))
    options.stylesheet = "";
  elseif (! ischar (options.stylesheet))
    error ("publish: STYLESHEET must be a string");
  endif

  ## Options for the figures
  if (! isfield (options, "createThumbnail"))
    options.createThumbnail = true;
  elseif (! isscalar (options.createThumbnail)
          || ! isreal (options.createThumbnail))
    error ("publish: CREATETHUMBNAIL must be TRUE or FALSE");
  endif

  if (! isfield (options, "figureSnapMethod"))
    options.figureSnapMethod = "entireGUIWindow";
  else
    options.figureSnapMethod = validatestring (options.figureSnapMethod, ...
      {"entireGUIWindow", "print", "getframe", "entireFigureWindow"});
    ## FIXME: implement other SnapMethods
    warning ("publish: option FIGURESNAPMETHOD currently not supported");
  endif

  if (! isfield (options, "imageFormat"))
    switch (options.format)
      case "latex"
        options.imageFormat = "epsc2";
      case "pdf"
        ## Note: Matlab R2016a uses bmp as default
        options.imageFormat = "jpg";
      otherwise
        options.imageFormat = "png";
    endswitch
  elseif (! ischar (options.imageFormat))
    error ("publish: IMAGEFORMAT must be a string");
  else
    ## Check valid imageFormat for chosen format
    ##   html, latex, and xml accept any imageFormat
    switch (options.format)
      case {"doc", "ppt"}
        options.imageFormat = validatestring (options.imageFormat,
                                              {"png", "jpg", "bmp", "tiff"});
      case "pdf"
        options.imageFormat = validatestring (options.imageFormat,
                                              {"bmp", "jpg"});
    endswitch
  endif

  if (! isfield (options, "maxHeight"))
    options.maxHeight = [];
  elseif (! isscalar (options.maxHeight) || options.maxHeight < 1)
    error ("publish: MAXHEIGHT must be a positive integer");
  else
    options.maxHeight = uint64 (options.maxHeight);
  endif

  if (! isfield (options, "maxWidth"))
    options.maxWidth = [];
  elseif (! isscalar (options.maxWidth) || options.maxWidth < 1)
    error ("publish: MAXWIDTH must be a positive integer");
  else
    options.maxWidth = uint64 (options.maxWidth);
  endif

  if (! isfield (options, "useNewFigure"))
    options.useNewFigure = true;
  elseif (! isscalar (options.useNewFigure) || ! isreal (options.useNewFigure))
    error ("publish: USENEWFIGURE must be TRUE or FALSE");
  endif

  ## Options for the code
  if (! isfield (options, "evalCode"))
    options.evalCode = true;
  elseif (! isscalar (options.evalCode) || ! isreal (options.evalCode))
    error ("publish: EVALCODE must be TRUE or FALSE");
  endif

  if (! isfield (options, "catchError"))
    options.catchError = true;
  elseif (! isscalar (options.catchError) || ! isreal (options.catchError))
    error ("publish: CATCHERROR must be TRUE or FALSE");
  endif

  if (! isfield (options, "codeToEvaluate"))
    options.codeToEvaluate = "";
  elseif (! ischar (options.codeToEvaluate))
    error ("publish: CODETOEVALUTE must be a string");
  endif

  if (! isfield (options, "maxOutputLines"))
    options.maxOutputLines = Inf;
  elseif (! isscalar (options.maxOutputLines) || options.maxOutputLines < 0)
    error ("publish: MAXOUTPUTLINES must be an integer >= 0");
  else
    options.maxOutputLines = uint64 (options.maxOutputLines);
  endif

  if (! isfield (options, "showCode"))
    options.showCode = true;
  elseif (! isscalar (options.showCode) || ! isreal (options.showCode))
    error ("publish: SHOWCODE must be TRUE or FALSE");
  endif

  doc.title = "";
  doc.intro = "";
  doc.body = cell ();
  doc.m_source = deblank (read_file_to_cellstr (file));
  doc.m_source_file_name = file;

  ## Split code and paragraphs, find formatting
  doc = parse_m_source (doc);

  ## Create output directory
  [status, msg] = mkdir (options.outputDir);
  if (status != 1)
    error ("publish: cannot create output directory: %s", msg);
  endif

  if (options.evalCode)
    doc = eval_code (doc, options);
    eval_context ("clear");
  endif

  output_file = create_output (doc, options);

endfunction


function doc = parse_m_source (doc)

  ## PARSE_M_SOURCE First parsing level
  ##   This function extracts the overall structure (paragraphs and code
  ##   sections) given in doc.m_source.
  ##
  ##   The result is written to doc.body, which then contains a cell
  ##   vector of structs, either of
  ##
  ##     a) {struct ("type", "code", ...
  ##                 "lines", [a, b], ...
  ##                 "output", [])}
  ##     b) {struct ("type", "section", ...
  ##                 "content", title_str)}
  ##
  ##   Second parsing level is invoked for the paragraph contents, resulting
  ##   in more elements for doc.body.

  if (isempty (doc.m_source))
    return;  # Nothing to parse
  endif

  ## Parsing helper functions
  ##
  ## Checks line to have N "%" or "#" lines
  ## followed either by a space or end of string
  function r = is_publish_markup (cstr, N)

    str = char (cstr);

    r = any (strncmp (str, {"%%%", "##"}, N));
    if (r)
      len = length (str);
      if (len == N)
        r = true;
      elseif (len > N && str(N+1) == " ")
        r = true;
      else
        r = false;
      endif
    endif

    return;
  endfunction
  ## Checks line of cellstring to be a paragraph line
  is_paragraph = @(cstr) is_publish_markup (cstr, 1);
  ## Checks line of cellstring to be a section headline
  is_head = @(cstr) is_publish_markup (cstr, 2);
  ## Checks line of cellstring to be a headline without section break, using
  ## the cell mode in Matlab (for compatibility), just treated as a new head.
  is_no_break_head = @(cstr) is_publish_markup (cstr, 3);

  ## Find the indices of paragraphs starting with "%%", "##", or "%%%"
  par_start_idx = find (cellfun (is_head, doc.m_source)
                        | cellfun (is_no_break_head, doc.m_source));

  ## If the whole document is code
  if (isempty (par_start_idx))
    doc.body{end+1}.type = "code";
    doc.body{end}.content = strtrim (strjoin (doc.m_source, "\n"));
    doc.body{end}.lines = [1, length(doc.m_source)];
    doc.body{end}.output = {};
    return;
  endif

  ## Determine continuous range of paragraphs
  par_end_idx = [par_start_idx(2:end) - 1, length(doc.m_source)];
  for i = 1:numel (par_end_idx)
    idx = find (! cellfun (is_paragraph,
                           doc.m_source(par_start_idx(i) + 1:par_end_idx(i))));
    if (! isempty (idx))
      par_end_idx(i) = par_start_idx(i) + idx(1) - 1;
    endif
  endfor
  ## Code sections between paragraphs
  code_start_idx = par_end_idx(1:end-1) + 1;
  code_end_idx = par_start_idx(2:end) - 1;
  ## Code at the beginning?
  if (par_start_idx(1) > 1)
    code_start_idx = [1, code_start_idx];
    code_end_idx = [par_start_idx(1) - 1, code_end_idx];
  endif
  ## Code at the end?
  if (par_end_idx(end) < length (doc.m_source))
    code_start_idx = [code_start_idx, par_end_idx(end) + 1];
    code_end_idx = [code_end_idx, length(doc.m_source)];
  endif
  ## Remove overlaps
  idx = code_start_idx > code_end_idx;
  code_start_idx(idx) = [];
  code_end_idx(idx) = [];
  ## Remove empty code blocks
  idx = [];
  for i = 1:numel (code_start_idx)
    if (all (cellfun (@(cstr) isempty (char (cstr)),
                      doc.m_source(code_start_idx(i):code_end_idx(i)))))
      idx = [idx, i];
    endif
  endfor
  code_start_idx(idx) = [];
  code_end_idx(idx) = [];

  ## Try to find a document title and introduction text
  ##   1. First paragraph must start in first line
  ##   2. Second paragraph must start before any code
  title_offset = 0;
  if (is_head (doc.m_source{1})
      && ! isempty (par_start_idx)
      && par_start_idx(1) == 1
      && (isempty (code_start_idx)
          || (length (par_start_idx) > 1
              && par_start_idx(2) < code_start_idx(1))))
    doc.title = doc.m_source{1};
    doc.title = doc.title(4:end);
    content = doc.m_source(2:par_end_idx(1));
    ## Strip leading "# "
    content = cellfun (@(c) cellstr (c(3:end)), content);
    doc.intro = parse_paragraph_content (content);
    title_offset = 1;
  endif

  ## Add non-empty paragraphs and code to doc
  j = 1;
  i = (1 + title_offset);
  while (i <= numel (par_start_idx) || j <= numel (code_start_idx))
    ## Add code while there is code left
    ##   and code is before the next paragraph or there are no more paragraphs
    while (j <= numel (code_start_idx)
           && (i > numel (par_start_idx)
               || par_start_idx(i) > code_start_idx(j)))
      doc.body{end+1}.type = "code";
      lines = [code_start_idx(j), code_end_idx(j)];
      doc.body{end}.content = ...
        strtrim (strjoin (doc.m_source(lines(1):lines(2)), "\n"));
      doc.body{end}.lines = lines;
      doc.body{end}.output = {};
      j++;
    endwhile

    if (i <= numel (par_start_idx))
      type_str = "section";
      title_str = doc.m_source{par_start_idx(i)};
      if (is_head (doc.m_source(par_start_idx(i))))
        title_str = title_str(4:end);
      else
        title_str = title_str(5:end);
      endif
      ## Append, if paragraph title is given
      if (! isempty (title_str))
        doc.body{end+1}.type = type_str;
        doc.body{end}.content = title_str;
      endif

      content = doc.m_source(par_start_idx(i) + 1:par_end_idx(i));
      ## Strip leading "# "
      content = cellfun (@(c) cellstr (c(3:end)), content);
      doc.body = [doc.body, parse_paragraph_content(content)];
      i++;
    endif
  endwhile

endfunction


function p_content = parse_paragraph_content (content)

  ## PARSE_PARAGRAPH_CONTENT second parsing level
  ##
  ##   Parses the content of a paragraph (without potential title) and
  ##   returns a cell vector of structs, that can be appended to doc.body,
  ##   either of
  ##
  ##     a) {struct ("type", "preformatted_code", ...
  ##                 "content", code_str)}
  ##     b) {struct ("type", "preformatted_text", ...
  ##                 "content", text_str)}
  ##     c) {struct ("type", "bulleted_list", ...
  ##                 "content", {"item1", "item2", ..})}
  ##     d) {struct ("type", "numbered_list", ...
  ##                 "content", {"item1", "item2", ..})}
  ##     e) {struct ("type", "include", ...
  ##                 "content", file_str)}
  ##     f) {struct ("type", "graphic", ...
  ##                 "content", file_str)}
  ##     g) {struct ("type", "html", ...
  ##                 "content", html_str)}
  ##     h) {struct ("type", "latex", ...
  ##                 "content", latex_str)}
  ##     i) {struct ("type", "text", ...
  ##                 "content", text_str)}
  ##
  ##   Option i) might contain:
  ##
  ##     * Italic "_", bold "*", and monospaced "|" text
  ##     * Inline "$" and block "$$" LaTeX math
  ##     * Links
  ##     * Trademark symbols

  p_content = cell ();

  if (isempty (content))
    return;
  endif

  ## Extract <html> and <latex> blocks recursively.
  content_str = strjoin (content, "\n");
  tags = {"html", "latex"};
  for i = 1:length (tags)
    tok = regexp (content_str, ...
      ['(.*?)(^|\n\n)(<', tags{i}, '>)\n(.*?)\n(<\/', ...
        tags{i}, '>)($|\n\n)(.*)'], "tokens", "once");
    if (! isempty (tok))
      ## If there was some text before that block --> recursion
      if (! strcmpi (tok{1}, ["<", tags{i}, ">"]))
        p_content = parse_paragraph_content (strsplit (tok{1}, "\n"));
        tok(1:2) = [];
      endif
      ## Extract the block content
      p_content{end+1}.type = tags{i};
      p_content{end}.content = tok{2};
      ## If there was some text after that block --> recursion
      if (length (tok) == 5)
        p_content = [p_content, ...
          parse_paragraph_content(strsplit (tok{5}, "\n"))];
      endif
      return;
    endif
  endfor

  ## Split into blocks separated by empty lines
  idx = [0, find(cellfun (@isempty, content)), length(content) + 1];

  ## For each block
  for i = find (diff (idx) > 1)
    block = content(idx(i) + 1:idx(i+1) - 1);

    ## Octave code (two leading spaces)
    if (all (cellfun (@(c) strncmp (char (c), "  ", 2), block)))
      p_content{end+1}.type = "preformatted_code";
      block = cellfun (@(c) cellstr (c(3:end)), block);
      p_content{end}.content = strjoin (block, "\n");
      continue;
    endif

    ## Preformatted text (one leading space)
    if (all (cellfun (@(c) strncmp (char (c), " ", 1), block)))
      p_content{end+1}.type = "preformatted_text";
      block = cellfun (@(c) cellstr (c(2:end)), block);
      p_content{end}.content = strjoin (block, "\n");
      continue;
    endif

    ## Bulleted list starts with "* "
    if (strncmp (block{1}, "* ", 2))
      p_content{end+1}.type = "bulleted_list";
      tmpstr = strjoin (block, "\n");
      ## Remove first "* "
      tmpstr = tmpstr(3:end);
      ## Split items
      p_content{end}.content = strsplit (tmpstr, "\n* ");
      continue;
    endif

    ## Numbered list starts with "# "
    if (strncmp (block{1}, "# ", 2))
      p_content{end+1}.type = "numbered_list";
      tmpstr = strjoin (block, "\n");
      ## Remove first "# "
      tmpstr = tmpstr(3:end);
      ## Split items
      p_content{end}.content = strsplit (tmpstr, "\n# ");
      continue;
    endif

    ## Include <include>fname.m</include>
    if (! isempty (fname = regexpi (strjoin (block, ""),
                                    '^<include>(.*)</include>$',
                                    "tokens")))
      ## Includes result in preformatted code
      p_content{end+1}.type = "preformatted_code";
      include_code = read_file_to_cellstr (strtrim ((fname{1}){1}));
      p_content{end}.content = strjoin (include_code, "\n");

      continue;
    endif

    ## Graphic <<myGraphic.png>>
    if (! isempty (fname = regexpi (strjoin (block, ""),
                                    '^<<(.*)>>$',
                                    "tokens")))
      p_content{end+1}.type = "graphic";
      p_content{end}.content = strtrim ((fname{1}){1});
      continue;
    endif

    ## Now it can be only normal text or markups belonging to normal text
    ## that are handled while output generation:
    ##
    ## * Italic "_", bold "*", and monospaced "|" text
    ## * Inline "$" and block "$$" LaTeX math
    ## * Links
    ## * Trademark symbols
    p_content{end+1}.type = "text";
    p_content{end}.content = strjoin (block, "\n");
  endfor

endfunction


function m_source = read_file_to_cellstr (file)

  ## READ_FILE_TO_CELLSTR reads a given file line by line into a cellstring
  fid = fopen (file, "r");
  i = 0;
  do
    m_source{++i} = fgetl (fid);
  until (! ischar (m_source{i}))
  fclose (fid);
  m_source = m_source(1:end-1);  # No EOL

endfunction


function ofile = create_output (doc, options)

  ## CREATE_OUTPUT creates the desired output file
  formatter = [];
  switch (options.format)
    case "html"
      formatter = @__publish_html_output__;
    case {"latex", "pdf"}
      formatter = @__publish_latex_output__;
    otherwise
      ## Custom formatter
      formatter = eval (["@__publish_", options.format, "_output__"]);
  endswitch

  ## Use title, or if not given, the m-file name
  title_str = doc.title;
  if (isempty (title_str))
    [~, title_str] = fileparts (doc.m_source_file_name);
  endif

  content = formatter ("header",
                       formatter ("escape_special_chars", title_str),
                       format_output (doc.intro, formatter, options),
                       get_toc (doc.body, formatter));
  content = [content, format_output(doc.body, formatter, options)];
  content = [content, formatter("footer", strjoin (doc.m_source, "\n"))];

  ## Write file
  [~, ofile] = fileparts (doc.m_source_file_name);
  ofile_name = [ofile, formatter("output_file_extension")];
  ofile = fullfile (options.outputDir, ofile_name);
  fid = fopen (ofile, "w");
  fputs (fid, content);
  fclose (fid);

  ## Compile LaTeX, if compiler found
  if (strcmp (options.format, "pdf"))
    status = system ("pdflatex --version");
    if (status == 0)
      for i = 1:2
        ## FIXME: This looks very likely to break when switching OS
        system (["cd ", options.outputDir," && pdflatex ", ofile_name]);
      endfor
    endif
  endif

endfunction


function toc_cstr = get_toc (cstr, formatter)

  ## GET_TOC extracts the table of contents from a cellstring (e.g., doc.body)
  ## with each section headline as a cell in a returned cellstring.
  toc_cstr = cell ();
  for i = 1:numel (cstr)
    if (strcmp (cstr{i}.type, "section"))
      toc_cstr{end+1} = format_text (cstr{i}.content, formatter);
    endif
  endfor

endfunction


function str = format_output (cstr, formatter, options)

  ## FORMAT_OUTPUT steps through all blocks (doc.intro or doc.body) in cstr and
  ## produces a single result string with the source code in the desired output
  ## format.
  ##
  ##   formatter has the only knowledge how to enforce the target format
  ##   and produces for each block the necessary target format source string.
  str = "";
  for i = 1:numel (cstr)
    switch (cstr{i}.type)
      case "code"
        if (options.showCode)
          str = [str, formatter("code", cstr{i}.content)];
        endif
        if ((options.evalCode) && (! isempty (cstr{i}.output)))
          str = [str, formatter("code_output", cstr{i}.output)];
        endif
      case {"text", "section"}
        str = [str, formatter(cstr{i}.type, ...
                              format_text (cstr{i}.content, formatter))];
      case {"bulleted_list", "numbered_list"}
        items = cellfun (@(str) format_text(str, formatter), ...
                         cstr{i}.content, "UniformOutput", false);
        str = [str, formatter(cstr{i}.type, items)];
      otherwise
        str = [str, formatter(cstr{i}.type, cstr{i}.content)];
    endswitch
  endfor

endfunction


function str = format_text (str, formatter)

  ## FORMAT_TEXT formats inline formats in strings.
  ##   These are: links, block/inline math, bold, italic, monospaced, (TM), (R)

  ## Helper to clarify the following regular expressions.  It is suitable for
  ## inline formatting, that is delimited literally at start and end by
  ## 'delim'.  'term' is an indicating character for the end delimiter.
  ##
  ## Best explained by example ('^' start and '$' end of input):
  ##
  ##  Positive matches:
  ##
  ##    ^*bold*$
  ##    ^*bold*.$
  ##    ^(*bold*)$
  ##    ^ *bold* $
  ##    ^Text *bold* text$
  ##    ^*bold text*$
  ##
  ##  Negative matches:
  ##
  ##    ^Text*bold*text$
  ##    ^*bold *$
  ##    ^* bold* $
  ##    ^*bold text *$
  ##
  regex_helper = @(delim, term) ['(^|(?<=\s)|(?=\W))', delim, ...
    '(?!\s)[^', term, ']*(?<!\s)', delim, '($|(?=\s)|(?=\W))'];

  ## Regular expressions for the formats:
  ##
  ## 1) Links "<https://www.someurl.com>"
  ## 2) Links "<octave:Function SOME TEXT>"
  ## 3) Links "<https://www.someurl.com SOME TEXT>"
  ## 4) LaTeX block math "$$x^2$$"
  ## 5) LaTeX inline math "$x^2$"
  ## 6) Bold *text*
  ## 7) Italic _text_
  ## 8) Monospaced |text|
  ## 9) (TM) or (R)
  regexes = {'<\S{3,}[^\s<>]*>', ...
             '<octave:[^\s<>]* *[^<>$]*>', ...
             '<\S{3,}[^\s<>]* *[^<>$]*>', ...
             regex_helper('\$\$', '$'), ...
             regex_helper('\$', '$'), ...
             regex_helper('\*', '*'), ...
             regex_helper('_', '_'), ...
             regex_helper('\|', '|'), ...
             '\((TM|R)\)'};

  ## Function to escape some special characters for the GNU Octave manual,
  ## see https://www.gnu.org/software/texinfo/manual/texinfo/html_node/HTML-Xref-Node-Name-Expansion.html
  texinfo_esc = @(str) strrep (strrep (str, "-", "_002d"), "_", "_005f");

  ## Substitute all occurrences with placeholders
  placeholder_cstr = {};
  plh = 0;
  for i = 1:numel (regexes)
    cstr = regexp (str, regexes{i}, "match");
    for j = 1:numel (cstr)
      plh += 1;
      str = regexprep (str, regexes{i}, ["PUBLISHPLACEHOLDER" num2str(plh)],
                       "once");
      switch (i)
        case 1
          ## Links "<https://www.someurl.com>"
          url = cstr{j};
          cstr{j} = formatter ("link", url(2:end-1), url(2:end-1));
        case 2
          ## Links "<octave:Function SOME TEXT>"
          idx = strfind (cstr{j}, " ")(1);
          url = cstr{j};
          url = texinfo_esc (url(9:idx-1));
          v = version ();
          if (v(end) != '0')  # No official release
            v = "latest";
          else
            v = ["v" v];  # "v6.4.0" etc.
          endif
          url = sprintf ("https://octave.org/doc/%s/XREF%s.html", v, url);
          txt = cstr{j};
          txt = format_text (txt(idx+1:end-1), formatter);
          cstr{j} = formatter ("link", url, txt);
        case 3
          ## Links "<https://www.someurl.com SOME TEXT>"
          idx = strfind (cstr{j}, " ")(1);
          url = cstr{j};
          url = url(2:idx-1);
          txt = cstr{j};
          txt = format_text (txt(idx+1:end-1), formatter);
          cstr{j} = formatter ("link", url, txt);
        case 4
          ## LaTeX block math "$$"
          txt = cstr{j};
          cstr{j} = formatter ("blockmath", txt(3:end-2));
        case 5
          ## LaTeX inline math "$"
          txt = cstr{j};
          cstr{j} = formatter ("inlinemath", txt(2:end-1));
        case 6
          ## Bold
          txt = cstr{j};
          cstr{j} = formatter ("bold", format_text (txt(2:end-1), formatter));
        case 7
          ## Italic
          txt = cstr{j};
          cstr{j} = formatter ("italic", format_text (txt(2:end-1), formatter));
        case 8
          ## Monospaced
          txt = cstr{j};
          cstr{j} = formatter ("monospaced", format_text (txt(2:end-1), ...
                               formatter));
        case 9
          ## (TM) or (R)
          txt = cstr{j};
          cstr{j} = formatter (txt(2:end-1));
      endswitch
    endfor
    placeholder_cstr = [placeholder_cstr, cstr];
  endfor

  ## Replace special symbols
  str = formatter ("escape_special_chars", str);

  ## Restore placeholders
  for i = plh:-1:1
    str = strrep (str, ["PUBLISHPLACEHOLDER" sprintf("%d", i)],
                       placeholder_cstr{i});
  endfor

endfunction


function doc = eval_code (doc, options)

  ## EVAL_CODE Third level parsing
  ##
  ##   Generates the output of the script code and takes care of generated
  ##   figures.

  ## Necessary as the code does not run interactively
  page_screen_output (false, "local");

  ## Remember previously opened figures
  fig_ids = findall (0, "type", "figure");
  [~, fig_name] = fileparts (doc.m_source_file_name);
  fig_num = 1;
  fig_list = struct ();

  ## Evaluate code, that does not appear in the output.
  eval_code_helper (options.codeToEvaluate);

  ## Create a new figure, if there are existing plots
  if (! isempty (fig_ids) && options.useNewFigure)
    figure ();
  endif

  for i = 1:numel (doc.body)
    if (strcmp (doc.body{i}.type, "code"))
      r = doc.body{i}.lines;
      code_str = strjoin (doc.m_source(r(1):r(2)), "\n");
      if (options.catchError)
        try
          doc.body{i}.output = eval_code_helper (code_str);
         catch err
          doc.body{i}.output = cellstr (["error: ", err.message, ...
                                                 "\n\tin:\n\n", code_str]);
        end_try_catch
      else
        doc.body{i}.output = eval_code_helper (code_str);
      endif

      ## Check for newly created figures ...
      fig_ids_new = setdiff (findall (0, "type", "figure"), fig_ids);
      ## ... and save them
      for j = 1:numel (fig_ids_new)
        drawnow ();
        if (isempty (get (fig_ids_new(j), "children")))
          continue;
        endif
        fname = [fig_name, "-", sprintf("%d", fig_num)];
        if (strncmp (options.imageFormat, "eps", 3))
          fname = [fname ".eps"];
        else
          fname = [fname "." options.imageFormat];
        endif
        print_opts = {fig_ids_new(j), ...
                      fullfile(options.outputDir, fname), ...
                      ["-d" options.imageFormat], "-color"};
        if (! isempty (options.maxWidth) && ! isempty (options.maxHeight))
          print_opts{end+1} = sprintf ("-S%d,%d", options.maxWidth,
                                                  options.maxHeight);
        elseif (! isempty (options.maxWidth) || ! isempty (options.maxHeight))
          warning (["publish: specify both options.maxWidth ", ...
                              "and options.maxHeight"]);
        endif
        print (print_opts{:});
        fig_num++;
        delete (fig_ids_new(j));
        fig_elem = cell ();
        fig_elem{1} = struct ("type", "graphic", "content", fname);
        if (isfield (fig_list, num2str (i)))
          fig_elem = [getfield(fig_list, sprintf ("%d", i)), fig_elem];
        endif
        fig_list = setfield (fig_list, sprintf ("%d", i), fig_elem);
        ## Create a new figure, if there are existing plots
        if (isempty (setdiff (findall (0, "type", "figure"), fig_ids)) ...
            && ! isempty (fig_ids) && options.useNewFigure)
          figure ();
        endif
      endfor

      ## Truncate output to desired length
      if (options.maxOutputLines < length (doc.body{i}.output))
        doc.body{i}.output = doc.body{i}.output(1:options.maxOutputLines);
      endif
      doc.body{i}.output = strjoin (doc.body{i}.output, "\n");
    endif
  endfor

  ## Close any figures opened by publish function
  delete (setdiff (findall (0, "type", "figure"), fig_ids));

  ## Insert figures to document
  fig_code_blocks = fieldnames (fig_list);
  body_offset = 0;
  for i = 1:numel (fig_code_blocks)
    elems = getfield (fig_list, fig_code_blocks{i});
    ## Compute index where the figure(s) has to be inserted
    j = str2double (fig_code_blocks{i}) + body_offset;
    doc.body = [doc.body(1:j), elems, doc.body(j+1:end)];
    body_offset = body_offset + numel (elems);
  endfor

endfunction


function cstr = eval_code_helper (__code__)

  ## EVAL_CODE_HELPER evaluates a given string with Octave code in an extra
  ## temporary context and returns a cellstring with the eval output.

  if (isempty (__code__))
    return;
  endif

  eval_context ("load");
  cstr = evalc (__code__);
  ## Split string by lines and preserve blank lines.
  cstr = strsplit (strrep (cstr, "\n\n", "\n \n"), "\n");
  eval_context ("save");

endfunction


function cstr = eval_context (op)

  ## EVAL_CONTEXT temporary evaluation context.
  persistent ctext

  ## Variable cstr in "eval_code_helper" is newly created anyways.
  forbidden_var_names = {"__code__"};

  switch (op)
    case "save"
      ## Clear previous context
      ctext = containers.Map;
      ## Get variable names
      var_names = evalin ("caller", "whos");
      var_names = {var_names.name};
      ## Store all variables to context
      for i = 1:length (var_names)
        if (! any (strcmp (var_names{i}, forbidden_var_names)))
          ctext(var_names{i}) = evalin ("caller", var_names{i});
        endif
      endfor

    case "load"
      if (! isempty (ctext))
        keys = ctext.keys ();
        for i = 1:length (keys)
          assignin ("caller", keys{i}, ctext(keys{i}));
        endfor
      endif

    case "clear"
      ## Clear any context
      ctext = [];

    otherwise
      ## Do nothing

  endswitch

endfunction


## Note: Functional BIST tests are located in the 'test/publish' directory.

## Test input validation
%!error <Invalid call> publish ()
%!error publish (1)
%!error <FILE does not exist> publish ("%%_non_existent_file_%%.m")
%!error <only script files can be published> publish ("publish.m")
%!error publish ("test_script.m", "format", "html", "showCode")
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{output} =} python (@var{scriptfile})
## @deftypefnx {} {@var{output} =} python (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
## @deftypefnx {} {[@var{output}, @var{status}] =} python (@dots{})
## Invoke Python script @var{scriptfile}, possibly with a list of command line
## arguments.
##
## Return output in @var{output} and optional status in @var{status}.  If
## @var{scriptfile} is not an absolute filename it is searched for in the
## current directory and then in the Octave loadpath.
## @seealso{system, perl}
## @end deftypefn

function [output, status] = python (scriptfile = "-c ''", varargin)

  if (ischar (scriptfile)
      && (   (nargin == 1 && ! isempty (scriptfile))
          || (nargin != 1 && iscellstr (varargin))))
    if (! strcmp (scriptfile(1:2), "-c"))
      ## Attempt to find file in loadpath.  No effect for absolute filenames.
      scriptfile = file_in_loadpath (scriptfile);
    endif

    [status, output] = system (["python ", scriptfile, ...
                                sprintf(" %s", varargin{:})]);
  else
    error ("python: invalid arguments");
  endif

endfunction


%!error <invalid arguments> python (123)
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{val} =} recycle ()
## @deftypefnx {} {@var{old_val} =} recycle (@var{new_val})
## Query or set the preference for recycling deleted files.
##
## When recycling is enabled, commands which would permanently erase files
## instead move them to a temporary location (such as the directory labeled
## Trash).
##
## Programming Note: This function is provided for @sc{matlab} compatibility,
## but recycling is not implemented in Octave.  To help avoid accidental data
## loss an error will be raised if an attempt is made to enable file recycling.
## @seealso{delete, rmdir}
## @end deftypefn

function val = recycle (new_val)

  persistent current_state = "off";

  if (nargin == 0 || nargout > 0)
    val = current_state;
  endif

  if (nargin == 1)
    if (! ischar (new_val))
      error ("recycle: NEW_VAL must be a character string");
    endif

    if (strcmpi (new_val, "on"))
      error ("recycle: recycling files is not implemented");
    elseif (strcmpi (new_val, "off"))
      current_state = "off";
    else
      error ("recycle: invalid value '%s'", new_val);
    endif
  endif

endfunction


%!test
%! recycle ("off");
%! assert (recycle ("off"), "off");

%!error recycle ("on", "and I mean it")
%!error <NEW_VAL must be a character string> recycle (1)
%!error <recycling files is not implemented> recycle ("on")
%!error <invalid value 'foobar'> recycle ("foobar")
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} run @var{script}
## @deftypefnx {} {} run ("@var{script}")
## Run @var{script} in the current workspace.
##
## Scripts which reside in directories specified in Octave's load path, and
## which end with the extension @file{.m}, can be run simply by typing
## their name.  For scripts not located on the load path, use @code{run}.
##
## The filename @var{script} can be a bare, fully qualified, or relative
## filename and with or without a file extension.  If no extension is
## specified, Octave will first search for a script with the @file{.m}
## extension before falling back to the script name without an extension.
##
## Implementation Note: If @var{script} includes a path component, then
## @code{run} first changes the working directory to the directory where
## @var{script} is found.  Next, the script is executed.  Finally, @code{run}
## returns to the original working directory @emph{unless} @var{script} has
## specifically changed directories.
## @seealso{path, addpath, source}
## @end deftypefn

function run (script)

  if (nargin < 1)
    print_usage ();
  endif

  [d, f, ext] = fileparts (script);
  if (! strcmp (ext, ".m"))
    ## prefer files with .m extension for compatibility with Matlab
    if (exist ([script ".m"], "file"))
      f = [f ext];
      ext = ".m";
      script = [script ".m"];
    endif
  endif

  if (! exist (script, "file"))
    error ("run: file SCRIPT must exist and be a valid Octave scriptfile");
  endif

  if (! isempty (d))
    if (! isfolder (d))
      error ("run: the path %s doesn't exist", d);
    endif

    startdir = pwd ();
    scriptdir = "";
    unwind_protect
      cd (d);
      scriptdir = pwd ();
      evalin ("caller", sprintf ("source ('%s%s');", f, ext),
              "rethrow (lasterror ())");
    unwind_protect_cleanup
      if (is_same_file (scriptdir, pwd ()))
        cd (startdir);
      endif
    end_unwind_protect

  else
    if (! isempty (ext))
      script = which (script);
    else
      ## Search PATH with null extension ('.' will be stripped and ext = "")
      script = which ([script "."]);
    endif
    evalin ("caller", sprintf ("source ('%s');", script),
            "rethrow (lasterror ())");
  endif

endfunction


## Test script file execution
## Use a variable name that is unlikely to be the name of a function.
%!test
%! clear _5yVNhWVJWJn47RKnzxPsyb_
%! assert (exist ("_5yVNhWVJWJn47RKnzxPsyb_"), 0);
%! tmp_dir = tempname ();
%! test_script = fullfile (tmp_dir, "test_script.m");
%! unwind_protect
%!   mkdir (tmp_dir);
%!   fid = fopen (test_script, "w");
%!   fprintf (fid, "_5yVNhWVJWJn47RKnzxPsyb_ = 1337;\n");
%!   fclose (fid);
%!   run (test_script);
%!   assert (exist ("_5yVNhWVJWJn47RKnzxPsyb_", "var"), 1);
%!   assert (_5yVNhWVJWJn47RKnzxPsyb_, 1337);
%! unwind_protect_cleanup
%!   unlink (test_script);
%!   sts = rmdir (tmp_dir);
%! end_unwind_protect

## Test function file execution
%!test
%! path_orig = path ();
%! tmp_dir = tempname ();
%! test_function = fullfile (tmp_dir, "tf.m");
%! unwind_protect
%!   mkdir (tmp_dir);
%!   fid = fopen (test_function, "w");
%!   fprintf (fid, "function tf ()\n");
%!   fprintf (fid, "  addpath ('%s');\n", tmp_dir);
%!   fprintf (fid, "endfunction\n");
%!   fclose (fid);
%!   ## Check if temporary directory is on the loadpath.
%!   ## Function 'dir_in_loadpath' is broken for this use case, so code a test.
%!   dirs = strsplit (path (), pathsep ());
%!   tstval1 = any (is_same_file (tmp_dir, dirs));
%!   run (test_function);
%!   dirs = strsplit (path (), pathsep ());
%!   tstval2 = any (is_same_file (tmp_dir, dirs));
%!   assert (tstval1, false);
%!   assert (tstval2, true);
%! unwind_protect_cleanup
%!   unlink (test_function);
%!   sts = rmdir (tmp_dir);
%!   path (path_orig);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> run ()
%!error run ("a", "b")
%!error <SCRIPT must exist> run ("__A_very_#unlikely#_file_name__")
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{b} =} saveobj (@var{a})
## Method of a class to manipulate an object prior to saving it to a file.
##
## The function @code{saveobj} is called when the object @var{a} is saved
## using the @code{save} function.  An example of the use of @code{saveobj}
## might be to remove fields of the object that don't make sense to be saved
## or it might be used to ensure that certain fields of the object are
## initialized before the object is saved.  For example:
##
## @example
## @group
## function b = saveobj (a)
##   b = a;
##   if (isempty (b.field))
##      b.field = initfield (b);
##   endif
## endfunction
## @end group
## @end example
##
## @seealso{loadobj, class}
## @end deftypefn

function b = saveobj (a)
  error ('saveobj: not defined for class "%s"', class (a));
endfunction
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{sout} =} setfield (@var{s}, @var{field}, @var{val})
## @deftypefnx {} {@var{sout} =} setfield (@var{s}, @var{sidx1}, @var{field1}, @var{fidx1}, @var{sidx2}, @var{field2}, @var{fidx2}, @dots{}, @var{val})
##
## Return a @emph{copy} of the structure @var{s} with the field member
## @var{field} set to the value @var{val}.
##
## For example:
##
## @example
## @group
## @var{s} = struct ();
## @var{s} = setfield (@var{s}, "foo bar", 42);
## @end group
## @end example
##
## @noindent
## This is equivalent to
##
## @example
## @var{s}.("foo bar") = 42;
## @end example
##
## @noindent
## Note that ordinary structure syntax @code{@var{s}.foo bar = 42} cannot be
## used here, as the field name is not a valid Octave identifier because of
## the space character.  Using arbitrary strings for field names is
## incompatible with @sc{matlab}, and this usage will emit a warning if the
## warning ID @code{Octave:language-extension} is enabled.
## @xref{XREFwarning_ids,,@code{warning_ids}}.
##
## With the second calling form, set a field of a structure array.  The
## input @var{sidx} selects an element of the structure array, @var{field}
## specifies the field name of the selected element, and @var{fidx} selects
## which element of the field (in the case of an array or cell array).
## The @var{sidx}, @var{field}, and @var{fidx} inputs can be repeated to
## address nested structure array elements.  The structure array index and
## field element index must be cell arrays while the field name must be a
## string.
##
## For example:
##
## @example
## @group
## @var{s} = struct ("baz", 42);
## setfield (@var{s}, @{1@}, "foo", @{1@}, "bar", 54)
## @result{}
##   ans =
##     scalar structure containing the fields:
##       baz =  42
##       foo =
##         scalar structure containing the fields:
##           bar =  54
## @end group
## @end example
##
## The example begins with an ordinary scalar structure to which a nested
## scalar structure is added.  In all cases, if the structure index @var{sidx}
## is not specified it defaults to 1 (scalar structure).  Thus, the example
## above could be written more concisely as
## @code{setfield (@var{s}, "foo", "bar", 54)}
##
## Finally, an example with nested structure arrays:
##
## @example
## @group
## @var{sa}.foo = 1;
## @var{sa} = setfield (@var{sa}, @{2@}, "bar", @{3@}, "baz", @{1, 4@}, 5);
## @var{sa}(2).bar(3)
## @result{}
##   ans =
##     scalar structure containing the fields:
##       baz =  0   0   0   5
## @end group
## @end example
##
## Here @var{sa} is a structure array whose field at elements 1 and 2 is in
## turn another structure array whose third element is a simple scalar
## structure.  The terminal scalar structure has a field which contains a
## matrix value.
##
## Note that the same result as in the above example could be achieved by:
##
## @example
## @group
## @var{sa}.foo = 1;
## @var{sa}(2).bar(3).baz(1,4) = 5
## @end group
## @end example
## @seealso{getfield, rmfield, orderfields, isfield, fieldnames, isstruct,
## struct}
## @end deftypefn

function sout = setfield (s, varargin)

  if (nargin < 3)
    print_usage ();
  endif

  subs = varargin(1:end-1);
  val = varargin{end};
  flds = cellfun ("isclass", subs, "char");
  idxs = cellfun ("isclass", subs, "cell");
  if (! all (flds | idxs))
    error ("setfield: invalid index");
  endif

  typs = ifelse (flds, {"."}, {"()"});
  sout = subsasgn (s, struct ("type", typs, "subs", subs), val);

endfunction


%!test
%! x.a = "hello";
%! x = setfield (x, "b", "world");
%! y = struct ("a", "hello", "b", "world");
%! assert (x, y);
%!test
%! oo(1,1).f0 = 1;
%! oo = setfield (oo,{1,2},"fd",{3},"b", {1,4}, 6);
%! assert (oo(1,2).fd(3).b(1,4), 6);

## Test input validation
%!error <Invalid call> setfield ()
%!error <Invalid call> setfield (1)
%!error <Invalid call> setfield (1,2)
%!error <invalid index> setfield (1,2,3)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} substruct (@var{type}, @var{subs}, @dots{})
## Create a subscript structure for use with @code{subsref} or @code{subsasgn}.
##
## For example:
##
## @example
## @group
## idx = substruct ("()", @{3, ":"@})
##   @result{} idx =
##        scalar structure containing the fields:
##          type = ()
##          subs =
##          @{
##            [1,1] =  3
##            [1,2] = :
##          @}
## x = [1, 2, 3;
##      4, 5, 6;
##      7, 8, 9];
## subsref (x, idx)
##   @result{}   7   8   9
## @end group
## @end example
## @seealso{subsref, subsasgn}
## @end deftypefn

function retval = substruct (varargin)

  if (nargin < 2 || mod (nargin, 2) != 0)
    print_usage ();
  endif

  typ = varargin(1:2:nargin);
  sub = varargin(2:2:nargin);
  braces = strcmp (typ, "()") | strcmp (typ, "{}");
  dots = strcmp (typ, ".");
  if (all (braces | dots))
    cells = cellfun ("isclass", sub, "cell");
    chars = cellfun ("isclass", sub, "char");
    if (any (braces & ! cells))
      error ("substruct: for TYPE == () or {}, SUBS must be a cell array");
    elseif (any (dots & ! chars))
      error ("substruct: for TYPE == ., SUBS must be a character string");
    endif
  else
    error ('substruct: TYPE must be one of "()", "{}", or ""');
  endif

  retval = struct ("type", typ, "subs", sub);

endfunction


%!test
%! x(1,1).type = "()";
%! x(1,2).type = "{}";
%! x(1,3).type = ".";
%! x(1,1).subs = {1,2,3};
%! x(1,2).subs = {":"};
%! x(1,3).subs = "foo";
%! y = substruct ("()", {1,2,3}, "{}", {":"}, ".", "foo");
%! assert (x,y);

## Test input validation
%!error <Invalid call> substruct ()
%!error <Invalid call> substruct (1)
%!error <Invalid call> substruct (1, 2, 3)
%!error substruct ("x", 1)
%!error substruct ("()", [1,2,3])
%!error substruct (".", {1,2,3})
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} swapbytes (@var{x})
## Swap the byte order on values, converting from little endian to big endian
## and vice versa.
##
## For example:
##
## @example
## @group
## swapbytes (uint16 (1:4))
## @result{}   256   512   768  1024
## @end group
## @end example
##
## @seealso{typecast, cast}
## @end deftypefn

function y = swapbytes (x)

  if (nargin < 1)
    print_usage ();
  endif

  cls = class (x);
  if (strcmp (cls, "int8") || strcmp (cls, "uint8") || isempty (x))
    y = x;
  else
    if (strcmp (cls, "int16") || strcmp (cls, "uint16"))
      nb = 2;
    elseif (strcmp (cls, "single")
            || strcmp (cls, "int32") || strcmp (cls, "uint32"))
      nb = 4;
    elseif (strcmp (cls, "double")
            || strcmp (cls, "int64") || strcmp (cls, "uint64"))
      nb = 8;
    else
      error ("swapbytes: invalid object of class '%s'", cls);
    endif
    y = reshape (typecast (reshape (typecast (x(:), "uint8"), nb, numel (x))
                           ([nb : -1 : 1], :) (:), cls), size (x));
  endif

endfunction


%!assert (swapbytes (uint16 (1:4)), uint16 ([256 512 768 1024]))
%!test
%! assert (swapbytes (swapbytes (pi)), pi);
%! assert (swapbytes (swapbytes (single (pi))), single (pi));

## Test input validation
%!error <Invalid call> swapbytes ()
%!error <invalid object of class 'cell'> swapbytes ({1})
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{vars} =} symvar (@var{str})
## Identify the symbolic variable names in the string @var{str}.
##
## Common constant names such as @code{i}, @code{j}, @code{pi}, @code{Inf} and
## Octave functions such as @code{sin} or @code{plot} are ignored.
##
## Any names identified are returned in a cell array of strings.  The array is
## empty if no variables were found.
##
## Example:
##
## @example
## @group
## symvar ("x^2 + y^2 == 4")
## @result{} @{
##      [1,1] = x
##      [2,1] = y
##    @}
## @end group
## @end example
## @end deftypefn

function vars = symvar (str)

  warning ("off", "Octave:legacy-function", "local");  # using inline below.
  vars = argnames (inline (str));
  ## Correct for auto-generated 'x' variable when no symvar was found.
  if (numel (vars) == 1 && strcmp (vars{1}, "x") && ! any (str == "x"))
    vars = {};
  endif

endfunction


%!assert (symvar ("3*x + 4*y + 5*cos (z)"), {"x"; "y"; "z"})
%!assert (symvar ("sin ()^2 + cos ()^2 == 1"), {})
%!assert (symvar ("1./x"), {"x"})
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{filelist} =} tar (@var{tarfile}, @var{files})
## @deftypefnx {} {@var{filelist} =} tar (@var{tarfile}, @var{files}, @var{rootdir})
## Pack the list of files and directories specified in @var{files} into the
## TAR archive @var{tarfile}.
##
## @var{files} is a character array or cell array of strings.  Shell wildcards
## in the filename such as @samp{*} or @samp{?} are accepted and expanded.
## Directories are recursively traversed and all files are added to the
## archive.
##
## If @var{rootdir} is defined then any files without absolute pathnames are
## located relative to @var{rootdir} rather than the current directory.
##
## The optional output @var{filelist} is a list of the files that were included
## in the archive.
## @seealso{untar, unpack, bzip2, gzip, zip}
## @end deftypefn

function filelist = tar (tarfile, files, rootdir = ".")

  if (nargin < 2)
    print_usage ();
  endif

  if (! ischar (tarfile))
    error ("tar: TARFILE must be a string");
  elseif (ischar (files))
    files = cellstr (files);
  elseif (! iscellstr (files))
    error ("tar: FILES must be a character array or cellstr");
  endif

  rootdir = tilde_expand (rootdir);

  tarfile = make_absolute_filename (tarfile);

  if (ispc)
    ## Change tarfile into a mingw style acceptable for tar
    tarfile = __w2mpth__ (tarfile);
  endif

  ## BSD tar emits progress on stderr
  if (tar_is_bsd ())
    cmd = sprintf ("tar cvf %s -C %s %s 2>&1",
                            tarfile, rootdir, sprintf (" '%s'", files{:}));
  else
    cmd = sprintf ("tar cvf %s -C %s %s",
                            tarfile, rootdir, sprintf (" %s", files{:}));
  endif

  ## Save and restore the TAR_OPTIONS environment variable used by GNU tar.
  tar_options_env = getenv ("TAR_OPTIONS");
  unwind_protect
    unsetenv ("TAR_OPTIONS");
    [status, output] = system (cmd);
  unwind_protect_cleanup
    if (! isempty (tar_options_env))
      setenv ("TAR_OPTIONS", tar_options_env);
    endif
  end_unwind_protect

  if (status)
    error ("tar: tar exited with status = %d", status);
  endif

  if (nargout > 0)
    filelist = ostrsplit (output, "\r\n", true);
    filelist = filelist';

    ## BSD tar emits file actions in the first 2 columns
    if (tar_is_bsd ())
      filelist = cellfun (@(x) x(3:end), filelist, 'UniformOutput', false);
    endif
  endif

endfunction


## FIXME: This test may fail if the tar command is not installed.  If this
##        test fails, it might be better to change it into a testif with a
##        runtime condition on the tar program.
%!test
%! ## test tar together with untar
%! orig_dir = pwd ();
%! unwind_protect
%!   dirname = tarname = outdir = "";
%!   dirname = tempname ();
%!   assert (mkdir (dirname));
%!   chdir (dirname);
%!   dirname2 = "dir2";
%!   assert (mkdir (dirname2));
%!   fname1 = "file1";
%!   fname2 = fullfile (dirname2, "file2");
%!   fid = fopen (fname1, "wt");
%!   assert (fid >= 0);
%!   fdisp (fid, "Hello World");
%!   fclose (fid);
%!   fid = fopen (fname2, "wt");
%!   assert (fid >= 0);
%!   fdisp (fid, "Goodbye World");
%!   fclose (fid);
%!   tarname = [tempname() ".tar"];
%!   filelist = tar (tarname, {dirname2, fname1});
%!   if (! strcmp (filelist{3}, fname1))
%!     error ("tar file contents does not match expected file");
%!   endif
%!   if (! exist (tarname, "file"))
%!     error ("tar archive file cannot be found!");
%!   endif
%!   outdir = tempname ();
%!   untar (tarname, outdir);
%!   fid = fopen (fullfile (outdir, fname1), "rt");
%!   assert (fid >= 0);
%!   str = fgetl (fid);
%!   fclose (fid);
%!   assert (str, "Hello World");
%!   fid = fopen (fullfile (outdir, fname2), "rt");
%!   assert (fid >= 0);
%!   str = fgetl (fid);
%!   fclose (fid);
%!   assert (str, "Goodbye World");
%! unwind_protect_cleanup
%!   chdir (orig_dir);
%!   unlink (tarname);
%!   confirm_recursive_rmdir (false, "local");
%!   sts = rmdir (dirname, "s");
%!   sts = rmdir (outdir, "s");
%! end_unwind_protect

## Test input validation
%!error <Invalid call> tar ()
%!error <Invalid call> tar (1)
%!error <TARFILE must be a string> tar (1, "foobar")
%!error <FILES must be a character array or cellstr> tar ("foobar", 1)
########################################################################
##
## Copyright (C) 2003-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{dir} =} tempdir ()
## Return the name of the host system's directory for temporary files.
##
## The directory name is taken first from the environment variable
## @env{TMPDIR}.  If that does not exist the system default returned by
## @code{P_tmpdir} is used.
## @seealso{P_tmpdir, tempname, mkstemp, tmpfile}
## @end deftypefn

function dirname = tempdir ()

  dirname = getenv ("TMPDIR");
  if (isempty (dirname))
    dirname = P_tmpdir ();
  endif

  if (! strcmp (dirname(end), filesep))
    dirname = [dirname filesep];
  endif

  if (! isfolder (dirname))
    warning ("tempdir: '%s' does not exist or is not a directory", dirname);
  endif

endfunction


%!assert (ischar (tempdir ()))

%!test
%! old_wstate = warning ("query");
%! warning ("off");
%! old_tmpdir = getenv ("TMPDIR");
%! unwind_protect
%!   setenv ("TMPDIR", "__MY_TMP_DIR__");
%!   assert (tempdir (), ["__MY_TMP_DIR__" filesep()]);
%! unwind_protect_cleanup
%!   if (! isempty (old_tmpdir))
%!     setenv ("TMPDIR", old_tmpdir);
%!   else
%!     unsetenv ("TMPDIR");
%!   endif
%!   warning (old_wstate);
%! end_unwind_protect
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} unix ("@var{command}")
## @deftypefnx {} {@var{status} =} unix ("@var{command}")
## @deftypefnx {} {[@var{status}, @var{text}] =} unix ("@var{command}")
## @deftypefnx {} {[@dots{}] =} unix ("@var{command}", "-echo")
## Execute a system command if running under a Unix-like operating system,
## otherwise do nothing.
##
## Octave waits for the external command to finish before returning the exit
## status of the program in @var{status} and any output in @var{text}.
##
## When called with no output argument, or the @qcode{"-echo"} argument is
## given, then @var{text} is also sent to standard output.
## @seealso{dos, system, isunix, ismac, ispc}
## @end deftypefn

function [status, text] = unix (command, echo_arg)

  if (nargin < 1)
    print_usage ();
  endif

  status = 1;
  text = "";

  if (isunix ())
    [status, text] = system (command);
    if (nargin > 1 || nargout == 0)
      printf ("%s\n", text);
    endif
  endif

endfunction


%!test
%! cmd = ls_command ();
%! [status, output] = unix (cmd);
%!
%! if (isunix ())
%!   assert (status, 0);
%!   assert (ischar (output));
%!   assert (! isempty (output));
%! else
%!   assert (status, 1);
%!   assert (output, "");
%! endif

## Test input validation
%!error <Invalid call> unix ()
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{files} =} unpack (@var{file})
## @deftypefnx {} {@var{files} =} unpack (@var{file}, @var{dir})
## @deftypefnx {} {@var{files} =} unpack (@var{file}, @var{dir}, @var{filetype})
## Unpack the archive @var{file} based on its extension to the directory
## @var{dir}.
##
## If @var{file} is a list of strings, then each file is unpacked
## individually.  Shell wildcards in the filename such as @samp{*} or
## @samp{?} are accepted and expanded.
##
## If @var{dir} is not specified or is empty (@code{[]}), it defaults to the
## current directory.  If a directory is in the file list, then @var{filetype}
## must also be specified.
##
## The specific archive filetype is inferred from the extension of the file.
## The @var{filetype} may also be specified directly using a string which
## corresponds to a known extension.
##
## Valid filetype extensions:
##
## @table @code
## @item  @nospell{bz}
## @itemx @nospell{bz2}
## bzip archive
##
## @item @nospell{gz}
## gzip archive
##
## @item tar
## tar archive
##
## @item  tarbz
## @itemx tarbz2
## @itemx tbz
## @itemx tbz2
## tar + bzip archive
##
## @item  targz
## @itemx tgz
## tar + gzip archive
##
## @item z
## compress archive
##
## @item zip
## zip archive
## @end table
##
## The optional return value is a list of @var{files} unpacked.
## @seealso{bunzip2, gunzip, unzip, untar, bzip2, gzip, zip, tar}
## @end deftypefn

function filelist = unpack (file, dir = [], filetype = "")

  if (nargin < 1)
    print_usage ();
  endif

  if (! ischar (file) && ! iscellstr (file))
    error ("unpack: FILE must be a string or cell array of strings");
  endif

  ## Convert char arrays to cell strings to simplify further processing
  if (ischar (file))
    file = cellstr (file);
  endif
  if (numel (file) == 1)
    ## FIXME: The code below is not a perfect test for a URL
    if (isempty (strfind (file{1}, "://")))
      if (ispc ())
        gfile = __wglob__ (file);
      else
        gfile = glob (file);
      endif
      if (isempty (gfile))
        error ('unpack: FILE "%s" not found', file{1});
      else
        file = gfile;
      endif
    endif
  endif

  ## Recursively unpack cellstr arrays one file at a time
  if (numel (file) > 1)
    files = {};
    for i = 1:numel (file)
      if (! isempty (dir))
        tmpfiles = unpack (file{i}, dir);
      else
        tmpfiles = unpack (file{i}, fileparts (file{i}));
      endif
      files = {files{:} tmpfiles{:}};
    endfor

    ## Return output if requested.
    if (nargout > 0)
      filelist = files;
    endif
    return;

  else
    file = file{1};
  endif

  if (nargin == 3 && (! ischar (filetype) || ! isrow (filetype)))
    error ("unpack: FILETYPE must be a string");
  endif

  if (isfolder (file))
    if (isempty (filetype))
      error ("unpack: FILETYPE must be given for a directory");
    elseif (! strcmpi (filetype, "gz"))
      error ('unpack: FILETYPE must be "gz" for a directory');
    endif
    ext = ".gz";
  else
    [pathstr, name, ext] = fileparts (file);

    if (nargin == 3 && ! strcmpi (ext, filetype))
      ## override extension with given filetype
      if (isempty (ext))
        ext = filetype;
      else
        ext = regexprep (ext, '(\.?)\S*$', ['$1' filetype]);
      endif
    endif

    ## Check to see if it's .tar.gz, .tar.Z, etc.
    if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
      [~, tmpname, tmpext] = fileparts (name);
      if (strcmpi (tmpext, ".tar"))
        name = tmpname;
        ext = [tmpext ext];
      endif
    endif

    ## If the file is a URL, download it and then work with that file.
    if (! isempty (strfind (file, "://")))
      ## FIXME: The above code is not a perfect test for a URL
      urlfile = file;
      tmpfile = fullfile (tempdir (), [name ext]);
      [file, success, msg] = urlwrite (urlfile, tmpfile);
      if (! success)
        error ('unpack: could not fetch "%s": %s', urlfile, msg);
      endif
    endif

  endif

  file = make_absolute_filename (file);

  if (isempty (dir))
    dir = ".";
  else
    dir = tilde_expand (dir);
  endif

  ## Instructions on what to do for any extension.
  ##
  ## The field names are the file extension without periods.
  ## The first cell is what is executed to unpack an archive verbosely.
  ## The second cell is what is executed to unpack an archive quietly.
  ## The third cell is the function to execute on output to get the files list.
  ## The fourth cell indicates if the files may need to be manually moved
  ##   (i.e., tar and unzip decompress into the current directory while
  ##    bzip2 and gzip decompress the file at its location).
  persistent commandlist;
  if (isempty (commandlist))
    commandlist.gz = {'gzip -d -k -v -f -r "%s"', ...
                      'gzip -d -k -f -r "%s"', ...
                      @__parse_gzip__, true};
    commandlist.z = commandlist.gz;
    commandlist.bz2 = {'bzip2 -d -k -v -f "%s"', ...
                       'bzip2 -d -k -f "%s"', ...
                       @__parse_bzip2__, true};
    commandlist.bz = commandlist.bz2;
    commandlist.tar = {'tar xvf "%s"', ...
                       'tar xf "%s"', ...
                       @__parse_tar__, false};
    commandlist.targz = {'gzip -d -c "%s" | tar xvf -', ...
                         'gzip -d -c "%s" | tar xf -', ...
                         @__parse_tar__, false};
    commandlist.tgz = commandlist.targz;
    commandlist.tarbz2 = {'bzip2 -d -c "%s" | tar xvf -', ...
                          'bzip2 -d -c "%s" | tar xf -', ...
                          @__parse_tar__, false};
    commandlist.tarbz = commandlist.tarbz2;
    commandlist.tbz2 = commandlist.tarbz2;
    commandlist.tbz = commandlist.tarbz2;
    commandlist.zip = {'unzip -n "%s"', ...
                       'unzip -nq "%s"', ...
                       @__parse_zip__, false};
  endif

  ## Unzip doesn't actually care about the extension
  if (strcmpi (filetype, "zip"))
    nodotext = "zip";
  else
    nodotext = ext(ext != '.');
  endif

  if (ispc && strcmp (nodotext, "tar"))
    ## Change file pathname into a mingw style acceptable for tar
    file = __w2mpth__ (file);
  endif

  ## Create the output directory if necessary.
  s = stat (dir);
  if (isempty (s))
    [status, msg] = mkdir (dir);
    if (! status)
      error ("unpack: mkdir failed to create %s: %s", dir, msg);
    endif
  elseif (! S_ISDIR (s.mode))
    error ("unpack: %s: not a directory", dir);
  endif

  if (isfield (commandlist, tolower (nodotext)))
    [commandv, commandq, parsefcn, move] = deal (commandlist.(nodotext){:});
    origdir = pwd ();
    if (move)
      startdir = fileparts (file);
    else
      startdir = origdir;
    endif
    cstartdir = make_absolute_filename (startdir);
    cenddir = make_absolute_filename (dir);
    if (cenddir(end) == filesep)
      cenddir(end) = [];
    endif
    needmove = move && ! is_same_file (cstartdir, cenddir);
    if (nargout > 0 || needmove)
      command = commandv;
    else
      command = commandq;
    endif
  else
    warning ("unpack: unrecognized FILETYPE <%s>", nodotext);
    filelist = {};
    return;
  endif

  ## Save and restore the TAR_OPTIONS environment variable used by GNU tar.
  tar_options_env = getenv ("TAR_OPTIONS");
  unwind_protect
    unsetenv ("TAR_OPTIONS");
    cd (dir);
    [status, output] = system (sprintf ([command " 2>&1"], file));
  unwind_protect_cleanup
    cd (origdir);
    if (! isempty (tar_options_env))
      setenv ("TAR_OPTIONS", tar_options_env);
    endif
  end_unwind_protect

  if (status)
    error ("unpack: unarchiving program exited with status: %d\n%s",
           status, output);
  endif

  if (nargout > 0 || needmove)
    ## Trim the last CR or NL if needed.
    files = parsefcn (ostrsplit (output, "\r\n", true))';

    ## Move files if necessary.
    if (needmove)
      [st, msg] = movefile (files, cenddir);
      if (! st)
        error ('unpack: unable to move files to "%s": %s', dir, msg);
      endif

      ## Fix the names of the files since they were moved.
      files = strrep (files, cstartdir, cenddir);
    endif

    ## Return output if requested.
    if (nargout > 0)
      filelist = files;
    endif
  endif

endfunction

function files = __parse_zip__ (output)
  ## Parse the output from zip and unzip.

  ## Skip first line which is Archive header.
  files = char (output(2:end));
  ## Trim constant width prefix and return cell array.
  files = cellstr (files(:,14:end));
endfunction

function output = __parse_tar__ (output)
  ## BSD tar emits file actions in the first 2 columns

  if (tar_is_bsd ())
    output = cellfun (@(x) x(3:end), output, 'UniformOutput', false);
  endif
endfunction

function files = __parse_gzip__ (output)
  ## Parse the output from gzip and gunzip returning the files
  ## compressed (or decompressed).

  files = regexprep (output, '^.+ -- (?:created|replaced with) (.*)$', '$1');
endfunction

function files = __parse_bzip2__ (output)
  ## Parse the output from bzip2 and bunzip2 returning the files
  ## compressed (or decompressed).

  ## Strip leading blanks and .bz2 extension from filename
  files = regexprep (output, '^\s+(.*)\.bz2: .*', '$1');
endfunction


%!testif HAVE_ZLIB
%! envvar = {"TMPDIR", "TMP"};
%! envdir = cellfun (@(x) getenv (x), envvar, "uniformoutput", false);
%! unwind_protect
%!   cellfun (@(x) unsetenv (x), envvar);
%!   ## Create temporary directory and file for packing and unpacking
%!   dirname = tempname ();
%!   assert (mkdir (dirname));
%!   filename = tempname ();
%!   fid = fopen (filename, "wt");
%!   assert (fid >= 0);
%!   fprintf (fid, "Hello World\n");
%!   fprintf (fid, "123 456 789\n");
%!   fclose (fid);
%!
%!   unwind_protect
%!     copyfile (filename, [filename ".orig"]);
%!     gzip (filename, dirname);
%!     [~, f] = fileparts (filename);
%!     filelist = unpack (fullfile (dirname, [f ".gz"]), tempdir);
%!     assert (filelist{1}, filename);
%!     fid = fopen ([filename ".orig"], "rb");
%!     assert (fid >= 0);
%!     orig_data = fread (fid);
%!     fclose (fid);
%!     fid = fopen (filename, "rb");
%!     assert (fid >= 0);
%!     new_data = fread (fid);
%!     fclose (fid);
%!     if (orig_data != new_data)
%!       error ("unpack: Unpacked file does not equal original");
%!     endif
%!   unwind_protect_cleanup
%!     unlink (filename);
%!     unlink ([filename ".orig"]);
%!     confirm_recursive_rmdir (false, "local");
%!     sts = rmdir (dirname, "s");
%!   end_unwind_protect
%! unwind_protect_cleanup
%!   ## Restore environment variables TMPDIR, TMP
%!   for i = 1:numel (envvar)
%!     if (isempty (envdir{i}))
%!       unsetenv (envvar{i});
%!     else
%!       setenv (envvar{i}, envdir{i});
%!     endif
%!   endfor
%! end_unwind_protect

## Test input validation
%!error <Invalid call> unpack ()
%!error <FILE must be a string or cell array of strings> unpack (1)
%!error <FILE "_%NOT_A_FILENAME%_" not found> unpack ("_%NOT_A_FILENAME%_")
%!error <FILE "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_"})
%!error <FILE "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_", "2nd_filename"})
%!error <FILETYPE must be a string>
%! if (isunix || ismac)
%!   unpack ("/", [], 1)
%! else
%!   unpack ('C:\', [], 1)
%! endif
%!error <FILETYPE must be given for a directory>
%! if (isunix || ismac)
%!   unpack ("/");
%! else
%!   unpack ('C:\');
%! endif
%!error <FILETYPE must be "gz" for a directory>
%! if (isunix || ismac)
%!   unpack ("/", [], "foobar");
%! else
%!   unpack ('C:\', [], "foobar");
%! endif
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} untar (@var{tarfile})
## @deftypefnx {} {} untar (@var{tarfile}, @var{dir})
## @deftypefnx {} {@var{filelist} =} untar (@dots{})
## Unpack the TAR archive @var{tarfile}.
##
## If @var{dir} is specified the files are unpacked in this directory rather
## than the current directory.
##
## The optional output @var{filelist} is a list of the uncompressed files.
## @seealso{tar, unpack, bunzip2, gunzip, unzip}
## @end deftypefn

function filelist = untar (tarfile, dir = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (nargout > 0)
    filelist = unpack (tarfile, dir, "tar");
  else
    unpack (tarfile, dir, "tar");
  endif

endfunction


## Tests for this m-file are located in tar.m
## Remove from test statistics
%!assert (1)
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} unzip (@var{zipfile})
## @deftypefnx {} {} unzip (@var{zipfile}, @var{dir})
## @deftypefnx {} {@var{filelist} =} unzip (@dots{})
## Unpack the ZIP archive @var{zipfile}.
##
## If @var{dir} is specified the files are unpacked in this directory rather
## than the current directory.
##
## The optional output @var{filelist} is a list of the uncompressed files.
## @seealso{zip, unpack, bunzip2, gunzip, untar}
## @end deftypefn

function filelist = unzip (zipfile, dir = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (nargout > 0)
    filelist = unpack (zipfile, dir, "zip");
  else
    unpack (zipfile, dir, "zip");
  endif

endfunction


## Tests for this m-file are located in zip.m
## Remove from test statistics
%!assert (1)
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} validateattributes (@var{A}, @var{classes}, @var{attributes})
## @deftypefnx {} {} validateattributes (@var{A}, @var{classes}, @var{attributes}, @var{arg_idx})
## @deftypefnx {} {} validateattributes (@var{A}, @var{classes}, @var{attributes}, @var{func_name})
## @deftypefnx {} {} validateattributes (@var{A}, @var{classes}, @var{attributes}, @var{func_name}, @var{arg_name})
## @deftypefnx {} {} validateattributes (@var{A}, @var{classes}, @var{attributes}, @var{func_name}, @var{arg_name}, @var{arg_idx})
## Check validity of input argument.
##
## Confirms that the argument @var{A} is valid by belonging to one of
## @var{classes}, and holding all of the @var{attributes}.  If it does not,
## an error is thrown, with a message formatted accordingly.  The error
## message can be made further complete by the function name @var{fun_name},
## the argument name @var{arg_name}, and its position in the input
## @var{arg_idx}.
##
## @var{classes} must be a cell array of strings (an empty cell array is
## allowed) with the name of classes (remember that a class name is case
## sensitive).  In addition to the class name, the following categories
## names are also valid:
##
## @table @asis
## @item @qcode{"float"}
## Floating point value comprising classes @qcode{"double"} and
## @qcode{"single"}.
##
## @item @qcode{"integer"}
## Integer value comprising classes (u)int8, (u)int16, (u)int32, (u)int64.
##
## @item @qcode{"numeric"}
## Numeric value comprising either a floating point or integer value.
##
## @end table
##
## @var{attributes} must be a cell array with names of checks for @var{A}.
## Some of them require an additional value to be supplied right after the
## name (see details for each below).
##
## @table @asis
## @item @qcode{"<="}
## All values are less than or equal to the following value in
## @var{attributes}.
##
## @item @qcode{"<"}
## All values are less than the following value in @var{attributes}.
##
## @item @qcode{">="}
## All values are greater than or equal to the following value in
## @var{attributes}.
##
## @item @qcode{">"}
## All values are greater than the following value in @var{attributes}.
##
## @item @qcode{"2d"}
## A 2-dimensional matrix.  Note that vectors and empty matrices have
## 2 dimensions, one of them being of length 1, or both length 0.
##
## @item @qcode{"3d"}
## Has no more than 3 dimensions.  A 2-dimensional matrix is a 3-D matrix
## whose 3rd dimension is of length 1.
##
## @item @qcode{"binary"}
## All values are either 1 or 0.
##
## @item @qcode{"column"}
## Values are arranged in a single column.
##
## @item @qcode{"decreasing"}
## No value is @var{NaN}, and each is less than the preceding one.
##
## @item @qcode{"diag"}
## Value is a diagonal matrix.
##
## @item @qcode{"even"}
## All values are even numbers.
##
## @item @qcode{"finite"}
## All values are finite.
##
## @item @qcode{"increasing"}
## No value is @var{NaN}, and each is greater than the preceding one.
##
## @item @qcode{"integer"}
## All values are integer.  This is different than using @code{isinteger}
## which only checks its an integer type.  This checks that each value in
## @var{A} is an integer value, i.e., it has no decimal part.
##
## @item @qcode{"ncols"}
## Has exactly as many columns as the next value in @var{attributes}.
##
## @item @qcode{"ndims"}
## Has exactly as many dimensions as the next value in @var{attributes}.
##
## @item @qcode{"nondecreasing"}
## No value is @var{NaN}, and each is greater than or equal to the preceding
## one.
##
## @item @qcode{"nonempty"}
## It is not empty.
##
## @item @qcode{"nonincreasing"}
## No value is @var{NaN}, and each is less than or equal to the preceding one.
##
## @item @qcode{"nonnan"}
## No value is a @code{NaN}.
##
## @item @nospell{@qcode{"nonnegative"}}
## All values are non negative.
##
## @item @qcode{"nonsparse"}
## It is not a sparse matrix.
##
## @item @qcode{"nonzero"}
## No value is zero.
##
## @item @qcode{"nrows"}
## Has exactly as many rows as the next value in @var{attributes}.
##
## @item @qcode{"numel"}
## Has exactly as many elements as the next value in @var{attributes}.
##
## @item @qcode{"odd"}
## All values are odd numbers.
##
## @item @qcode{"positive"}
## All values are positive.
##
## @item @qcode{"real"}
## It is a non-complex matrix.
##
## @item @qcode{"row"}
## Values are arranged in a single row.
##
## @item @qcode{"scalar"}
## It is a scalar.
##
## @item @qcode{"size"}
## Its size has length equal to the values of the next in @var{attributes}.
## The next value must is an array with the length for each dimension.  To
## ignore the check for a certain dimension, the value of @code{NaN} can be
## used.
##
## @item @qcode{"square"}
## Is a square matrix.
##
## @item @qcode{"vector"}
## Values are arranged in a single vector (column or vector).
##
## @end table
##
## @seealso{isa, validatestring, inputParser}
## @end deftypefn

function validateattributes (A, cls, attr, varargin)

  if (nargin < 3 || nargin > 6)
    print_usage ();
  elseif (! iscellstr (cls))
    error ("Octave:invalid-type",
           "validateattributes: CLASSES must be a cell array of strings");
  elseif (! iscell (attr))
    error ("Octave:invalid-type",
           "validateattributes: ATTRIBUTES must be a cell array");
  endif

  ## Built start of error message from the extra optional arguments
  func_name = "";
  var_name  = "input";
  if (nargin > 3)
    fourth = varargin{1};
    if (ischar (fourth))
      func_name = [fourth ": "];
    elseif (nargin == 4 && valid_arg_idx (fourth))
      var_name = sprintf ("input %d", fourth);
    else
      error ("Octave:invalid-input-arg",
             "validateattributes: 4th input argument must be ARG_IDX or FUNC_NAME");
    endif

    if (nargin > 4)
      var_name = varargin{2};
      if (! ischar (var_name))
        error ("Octave:invalid-type",
               "validateattributes: VAR_NAME must be a string");
      endif

      if (nargin > 5)
        arg_idx = varargin{3};
        if (! valid_arg_idx (arg_idx))
          error ("Octave:invalid-input-arg",
                 "validateattributes: ARG_IDX must be a positive integer");
        endif
        var_name = sprintf ("%s (argument #%i)", var_name, arg_idx);
      endif
    endif
  endif
  err_ini = [func_name var_name];

  check_cl = isa (A, cls);
  if (! isempty (check_cl) && ! any (check_cl))
    ## Allowing for an empty list of classes is Matlab incompatible but
    ## that should count as a just a Matlab bug, not an incompatibility.

    ## Replace the category names with the classes that belong to it.
    integer = { "int8"  "int16"  "int32"  "int64" ...
               "uint8" "uint16" "uint32" "uint64"};
    float   = {"single" "double"};
    numeric = {integer{:} float{:}};
    cls = replace_cl_group (cls, "integer", integer);
    cls = replace_cl_group (cls, "float",   float  );
    cls = replace_cl_group (cls, "numeric", numeric);
    cls = unique (cls);

    classes = sprintf (" %s", cls{:});
    error ("Octave:invalid-type",
           "%s must be of class:\n\n %s\n\nbut was of class %s",
           err_ini, classes, class (A));
  endif

  ## We use a while loop because some attributes require the following value
  ## in the cell array.  Also, we can't just get the boolean value for the
  ## test and check at the end the error message since some of the tests
  ## require some more complex error message.

  ## It may look like that we don't perform enough input check in this
  ## function (e.g., we don't check if there's a value after the size
  ## attribute).  The reasoning is that this will be a function mostly used
  ## by developers with fairly static input so any problem would be caught
  ## immediately during that function development, it's no dependent on the
  ## final user input.  In addition, it can be called so many times at the
  ## start of every function, we want it to run specially fast.
  idx = 1;
  problem = false; # becomes true when one of the tests fails
  while (idx <= numel (attr))
    ## FIXME: once we use this in Octave core, it might be worthy to find
    ## which attributes are checked more often, and place them in that
    ## order inside the switch block.
    switch (tolower (attr{idx++}))
      case "2d",
        problem = ndims (A) != 2;
        err_id = "Octave:expected-2d";
      case "3d",
        problem = ndims (A) > 3;
        err_id = "Octave:expected-3d";
      case "column",
        problem = ! iscolumn (A);
        err_id = "Octave:expected-column";
      case "row",
        problem = ! isrow (A);
        err_id = "Octave:expected-row";
      case "scalar",
        problem = ! isscalar (A);
        err_id = "Octave:expected-scalar";
      case "vector",
        problem = ! isvector (A);
        err_id = "Octave:expected-vector";
      case "square",
        problem = ! issquare (A);
        err_id = "Octave:expected-square";
      case "diag",
        problem = ! isdiag (A);
        err_id = "Octave:expected-diag";
      case "nonempty",
        problem = isempty (A);
        err_id = "Octave:expected-nonempty";
      case "nonsparse",
        problem = issparse (A);
        err_id = "Octave:expected-nonsparse";
      case "binary",
        problem = ! islogical (A) && ...
                  any ((A(:) != 1) & (A(:) != 0));
        err_id = "Octave:expected-binary";
      case "even",
        problem = any (rem (A(:), 2) != 0);
        err_id = "Octave:expected-even";
      case "odd",
        problem = any (mod (A(:), 2) != 1);
        err_id = "Octave:expected-odd";
      case "integer",
        problem = ! isinteger (A) && ...
                  any (ceil (A(:)) != A(:));
        err_id = "Octave:expected-integer";
      case "real",
        problem = ! isreal (A);
        err_id = "Octave:expected-real";
      case "finite",
        problem = ! isinteger (A) && ...
                  ! all (isfinite (A(:)));
        err_id = "Octave:expected-finite";
      case "nonnan",
        problem = ! isinteger (A) && ...
                  any (isnan (A(:)));
        err_id = "Octave:expected-nonnan";
      case "nonnegative",
        problem = any (A(:) < 0);
        err_id = "Octave:expected-nonnegative";
      case "nonzero",
        problem = any (A(:) == 0);
        err_id = "Octave:expected-nonzero";
      case "positive",
        problem = any (A(:) <= 0);
        err_id = "Octave:expected-positive";
      case "decreasing",
        problem = (any (isnan (A(:)))
                   || any (diff (A(:)) >= 0));
        err_id = "Octave:expected-decreasing";
      case "increasing",
        problem = (any (isnan (A(:)))
                   || any (diff (A(:)) <= 0));
        err_id = "Octave:expected-increasing";
      case "nondecreasing",
        problem = (any (isnan (A(:)))
                   || any (diff (A(:)) <  0));
        err_id = "Octave:expected-nondecreasing";
      case "nonincreasing",
        problem = (any (isnan (A(:)))
                   || any (diff (A(:)) >  0));
        err_id = "Octave:expected-nonincreasing";
      case "size",
        A_size = size (A);
        w_size = attr{idx++};
        A_size(isnan (w_size)) = NaN;
        if (! isequaln (A_size, w_size))
          A_size_str = sprintf ("%dx", size (A))(1:end-1);
          w_size_str = sprintf ("%ix", w_size)(1:end-1);
          w_size_str = strrep (w_size_str, "NaN", "N");
          err_id = "Octave:incorrect-size";
          error (err_id,
                 "%s must be of size %s but was %s",
                 err_ini, w_size_str, A_size_str);
        endif
      case "numel",
        if (numel (A) != attr{idx++})
          err_id = "Octave:incorrect-numel";
          error (err_id,
                 "%s must have %d elements", err_ini, attr{idx-1});
        endif
      case "ncols",
        if (columns (A) != attr{idx++})
          err_id = "Octave:incorrect-numcols";
          error (err_id,
                 "%s must have %d columns", err_ini, attr{idx-1});
        endif
      case "nrows",
        if (rows (A) != attr{idx++})
          err_id = "Octave:incorrect-numrows";
          error (err_id,
                 "%s must have %d rows", err_ini, attr{idx-1});
        endif
      case "ndims",
        ## Note that a [4 5 1] matrix is not considered to have ndims == 3
        ## but is ok for "3d".  This is not a bug.
        if (ndims (A) != attr{idx++})
          err_id = "Octave:incorrect-numdims";
          error (err_id,
                 "%s must have %d dimensions", err_ini, attr{idx-1});
        endif
      case ">"
        if (! all (A(:) > attr{idx++}))
          err_id = "Octave:expected-greater";
          error (err_id,
                 "%s must be greater than %f", err_ini, attr{idx-1});
        endif
      case ">="
        if (! all (A(:) >= attr{idx++}))
          err_id = "Octave:expected-greater-equal";
          error (err_id,
                 "%s must be greater than or equal to %f", err_ini, attr{idx-1});
        endif
      case "<"
        if (! all (A(:) < attr{idx++}))
          err_id = "Octave:expected-less";
          error (err_id,
                 "%s must be less than %f", err_ini, attr{idx-1});
        endif
      case "<="
        if (! all (A(:) <= attr{idx++}))
          err_id = "Octave:expected-less-equal";
          error (err_id,
                 "%s must be less than or equal to %f", err_ini, attr{idx-1});
        endif
      otherwise
        err_id = "Octave:invalid-input-arg";
        error (err_id,
               "validateattributes: unknown ATTRIBUTE %s", attr{idx-1});
    endswitch
    if (problem)
      error (err_id,
             "%s must be %s", err_ini, attr{idx-1});
    endif
  endwhile

endfunction

function retval = valid_arg_idx (arg)
  retval = isnumeric (arg) && isscalar (arg) && arg > 0 && arg == fix (arg);
endfunction

function cls = replace_cl_group (cls, name, group)
  num_pos = strcmpi (cls, name);
  if (any (num_pos))
    cls(num_pos) = [];
    cls(end+1:end+numel (group)) = group;
  endif
endfunction


%!error <double> validateattributes (rand (5), {"uint8"}, {})
%!error <single> validateattributes (uint8 (rand (5)), {"float"}, {})
%!error <2d> validateattributes (rand (5, 5, 5), {}, {"2d"})
%!error <3d> validateattributes (rand (5, 5, 5, 7), {}, {"3d"})
%!error <column> validateattributes (rand (5, 5), {}, {"column"})
%!error <column> validateattributes (rand (1, 5), {}, {"column"})
%!error <row> validateattributes (rand (5, 5), {}, {"row"})
%!error <row> validateattributes (rand (5, 1), {}, {"row"})
%!error <scalar> validateattributes (rand (1, 5), {}, {"scalar"})
%!error <vector> validateattributes (rand (5), {}, {"vector"})
%!error <square> validateattributes (rand (5, 6), {}, {"square"})
%!error <nonempty> validateattributes ([], {}, {"nonempty"})
%!error <nonsparse> validateattributes (sparse(rand(5)), {}, {"nonsparse"})
%!error <binary> validateattributes ("text", {}, {"binary"})
%!error <binary> validateattributes ([0 1 0 3 0], {}, {"binary"})
%!error <even> validateattributes ([2 3 6 8], {}, {"even"})
%!error <even> validateattributes ([2 NaN], {}, {"even"})
%!error <odd> validateattributes ([3 4 7 5], {}, {"odd"})
%!error <odd> validateattributes ([5 NaN], {}, {"odd"})
%!error <integer> validateattributes ([5 5.2 5.7], {}, {"integer"})
%!error <real> validateattributes ([5i 8 9], {}, {"real"})
%!error <finite> validateattributes ([5i Inf 8], {}, {"finite"})
%!error <nonnan> validateattributes ([NaN Inf 8], {}, {"nonnan"})
%!error <nonnegative> validateattributes ([7 8 -9], {}, {"nonnegative"})
%!error <nonzero> validateattributes ([7 8 0], {}, {"nonzero"})
%!error <positive> validateattributes ([7 0 8], {}, {"positive"})
%!error <decreasing> validateattributes ([7 8 4 3 -5], {}, {"decreasing"})
%!error <decreasing> validateattributes ([7 NaN 4 3 -5], {}, {"decreasing"})
%!error <increasing> validateattributes ([7 8 4 9 20], {}, {"increasing"})
%!error <increasing> validateattributes ([7 8 NaN 9 20], {}, {"increasing"})
%!error <nonincreasing> validateattributes ([7 8 4 9 20], {}, {"nonincreasing"})
%!error <nonincreasing> validateattributes ([7 8 NaN 9 20], {}, {"nonincreasing"})
%!error <nondecreasing> validateattributes ([7 8 4 3 -5], {}, {"nondecreasing"})
%!error <nondecreasing> validateattributes ([7 NaN 4 3 -5], {}, {"nondecreasing"})
%!error <size> validateattributes (ones (5, 3, 6), {}, {"size", [5 4 7]})
%!error <size> validateattributes (ones (5, 3, 6), {}, {"size", [5 NaN 7]})
%!error <size> validateattributes (ones (5, 3, 6), {}, {"size", [5 3 6 2]})
%!error <elements> validateattributes (ones (6, 3), {}, {"numel", 12})
%!error <columns> validateattributes (ones (6, 2), {}, {"ncols", 3})
%!error <rows> validateattributes (ones (6, 2), {}, {"nrows", 3})
%!error <dimensions> validateattributes (ones (6, 2, 6, 3), {}, {"ndims", 3})
%!error <greater than> validateattributes ([6 7 8 5], {}, {">", 5})
%!error <greater than> validateattributes ([6 7 8 5], {}, {">=", 6})
%!error <less than> validateattributes ([6 7 8 5], {}, {"<", 8})
%!error <less than> validateattributes ([6 7 8 5], {}, {"<=", 7})
%!error <diag> validateattributes ([0 0 0; 0 0 0; 1 0 0], {}, {"diag"})
%!error <diag> validateattributes (repmat (eye (3), [1 1 3]), {}, {"diag"})

%!test
%! validateattributes (rand (5), {"numeric"}, {});
%! validateattributes (rand (5), {"float"}, {});
%! validateattributes (rand (5), {"double"}, {});
%! validateattributes ("text", {"char"}, {});
%! validateattributes (rand (5), {}, {"2d"});
%! validateattributes (rand (5), {}, {"3d"});
%! validateattributes (rand (5, 5, 5), {}, {"3d"});
%! validateattributes (rand (5, 1), {}, {"column"});
%! validateattributes (rand (1, 5), {}, {"row"});
%! validateattributes ("a", {}, {"scalar"});
%! validateattributes (5, {}, {"scalar"});
%! validateattributes (rand (1, 5), {}, {"vector"});
%! validateattributes (rand (5, 1), {}, {"vector"});
%! validateattributes (rand (5), {}, {"square"});
%! validateattributes (rand (5), {}, {"nonempty"});
%! validateattributes (rand (5), {}, {"nonsparse"});
%! validateattributes ([0 1 0 1 0], {}, {"binary"});
%! validateattributes (rand (5) > 0.5, {}, {"binary"});
%! validateattributes ([8 4 0 6], {}, {"even"});
%! validateattributes ([-1 3 5], {}, {"odd"});
%! validateattributes ([8 4 0 6], {}, {"real"});
%! validateattributes ([8 4i 0 6], {}, {"finite"});
%! validateattributes (uint8 ([8 4]), {}, {"finite"});
%! validateattributes ([8 Inf], {}, {"nonnan"});
%! validateattributes ([0 7 4], {}, {"nonnegative"});
%! validateattributes ([-8 7 4], {}, {"nonzero"});
%! validateattributes ([8 7 4], {}, {"positive"});
%! validateattributes ([8 7 4 -5], {}, {"decreasing"});
%! validateattributes ([-8 -7 4 5], {}, {"increasing"});
%! validateattributes ([8 4 4 -5], {}, {"nonincreasing"});
%! validateattributes ([-8 -8 4 5], {}, {"nondecreasing"});
%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 6 7 2]});
%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 NaN 7 2]});
%! validateattributes (rand (4, 6, 7, 2), {}, {"size", [4 6 NaN 2 NaN]});
%! validateattributes (rand (6, 2), {}, {"numel", 12});
%! validateattributes (rand (6, 2), {}, {"ncols", 2});
%! validateattributes (rand (6, 2), {}, {"nrows", 6});
%! validateattributes (rand (6, 2, 4, 5), {}, {"ndims", 4});
%! validateattributes ([4 5 6 7], {}, {">", 3});
%! validateattributes ([4 5 6 7], {}, {">=", 4});
%! validateattributes ([4 5 6 7], {}, {"<", 8});
%! validateattributes ([4 5 6 7], {}, {"<=", 7});
%! validateattributes (eye (3), {}, {"diag"});
%! validateattributes ([1 0 0; 0 1 0; 0 0 1], {}, {"diag"});
%! validateattributes (zeros (3), {}, {"diag"});

%!test
%! validateattributes ([0 1 0 1], {"double", "uint8"}, {"binary", "size", [NaN 4], "nonnan"});

%!test
%! try validateattributes (ones(1,2,3), {"numeric"}, {"2d"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-2d");
%! end_try_catch

%!test
%! try validateattributes (ones(1,2,3,4), {"numeric"}, {"3d"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-3d");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"column"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-column");
%! end_try_catch

%!test
%! try validateattributes ([1 2].', {"numeric"}, {"row"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-row");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"scalar"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-scalar");
%! end_try_catch

%!test
%! try validateattributes (ones(3), {"numeric"}, {"vector"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-vector");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"size", [1 1]});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:incorrect-size");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"numel", 7});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:incorrect-numel");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"ncols", 7});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:incorrect-numcols");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"nrows", 7});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:incorrect-numrows");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"ndims", 5});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:incorrect-numdims");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"square"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-square");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"diag"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-diag");
%! end_try_catch

%!test
%! try validateattributes ([], {"numeric"}, {"nonempty"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nonempty");
%! end_try_catch

%!test
%! try validateattributes (speye(2), {"numeric"}, {"nonsparse"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nonsparse");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {">", 3});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-greater");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {">=", 3});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-greater-equal");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"<", -3});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-less");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"<=", -3});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-less-equal");
%! end_try_catch

%!test
%! try validateattributes (3, {"numeric"}, {"binary"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-binary");
%! end_try_catch

%!test
%! try validateattributes (1, {"numeric"}, {"even"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-even");
%! end_try_catch

%!test
%! try validateattributes (2, {"numeric"}, {"odd"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-odd");
%! end_try_catch

%!test
%! try validateattributes (1.1, {"numeric"}, {"integer"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-integer");
%! end_try_catch

%!test
%! try validateattributes (1+1i*2, {"numeric"}, {"real"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-real");
%! end_try_catch

%!test
%! try validateattributes (Inf, {"numeric"}, {"finite"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-finite");
%! end_try_catch

%!test
%! try validateattributes (NaN, {"numeric"}, {"nonnan"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nonnan");
%! end_try_catch

%!test
%! try validateattributes (-1, {"numeric"}, {"nonnegative"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nonnegative");
%! end_try_catch

%!test
%! try validateattributes (0, {"numeric"}, {"nonzero"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nonzero");
%! end_try_catch

%!test
%! try validateattributes (-1, {"numeric"}, {"positive"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-positive");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"decreasing"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-decreasing");
%! end_try_catch

%!test
%! try validateattributes ([2 1], {"numeric"}, {"increasing"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-increasing");
%! end_try_catch

%!test
%! try validateattributes ([1 0], {"numeric"}, {"nondecreasing"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nondecreasing");
%! end_try_catch

%!test
%! try validateattributes ([1 2], {"numeric"}, {"nonincreasing"});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:expected-nonincreasing");
%! end_try_catch

%!test
%! try validateattributes (@sin, {"numeric"}, {});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:invalid-type");
%! end_try_catch

%!test
%! try validateattributes (@sin, 1, {});
%! catch id,
%! assert (getfield (id, "identifier"), "Octave:invalid-type");
%! end_try_catch
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} ver
## @deftypefnx {} {} ver Octave
## @deftypefnx {} {} ver @var{package}
## @deftypefnx {} {v =} ver (@dots{})
##
## Display a header containing the current Octave version number, license
## string, and operating system.  The header is followed by a list of installed
## packages, versions, and installation directories.
##
## Use the package name @var{package} or Octave to query a specific component.
##
## When called with an output argument, return a vector of structures
## describing Octave and each installed package.  Each structure includes the
## following fields.
##
## @table @code
## @item Name
## Package name.
##
## @item Version
## Version of the package.
##
## @item Release
## Release of the package (currently unused, defaults to @code{[]}).
##
## @item Date
## Date that the version was released.
## @end table
##
## @seealso{version, usejava, pkg}
## @end deftypefn

function retval = ver (package = "")

  if (nargout == 0)
    hg_id = __octave_config_info__ ("hg_id");

    [unm, err] = uname ();

    if (err)
      os_string = "unknown";
    else
      os_string = sprintf ("%s %s %s %s",
                           unm.sysname, unm.release, unm.version, unm.machine);
    endif

    hbar(1:70) = "-";
    desc = {hbar
            ["GNU Octave Version: " OCTAVE_VERSION " (hg id: " hg_id ")"]
            ["GNU Octave License: " license]
            ["Operating System: " os_string]
            hbar};

    printf ("%s\n", desc{:});

    if (isempty (package))
      pkg ("list");
    elseif (strcmpi (package, "Octave"))
      ## Nothing to do, Octave version was already reported
    else
      pkg ("list", package);
    endif
  else
    ## Return outputs rather than displaying summary to screen.
    if (isempty (package))
      ## Start with the version info for Octave
      [octver, octdate] = version ();
      retval = struct ("Name", "Octave", "Version", octver,
                       "Release", [], "Date", octdate);
      lst = pkg ("list");
      for i = 1:numel (lst)
        retval(end+1) = struct ("Name", lst{i}.name, "Version", lst{i}.version,
                                "Release", [], "Date", lst{i}.date);
      endfor
    elseif (strcmpi (package, "Octave"))
      [octver, octdate] = version ();
      retval = struct ("Name", "Octave", "Version", octver,
                       "Release", [], "Date", octdate);
    else
      lst = pkg ("list", package);
      if (isempty (lst))
        retval = struct ("Name", {}, "Version", {}, "Release", {}, "Date", {});
      else
        retval = struct ("Name", lst{1}.name, "Version", lst{1}.version,
                         "Release", [], "Date", lst{1}.date);
      endif
    endif
  endif

endfunction


%!test
%! result = ver;
%! assert (result(1).Name, "Octave");
%! assert (result(1).Version, OCTAVE_VERSION ());
%! assert (result(1).Release, []);
%! assert (result(1).Date, __octave_config_info__ ("release_date"));
%! result = ver ("octave");
%! assert (result.Name, "Octave");
%! assert (result.Version, OCTAVE_VERSION ());
%! assert (result.Release, []);
%! assert (result.Date, __octave_config_info__ ("release_date"));

%!test
%! lst = pkg ("list");
%! for n = 1:numel (lst)
%!   expected = lst{n}.name;
%!   result = ver (expected);
%!   assert (result.Name, expected);
%!   assert (isfield (result, "Version"), true);
%!   assert (isfield (result, "Release"), true);
%!   assert (isfield (result, "Date"), true);
%! endfor

%!test
%! result = ver ("%_an_unknown_package_%");
%! assert (isempty (result), true);
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} verLessThan (@var{package}, @var{version})
## Return true if the installed version of the package is less than
## @var{version}.
##
## @var{package} is the name of the package to check.  Use @qcode{"Octave"} as
## the @var{package} to check the version of Octave itself.
##
## @var{version} is the version to compare it to.  A version is a string in the
## format accepted by @code{compare_versions}: an arbitrarily long string
## composed of numeric and period characters, possibly followed by an arbitrary
## string (e.g., @qcode{"1.2.3"}, @qcode{"0.3"}, @qcode{"0.1.2+"}, or
## @qcode{"1.2.3.4-test1"}).
##
## Examples:
##
## @example
## @group
## tf = verLessThan ("Octave", "5")
## @result{} tf = 0
##
## tf = verLessThan ("io", "2.4.12")
## @result{} ...
##
## if (! verLessThan ("Octave", "5"))
##   ## ... use new Octave 5 features ...
## endif
## @end group
## @end example
##
## @seealso{compare_versions, version, ver, pkg}
## @end deftypefn

function retval = verLessThan (package, version)

  if (nargin != 2)
    print_usage ();
  endif

  if (! ischar (package) || rows (package) != 1)
    error ("verLessThan: PACKAGE must be a string");
  endif

  v = ver ();
  idx = find (strcmpi (package, {v.Name}));
  if (isempty (idx))
    error ('verLessThan: package "%s" is not installed', package);
  endif

  retval = compare_versions (v(idx).Version, version, "<");

endfunction


%!assert (! verLessThan ("Octave", "0"))
%!assert (! verLessThan ("Octave", "6"))
%!assert (! verLessThan ("Octave", "3.0.0"))
%!assert (verLessThan ("Octave", "99.9.9"))

## Test input validation
%!error <Invalid call> verLessThan ()
%!error verLessThan ("a")
%!error verLessThan ("a", "1", "b")
%!error <package "no-such-package" is not installed>
%! verLessThan ("no-such-package", "1.1.1")
%!error <compare_versions: version numbers V1 and V2 must be strings>
%! verLessThan ("Octave", 4.1)
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{v} =} version ()
## @deftypefnx {} {[@var{v}, @var{d}] =} version ()
## @deftypefnx {} {@var{v} =} version (@var{feature})
## Get version information for Octave.
##
## If called without input argument, the first return value @var{v} gives the
## version number of Octave as a string.  The second return value @var{d} holds
## the release date as a string.
##
## The following options can be passed for @var{feature}:
##
## @table @asis
## @item @qcode{"-date"}
## for the release date of the running build,
##
## @item @qcode{"-description"}
## for a description of the release (always an empty string),
##
## @item @qcode{"-release"}
## for the name of the running build (always an empty string),
##
## @item @qcode{"-java"}
## for version information of the Java @nospell{VM},
##
## @item @qcode{"-fftw"}
## for version information for the linked @sc{fftw},
##
## @item @qcode{"-blas"}
## for version information for the linked @sc{blas},
##
## @item @qcode{"-lapack"}
## for version information for the linked @sc{lapack}.
##
## @item @qcode{"-hgid"}
## the mercurial ID of the sources used to build Octave.
## @end table
##
## The information returned for the @qcode{"-blas"} and @qcode{"-lapack"}
## options might be unreliable.  It might report which library was linked in
## when Octave was built instead of which library is currently used.
##
## The variant with no input and output argument is an alias for the function
## @w{@env{OCTAVE_VERSION}} provided for compatibility.
## @seealso{OCTAVE_VERSION, ver}
## @end deftypefn

function [v, d] = version (feature)

  if (nargin == 1 && (nargout > 1 || ! ischar (feature)))
    print_usage ();
  endif

  if (nargin == 0)
    v = OCTAVE_VERSION ();

    if (nargout > 1)
      d = __octave_config_info__ ("release_date");
    endif
  else
    switch (lower (feature))
      case "-date"
        v = __octave_config_info__ ("release_date");
      case "-description"
        v = "";
      case "-release"
        v = "";
      case "-java"
        try
          jversion = javaMethod ("getProperty", "java.lang.System", ...
                                 "java.runtime.version");
          jvendor = javaMethod ("getProperty", "java.lang.System", ...
                                "java.vendor");
          jname = javaMethod ("getProperty", "java.lang.System", ...
                              "java.vm.name");
          jjitmode = javaMethod ("getProperty", "java.lang.System", ...
                                 "java.vm.info");
          v = ["Java " jversion " with " jvendor " " jname " " jjitmode];
        catch err
          v = sprintf ("no usable Java Runtime Environment (%s) found:\n%s", ...
                       uname ().machine, err.message);
        end_try_catch
      case "-fftw"
        v = __octave_config_info__ ("fftw_version");
      case "-blas"
        v = __blas_version__ ();
      case "-lapack"
        v = __lapack_version__ ();
      case "-hgid"
        v = __octave_config_info__ ("hg_id");
      otherwise
        error ("version: invalid FEATURE");
    endswitch
  endif

endfunction


%!assert (ischar (version ()))

%!test
%! [v, d] = version ();
%! assert (v, OCTAVE_VERSION);
%! assert (d, __octave_config_info__ ("release_date"));

%!assert (version ("-date"), __octave_config_info__ ("release_date"))

%!assert (version ("-description"), "")
%!assert (version ("-release"), "")
%!assert (ischar (version ("-blas")))
%!assert (ischar (version ("-LAPACK")))

## Test input validation
%!error version ("-date", "-release")
%!error [v, d] = version ("-date")
%!error version (1)
%!error <invalid FEATURE> version ("-foobar")
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} what
## @deftypefnx {} {} what @var{dir}
## @deftypefnx {} {w =} what (@var{dir})
## List the Octave specific files in directory @var{dir}.
##
## If @var{dir} is not specified then the current directory is used.
##
## If a return argument is requested, the files found are returned in the
## structure @var{w}.  The structure contains the following fields:
##
## @table @asis
## @item path
## Full path to directory @var{dir}
##
## @item m
## Cell array of m-files
##
## @item mat
## Cell array of mat files
##
## @item mex
## Cell array of mex files
##
## @item oct
## Cell array of oct files
##
## @item mdl
## Cell array of mdl files
##
## @item slx
## Cell array of slx files
##
## @item p
## Cell array of p-files
##
## @item classes
## Cell array of class directories (@file{@@@var{classname}/})
##
## @item packages
## Cell array of package directories (@file{+@var{pkgname}/})
## @end table
##
## Compatibility Note: Octave does not support mdl, slx, and p files.
## @code{what} will always return an empty list for these categories.
## @seealso{which, ls, exist}
## @end deftypefn

function retval = what (dir)

  if (nargin == 0)
    dir = { pwd() };
  else
    dtmp = canonicalize_file_name (dir);
    if (isempty (dtmp))
      dtmp = {};
    else
      dtmp = {dtmp};
    endif
    ## Search for directory name in path
    if (dir(end) == '/' || dir(end) == '\')
      dir(end) = [];
    endif
    dtmp = unique ([dtmp; dir_in_loadpath(dir, "all")]);

    if (isempty (dtmp) && nargout == 0)
      printf ("%s not found\n", dir);
      return;
    endif

    dir = dtmp;
  endif

   ## Lookup info for each directory
   for i = 1 : numel (dir)
     w(i) = __what__ (dir{i});
   endfor

   ## If none was found, return an empty struct
   if (numel (dir) == 0)
     w = __what__ ("");
     w = resize (w, [0, 1]);  # Matlab compatibility, return 0x1 empty array
   endif

  if (nargout == 0)
    for i = 1 : numel (w)
      __print_fnames__ ("M-files in directory", w(i).path, w(i).m);
      __print_fnames__ ("\nMAT-files in directory", w(i).path, w(i).mat);
      __print_fnames__ ("\nMEX-files in directory", w(i).path, w(i).mex);
      __print_fnames__ ("\nOCT-files in directory", w(i).path, w(i).oct);
      __print_fnames__ ("\nClasses in directory", w(i).path, w(i).classes);
      __print_fnames__ ("\nPackages in directory", w(i).path, w(i).packages);
    endfor
  else
    retval = w;
  endif

endfunction


## what() functionality for a single directory
function w = __what__ (dir)

  files = readdir (dir);
  w.path = dir;
  w.m = cell (0, 1);
  w.mat = cell (0, 1);
  w.mex = cell (0, 1);
  w.oct = cell (0, 1);
  w.mdl = cell (0, 1);
  w.slx = cell (0, 1);
  w.p = cell (0, 1);
  w.classes = cell (0, 1);
  w.packages = cell (0, 1);

  for i = 1 : numel (files)
    nm = files{i};

    if (strcmp (nm, ".") || strcmp (nm, ".."))
      continue;   # Ignore . and ..
    endif

    ## mdl, slx, and p are ignored (no if test) since they are not implemented
    [~, f, e] = fileparts (nm);
    if (strcmp (e, ".m"))
      if (isfile (fullfile (dir, nm)))
        w.m{end+1} = nm;
      endif
    elseif (strcmp (e, ".mat"))
      if (isfile (fullfile (dir, nm)))
        w.mat{end+1} = nm;
      endif
    elseif (strcmp (e, ".oct"))
      if (isfile (fullfile (dir, nm)))
        w.oct{end+1} = nm;
      endif
    elseif (strcmp (e, ['.' mexext]))
      if (isfile (fullfile (dir, nm)))
        w.mex{end+1} = nm;
      endif
    elseif (nm(1) == "@")
      if (isfolder (fullfile (dir, nm)))
        w.classes{end+1} = nm;
      endif
    elseif (nm(1) == "+")
      if (isfolder (fullfile (dir, nm)))
        w.packages{end+1} = nm;
      endif
    endif

  endfor

endfunction


## Pretty print filenames to terminal
function __print_fnames__ (msg, p, f)

  if (! isempty (f))
    printf ("%s %s:\n\n", msg, p);
    printf ("%s", list_in_columns (f, 0, "   "));
  endif

endfunction


%!test
%! w = what ();
%! assert (w.path, pwd);
%! assert (fieldnames (w), {"path"; "m"; "mat"; "mex"; "oct"; "mdl"; "slx";
%!                          "p"; "classes"; "packages"});

## FIXME: Should have additional tests.  Possibly create a temporary directory
## within TMPDIR, create files and folders, and call what() on that dir.
%!error what (1, 2)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{filelist} =} zip (@var{zipfile}, @var{files})
## @deftypefnx {} {@var{filelist} =} zip (@var{zipfile}, @var{files}, @var{rootdir})
## Compress the list of files and directories specified in @var{files} into the
## ZIP archive @var{zipfile}.
##
## @var{files} is a character array or cell array of strings.  Shell
## wildcards in the filename such as @samp{*} or @samp{?} are accepted and
## expanded.  Directories are recursively traversed and all files are
## compressed and added to the archive.
##
## If @var{rootdir} is defined then any files without absolute pathnames are
## located relative to @var{rootdir} rather than the current directory.
##
## The optional output @var{filelist} is a list of the files that were included
## in the archive.
## @seealso{unzip, unpack, bzip2, gzip, tar}
## @end deftypefn

function filelist = zip (zipfile, files, rootdir = ".")

  if (nargin < 2)
    print_usage ();
  endif

  if (! ischar (zipfile))
    error ("zip: ZIPFILE must be a string");
  elseif (ischar (files))
    files = cellstr (files);
  elseif (! iscellstr (files))
    error ("zip: FILES must be a character array or cellstr");
  endif

  rootdir = tilde_expand (rootdir);

  zipfile = make_absolute_filename (zipfile);

  ## FIXME: This is a lot of processing that could be done by the shell
  ##        if Octave had a way to call system without passing a single string.
  ## Escape bad shell characters
  files = regexprep (files, "([|&;<>()$`\\'\" ])", '\\$1');
  files = sprintf (' %s', files{:});   # convert to space separated list
  zipfile = regexprep (zipfile, "'", "\\'");  # escape single quotes
  cmd = sprintf ("zip -r '%s' %s", zipfile, files);
  if (ispc () && ! isunix ())
    cmd = strrep (cmd, '\', '/');
  endif

  origdir = pwd ();
  cd (rootdir);
  [status, output] = system (cmd);
  cd (origdir);

  if (status)
    error ("zip: zip failed with exit status = %d", status);
  endif

  if (nargout > 0)
    cmd = sprintf ("unzip -Z -1 '%s'", zipfile);
    [status, filelist] = system (cmd);
    if (status)
      error ("zip: zipinfo failed with exit status = %d", status);
    endif
    filelist = ostrsplit (filelist, "\r\n", true);
  endif

endfunction


## FIXME: This test may fail if the zip or unzip command is not installed.
##        If this test fails, it might be better to change it into a testif
##        with a runtime condition on the zip and unzip programs.
%!test
%! ## test zip together with unzip
%! unwind_protect
%!   filename = tempname ();
%!   tmp_var  = pi;
%!   save (filename, "tmp_var");
%!   dirname = tempname ();
%!   mkdir (dirname);
%!   zipfile = tempname ();
%!   [~, basename, ext] = fileparts (filename);
%!   filelist = zip (zipfile, [basename ext], tempdir);
%!   filelist = filelist{1};
%!   if (! strcmp (filelist, [basename ext]))
%!     error ("zip archive does not contain expected name!");
%!   endif
%!   if (! exist ([zipfile ".zip"], "file"))
%!     error ("zip file cannot be found!");
%!   endif
%!   unzip ([zipfile ".zip"], dirname);
%!   fid = fopen (filename, "rb");
%!   assert (fid >= 0);
%!   orig_data = fread (fid);
%!   fclose (fid);
%!   fid = fopen ([dirname filesep basename ext], "rb");
%!   assert (fid >= 0);
%!   new_data = fread (fid);
%!   fclose (fid);
%!   if (orig_data != new_data)
%!     error ("unzipped file not equal to original file!");
%!   endif
%! unwind_protect_cleanup
%!   sts = unlink (filename);
%!   sts = unlink ([dirname, filesep, basename, ext]);
%!   sts = unlink (zipfile);
%!   sts = unlink ([zipfile ".zip"]);
%!   sts = rmdir (dirname);
%! end_unwind_protect

## Test input validation
%!error <Invalid call> zip ()
%!error <Invalid call> zip (1)
%!error <ZIPFILE must be a string> zip (1, "foobar")
%!error <FILES must be a character array or cellstr> zip ("foobar", 1)
encoding=utf-8
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} import PACKAGE.FUNCTION
## @deftypefnx {} {} import PACKAGE.CLASS
## @deftypefnx {} {} import PACKAGE.*
## @deftypefnx {} {} import
## @deftypefnx {} {@var{list} =} import
##
## Import function or classes into the current scope.
##
## @strong{Warning:} This functionality is not yet implemented, and invoking
## the function will emit an error.
##
## When invoked with the name of a PACKAGE and a FUNCTION or CLASS name, that
## name is made available in the current code without having to use namespace
## qualifiers.  This can facilitate the readability of the code, and require
## less typing by programmers.
##
## Example
##
## @example
## @group
## import containers.Map;
##
## m = Map (@{"A", "B"@}, @{[1], [2]@});
## @end group
## @end example
##
## When called with no inputs and no outputs @code{import} prints a list of
## any import definitions.
##
## When called with no inputs and one output, a cell array of strings
## @var{list} is returned with any import definitions.
##
## @end deftypefn

function list = import (varargin)

  error ("the import function is not yet implemented in Octave");

endfunction


%!error <not yet implemented> import ("foobar")
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} matlabroot ()
## Return the name of the top-level Octave installation directory.
##
## This is an alias for the function @w{@code{OCTAVE_HOME}} provided for
## compatibility.
## @seealso{OCTAVE_HOME}
## @end deftypefn

function retval = matlabroot ()

  retval = OCTAVE_HOME ();

endfunction


%!assert (matlabroot (), OCTAVE_HOME ())
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{val} =} pathdef ()
## Return the default path for Octave.
##
## The path information is extracted from one of four sources.
## The possible sources, in order of preference, are:
##
## @enumerate
## @item @file{.octaverc}
##
## @item @file{~/.octaverc}
##
## @item @file{<OCTAVE_HOME>/@dots{}/<version>/m/startup/octaverc}
##
## @item Octave's path prior to changes by any octaverc file.
## @end enumerate
## @seealso{path, addpath, rmpath, genpath, savepath}
## @end deftypefn

function val = pathdef ()

  ## Locate any project-specific .octaverc file.
  proj_octaverc = fullfile (pwd, ".octaverc");
  if (exist (proj_octaverc, "file"))
    proj_path = __extractpath__ (proj_octaverc);
    if (! isempty (proj_path))
      val = proj_path;
      return;
    endif
  endif

  ## Locate the user's ~/.octaverc file.
  user_octaverc = fullfile ("~", ".octaverc");
  if (exist (user_octaverc, "file"))
    user_path = __extractpath__ (user_octaverc);
    if (! isempty (user_path))
      val = user_path;
      return;
    endif
  endif

  ## No user octaverc file, locate the site octaverc file.
  pathdir = __octave_config_info__ ("localstartupfiledir");
  site_octaverc = fullfile (pathdir, "octaverc");
  site_path = __extractpath__ (site_octaverc);
  if (! isempty (site_path))
    val = site_path;
    return;
  endif

  ## No project, user, or site octaverc file.  Use Octave's default.
  val = __pathorig__ ();

endfunction

## Extract the path information from the script/function @var{file}, created by
## @file{savepath.m}.  If successful, @code{__extractpath__} returns the path
## specified in @var{file}.

function path = __extractpath__ (savefile)

  [filelines, startline, endline] = getsavepath (savefile);
  if (startline > 0)
    tmp = regexprep (filelines(startline+1:endline-1),
                     "^.*path \\('([^\']+)'.*$", "$1");
    path = strjoin (tmp, ":");
  else
    path = "";
  endif

endfunction


## Test that pathdef does not contain a newly added directory
%!test
%! path_orig = path ();
%! tmp_dir = tempname ();
%! unwind_protect
%!   mkdir (tmp_dir);
%!   ## Required on Windows to make sure an 8.3 name is converted to full name
%!   ## which is what is always stored in path().  See bug #59039.
%!   tmp_dir = canonicalize_file_name (tmp_dir);
%!   addpath (tmp_dir);
%!   p1 = path ();
%!   p2 = pathdef ();
%!   assert (! isempty (strfind (p1, tmp_dir)));
%!   assert (isempty (strfind (p2, tmp_dir)));
%! unwind_protect_cleanup
%!   sts = rmdir (tmp_dir);
%!   path (path_orig);
%! end_unwind_protect

## Test that pathdef does not modify the current load path
%!test <*51994>
%! path_orig = path ();
%! tmp_dir = tempname ();
%! unwind_protect
%!   mkdir (tmp_dir);
%!   tmp_dir = canonicalize_file_name (tmp_dir);
%!   addpath (tmp_dir);
%!   path_1 = path ();
%!   p = pathdef ();
%!   path_2 = path ();
%!   assert (path_1, path_2);
%! unwind_protect_cleanup
%!   sts = rmdir (tmp_dir);
%!   path (path_orig);
%! end_unwind_protect

## Test input validation
%!error pathdef (1)
%!error pathdef ("/")
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

function [filelines, startline, endline] = getsavepath (file)

  beginstring = "## Begin savepath auto-created section, do not edit";
  endstring   = "## End savepath auto-created section";

  ## Read in the file while checking for errors along the way.
  startline = endline = 0;
  filelines = {};
  if (exist (file) == 2)
    [fid, msg] = fopen (file, "rt");
    if (fid < 0)
      error ("getsavepath: could not open file, %s: %s", file, msg);
    endif
    linenum = 0;
    while (ischar (line = fgetl (fid)))
      filelines{++linenum} = line;
      ## Find the first and last lines if they exist in the file.
      if (strcmp (line, beginstring))
        startline = linenum;
      elseif (strcmp (line, endstring))
        endline = linenum;
      endif
    endwhile
    if (fclose (fid) < 0)
      error ("getsavepath: could not close file after reading, %s", file);
    endif
  endif

  ## Verify the file was correctly formatted.
  if (startline > endline || (startline > 0 && endline == 0))
    error ("getsavepath: unable to parse file, %s", file);
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} savepath ()
## @deftypefnx {} {} savepath (@var{file})
## @deftypefnx {} {@var{status} =} savepath (@dots{})
## Save the unique portion of the current function search path that is
## not set during Octave's initialization process to @var{file}.
##
## If @var{file} is omitted, Octave looks in the current directory for a
## project-specific @file{.octaverc} file in which to save the path
## information.  If no such file is present then the user's configuration file
## @file{~/.octaverc} is used.
##
## If successful, @code{savepath} returns 0.
##
## The @code{savepath} function makes it simple to customize a user's
## configuration file to restore the working paths necessary for a particular
## instance of Octave.  Assuming no filename is specified, Octave will
## automatically restore the saved directory paths from the appropriate
## @file{.octaverc} file when starting up.  If a filename has been specified
## then the paths may be restored manually by calling @code{source @var{file}}.
## @seealso{path, addpath, rmpath, genpath, pathdef}
## @end deftypefn

function retval = savepath (file)

  beginstring = "## Begin savepath auto-created section, do not edit";
  endstring   = "## End savepath auto-created section";

  ## Use project-specific or user's .octaverc when no file specified
  if (nargin == 0)
    file = fullfile (pwd, ".octaverc");
    if (! exist (file, "file"))
      file = fullfile ("~", ".octaverc");
    endif
  endif

  ## Read in the file
  [filelines, startline, endline] = getsavepath (file);

  ## Determine where the savepath lines are placed in the file.
  if (isempty (filelines)
      || (startline == 1 && endline == length (filelines)))
    ## savepath is the entire file.
    pre = post = {};
  elseif (endline == 0)
    ## Drop the savepath statements at the end of the file.
    pre = filelines;
    post = {};
  elseif (startline == 1)
    pre = {};
    post = filelines(endline+1:end);
  elseif (endline == length (filelines))
    pre = filelines(1:startline-1);
    post = {};
  else
    ## Insert in the middle.
    pre = filelines(1:startline-1);
    post = filelines(endline+1:end);
  endif

  ## Write the results.
  [fid, msg] = fopen (file, "wt");
  if (fid < 0)
    error ("savepath: unable to open FILE for writing, %s, %s", file, msg);
  endif
  unwind_protect
    fprintf (fid, "%s\n", pre{:});

    ## Remove the portion of the path defined via the command line
    ## and/or the environment.
    workingpath = parsepath (path);
    cmd_line_path = parsepath (command_line_path ());
    octave_path = parsepath (getenv ("OCTAVE_PATH"));
    default_path = pathdef ();
    if (isempty (default_path))
      ## This occurs when running octave via run-octave.  In this instance
      ## the entire path is specified via the command line and pathdef()
      ## is empty.
      [~, n] = setdiff (workingpath, octave_path);
      default_path = cmd_line_path;
    else
      [~, n] = setdiff (workingpath, union (cmd_line_path, octave_path));
      default_path = parsepath (default_path);
    endif
    ## This is the path we'd like to preserve when octave is run.
    path_to_preserve = workingpath(sort (n));

    ## Determine the path to Octave's user and system wide packages.
    [pkg_user, pkg_system] = pkg ("list");

    ## Conversion from cell array of structs to cellstr of archprefixes.
    pkg_path = unique (cellfun (@(elt) elt.archprefix,
                                [pkg_user, pkg_system],
                                "uniformoutput", false));

    ## Rely on Octave's initialization to include the pkg path elements.
    if (! isempty (pkg_path))
      [~, n] = setdiff (path_to_preserve, strcat (pkg_path, ":"));
      path_to_preserve = path_to_preserve(sort (n));
    endif

    ## Split the path to be saved into two groups.  Those path elements that
    ## belong at the beginning and those at the end.
    if (! isempty (default_path))
      n1 = find (strcmp (default_path{1}, path_to_preserve));
      n2 = find (strcmp (default_path{end}, path_to_preserve));
      n_middle = round ((n1+n2)/2);
      [~, n] = setdiff (path_to_preserve, default_path);
      path_to_save = path_to_preserve(sort (n));
      ## Remove pwd
      path_to_save(strcmp (path_to_save, ["." pathsep])) = [];
      if (! isempty (path_to_save))
        n = ones (numel (path_to_save), 1);
        for m = 1:numel (path_to_save)
          n(m) = find (strcmp (path_to_save{m}, path_to_preserve));
        endfor
        path_to_save_begin = path_to_save(n <= n_middle);
        path_to_save_end   = path_to_save(n > n_middle);
      else
        path_to_save_begin = {};
        path_to_save_end   = {};
      endif
    else
      path_to_save_begin = path_to_preserve;
      path_to_save_end   = {};
    endif
    path_to_save_begin = cell2mat (path_to_save_begin);
    path_to_save_end   = cell2mat (path_to_save_end);

    ## Use single quotes for PATH argument to avoid string escape
    ## processing.  Since we are using single quotes around the arg,
    ## double any single quote characters found in the string.
    fprintf (fid, "%s\n", beginstring);
    if (! isempty (path_to_save_begin))
      n = find (path_to_save_begin != pathsep, 1, "last");
      fprintf (fid, "  addpath ('%s', '-begin');\n",
               strrep (path_to_save_begin(1:n), "'", "''"));
    endif
    if (! isempty (path_to_save_end))
      n = find (path_to_save_end != pathsep, 1, "last");
      fprintf (fid, "  addpath ('%s', '-end');\n",
               strrep (path_to_save_end(1:n), "'", "''"));
    endif
    fprintf (fid, "%s\n", endstring);

    fprintf (fid, "%s\n", post{:});
  unwind_protect_cleanup
    status = fclose (fid);
    if (status < 0)
      error ("savepath: could not close savefile after writing, %s", file);
    elseif (nargin == 0)
      warning ("off", "backtrace", "local");
      warning ("Octave:savepath-local",
               "savepath: current path saved to %s", file);
    endif
  end_unwind_protect

  if (nargout > 0)
    retval = 0;
  endif

endfunction

## Convert single string of paths to cell array of paths
function path_elements = parsepath (p)
  path_elements = strcat (ostrsplit (p, pathsep), pathsep);
endfunction


%!test
%! fname = tempname ();
%! test_dir = tempname ();
%! unwind_protect
%!   if (! mkdir (test_dir))
%!     error ("unable to create directory for tests");
%!   endif
%!   status = savepath (fname);
%!   assert (status == 0);
%!   old_dir = pwd ();
%!   unwind_protect
%!     cd (test_dir);
%!     if (exist (fullfile (pwd, ".octaverc")))
%!       unlink (".octaverc");
%!     endif
%!     ## Create blank .octaverc file
%!     fid = fopen (".octaverc", "wt");
%!     assert (fid >= 0);
%!     fclose (fid);
%!     ## Save path into local .octaverc file
%!     warning ("off", "Octave:savepath-local", "local");
%!     status = savepath ();
%!     assert (status == 0);
%!     ## Compare old and new versions
%!     fid = fopen (fname, "rb");
%!     assert (fid >= 0);
%!     orig_data = fread (fid);
%!     fclose (fid);
%!     fid = fopen (".octaverc", "rb");
%!     assert (fid >= 0);
%!     new_data = fread (fid);
%!     fclose (fid);
%!     assert (orig_data, new_data);
%!   unwind_protect_cleanup
%!     cd (old_dir);
%!   end_unwind_protect
%! unwind_protect_cleanup
%!   confirm_recursive_rmdir (false, "local");
%!   sts = rmdir (test_dir, "s");
%!   unlink (fname);
%! end_unwind_protect
encoding=utf-8
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} pkg @var{command} @var{pkg_name}
## @deftypefnx {} {} pkg @var{command} @var{option} @var{pkg_name}
## @deftypefnx {} {[@var{out1}, @dots{}] =} pkg (@var{command}, @dots{} )
## Manage or query packages (groups of add-on functions) for Octave.
##
## Packages can be installed globally (i.e., for all users of the system) or
## locally (i.e., for the current user only).
##
## Global packages are installed by default in a system-wide location.  This is
## usually a subdirectory of the folder where Octave itself is installed.
## Therefore, Octave needs write access to this folder to install global
## packages, which is usually only available when Octave is run with
## administrative privileges, such as when run as root (or superuser) on
## Unix-like systems, or run with elevated privileges ("Run as administrator")
## on Windows.
##
## In contrast, local packages are installed by default in the user's home
## directory (or user profile on Windows) and are only available to that
## specific user.  Usually, they can be installed without administrative
## privileges.
##
## When Octave is running with administrative privileges, @code{pkg} will
## install packages to the global package location by default.  Otherwise,
## packages will be installed to the local location by default.  The user can
## override this default installation location with optional arguments
## (@option{-local} or @option{-global}) as described below.  The currently
## used default package installation location can be queried with
## @code{pkg prefix}.
##
## For global and local packages, there are separate databases holding the
## information about the installed packages.  If some package is installed
## globally as well as locally, the local installation takes precedence over
## ("shadows") the global one.  Which (global or local) package installation is
## used can also be manipulated by using prefixes and/or using the
## @samp{local_list} input argument.  Using these mechanisms, several different
## releases of the same package can be installed side by side as well (but
## cannot be loaded simultaneously).
##
## Packages might depend on external software and/or other packages.  To be
## able to install such packages, these dependencies should be installed
## beforehand.  A package that depends on other package(s) can still be
## installed using the @option{-nodeps} flag.  The effects of unsatisfied
## dependencies on external software---like libraries---depends on the
## individual package.
##
## Packages must be loaded before they can be used.  When loading a package,
## Octave performs the following tasks:
## @enumerate
## @item
## If the package depends on other packages (and @code{pkg load} is called
## without the @option{-nodeps} option), the package is not loaded
## immediately.  Instead, those dependencies are loaded first (recursively if
## needed).
##
## @item
## When all dependencies are satisfied, the package's subdirectories are
## added to the search path.
## @end enumerate
##
## This load order leads to functions that are provided by dependencies being
## potentially shadowed by functions of the same name that are provided by
## top-level packages.
##
## Each time, a package is added to the search path, initialization script(s)
## for the package are automatically executed if they are provided by the
## package.
##
## Depending on the value of @var{command} and on the number of requested
## return arguments, @code{pkg} can be used to perform several tasks.
## Possible values for @var{command} are:
##
## @table @samp
##
## @item install
## Install named packages.  For example,
##
## @example
## pkg install image-1.0.0.tar.gz
## @end example
##
## @noindent
## installs the package found in the file @file{image-1.0.0.tar.gz}.  The
## file containing the package can be a URL, e.g.,
##
## @example
## pkg install 'http://somewebsite.org/image-1.0.0.tar.gz'
## @end example
##
## @noindent
## installs the package found in the given URL@.  This
## requires an internet connection and the cURL library.
##
## @noindent
## @emph{Security risk}: no verification of the package is performed
## before the installation.  It has the same security issues as manually
## downloading the package from the given URL and installing it.
##
## @noindent
## @emph{No support}: the GNU Octave community is not responsible for
## packages installed from foreign sites.  For support or for
## reporting bugs you need to contact the maintainers of the installed
## package directly (see the @file{DESCRIPTION} file of the package)
##
## The @var{option} variable can contain options that affect the manner
## in which a package is installed.  These options can be one or more of
##
## @table @code
## @item -nodeps
## The package manager will disable dependency checking.  With this option it
## is possible to install a package even when it depends on another package
## which is not installed on the system.  @strong{Use this option with care.}
##
## @item -local
## A local installation (package available only to current user) is forced,
## even if Octave is being run with administrative privileges.
##
## @item -global
## A global installation (package available to all users) is forced, even if
## Octave is not being run with administrative privileges.  The user must have
## write access to the global package store.
##
## @item -forge
## Install a package directly from the Octave Forge repository.  This
## requires an internet connection and the cURL library.
##
## @emph{Security risk}: no verification of the package is performed
## before the installation.  There are no signatures for packages, or
## checksums to confirm the correct file was downloaded.  It has the
## same security issues as manually downloading the package from the
## Octave Forge repository and installing it.
##
## @item -verbose
## The package manager will print the output of all commands as
## they are performed.
## @end table
##
## @item update
## Check installed Octave Forge packages against repository and update any
## outdated items.  Updated packages are installed either globally or locally
## depending on whether Octave is running with elevated privileges.  This
## requires an internet connection and the cURL library.
##
## Options for the install command and the names of individual packages to be
## checked for updates may be specified as a list following the update
## command. If the @option{-local} or @option{-global} option is specified,
## @code{pkg update} limits the update check to the local or global installed
## packages, and installs updates in that same context.  For example,
##
## Update all packages:
## @example
## pkg update
## @end example
##
## Update all local packages:
## @example
## pkg update -local
## @end example
##
## Update certain packages, ignore dependencies, max verbosity:
## @example
## pkg update -verbose -nodeps image signal geometry
## @end example
##
## @noindent
## Updates for multiple packages are sorted alphabetically and not checked
## for dependencies affected by installation order.  If dependency order
## related @code{pkg update} failure occurs, use @code{pkg update -nodeps} to
## ignore dependencies, or @code{pkg install -forge <package_name>} to update
## individual packages manually.
##
## @item uninstall
## Uninstall named packages.  For example,
##
## @example
## pkg uninstall image
## @end example
##
## @noindent
## removes the @code{image} package from the system.  If another installed
## package depends on the @code{image} package an error will be issued.
## The package can be uninstalled anyway by using the @option{-nodeps} option.
##
## @item load
## Add named packages to the path.  After loading a package it is
## possible to use the functions provided by the package.  For example,
##
## @example
## pkg load image
## @end example
##
## @noindent
## adds the @code{image} package to the path.
##
## Note: When loading a package, @code{pkg} will automatically try to load
## any unloaded dependencies as well, unless the @option{-nodeps} flag has
## been specified.  For example,
##
## @example
## pkg load signal
## @end example
##
## @noindent
## adds the @code{signal} package and also tries to load its dependency: the
## @code{control} package.  Be aware that the functionality of package(s)
## loaded will probably be impacted by use of the @option{-nodeps} flag.  Even
## if necessary dependencies are loaded later, the functionality of top-level
## packages can still be affected because the optimal loading order may not
## have been followed.
##
## @item unload
## Remove named packages from the path.  After unloading a package it is
## no longer possible to use the functions provided by the package.  Trying
## to unload a package that other loaded packages still depend on will result
## in an error; no packages will be unloaded in this case.  A package can
## be forcibly removed with the @option{-nodeps} flag, but be aware that the
## functionality of dependent packages will likely be affected.  As when
## loading packages, reloading dependencies after having unloaded them with the
## @option{-nodeps} flag may not restore all functionality of the dependent
## packages as the required loading order may be incorrect.
##
## @item list
## Show the list of currently installed packages.  For example,
##
## @example
## pkg list
## @end example
##
## @noindent
## will produce a short report with the package name, version, and installation
## directory for each installed package.  Supply a package name to limit
## reporting to a particular package.  For example:
##
## @example
## pkg list image
## @end example
##
## If a single return argument is requested then @code{pkg} returns a cell
## array where each element is a structure with information on a single
## package.
##
## @example
## installed_packages = pkg ("list")
## @end example
##
## If two output arguments are requested @code{pkg} splits the list of
## installed packages into those which were installed by the current user,
## and those which were installed by the system administrator.
##
## @example
## [user_packages, system_packages] = pkg ("list")
## @end example
##
## The @qcode{"-forge"} option lists packages available at the Octave Forge
## repository.  This requires an internet connection and the cURL library.
## For example:
##
## @example
## oct_forge_pkgs = pkg ("list", "-forge")
## @end example
##
## @item describe
## Show a short description of installed packages.  With the option
## @qcode{"-verbose"} also list functions provided by the package.  For
## example,
##
## @example
## pkg describe -verbose
## @end example
##
## @noindent
## will describe all installed packages and the functions they provide.
## Display can be limited to a set of packages:
##
## @example
## @group
## ## describe control and signal packages
## pkg describe control signal
## @end group
## @end example
##
## If one output is requested a cell of structure containing the
## description and list of functions of each package is returned as
## output rather than printed on screen:
##
## @example
## desc = pkg ("describe", "secs1d", "image")
## @end example
##
## @noindent
## If any of the requested packages is not installed, @code{pkg} returns an
## error, unless a second output is requested:
##
## @example
## [desc, flag] = pkg ("describe", "secs1d", "image")
## @end example
##
## @noindent
## @var{flag} will take one of the values @qcode{"Not installed"},
## @qcode{"Loaded"}, or
## @qcode{"Not loaded"} for each of the named packages.
##
## @item prefix
## Set the installation prefix directory.  For example,
##
## @example
## pkg prefix ~/my_octave_packages
## @end example
##
## @noindent
## sets the installation prefix to @file{~/my_octave_packages}.
## Packages will be installed in this directory.
##
## It is possible to get the current installation prefix by requesting an
## output argument.  For example:
##
## @example
## pfx = pkg ("prefix")
## @end example
##
## The location in which to install the architecture dependent files can be
## independently specified with an addition argument.  For example:
##
## @example
## pkg prefix ~/my_octave_packages ~/my_arch_dep_pkgs
## @end example
##
## @item local_list
## Set the file in which to look for information on locally
## installed packages.  Locally installed packages are those that are
## available only to the current user.  For example:
##
## @example
## pkg local_list ~/.octave_packages
## @end example
##
## It is possible to get the current value of local_list with the following
##
## @example
## pkg local_list
## @end example
##
## @item global_list
## Set the file in which to look for information on globally
## installed packages.  Globally installed packages are those that are
## available to all users.  For example:
##
## @example
## pkg global_list /usr/share/octave/octave_packages
## @end example
##
## It is possible to get the current value of global_list with the following
##
## @example
## pkg global_list
## @end example
##
## @item build
## Build a binary form of a package or packages.  The binary file produced
## will itself be an Octave package that can be installed normally with
## @code{pkg}.  The form of the command to build a binary package is
##
## @example
## pkg build builddir image-1.0.0.tar.gz @dots{}
## @end example
##
## @noindent
## where @code{builddir} is the name of a directory where the temporary
## installation will be produced and the binary packages will be found.
## The options @option{-verbose} and @option{-nodeps} are respected, while
## all other options are ignored.
##
## @item rebuild
## Rebuild the package database from the installed directories.  This can
## be used in cases where the package database has been corrupted.
##
## @item test
## Perform the built-in self tests contained in all functions provided by
## the named packages.  For example:
##
## @example
## pkg test image
## @end example
##
## @end table
## @seealso{ver, news}
## @end deftypefn

function [local_packages, global_packages] = pkg (varargin)

  ## Installation prefix
  persistent user_prefix = false;
  persistent prefix = false;
  persistent archprefix = -1;
  persistent local_list = fullfile (user_config_dir (), "octave", ...
                                    __octave_config_info__ ("api_version"), ...
                                    "octave_packages");
  persistent global_list = fullfile (OCTAVE_HOME (), "share", "octave", ...
                                     "octave_packages");

  ## If user is superuser (posix) or the process has elevated rights (Windows),
  ## set global_install to true.
  if (ispc () && ! isunix ())
    global_install = __is_elevated_process__ ();
  else
    global_install = (geteuid () == 0);
  endif

  if (! user_prefix)
    [prefix, archprefix] = default_prefix (global_install);
    prefix = tilde_expand (prefix);
    archprefix = tilde_expand (archprefix);
  endif

  mlock ();

  confirm_recursive_rmdir (false, "local");

  ## valid actions in alphabetical order
  available_actions = {"build", "describe", "global_list",  "install", ...
                       "list", "load", "local_list", "prefix", "rebuild", ...
                       "test", "uninstall", "unload", "update"};

  ## Parse input arguments
  if (isempty (varargin) || ! iscellstr (varargin))
    print_usage ();
  endif
  files = {};
  deps = true;
  action = "none";
  verbose = false;
  octave_forge = false;
  for i = 1:numel (varargin)
    switch (varargin{i})
      case "-nodeps"
        deps = false;
      ## TODO completely remove these warnings after some releases.
      case "-noauto"
        warning ("Octave:deprecated-option",
                 ["pkg: autoload is no longer supported.  The -noauto "...
                  "option is no longer required."]);
      case "-auto"
        warning ("Octave:deprecated-option",
                 ["pkg: autoload is no longer supported.  Add a "...
                  "'pkg load ...' command to octaverc instead."]);
      case "-verbose"
        verbose = true;
        ## Send verbose output to pager immediately.  Change setting locally.
        page_output_immediately (true, "local");
      case "-forge"
        if (! __octave_config_info__ ("CURL_LIBS"))
          error ("pkg: can't download from Octave Forge without the cURL library");
        endif
        octave_forge = true;
      case "-local"
        global_install = false;
        if (! user_prefix)
          [prefix, archprefix] = default_prefix (global_install);
        endif
      case "-global"
        global_install = true;
        if (! user_prefix)
          [prefix, archprefix] = default_prefix (global_install);
        endif
      case available_actions
        if (! strcmp (action, "none"))
          error ("pkg: more than one action specified");
        endif
        action = varargin{i};
      otherwise
        files{end+1} = varargin{i};
    endswitch
  endfor

  if (octave_forge && ! any (strcmp (action, {"install", "list"})))
    error ("pkg: '-forge' can only be used with install or list");
  endif

  ## Take action
  switch (action)
    case "list"
      if (octave_forge)
        if (nargout)
          local_packages = list_forge_packages ();
        else
          list_forge_packages ();
        endif
      else
        if (nargout == 1)
          local_packages = installed_packages (local_list, global_list, files);
        elseif (nargout > 1)
          [local_packages, global_packages] = installed_packages (local_list,
                                                                  global_list,
                                                                  files);
        else
          installed_packages (local_list, global_list, files);
        endif
      endif

    case "install"
      if (isempty (files))
        error ("pkg: install action requires at least one filename");
      endif

      local_files = {};
      tmp_dir = tempname ();
      unwind_protect

        if (octave_forge)
          [urls, local_files] = cellfun ("get_forge_download", files,
                                         "uniformoutput", false);
          [files, succ] = cellfun ("urlwrite", urls, local_files,
                                   "uniformoutput", false);
          succ = [succ{:}];
          if (! all (succ))
            i = find (! succ, 1);
            error ("pkg: could not download file %s from URL %s",
                   local_files{i}, urls{i});
          endif
        else
          ## If files do not exist, maybe they are not local files.
          ## Try to download them.
          not_local_files = cellfun (@(x) isempty (glob (x)), files);
          if (any (not_local_files))
            [success, msg] = mkdir (tmp_dir);
            if (success != 1)
              error ("pkg: failed to create temporary directory: %s", msg);
            endif

            for file = files(not_local_files)
              file = file{1};
              [~, fname, fext] = fileparts (file);
              tmp_file = fullfile (tmp_dir, [fname fext]);
              local_files{end+1} = tmp_file;
              looks_like_url = regexp (file, '^\w+://');
              if (looks_like_url)
                [~, success, msg] = urlwrite (file, local_files{end});
                if (success != 1)
                  error ("pkg: failed downloading '%s': %s", file, msg);
                endif
                ## Verify that download is a tarball,
                ## to protect against ISP DNS hijacking.
                ## FIXME: Need a test which does not rely on external OS.
                #{
                if (isunix ())
                  [ok, file_descr] = ...
                    system (sprintf ('file "%s" | cut -d ":" -f 2', ...
                                     local_files{end}));
                  if (! ok)
                    if (strfind (file_descr, "HTML"))
                      error (["pkg: Invalid package file downloaded from " ...
                              "%s\n" ...
                              "File is HTML, not a tar archive."], ...
                             file);
                    endif
                  else
                    ## Ignore: maybe something went wrong with the "file" call.
                  endif
                endif
                #}
              else
                looks_like_pkg_name = regexp (file, '^[\w-]+$');
                if (looks_like_pkg_name)
                  error (["pkg: file not found: %s.\n" ...
                          "This looks like an Octave Forge package name." ...
                          "  Did you mean:\n" ...
                          "       pkg install -forge %s"], ...
                         file, file);
                else
                  error ("pkg: file not found: %s", file);
                endif
              endif
              files{strcmp (files, file)} = local_files{end};

            endfor
          endif
        endif

        ## make sure the PREFIX and the ARCHPREFIX directories are created
        if (! isfolder (prefix))
          mkdir (prefix);
        endif
        if (! isfolder (archprefix))
          mkdir (archprefix);
        endif

        install (files, deps, prefix, archprefix, verbose, local_list,
                 global_list, global_install);

      unwind_protect_cleanup
        [~] = cellfun ("unlink", local_files);
        if (exist (tmp_dir, "file"))
          [~] = rmdir (tmp_dir, "s");
        endif
      end_unwind_protect

    case "uninstall"
      if (isempty (files))
        error ("pkg: uninstall action requires at least one package name");
      endif
      uninstall (files, deps, verbose, local_list, global_list, global_install);

    case "load"
      if (isempty (files))
        error ("pkg: load action requires at least one package name");
      endif
      load_packages (files, deps, local_list, global_list);

    case "unload"
      if (isempty (files))
        error ("pkg: unload action requires at least one package name");
      endif
      unload_packages (files, deps, local_list, global_list);

    case "prefix"
      if (isempty (files) && ! nargout)
        printf ("Installation prefix:             %s\n", prefix);
        printf ("Architecture dependent prefix:   %s\n", archprefix);
      elseif (isempty (files) && nargout)
        local_packages = prefix;
        global_packages = archprefix;
      elseif (numel (files) >= 1 && ischar (files{1}))
        prefix = tilde_expand (files{1});
        local_packages = prefix = make_absolute_filename (prefix);
        user_prefix = true;
        if (numel (files) >= 2 && ischar (files{2}))
          archprefix = make_absolute_filename (tilde_expand (files{2}));
        endif
      else
        error ("pkg: prefix action requires a directory input, or an output argument");
      endif

    case "local_list"
      if (isempty (files) && ! nargout)
        disp (local_list);
      elseif (isempty (files) && nargout)
        local_packages = local_list;
      elseif (numel (files) == 1 && ! nargout && ischar (files{1}))
        local_list = tilde_expand (files{1});
        if (! exist (local_list, "file"))
          try
            ## Force file to be created
            fclose (fopen (local_list, "wt"));
          catch
            error ("pkg: cannot create file %s", local_list);
          end_try_catch
        endif
        local_list = canonicalize_file_name (local_list);
      else
        error ("pkg: specify a local_list file, or request an output argument");
      endif

    case "global_list"
      if (isempty (files) && ! nargout)
        disp (global_list);
      elseif (isempty (files) && nargout)
        local_packages = global_list;
      elseif (numel (files) == 1 && ! nargout && ischar (files{1}))
        global_list = files{1};
        if (! exist (global_list, "file"))
          try
            ## Force file to be created
            fclose (fopen (files{1}, "wt"));
          catch
            error ("pkg: cannot create file %s", global_list);
          end_try_catch
        endif
        global_list = canonicalize_file_name (global_list);
      else
        error ("pkg: specify a global_list file, or request an output argument");
      endif

    case "rebuild"
      if (global_install)
        global_packages = rebuild (prefix, archprefix, global_list, files,
                                   verbose);
        global_packages = save_order (global_packages);
        if (ispc)
          ## On Windows ensure LFN paths are saved rather than 8.3 style paths
          global_packages = standardize_paths (global_packages);
        endif
        global_packages = make_rel_paths (global_packages);
        global_list_dir = fileparts (global_list);
        if (! isempty (global_list_dir) && ! exist (global_list_dir, "dir"))
          mkdir (global_list_dir);
        endif
        save (global_list, "global_packages");
        if (nargout)
          local_packages = global_packages;
        endif
      else
        local_packages = rebuild (prefix, archprefix, local_list, files,
                                  verbose);
        local_packages = save_order (local_packages);
        if (ispc)
          local_packages = standardize_paths (local_packages);
        endif
        local_list_dir = fileparts (local_list);
        if (! isempty (local_list_dir) && ! exist (local_list_dir, "dir"))
          mkdir (local_list_dir);
        endif
        save (local_list, "local_packages");
        if (! nargout)
          clear ("local_packages");
        endif
      endif

    case "build"
      if (numel (files) < 2)
        error ("pkg: build action requires build directory and at least one filename");
      endif
      build (files{1}, files(2:end), verbose);

    case "describe"
      ## FIXME: name of the output variables is inconsistent with their content
      if (nargout)
        [local_packages, global_packages] = describe (files, verbose,
                                                      local_list, global_list);
      else
        describe (files, verbose, local_list, global_list);
      endif

    case "update"
      installed_pkgs_lst = installed_packages (local_list, global_list);

      ## If -global or -local, limit updates to global or local list pkgs
      globalflag = any (strcmp (varargin, "-global"));
      localflag = any (strcmp (varargin, "-local"));
      if (globalflag || localflag)
        if (globalflag && localflag)
          error ("pkg: cannot specify both global and local options.")
        elseif (globalflag)
          [~, installed_pkgs_lst] = installed_packages (local_list, global_list);
        else
          [installed_pkgs_lst, ~] = installed_packages (local_list, global_list);
        endif
      else
        installed_pkgs_lst = installed_packages (local_list, global_list);
      endif

      ## Explicit list of packages to update, rather than all packages
      if (numel (files) > 0)
        update_lst = {};
        installed_names = cellfun (@(idx) idx.name, installed_pkgs_lst,
                                   "UniformOutput", false);
        for i = 1:numel (files)
          idx = find (strcmp (files{i}, installed_names), 1);
          if (isempty (idx))
            warning ("pkg: package %s is not installed - skipping update",
                     files{i});
          else
            update_lst = [ update_lst, installed_pkgs_lst(idx) ];
          endif
        endfor
        installed_pkgs_lst = update_lst;
      endif

      for i = 1:numel (installed_pkgs_lst)
        installed_pkg_name = installed_pkgs_lst{i}.name;
        installed_pkg_version = installed_pkgs_lst{i}.version;
        try
          forge_pkg_version = get_forge_pkg (installed_pkg_name);
        catch
          warning ("pkg: package %s not found on Octave Forge - skipping update\n",
                   installed_pkg_name);
          forge_pkg_version = "0";
        end_try_catch
        if (compare_versions (forge_pkg_version, installed_pkg_version, ">"))
          options_to_pass = varargin (strncmp (varargin, "-", 1));
          options_to_pass(end+1) = "-forge";
          feval (@pkg, "install", options_to_pass{:}, installed_pkg_name);
        endif
      endfor

    case "test"
      if (isempty (files))
        error ("pkg: test action requires at least one package name");
      endif
      ## Make sure the requested packages are loaded
      orig_path = path ();
      load_packages (files, deps, local_list, global_list);
      ## Test packages one by one
      installed_pkgs_lst = installed_packages (local_list, global_list, files);
      unwind_protect
        for i = 1:numel (installed_pkgs_lst)
          printf ("Testing functions in package '%s':\n", files{i});
          installed_pkgs_dirs = {installed_pkgs_lst{i}.dir, ...
                                 installed_pkgs_lst{i}.archprefix};
          installed_pkgs_dirs = ...
            installed_pkgs_dirs (! cellfun (@isempty, installed_pkgs_dirs));
          ## For local installs installed_pkgs_dirs contains the same subdirs
          installed_pkgs_dirs = unique (installed_pkgs_dirs);
          if (! isempty (installed_pkgs_dirs))
            ## FIXME invoke another test routine once that is available.
            ## Until then __run_test_suite__.m will do the job fine enough
            __run_test_suite__ ({installed_pkgs_dirs{:}}, {});
          endif
        endfor
      unwind_protect_cleanup
        ## Restore load path back to its original value before loading packages
        path (orig_path);
      end_unwind_protect

    otherwise
      error ("pkg: invalid action.  See 'help pkg' for available actions");
  endswitch

endfunction
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} build (@var{builddir}, @var{tarballs}, @var{verbose})
## Prepare binary packages from Octave source packages.
##
## Boils down to (for each in @var{tarballs}):
##
## @enumerate
## @item untar the tarball in @var{builddir};
##
## @item build anything necessary (configure and make);
##
## @item repackage specifying the build arch in the tarball filename.
## @end enumerate
##
## @end deftypefn

function build (builddir, tarballs, verbose)

  if (nargin != 3)
    print_usage ();
  endif

  if (! isfolder (builddir))
    warning ("creating build directory %s", builddir);
    [status, msg] = mkdir (builddir);
    if (status != 1)
      error ("could not create installation directory: %s", msg);
    endif
  endif

  for i = 1:numel (tarballs)
    filelist = unpack (tarballs{i}, builddir);

    ## We want the path for the package root but we can't assume that
    ## exists in the filelist (see patch #9030).  So we deduce it from
    ## the path of the DESCRIPTION file (smallest in case there's another
    ## file named DESCRIPTION somewhere).
    desc_pos = regexp (filelist, "DESCRIPTION$");
    desc_mask = ! cellfun ("isempty", desc_pos);
    [~, desc_r_idx] = min ([desc_pos{desc_mask}]);
    desc_path = fullfile (builddir, filelist(desc_mask){desc_r_idx});
    build_root = desc_path(1:end-12); # do not include the last filesep

    desc = get_description (desc_path);

    ## If there is no configure or Makefile within src/, there is nothing
    ## to do to prepare a "binary" package.  We only repackage to add more
    ## info to the tarball filename (version and arch).
    if (! exist (fullfile (build_root, "src", "configure"), "file")
        && ! exist (fullfile (build_root, "src", "Makefile"), "file"))
      arch_abi = "any-none";
    else
      arch_abi = getarch ();
      configure_make (desc, build_root, verbose);
      if exist (fullfile (build_root, "src", "configure"), "file")
        unlink (fullfile (build_root, "src", "configure"));
      endif
      if exist (fullfile (build_root, "src", "Makefile"), "file")
        unlink (fullfile (build_root, "src", "Makefile"));
      endif
    endif
    tar_name = [desc.name "-" desc.version "-" arch_abi ".tar"];
    tar_path = fullfile (builddir, tar_name);

    ## Figure out the directory name of the build.  Note that fileparts
    ## gets confused with the version string (the periods makes it think
    ## it's a file extension).
    [~, package_root, package_ext] = fileparts (build_root);
    package_root = [package_root, package_ext];

    tar (tar_path, package_root, builddir);
    gzip (tar_path, builddir);
    [~] = rmdir (build_root, "s");

    ## Currently does nothing because gzip() removes the original tar
    ## file but that should change in the future (bug #43431).
    [~] = unlink (tar_path);
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} configure_make (@var{desc}, @var{packdir}, @var{verbose})
## Undocumented internal function.
## @end deftypefn

function configure_make (desc, packdir, verbose)

  ## Perform ./configure, make, make install in "src".
  if (isfolder (fullfile (packdir, "src")))
    src = fullfile (packdir, "src");
    octave_bindir = __octave_config_info__ ("bindir");
    ver = version ();
    ext = __octave_config_info__ ("EXEEXT");
    mkoctfile_program = fullfile (octave_bindir, ...
                                  sprintf ("mkoctfile-%s%s", ver, ext));
    octave_config_program = fullfile (octave_bindir, ...
                                      sprintf ("octave-config-%s%s", ver, ext));
    octave_binary = fullfile (octave_bindir, sprintf ("octave-%s%s", ver, ext));

    if (! exist (mkoctfile_program, "file"))
      __gripe_missing_component__ ("pkg", "mkoctfile");
    endif
    if (! exist (octave_config_program, "file"))
      __gripe_missing_component__ ("pkg", "octave-config");
    endif
    if (! exist (octave_binary, "file"))
      __gripe_missing_component__ ("pkg", "octave");
    endif

    if (ispc () && ! isunix ())
      # replace all backslashes with forward slashes
      mkoctfile_program = strrep (mkoctfile_program, '\', '/');
      octave_config_program = strrep (octave_config_program, '\', '/');
      octave_binary = strrep (octave_binary, '\', '/');
    endif

    # escape spaces in file paths unless they are already escaped
    mkoctfile_program = regexprep (mkoctfile_program, '([^\\]) ', '$1\\ ');
    octave_config_program = regexprep (octave_config_program, ...
                                       '([^\\]) ', '$1\\ ');
    octave_binary = regexprep (octave_binary, '([^\\]) ', '$1\\ ');

    if (verbose)
      mkoctfile_program = [mkoctfile_program " --verbose"];
    endif

    cenv = {"MKOCTFILE"; mkoctfile_program;
            "OCTAVE_CONFIG"; octave_config_program;
            "OCTAVE"; octave_binary};
    scenv = sprintf ("%s='%s' ", cenv{:});

    if (verbose)
      ## Add standard V=1 make argument for verbose build rules
      scenv = [scenv, "V=1"];
    endif

    ## Configure.
    if (exist (fullfile (src, "configure"), "file"))
      flags = "";
      if (isempty (getenv ("CC")))
        flags = [flags ' CC="' mkoctfile("-p", "CC") '"'];
      endif
      if (isempty (getenv ("CXX")))
        flags = [flags ' CXX="' mkoctfile("-p", "CXX") '"'];
      endif
      if (isempty (getenv ("AR")))
        flags = [flags ' AR="' mkoctfile("-p", "AR") '"'];
      endif
      if (isempty (getenv ("RANLIB")))
        flags = [flags ' RANLIB="' mkoctfile("-p", "RANLIB") '"'];
      endif
      cmd = ["cd '" src "'; " scenv " ./configure " flags];
      [status, output] = shell (cmd, verbose);
      if (status != 0)
        disp (output);
        error ("pkg: error running the configure script for %s", desc.name);
      endif
    endif

    ## Make.
    if (ispc ())
      jobs = 1;
    else
      jobs = nproc ("overridable");
    endif

    if (exist (fullfile (src, "Makefile"), "file"))
      [status, output] = shell (sprintf ("%s make --jobs %i --directory '%s'",
                                         scenv, jobs, src), verbose);
      if (status != 0)
        disp (output);
        error ("pkg: error running 'make' for the %s package", desc.name);
      endif
    endif

    ## Extract tests from source files which will not to be installed
    tst_files_src = [];
    for suffix = {"*.cc", "*.c", "*.C", "*.cpp", "*.cxx"}
      tst_files_src = [tst_files_src; ...
                       nthargout(1, 1, @dir, fullfile (src, suffix{1}))];
    endfor
    if (! isempty (tst_files_src))
      for tst_file_src = {tst_files_src.name}
        full_tst_file_src = fullfile (src, tst_file_src{1});
        tst_code = __extract_test_code__ (full_tst_file_src);
        if (isempty (tst_code))
          continue;
        endif
        full_tst_file = strcat (full_tst_file_src, "-tst");
        if (exist (full_tst_file))
          continue;
        endif
        tst_code = ...
          ["## DO NOT EDIT!\n", ...
           "## Generated automatically from ", tst_file_src{1}, "\n", ...
           "## by ", mfilename(), ".m during package installation.\n\n", ...
           tst_code];
        [fid, output] = fopen (full_tst_file, "w");
        if (fid == -1)
          error ("Octave:pkg:extract-tests", ...
                 "pkg: error writing extracted tests to 'src': %s", output);
        endif
        fputs (fid, tst_code);
        fclose (fid);
      endfor
    endif

  endif

endfunction

## Executes a shell command.
## In the end it calls system(), but in the case of MS Windows it will first
## check if sh.exe works.
##
## If VERBOSE is true, it will prints the output to STDOUT in real time and
## the second output argument will be an empty string.  Otherwise, it will
## contain the output of the execeuted command.
function [status, output] = shell (cmd, verbose)
  persistent have_sh;

  if (ispc () && ! isunix ())
    if (isempty (have_sh))
      if (system ('sh.exe -c "exit"'))
        have_sh = false;
      else
        have_sh = true;
      endif
    endif
    if (have_sh)
      cmd = ['sh.exe -c "' cmd '"'];
    else
      error ("pkg: unable to find the command shell");
    endif
  endif
  ## if verbose, we want to display the output in real time.  To do this, we
  ## must call system with 1 output argument.  But then the variable 'output'
  ## won't exist.  So we initialize it empty.  If an error does occur, and we
  ## are verbose we will return an empty string but it's all fine since
  ## the error message has already been displayed.
  output = "";
  if (verbose)
    [status] = system (cmd);
  else
    [status, output] = system (cmd);
  endif

endfunction

function body = __extract_test_code__ (nm)

  ## Collect all BIST lines starting %! from the file named nm
  ## and return them as a single \n-delimited string.
  fid = fopen (nm, "rt");
  body = "";
  if (fid >= 0)
    while (ischar (ln = fgets (fid)))
      if (strncmp (ln, "%!", 2))
        body = [body, ln];
      endif
    endwhile
    fclose (fid);
  endif

endfunction
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{prefix}, @var{archprefix} =} default_prefix (@var{global_install}, @var{desc})
## Undocumented internal function.
## @end deftypefn

## FIXME: second input "desc" does not appear to be used.
function [prefix, archprefix] = default_prefix (global_install, desc)

  if (global_install)
    prefix = fullfile (OCTAVE_HOME (), "share", "octave", "packages");
    if (nargin == 2)
      archprefix = fullfile (__octave_config_info__ ("libdir"), "octave",
                             "packages", [desc.name "-" desc.version]);
    else
      archprefix = fullfile (__octave_config_info__ ("libdir"), "octave",
                             "packages");
    endif
  else
    prefix = fullfile (user_data_dir (), "octave", ...
                       __octave_config_info__ ("api_version"), "packages");
    archprefix = prefix;
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{pkg_desc_list}, @var{flag}] =} describe (@var{pkgnames}, @var{verbose}, @var{local_list}, @var{global_list})
## Undocumented internal function.
## @end deftypefn

function [pkg_desc_list, flag] = describe (pkgnames, verbose, local_list, global_list)

  ## Get the list of installed packages.
  installed_pkgs_lst = installed_packages (local_list, global_list);
  num_packages = length (installed_pkgs_lst);
  ## Add inverse dependencies to "installed_pkgs_lst"
  installed_pkgs_lst = get_inverse_dependencies (installed_pkgs_lst);

  if (isempty (pkgnames))
    describe_all = true;
    flag(1:num_packages) = {"Not Loaded"};
    num_pkgnames = num_packages;
  else
    describe_all = false;
    num_pkgnames = length (pkgnames);
    flag(1:num_pkgnames) = {"Not installed"};
  endif

  for i = 1:num_packages
    curr_name = installed_pkgs_lst{i}.name;
    if (describe_all)
      name_pos = i;
    else
      name_pos = find (strcmp (curr_name, pkgnames));
    endif

    if (! isempty (name_pos))
      if (installed_pkgs_lst{i}.loaded)
        flag{name_pos} = "Loaded";
      else
        flag{name_pos} = "Not loaded";
      endif

      pkg_desc_list{name_pos}.name = installed_pkgs_lst{i}.name;
      pkg_desc_list{name_pos}.version = installed_pkgs_lst{i}.version;
      pkg_desc_list{name_pos}.description = installed_pkgs_lst{i}.description;
      pkg_desc_list{name_pos}.depends = installed_pkgs_lst{i}.depends;
      pkg_desc_list{name_pos}.provides = parse_pkg_idx (installed_pkgs_lst{i}.dir);
      pkg_desc_list{name_pos}.invdeps = unique (installed_pkgs_lst{i}.invdeps);

    endif
  endfor

  non_inst = find (strcmp (flag, "Not installed"));
  if (! isempty (non_inst))
    if (nargout < 2)
      non_inst_str = sprintf (" %s ", pkgnames{non_inst});
      error ("some packages are not installed: %s", non_inst_str);
    else
      pkg_desc_list{non_inst} = struct ("name", {}, "description",
                                        {}, "provides", {});
    endif
  endif

  if (nargout == 0)
    for i = 1:num_pkgnames
      print_package_description (pkg_desc_list{i}.name,
                                 pkg_desc_list{i}.version,
                                 pkg_desc_list{i}.provides,
                                 pkg_desc_list{i}.description,
                                 pkg_desc_list{i}.depends,
                                 pkg_desc_list{i}.invdeps,
                                 flag{i}, verbose);
    endfor
  endif

endfunction


## Read an INDEX file.
function pkg_idx_struct = parse_pkg_idx (packdir)

  index_file = fullfile (packdir, "packinfo", "INDEX");

  if (! exist (index_file, "file"))
    error ("could not find any INDEX file in directory %s, try 'pkg rebuild all' to generate missing INDEX files", packdir);
  endif


  [fid, msg] = fopen (index_file, "r");
  if (fid == -1)
    error ("the INDEX file %s could not be read: %s",
           index_file, msg);
  endif

  cat_num = 1;
  pkg_idx_struct{1}.category = "Uncategorized";
  pkg_idx_struct{1}.functions = {};

  line = fgetl (fid);
  while (isempty (strfind (line, ">>")) && ! feof (fid))
    line = fgetl (fid);
  endwhile

  while (! feof (fid) || line != -1)
    if (! any (! isspace (line)) || line(1) == "#" || any (line == "="))
      ## Comments,  blank lines or comments about unimplemented
      ## functions: do nothing
      ## FIXME: probably comments and pointers to external functions
      ## could be treated better when printing to screen?
    elseif (! isempty (strfind (line, ">>")))
      ## Skip package name and description as they are in DESCRIPTION
      ## already.
    elseif (! isspace (line(1)))
      ## Category.
      if (! isempty (pkg_idx_struct{cat_num}.functions))
        pkg_idx_struct{++cat_num}.functions = {};
      endif
      pkg_idx_struct{cat_num}.category = deblank (line);
    else
      ## Function names.
      while (any (! isspace (line)))
        [fun_name, line] = strtok (line);
        pkg_idx_struct{cat_num}.functions{end+1} = deblank (fun_name);
      endwhile
    endif
    line = fgetl (fid);
  endwhile
  fclose (fid);

endfunction


function print_package_description (pkg_name, pkg_ver, pkg_idx_struct,
                                    pkg_desc, pkg_deps, pkg_invd, status,
                                    verbose)

  printf ("---\nPackage name:\n\t%s\n", pkg_name);
  printf ("Version:\n\t%s\n", pkg_ver);
  printf ("Short description:\n\t%s\n", pkg_desc);
  pkg_deps = cellfun (@(d) sprintf ("%s %s %s", struct2cell (d){:}), pkg_deps,
                      "UniformOutput", false);
  pkg_deps = strjoin (pkg_deps, "\n\t");
  printf ("Depends on:\n\t%s\n", pkg_deps);

  pkg_invd = strjoin (pkg_invd, "\n\t");
  printf ("Depended on by:\n\t%s\n", pkg_invd);

  printf ("Status:\n\t%s\n", status);
  if (verbose)
    printf ("---\nProvides:\n");
    for i = 1:length (pkg_idx_struct)
      if (! isempty (pkg_idx_struct{i}.functions))
        printf ("%s\n", pkg_idx_struct{i}.category);
        for j = 1:length (pkg_idx_struct{i}.functions)
          printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
        endfor
      endif
    endfor
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{emp} =} dirempty (@var{nm}, @var{ign})
## Undocumented internal function.
## @end deftypefn

function emp = dirempty (nm, ign)

  if (isfolder (nm))
    if (nargin < 2)
      ign = {".", ".."};
    else
      ign = [{".", ".."}, ign];
    endif
    l = dir (nm);
    for i = 1:length (l)
      found = false;
      for j = 1:length (ign)
        if (strcmp (l(i).name, ign{j}))
          found = true;
          break;
        endif
      endfor
      if (! found)
        emp = false;
        return;
      endif
    endfor
    emp = true;
  else
    emp = true;
  endif

endfunction
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{pkg_list} =} expand_rel_paths (@var{pkg_list})
## Internal undocumented function.
## @end deftypefn

function pkg_list = expand_rel_paths (pkg_list)

  ## Prepend location of OCTAVE_HOME to install directories
  loc = regexptranslate ("escape", OCTAVE_HOME ());
  for i = 1:numel (pkg_list)
    ## Be sure to only prepend OCTAVE_HOME to pertinent package paths
    pkg_list{i}.dir = regexprep (pkg_list{i}.dir, "^__OH__", loc);
    pkg_list{i}.archprefix = regexprep (pkg_list{i}.archprefix, ...
                                        "^__OH__", loc);
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{desc} =} get_description (@var{filename})
## Undocumented internal function.
## @end deftypefn

## Parse the DESCRIPTION file.
function desc = get_description (filename)

  [fid, msg] = fopen (filename, "r");
  if (fid == -1)
    error ("the DESCRIPTION file %s could not be read: %s", filename, msg);
  endif

  desc = struct ();

  line = fgetl (fid);
  while (line != -1)
    if (line(1) == "#")
      ## Comments, do nothing.
    elseif (isspace (line(1)))
      ## Continuation lines
      if (exist ("keyword", "var") && isfield (desc, keyword))
        desc.(keyword) = [desc.(keyword) " " deblank(line)];
      endif
    else
      ## Keyword/value pair
      colon = find (line == ":");
      if (length (colon) == 0)
        warning ("pkg: skipping invalid line in DESCRIPTION file");
      else
        colon = colon(1);
        keyword = tolower (strtrim (line(1:colon-1)));
        value = strtrim (line (colon+1:end));
        if (length (value) == 0)
            fclose (fid);
            error ("The keyword '%s' of the package '%s' has an empty value",
                    keyword, desc.name);
        endif
        if (isfield (desc, keyword))
          warning ('pkg: duplicate keyword "%s" in DESCRIPTION, ignoring',
                   keyword);
        else
          desc.(keyword) = value;
        endif
      endif
    endif
    line = fgetl (fid);
  endwhile
  fclose (fid);

  ## Make sure all is okay.
  needed_fields = {"name", "version", "date", "title", ...
                   "author", "maintainer", "description"};
  for f = needed_fields
    if (! isfield (desc, f{1}))
      error ("description is missing needed field %s", f{1});
    endif
  endfor

  if (! is_valid_pkg_version_string (desc.version))
    error ("invalid version string '%s'", desc.version);
  endif

  if (isfield (desc, "depends"))
    desc.depends = fix_depends (desc.depends);
  else
    desc.depends = "";
  endif
  desc.name = tolower (desc.name);

endfunction


## Make sure the depends field is of the right format.
## This function returns a cell of structures with the following fields:
##   package, version, operator
function deps_cell = fix_depends (depends)

  deps = strtrim (ostrsplit (tolower (depends), ","));
  deps_cell = cell (1, length (deps));
  dep_pat = ...
  '\s*(?<name>[-\w]+)\s*(\(\s*(?<op>[<>=]+)\s*(?<ver>\d+\.\d+(\.\d+)*)\s*\))*\s*';

  ## For each dependency.
  for i = 1:length (deps)
    dep = deps{i};
    [start, nm] = regexp (dep, dep_pat, 'start', 'names');
    ## Is the dependency specified
    ## in the correct format?
    if (! isempty (start))
      package = tolower (strtrim (nm.name));
      ## Does the dependency specify a version
      ## Example: package(>= version).
      if (! isempty (nm.ver))
        operator = nm.op;
        if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
          error ("unsupported operator: %s", operator);
        endif
        if (! is_valid_pkg_version_string (nm.ver))
          error ("invalid dependency version string '%s'", nm.ver);
        endif
      else
        ## If no version is specified for the dependency
        ## we say that the version should be greater than
        ## or equal to "0.0.0".
        package = tolower (strtrim (dep));
        operator = ">=";
        nm.ver  = "0.0.0";
      endif
      deps_cell{i} = struct ("package", package,
                             "operator", operator,
                             "version", nm.ver);
    else
      error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
             dep);
    endif
  endfor

endfunction

function valid = is_valid_pkg_version_string (str)

  ## We are limiting ourselves to this set of characters because the
  ## version will appear on the filepath.  The portable character, according to
  ## http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_278
  ## is [A-Za-z0-9\.\_\-].  However, this is very limited.  We specially
  ## want to support a "+" so we can support "pkgname-2.1.0+" during
  ## development.  So we use Debian's character set for version strings
  ## https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version
  ## with the exception of ":" (colon) because that's the PATH separator.
  ##
  ## Debian does not include "_" because it is used to separate the name,
  ## version, and arch in their deb files.  While the actual filenames are
  ## never parsed to get that information, it is important to have a unique
  ## separator character to prevent filename clashes.  For example, if we
  ## used hyhen as separator, "signal-2-1-rc1" could be "signal-2" version
  ## "1-rc1" or "signal" version "2-1-rc1".  A package file for both must be
  ## able to co-exist in the same directory, e.g., during package install or
  ## in a flat level package repository.
  valid = numel (regexp (str, '[^0-9a-zA-Z\.\+\-\~]')) == 0;

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{url}, @var{local_file}] =} get_forge_download (@var{name})
## Undocumented internal function.
## @end deftypefn

function [url, local_file] = get_forge_download (name)
  [ver, url] = get_forge_pkg (name);
  local_file = tempname (tempdir (), [name "-" ver "-"]);
  local_file = [local_file ".tar.gz"];
endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{ver}, @var{url}] =} get_forge_pkg (@var{name})
## Try to discover the current version of an Octave Forge package from the web,
## using a working internet connection and the urlread function.
## If two output arguments are requested, also return an address from which
## to download the file.
## @end deftypefn

function [ver, url] = get_forge_pkg (name)

  ## Verify that name is valid.
  if (! (ischar (name) && rows (name) == 1 && ndims (name) == 2))
    error ("get_forge_pkg: package NAME must be a string");
  elseif (! all (isalnum (name) | name == "-" | name == "." | name == "_"))
    error ("get_forge_pkg: invalid package NAME: %s", name);
  endif

  name = tolower (name);

  ## Try to download package's index page.
  [html, succ] = urlread (sprintf ("https://packages.octave.org/%s/index.html", ...
                                   name));
  if (succ)
    ## Remove blanks for simpler matching.
    html(isspace (html)) = [];
    ## Good.  Let's grep for the version.
    pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
    t = regexp (html, pat, "tokens");
    if (isempty (t) || isempty (t{1}))
      error ("get_forge_pkg: could not read version number from package's page");
    else
      ver = t{1}{1};
      if (nargout > 1)
        ## Build download string.
        pkg_file = sprintf ("%s-%s.tar.gz", name, ver);
        url = ["https://packages.octave.org/download/" pkg_file];
        ## Verify that the package string exists on the page.
        if (isempty (strfind (html, pkg_file)))
          warning ("get_forge_pkg: download URL not verified");
        endif
      endif
    endif
  else
    ## Try get the list of all packages.
    [html, succ] = urlread ("https://packages.octave.org/list_packages.php");
    if (! succ)
      error ("get_forge_pkg: could not read URL, please verify internet connection");
    endif
    t = strsplit (html);
    if (any (strcmp (t, name)))
      error ("get_forge_pkg: package NAME exists, but index page not available");
    endif
    ## Try a simplistic method to determine similar names.
    function d = fdist (x)

      len1 = length (name);
      len2 = length (x);
      if (len1 <= len2)
        d = sum (abs (tolower (name(1:len1)) - tolower (x(1:len1)))) ...
            + (len2 - len1)*23;
      else
        d = sum (abs (tolower (name(1:len2)) - tolower (x(1:len2)))) ...
            + (len1 - len2)*23;
      endif

    endfunction

    dist = cellfun ("fdist", t);
    [~, i] = min (dist);
    error ("get_forge_pkg: package not found: ""%s"".  Did you mean ""%s""?", ...
           name, t{i});
  endif

endfunction
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{installed_pkgs_list} =} get_inverse_dependencies (@var{installed_pkgs_lst})
## Find inverse dependencies, if any, for each package, and store in
## the struct field @qcode{"invdeps"}.
##
## @end deftypefn

function installed_pkgs_lst = get_inverse_dependencies (installed_pkgs_lst)

  for i = 1:numel (installed_pkgs_lst)
    installed_pkgs_lst{i}.invdeps = {};  # initialize invdeps field
  endfor

  for i = 1:numel (installed_pkgs_lst)
    pdeps = installed_pkgs_lst{i}.depends;
    for j = 1:numel (pdeps)
      pdep_nm = pdeps{j}.package;
      if (! strcmpi (pdep_nm, "octave"))
        idx = cellfun (@(S) strcmpi (S.name, pdep_nm), installed_pkgs_lst);
        if (any (idx))
          installed_pkgs_lst{idx}.invdeps(end+1) = {installed_pkgs_lst{i}.name};
        endif
      endif
    endfor
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{bad_deps} =} get_unsatisfied_deps (@var{desc}, @var{installed_pkgs_lst}, @var{uninstall_flag})
## Undocumented internal function.
## @end deftypefn

function bad_deps = get_unsatisfied_deps (desc, installed_pkgs_lst,
                                          uninstall_flag = false)

  bad_deps = {};

  ## For each dependency.
  for i = 1:length (desc.depends)
    dep = desc.depends{i};

    ## Is the current dependency Octave?
    if (strcmp (dep.package, "octave"))
      if (! compare_versions (OCTAVE_VERSION, dep.version, dep.operator))
        bad_deps{end+1} = dep;
      endif
      ## Is the current dependency not Octave?
    else
      ok = xor (false, uninstall_flag);
      for i = 1:length (installed_pkgs_lst)
        cur_name = installed_pkgs_lst{i}.name;
        cur_version = installed_pkgs_lst{i}.version;
        if (strcmp (dep.package, cur_name)
            && compare_versions (cur_version, dep.version, dep.operator))
          ok = xor (true, uninstall_flag);
          break;
        endif
      endfor
      if (! ok)
        bad_deps{end+1} = dep;
      endif
    endif
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{arch} =} getarch ()
## Undocumented internal function.
## @end deftypefn

function arch = getarch ()
  persistent _arch = [__octave_config_info__("canonical_host_type"), "-", ...
                      __octave_config_info__("api_version")];

  arch = _arch;
endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{archdir} =} getarchdir (@var{desc})
## Undocumented internal function.
## @end deftypefn

function archdir = getarchdir (desc)
  archdir = fullfile (desc.archprefix, getarch ());
endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} install (@var{files}, @var{handle_deps}, @var{prefix}, @var{archprefix}, @var{verbose}, @var{local_list}, @var{global_list}, @var{global_install})
## Undocumented internal function.
## @end deftypefn

function install (files, handle_deps, prefix, archprefix, verbose,
                  local_list, global_list, global_install)

  ## Check that the directory in prefix exist.  If it doesn't: create it!
  if (! isfolder (prefix))
    warning ("creating installation directory %s", prefix);
    [status, msg] = mkdir (prefix);
    if (status != 1)
      error ("could not create installation directory: %s", msg);
    endif
  endif

  ## Get the list of installed packages.
  [local_packages, global_packages] = installed_packages (local_list,
                                                          global_list);

  installed_pkgs_lst = {local_packages{:}, global_packages{:}};

  if (global_install)
    packages = global_packages;
  else
    packages = local_packages;
  endif

  if (ispc ())
    oct_glob = @__wglob__;
  else
    oct_glob = @glob;
  endif

  ## Uncompress the packages and read the DESCRIPTION files.
  tmpdirs = packdirs = descriptions = {};
  try
    ## Warn about non existent files.
    for i = 1:length (files)
      if (isempty (oct_glob (files{i})))
        warning ("file %s does not exist", files{i});
      endif
    endfor

    ## Unpack the package files and read the DESCRIPTION files.
    files = oct_glob (files);
    packages_to_uninstall = [];
    for i = 1:length (files)
      tgz = files{i};

      if (exist (tgz, "file"))
        ## Create a temporary directory.
        tmpdir = tempname ();
        tmpdirs{end+1} = tmpdir;
        if (verbose)
          printf ("mkdir (%s)\n", tmpdir);
        endif
        [status, msg] = mkdir (tmpdir);
        if (status != 1)
          error ("couldn't create temporary directory: %s", msg);
        endif

        ## Uncompress the package.
        [~, ~, ext] = fileparts (tgz);
        if (strcmpi (ext, ".zip"))
          func_uncompress = @unzip;
        else
          func_uncompress = @untar;
        endif
        if (verbose)
          printf ("%s (%s, %s)\n", func2str (func_uncompress), tgz, tmpdir);
        endif
        func_uncompress (tgz, tmpdir);

        ## Get the name of the directories produced by tar.
        [dirlist, err, msg] = readdir (tmpdir);
        if (err)
          error ("couldn't read directory produced by tar: %s", msg);
        endif

        if (length (dirlist) > 3)
          error ("bundles of packages are not allowed");
        endif
      endif

      ## The filename pointed to an uncompressed package to begin with.
      if (isfolder (tgz))
        dirlist = {".", "..", tgz};
      endif

      if (exist (tgz, "file") || isfolder (tgz))
        ## The two first entries of dirlist are "." and "..".
        if (exist (tgz, "file"))
          packdir = fullfile (tmpdir, dirlist{3});
        else
          packdir = fullfile (pwd (), dirlist{3});
        endif
        packdirs{end+1} = packdir;

        ## Make sure the package contains necessary files.
        verify_directory (packdir);

        ## Read the DESCRIPTION file.
        filename = fullfile (packdir, "DESCRIPTION");
        desc = get_description (filename);

        ## Set default installation directory.
        desc.dir = fullfile (prefix, [desc.name "-" desc.version]);

        ## Set default architectire dependent installation directory.
        desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);

        ## Save desc.
        descriptions{end+1} = desc;

        ## Are any of the new packages already installed?
        ## If so we'll remove the old version.
        for j = 1:length (packages)
          if (strcmp (packages{j}.name, desc.name))
            packages_to_uninstall(end+1) = j;
          endif
        endfor
      endif
    endfor
  catch
    ## Something went wrong, delete tmpdirs.
    for i = 1:length (tmpdirs)
      sts = rmdir (tmpdirs{i}, "s");
    endfor
    rethrow (lasterror ());
  end_try_catch

  ## Check dependencies.
  if (handle_deps)
    ok = true;
    error_text = "";
    for i = 1:length (descriptions)
      desc = descriptions{i};
      idx2 = setdiff (1:length (descriptions), i);
      if (global_install)
        ## Global installation is not allowed to have dependencies on locally
        ## installed packages.
        idx1 = setdiff (1:length (global_packages), packages_to_uninstall);
        pseudo_installed_packages = {global_packages{idx1}, ...
                                     descriptions{idx2}};
      else
        idx1 = setdiff (1:length (local_packages), packages_to_uninstall);
        pseudo_installed_packages = {local_packages{idx1}, ...
                                     global_packages{:}, ...
                                     descriptions{idx2}};
      endif
      bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
      ## Are there any unsatisfied dependencies?
      if (! isempty (bad_deps))
        ok = false;
        for i = 1:length (bad_deps)
          dep = bad_deps{i};
          error_text = [error_text " " desc.name " needs " ...
                        dep.package " " dep.operator " " dep.version "\n"];
        endfor
      endif
    endfor

    ## Did we find any unsatisfied dependencies?
    if (! ok)
      error ("the following dependencies were unsatisfied:\n  %s", error_text);
    endif
  endif

  ## Prepare each package for installation.
  try
    for i = 1:length (descriptions)
      desc = descriptions{i};
      pdir = packdirs{i};
      prepare_installation (desc, pdir);
      configure_make (desc, pdir, verbose);
      copy_built_files (desc, pdir, verbose);
    endfor
  catch
    ## Something went wrong, delete tmpdirs.
    for i = 1:length (tmpdirs)
      sts = rmdir (tmpdirs{i}, "s");
    endfor
    rethrow (lasterror ());
  end_try_catch

  ## Uninstall the packages that will be replaced.
  try
    for i = packages_to_uninstall
      if (global_install)
        uninstall ({global_packages{i}.name}, false, verbose, local_list,
                   global_list, global_install);
      else
        uninstall ({local_packages{i}.name}, false, verbose, local_list,
                   global_list, global_install);
      endif
    endfor
  catch
    ## Something went wrong, delete tmpdirs.
    for i = 1:length (tmpdirs)
      sts = rmdir (tmpdirs{i}, "s");
    endfor
    rethrow (lasterror ());
  end_try_catch

  ## Install each package.
  try
    for i = 1:length (descriptions)
      desc = descriptions{i};
      pdir = packdirs{i};
      copy_files (desc, pdir, global_install);
      create_pkgadddel (desc, pdir, "PKG_ADD", global_install);
      create_pkgadddel (desc, pdir, "PKG_DEL", global_install);
      finish_installation (desc, pdir, global_install);
      generate_lookfor_cache (desc);
    endfor
  catch
    ## Something went wrong, delete tmpdirs.
    for i = 1:length (tmpdirs)
      sts = rmdir (tmpdirs{i}, "s");
    endfor
    for i = 1:length (descriptions)
      sts = rmdir (descriptions{i}.dir, "s");
      sts = rmdir (getarchdir (descriptions{i}), "s");
    endfor
    rethrow (lasterror ());
  end_try_catch

  ## Check if the installed directory is empty.  If it is remove it
  ## from the list.
  for i = length (descriptions):-1:1
    if (dirempty (descriptions{i}.dir, {"packinfo", "doc"})
        && dirempty (getarchdir (descriptions{i})))
      warning ("package %s is empty\n", descriptions{i}.name);
      sts = rmdir (descriptions{i}.dir, "s");
      sts = rmdir (getarchdir (descriptions{i}), "s");
      descriptions(i) = [];
    endif
  endfor

  ## Add the packages to the package list.
  try
    if (global_install)
      idx = setdiff (1:length (global_packages), packages_to_uninstall);
      global_packages = save_order ({global_packages{idx}, descriptions{:}});
      if (ispc)
        ## On Windows ensure LFN paths are saved rather than 8.3 style paths
        global_packages = standardize_paths (global_packages);
      endif
      global_packages = make_rel_paths (global_packages);
      save (global_list, "global_packages");
      installed_pkgs_lst = {local_packages{:}, global_packages{:}};
    else
      idx = setdiff (1:length (local_packages), packages_to_uninstall);
      local_packages = save_order ({local_packages{idx}, descriptions{:}});
      if (ispc)
        local_packages = standardize_paths (local_packages);
      endif
      if (! exist (fileparts (local_list), "dir")
          && ! mkdir (fileparts (local_list)))
        error ("Octave:pkg:install:local-dir", ...
               "pkg: Could not create directory for local package configuration");
      endif
      save (local_list, "local_packages");
      installed_pkgs_lst = {local_packages{:}, global_packages{:}};
    endif
  catch
    ## Something went wrong, delete tmpdirs.
    for i = 1:length (tmpdirs)
      sts = rmdir (tmpdirs{i}, "s");
    endfor
    for i = 1:length (descriptions)
      sts = rmdir (descriptions{i}.dir, "s");
    endfor
    if (global_install)
      printf ("error: couldn't append to %s\n", global_list);
    else
      printf ("error: couldn't append to %s\n", local_list);
    endif
    rethrow (lasterror ());
  end_try_catch

  ## All is well, let's clean up.
  for i = 1:length (tmpdirs)
    [status, msg] = rmdir (tmpdirs{i}, "s");
    if (status != 1 && isfolder (tmpdirs{i}))
      warning ("couldn't clean up after my self: %s\n", msg);
    endif
  endfor

  ## If there is a NEWS file, mention it.
  ## Check if desc exists too because it's possible to get to this point
  ## without creating it such as giving an invalid filename for the package
  if (exist ("desc", "var")
      && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
    printf (["For information about changes from previous versions " ...
             "of the %s package, run 'news %s'.\n"],
            desc.name, desc.name);
  endif

endfunction


function pkg = extract_pkg (nm, pat)

  mfile_encoding = __mfile_encoding__ ();
  if (strcmp (mfile_encoding, "system"))
    mfile_encoding = __locale_charset__ ();
  endif
  fid = fopen (nm, "rt", "n", mfile_encoding);
  pkg = "";
  if (fid >= 0)
    while (! feof (fid))
      ln = __u8_validate__ (fgetl (fid));
      if (ln > 0)
        t = regexp (ln, pat, "tokens");
        if (! isempty (t))
          pkg = [pkg "\n" t{1}{1}];
        endif
      endif
    endwhile
    if (! isempty (pkg))
      pkg = [pkg "\n"];
    endif
    fclose (fid);
  endif

endfunction


## Make sure the package contains the essential files.
function verify_directory (dir)

  needed_files = {"COPYING", "DESCRIPTION"};
  for f = needed_files
    if (! exist (fullfile (dir, f{1}), "file"))
      error ("package is missing file: %s", f{1});
    endif
  endfor

endfunction


function prepare_installation (desc, packdir)

  ## Is there a pre_install to call?
  if (exist (fullfile (packdir, "pre_install.m"), "file"))
    wd = pwd ();
    try
      cd (packdir);
      pre_install (desc);
      cd (wd);
    catch
      cd (wd);
      rethrow (lasterror ());
    end_try_catch
  endif

  ## If the directory "inst" doesn't exist, we create it.
  inst_dir = fullfile (packdir, "inst");
  if (! isfolder (inst_dir))
    [status, msg] = mkdir (inst_dir);
    if (status != 1)
      sts = rmdir (desc.dir, "s");
      error ("the 'inst' directory did not exist and could not be created: %s",
             msg);
    endif
  endif

endfunction


function copy_built_files (desc, packdir, verbose)

  src = fullfile (packdir, "src");
  if (! isfolder (src))
    return;
  endif

  ## Copy files to "inst" and "inst/arch" (this is instead of 'make install').
  files = fullfile (src, "FILES");
  instdir = fullfile (packdir, "inst");
  archdir = fullfile (packdir, "inst", getarch ());

  ## Get filenames.
  if (exist (files, "file"))
    [fid, msg] = fopen (files, "r");
    if (fid < 0)
      error ("couldn't open %s: %s", files, msg);
    endif
    filenames = char (fread (fid))';
    fclose (fid);
    if (filenames(end) == "\n")
      filenames(end) = [];
    endif
    filenames = strtrim (ostrsplit (filenames, "\n"));
    delete_idx = [];
    for i = 1:length (filenames)
      if (! all (isspace (filenames{i})))
        filenames{i} = fullfile (src, filenames{i});
      else
        delete_idx(end+1) = i;
      endif
    endfor
    filenames(delete_idx) = [];
  else
    m = dir (fullfile (src, "*.m"));
    oct = dir (fullfile (src, "*.oct"));
    mex = dir (fullfile (src, "*.mex"));
    tst = dir (fullfile (src, "*tst"));

    filenames = cellfun (@(x) fullfile (src, x),
                         {m.name, oct.name, mex.name, tst.name},
                         "uniformoutput", false);
  endif

  ## Split into architecture dependent and independent files.
  if (isempty (filenames))
    idx = [];
  else
    idx = cellfun ("is_architecture_dependent", filenames);
  endif
  archdependent = filenames(idx);
  archindependent = filenames(! idx);

  ## Copy the files.
  if (! all (isspace ([filenames{:}])))
      if (! isfolder (instdir))
        mkdir (instdir);
      endif
      if (! all (isspace ([archindependent{:}])))
        if (verbose)
          printf ("copyfile");
          printf (" %s", archindependent{:});
          printf (" %s\n", instdir);
        endif
        [status, output] = copyfile (archindependent, instdir);
        if (status != 1)
          sts = rmdir (desc.dir, "s");
          error ("Couldn't copy files from 'src' to 'inst': %s", output);
        endif
      endif
      if (! all (isspace ([archdependent{:}])))
        if (verbose)
          printf ("copyfile");
          printf (" %s", archdependent{:});
          printf (" %s\n", archdir);
        endif
        if (! isfolder (archdir))
          mkdir (archdir);
        endif
        [status, output] = copyfile (archdependent, archdir);
        if (status != 1)
          sts = rmdir (desc.dir, "s");
          error ("Couldn't copy files from 'src' to 'inst': %s", output);
        endif
      endif
  endif

endfunction


function dep = is_architecture_dependent (nm)

  persistent archdepsuffix = {".oct", ".mex", ".a", ".lib", ".so", ...
                              "tst", ".so.*", ".dll", "dylib"};

  dep = false;
  for i = 1 : length (archdepsuffix)
    ext = archdepsuffix{i};
    if (ext(end) == "*")
      isglob = true;
      ext(end) = [];
    else
      isglob = false;
    endif
    pos = strfind (nm, ext);
    if (pos)
      if (! isglob && (length (nm) - pos(end) != length (ext) - 1))
        continue;
      endif
      dep = true;
      break;
    endif
  endfor

endfunction


function copy_files (desc, packdir, global_install)

  ## Create the installation directory.
  if (! isfolder (desc.dir))
    [status, output] = mkdir (desc.dir);
    if (status != 1)
      error ("couldn't create installation directory %s : %s",
             desc.dir, output);
    endif
  endif

  octfiledir = getarchdir (desc);

  ## Copy the files from "inst" to installdir.
  instdir = fullfile (packdir, "inst");
  if (! dirempty (instdir))
    [status, output] = copyfile (fullfile (instdir, "*"), desc.dir);
    if (status != 1)
      sts = rmdir (desc.dir, "s");
      error ("couldn't copy files to the installation directory");
    endif
    if (isfolder (fullfile (desc.dir, getarch ()))
        && ! is_same_file (fullfile (desc.dir, getarch ()), octfiledir))
      if (! isfolder (octfiledir))
        ## Can be required to create up to three levels of dirs.
        octm1 = fileparts (octfiledir);
        if (! isfolder (octm1))
          octm2 = fileparts (octm1);
          if (! isfolder (octm2))
            octm3 = fileparts (octm2);
            if (! isfolder (octm3))
              [status, output] = mkdir (octm3);
              if (status != 1)
                sts = rmdir (desc.dir, "s");
                error ("couldn't create installation directory %s : %s",
                       octm3, output);
              endif
            endif
            [status, output] = mkdir (octm2);
            if (status != 1)
              sts = rmdir (desc.dir, "s");
              error ("couldn't create installation directory %s : %s",
                     octm2, output);
            endif
          endif
          [status, output] = mkdir (octm1);
          if (status != 1)
            sts = rmdir (desc.dir, "s");
            error ("couldn't create installation directory %s : %s",
                   octm1, output);
          endif
        endif
        [status, output] = mkdir (octfiledir);
        if (status != 1)
          sts = rmdir (desc.dir, "s");
          error ("couldn't create installation directory %s : %s",
                 octfiledir, output);
        endif
      endif
      [status, output] = movefile (fullfile (desc.dir, getarch (), "*"),
                                   octfiledir);
      sts = rmdir (fullfile (desc.dir, getarch ()), "s");

      if (status != 1)
        sts = rmdir (desc.dir, "s");
        sts = rmdir (octfiledir, "s");
        error ("couldn't copy files to the installation directory");
      endif
    endif

  endif

  ## Create the "packinfo" directory.
  packinfo = fullfile (desc.dir, "packinfo");
  [status, msg] = mkdir (packinfo);
  if (status != 1)
    sts = rmdir (desc.dir, "s");
    sts = rmdir (octfiledir, "s");
    error ("couldn't create packinfo directory: %s", msg);
  endif

  packinfo_copy_file ("DESCRIPTION", "required", packdir, packinfo, desc, octfiledir);
  packinfo_copy_file ("COPYING", "required", packdir, packinfo, desc, octfiledir);
  packinfo_copy_file ("CITATION", "optional", packdir, packinfo, desc, octfiledir);
  packinfo_copy_file ("NEWS", "optional", packdir, packinfo, desc, octfiledir);
  packinfo_copy_file ("ONEWS", "optional", packdir, packinfo, desc, octfiledir);
  packinfo_copy_file ("ChangeLog", "optional", packdir, packinfo, desc, octfiledir);

  ## Is there an INDEX file to copy or should we generate one?
  index_file = fullfile (packdir, "INDEX");
  if (exist (index_file, "file"))
    packinfo_copy_file ("INDEX", "required", packdir, packinfo, desc, octfiledir);
  else
    try
      write_index (desc, fullfile (packdir, "inst"),
                   fullfile (packinfo, "INDEX"), global_install);
    catch
      sts = rmdir (desc.dir, "s");
      sts = rmdir (octfiledir, "s");
      rethrow (lasterror ());
    end_try_catch
  endif

  ## Is there an 'on_uninstall.m' to install?
  packinfo_copy_file ("on_uninstall.m", "optional", packdir, packinfo, desc, octfiledir);

  ## Is there a doc/ directory that needs to be installed?
  docdir = fullfile (packdir, "doc");
  if (isfolder (docdir) && ! dirempty (docdir))
    [status, output] = copyfile (docdir, desc.dir);
  endif

  ## Is there a bin/ directory that needs to be installed?
  ## FIXME: Need to treat architecture dependent files in bin/
  bindir = fullfile (packdir, "bin");
  if (isfolder (bindir) && ! dirempty (bindir))
    [status, output] = copyfile (bindir, desc.dir);
  endif

endfunction


function packinfo_copy_file (filename, requirement, packdir, packinfo, desc, octfiledir)

  filepath = fullfile (packdir, filename);
  if (! exist (filepath, "file") && strcmpi (requirement, "optional"))
    ## do nothing, it's still OK
  else
    [status, output] = copyfile (filepath, packinfo);
    if (status != 1)
      sts = rmdir (desc.dir, "s");
      sts = rmdir (octfiledir, "s");
      error ("Couldn't copy %s file: %s", filename, output);
    endif
  endif

endfunction


## Create an INDEX file for a package that doesn't provide one.
##   'desc'  describes the package.
##   'dir'   is the 'inst' directory in temporary directory.
##   'index_file' is the name (including path) of resulting INDEX file.
function write_index (desc, dir, index_file, global_install)

  ## Get names of functions in dir
  [files, err, msg] = readdir (dir);
  if (err)
    error ("couldn't read directory %s: %s", dir, msg);
  endif

  ## Get classes in dir
  class_idx = find (strncmp (files, '@', 1));
  for k = 1:length (class_idx)
    class_name = files {class_idx(k)};
    class_dir = fullfile (dir, class_name);
    if (isfolder (class_dir))
      [files2, err, msg] = readdir (class_dir);
      if (err)
        error ("couldn't read directory %s: %s", class_dir, msg);
      endif
      files2 = strcat (class_name, filesep (), files2);
      files = [files; files2];
    endif
  endfor

  ## Check for architecture dependent files.
  tmpdir = getarchdir (desc);
  if (isfolder (tmpdir))
    [files2, err, msg] = readdir (tmpdir);
    if (err)
      error ("couldn't read directory %s: %s", tmpdir, msg);
    endif
    files = [files; files2];
  endif

  functions = {};
  for i = 1:length (files)
    file = files{i};
    lf = length (file);
    if (lf > 2 && strcmp (file(end-1:end), ".m"))
      functions{end+1} = file(1:end-2);
    elseif (lf > 4 && strcmp (file(end-3:end), ".oct"))
      functions{end+1} = file(1:end-4);
    endif
  endfor

  ## Does desc have a categories field?
  if (! isfield (desc, "categories"))
    error ("the DESCRIPTION file must have a Categories field, when no INDEX file is given");
  endif
  categories = strtrim (strsplit (desc.categories, ","));
  if (length (categories) < 1)
    error ("the Category field is empty");
  endif

  ## Write INDEX.
  fid = fopen (index_file, "w");
  if (fid == -1)
    error ("couldn't open %s for writing", index_file);
  endif
  fprintf (fid, "%s >> %s\n", desc.name, desc.title);
  fprintf (fid, "%s\n", categories{1});
  fprintf (fid, "  %s\n", functions{:});
  fclose (fid);

endfunction


function create_pkgadddel (desc, packdir, nm, global_install)

  instpkg = fullfile (desc.dir, nm);
  instfid = fopen (instpkg, "at"); # append to support PKG_ADD at inst/
  ## If it is exists, most of the PKG_* file should go into the
  ## architecture dependent directory so that the autoload/mfilename
  ## commands work as expected.  The only part that doesn't is the
  ## part in the main directory.
  archdir = fullfile (getarchprefix (desc, global_install),
                      [desc.name "-" desc.version], getarch ());
  if (isfolder (getarchdir (desc)))
    archpkg = fullfile (getarchdir (desc), nm);
    archfid = fopen (archpkg, "at");
  else
    archpkg = instpkg;
    archfid = instfid;
  endif

  if (archfid >= 0 && instfid >= 0)
    if (ispc ())
      oct_glob = @__wglob__;
    else
      oct_glob = @glob;
    endif

    ## Search all dot-m files for PKG commands.
    lst = oct_glob (fullfile (packdir, "inst", "*.m"));
    for i = 1:length (lst)
      nam = lst{i};
      fwrite (instfid, extract_pkg (nam, ['^[#%][#%]* *' nm ': *(.*)$']));
    endfor

    ## Search all C++ source files for PKG commands.
    cc_lst = oct_glob (fullfile (packdir, "src", "*.cc"));
    cpp_lst = oct_glob (fullfile (packdir, "src", "*.cpp"));
    cxx_lst = oct_glob (fullfile (packdir, "src", "*.cxx"));
    lst = [cc_lst; cpp_lst; cxx_lst];
    for i = 1:length (lst)
      nam = lst{i};
      fwrite (archfid, extract_pkg (nam, ['^//* *' nm ': *(.*)$']));
      fwrite (archfid, extract_pkg (nam, ['^/\** *' nm ': *(.*) *\*/$']));
    endfor

    ## Add developer included PKG commands.
    packdirnm = fullfile (packdir, nm);
    if (exist (packdirnm, "file"))
      fid = fopen (packdirnm, "rt");
      if (fid >= 0)
        while (! feof (fid))
          ln = fgets (fid);
          if (ln > 0)
            fwrite (archfid, ln);
          endif
        endwhile
        fclose (fid);
      endif
    endif

    ## If the files is empty remove it.
    fclose (instfid);
    t = dir (instpkg);
    if (t.bytes <= 0)
      unlink (instpkg);
    endif

    if (instfid != archfid)
      fclose (archfid);
      t = dir (archpkg);
      if (t.bytes <= 0)
        unlink (archpkg);
      endif
    endif
  endif

endfunction


function archprefix = getarchprefix (desc, global_install)

  if (global_install)
    [~, archprefix] = default_prefix (global_install, desc);
  else
    archprefix = desc.dir;
  endif

endfunction


function finish_installation (desc, packdir, global_install)

  ## Is there a post-install to call?
  if (exist (fullfile (packdir, "post_install.m"), "file"))
    wd = pwd ();
    try
      cd (packdir);
      post_install (desc);
      cd (wd);
    catch
      cd (wd);
      sts = rmdir (desc.dir, "s");
      sts = rmdir (getarchdir (desc), "s");
      rethrow (lasterror ());
    end_try_catch
  endif

endfunction


function generate_lookfor_cache (desc)

  dirs = strtrim (ostrsplit (genpath (desc.dir), pathsep ()));
  if (ispc)
    dirs = cellfun (@canonicalize_file_name, dirs, "uniformoutput", false);
  endif
  for i = 1 : length (dirs)
    doc_cache_create (fullfile (dirs{i}, "doc-cache"), dirs{i});
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{out1}, @var{out2}] =} installed_packages (@var{local_list}, @var{global_list}, @var{pkgname})
## Undocumented internal function.
## @end deftypefn

function [out1, out2] = installed_packages (local_list, global_list, pkgname = {})

  ## Get the list of installed packages.
  local_packages = {};
  global_packages = {};
  installed_pkgs_lst = {local_packages{:}, global_packages{:}};

  ## Eliminate duplicates in the installed package list.
  ## Locally installed packages take precedence.
  installed_names = cellfun (@(x) x.name, installed_pkgs_lst,
                             "uniformoutput", false);
  [~, idx] = unique (installed_names, "first");
  installed_names = installed_names(idx);
  installed_pkgs_lst = installed_pkgs_lst(idx);

  ## Check whether info on a particular package was requested
  if (! isempty (pkgname))
    idx = [];
    for i = 1 : numel (pkgname)
      idx = [idx, find(strcmp (pkgname{i}, installed_names))];
    endfor
    if (isempty (idx))
      installed_names = {};
      installed_pkgs_lst = {};
    else
      installed_names = installed_names(idx);
      installed_pkgs_lst = installed_pkgs_lst(idx);
    endif
  endif

  ## Now check if the package is loaded.
  ## FIXME: Couldn't dir_in_loadpath() be used here?
  tmppath = path ();
  for i = 1:numel (installed_pkgs_lst)
    if (strfind (tmppath, installed_pkgs_lst{i}.dir))
      installed_pkgs_lst{i}.loaded = true;
    else
      installed_pkgs_lst{i}.loaded = false;
    endif
  endfor
  for i = 1:numel (local_packages)
    if (strfind (tmppath, local_packages{i}.dir))
      local_packages{i}.loaded = true;
    else
      local_packages{i}.loaded = false;
    endif
  endfor
  for i = 1:numel (global_packages)
    if (strfind (tmppath, global_packages{i}.dir))
      global_packages{i}.loaded = true;
    else
      global_packages{i}.loaded = false;
    endif
  endfor

  ## Should we return something?
  if (nargout == 1)
    out1 = installed_pkgs_lst;
  elseif (nargout > 1)
    out1 = local_packages;
    out2 = global_packages;
  else
    ## Don't return anything, instead we'll print something.
    num_packages = numel (installed_pkgs_lst);
    if (num_packages == 0)
      if (isempty (pkgname))
        printf ("no packages installed.\n");
      else
        printf ("package %s is not installed.\n", pkgname{1});
      endif
      return;
    endif

    ## Compute the maximal lengths of name, version, and dir.
    h1 = "Package Name";
    h2 = "Version";
    h3 = "Installation directory";
    max_name_length = max ([length(h1), cellfun(@length, installed_names)]);
    version_lengths = cellfun (@(x) length (x.version), installed_pkgs_lst);
    max_version_length = max ([length(h2), version_lengths]);
    ncols = terminal_size ()(2);
    max_dir_length = ncols - max_name_length - max_version_length - 7;
    if (max_dir_length < 20)
      max_dir_length = Inf;
    endif

    h1 = postpad (h1, max_name_length + 1, " ");
    h2 = postpad (h2, max_version_length, " ");;

    ## Print a header.
    header = sprintf ("%s | %s | %s\n", h1, h2, h3);
    printf (header);
    tmp = sprintf (repmat ("-", 1, length (header) - 1));
    tmp(length (h1)+2) = "+";
    tmp(length (h1)+length (h2)+5) = "+";
    printf ("%s\n", tmp);

    ## Print the packages.
    format = sprintf ("%%%ds %%1s| %%%ds | %%s\n",
                      max_name_length, max_version_length);
    for i = 1:num_packages
      cur_name = installed_pkgs_lst{i}.name;
      cur_version = installed_pkgs_lst{i}.version;
      cur_dir = installed_pkgs_lst{i}.dir;
      if (length (cur_dir) > max_dir_length)
        first_char = length (cur_dir) - max_dir_length + 4;
        first_filesep = strfind (cur_dir(first_char:end), filesep ());
        if (! isempty (first_filesep))
          cur_dir = ["..." cur_dir((first_char + first_filesep(1) - 1):end)];
        else
          cur_dir = ["..." cur_dir(first_char:end)];
        endif
      endif
      if (installed_pkgs_lst{i}.loaded)
        cur_loaded = "*";
      else
        cur_loaded = " ";
      endif
      printf (format, cur_name, cur_loaded, cur_version, cur_dir);
    endfor
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{list} =} list_forge_packages ()
## Undocumented internal function.
## @end deftypefn

function list = list_forge_packages ()

  [list, succ] = urlread ("https://packages.octave.org/list_packages.php");
  if (! succ)
    error ("pkg: could not read URL, please verify internet connection");
  endif

  list = ostrsplit (list, " \n\t", true);

  if (nargout == 0)
    ## FIXME: This is a convoluted way to get the latest version number
    ##        for each package in less than 56 seconds (bug #39479).

    ## Get the list of all packages ever published
    [html, succ] = urlread ('https://sourceforge.net/projects/octave/files/Octave%20Forge%20Packages/Individual%20Package%20Releases');

    if (! succ)
      error ("pkg: failed to fetch list of packages from sourceforge.net");
    endif

    ## Scrape the HTML
    ptn = '<tr\s+title="(.*?gz)"\s+class="file';
    [succ, tok] = regexp (html, ptn, "start", "tokens");
    if (isempty (succ))
      error ("pkg: failed to parse list of packages from sourceforge.net");
    endif

    ## Remove version numbers and produce unique list of packages
    files = cellstr (tok);
    pkg_names = cellstr (regexp (files, '^.*?(?=-\d)', "match"));
    [~, idx] = unique (pkg_names, "first");
    files = files(idx);

    page_screen_output (false, "local");
    puts ("Octave Forge provides these packages:\n");
    for i = 1:length (list)
      pkg_nm = list{i};
      idx = regexp (files, sprintf ('^%s(?=-\\d)', pkg_nm));
      idx = ! cellfun (@isempty, idx);
      if (any (idx))
        ver = regexp (files{idx}, '\d+\.\d+\.\d+', "match"){1};
      else
        ver = "unknown";
      endif
      printf ("  %s %s\n", pkg_nm, ver);
    endfor
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} load_packages (@var{files}, @var{handle_deps}, @var{local_list}, @var{global_list})
## Undocumented internal function.
## @end deftypefn

function load_packages (files, handle_deps, local_list, global_list)

  installed_pkgs_lst = installed_packages (local_list, global_list);
  num_packages = length (installed_pkgs_lst);

  ## Read package names and installdirs into a more convenient format.
  pnames = pdirs = cell (1, num_packages);
  for i = 1:num_packages
    pnames{i} = installed_pkgs_lst{i}.name;
    pdirs{i} = installed_pkgs_lst{i}.dir;
  endfor

  idx = [];
  for i = 1:length (files)
    idx2 = find (strcmp (pnames, files{i}));
    if (! any (idx2))
      error ("package %s is not installed", files{i});
    endif
    idx(end + 1) = idx2;
  endfor

  ## Load the packages, but take care of the ordering of dependencies.
  load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst, true);

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} load_packages_and_dependencies (@var{idx}, @var{handle_deps}, @var{installed_pkgs_lst}, @var{global_install})
## Undocumented internal function.
## @end deftypefn

function load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
                                         global_install)

  idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
  dirs = {};
  execpath = EXEC_PATH ();
  for i = idx
    ndir = installed_pkgs_lst{i}.dir;
    dirs{end+1} = ndir;
    if (isfolder (fullfile (dirs{end}, "bin")))
      execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
    endif
    tmpdir = getarchdir (installed_pkgs_lst{i});
    if (isfolder (tmpdir))
      dirs{end + 1} = tmpdir;
      if (isfolder (fullfile (dirs{end}, "bin")))
        execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
      endif
    endif
  endfor

  ## Dependencies are sorted before their dependers in "dirs". Add them
  ## consecutively in a for loop to the path to make sure dependencies are
  ## added before their dependers (bug #57403).
  for ii = 1:numel (dirs)
    addpath (dirs{ii});
  endfor

  ## Add the binaries to exec_path.
  if (! strcmp (EXEC_PATH, execpath))
    EXEC_PATH (execpath);
  endif

  ## Update lexer for autocompletion if necessary
  if (isguirunning && (length (idx) > 0))
    __event_manager_update_gui_lexer__;
  endif

endfunction


function idx = load_package_dirs (lidx, idx, handle_deps, installed_pkgs_lst)

  for i = lidx
    if (isfield (installed_pkgs_lst{i}, "loaded")
        && installed_pkgs_lst{i}.loaded)
      continue;
    else
      ## Insert this package at the front before recursing over dependencies.
      if (! any (idx == i))
        idx = [i, idx];
      endif

      if (handle_deps)
        deps = installed_pkgs_lst{i}.depends;
        if ((length (deps) > 1)
            || (length (deps) == 1 && ! strcmp (deps{1}.package, "octave")))
          tmplidx = [];
          for k = 1 : length (deps)
            for j = 1 : length (installed_pkgs_lst)
              if (strcmp (installed_pkgs_lst{j}.name, deps{k}.package))
                if (! any (idx == j))
                  tmplidx(end + 1) = j;
                  break;
                endif
              endif
            endfor
          endfor
          idx = load_package_dirs (tmplidx, idx, handle_deps,
                                 installed_pkgs_lst);
        endif
      endif
    endif
  endfor

endfunction
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## Octave is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{pkg_list} =} make_rel_paths (@var{pkg_list})
## Internal undocumented function.
## @end deftypefn

function pkg_list = make_rel_paths (pkg_list)

  ptn = ["^" strrep(canonicalize_file_name (OCTAVE_HOME), '\', '\\')];

  ## Strip pkg install directories from OCTAVE_HOME
  for i = 1:numel (pkg_list)
    pkg_list{i}.dir = canonicalize_file_name (pkg_list{i}.dir);
    pkg_list{i}.dir = regexprep (pkg_list{i}.dir, ptn, "__OH__");
    pkg_list{i}.archprefix = canonicalize_file_name (pkg_list{i}.archprefix);
    pkg_list{i}.archprefix = regexprep (pkg_list{i}.archprefix, ptn, "__OH__");
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{descriptions} =} rebuild (@var{prefix}, @var{archprefix}, @var{list}, @var{files}, @var{verbose})
## Undocumented internal function.
## @end deftypefn

function descriptions = rebuild (prefix, archprefix, list, files, verbose)

  if (isempty (files))
    if (! exist (prefix, "dir"))
      dirlist = [];
    else
      [dirlist, err, msg] = readdir (prefix);
      if (err)
        error ("couldn't read directory %s: %s", prefix, msg);
      endif
      ## the two first entries of dirlist are "." and ".."
      dirlist([1,2]) = [];
    endif
  else
    old_descriptions = installed_packages (list, list);
    wd = pwd ();
    unwind_protect
      cd (prefix);
      if (ispc ())
        dirlist = __wglob__ (strcat (files, '-*'));
      else
        dirlist = glob (strcat (files, '-*'));
      endif
    unwind_protect_cleanup
      cd (wd);
    end_unwind_protect
  endif

  descriptions = {};
  for k = 1:length (dirlist)
    descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
    if (verbose)
      printf ("recreating package description from %s\n", dirlist{k});
    endif
    if (exist (descfile, "file"))
      desc = get_description (descfile);
      desc.dir = fullfile (prefix, dirlist{k});
      desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);
      descriptions{end + 1} = desc;
    elseif (verbose)
      warning ("directory %s is not a valid package", dirlist{k});
    endif
  endfor

  if (! isempty (files))
    ## We are rebuilding for a particular package(s) so we should take
    ## care to keep the other untouched packages in the descriptions
    descriptions = {descriptions{:}, old_descriptions{:}};

    dup = [];
    for i = 1:length (descriptions)
      if (any (dup == i))
        continue;
      endif
      for j = (i+1):length (descriptions)
        if (any (dup == j))
          continue;
        endif
        if (strcmp (descriptions{i}.name, descriptions{j}.name))
          dup = [dup, j];
        endif
      endfor
    endfor
    if (! isempty (dup))
      descriptions(dup) = [];
    endif
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{newdesc} =} save_order (@var{desc})
## Undocumented internal function.
## @end deftypefn

function newdesc = save_order (desc)

  newdesc = {};
  for i = 1 : length (desc)
    deps = desc{i}.depends;
    if (isempty (deps)
        || (length (deps) == 1 && strcmp (deps{1}.package, "octave")))
      newdesc{end + 1} = desc{i};
    else
      tmpdesc = {};
      for k = 1 : length (deps)
        for j = 1 : length (desc)
          if (strcmp (desc{j}.name, deps{k}.package))
            tmpdesc{end+1} = desc{j};
            break;
          endif
        endfor
      endfor
      if (! isempty (tmpdesc))
        newdesc = {newdesc{:}, save_order(tmpdesc){:}, desc{i}};
      else
        newdesc{end+1} = desc{i};
      endif
    endif
  endfor

  ## Eliminate the duplicates.
  idx = [];
  for i = 1 : length (newdesc)
    for j = (i + 1) : length (newdesc)
      if (strcmp (newdesc{i}.name, newdesc{j}.name))
        idx(end + 1) = j;
      endif
    endfor
  endfor
  newdesc(idx) = [];

endfunction
########################################################################
##
## Copyright (C) 2019-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{pkg_list} =} standardize_paths (@var{pkg_list})
## Convert pathnames in various representations to unique strings.
##
## The input @var{pkg_list} must be a cell array of strings.
##
## This function is particularly necessary on Windows platforms where pathnames
## may differ in case (@file{file1} vs.@: @file {FILE1}), file separator
## (@samp{\} vs.@: @samp{/}), and format (@file{A~spaces.txt} (8.3 convention)
## vs.@: @file{A filename with spaces.txt}).
##
## @seealso{canonicalize_file_name}
## @end deftypefn

function pkg_list = standardize_paths (pkg_list)

  for i = 1:numel (pkg_list)
    pkg_list{i}.dir = canonicalize_file_name (pkg_list{i}.dir);
    pkg_list{i}.archprefix = canonicalize_file_name (pkg_list{i}.archprefix);
  endfor

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} uninstall (@var{pkgnames}, @var{handle_deps}, @var{verbose}, @var{local_list}, @var{global_list}, @var{global_install})
## Undocumented internal function.
## @end deftypefn

function uninstall (pkgnames, handle_deps, verbose, local_list,
                    global_list, global_install)

  ## Get the list of installed packages.
  [local_packages, global_packages] = installed_packages (local_list,
                                                          global_list);
  if (global_install)
    installed_pkgs_lst = [local_packages, global_packages];
  else
    installed_pkgs_lst = local_packages;
  endif

  all_pkgs_list = [local_packages, global_packages];
  all_installed_pkgs_lst = cellfun (@(x) x.name, all_pkgs_list, ...
                                    "uniformoutput", false);
  num_packages = numel (installed_pkgs_lst);
  delete_idx = [];
  available_packages = intersect (all_installed_pkgs_lst, pkgnames);

  for i = 1:num_packages
    cur_name = installed_pkgs_lst{i}.name;
    if (any (strcmp (cur_name, pkgnames)))
      delete_idx(end+1) = i;
    endif
  endfor

  ## Are all the packages that should be uninstalled already installed?
  if (numel (available_packages) != numel (pkgnames))
    pkgs_not_installed = setxor (available_packages, pkgnames);
    for idx = 1:numel (pkgs_not_installed)
      warning ("package %s is not installed\n", pkgs_not_installed{idx});
    endfor
  endif

  ## inform user if any global packages can't be uninstalled
  if (! global_install)
    for i = 1:numel (global_packages)
      if (any (strcmp (global_packages{i}.name, pkgnames)))
        warning ("%s is a global package and cannot be removed locally\n", ...
          global_packages{i}.name);
      endif
    endfor
  endif

  if (isempty (delete_idx))
    warning ("no packages will be uninstalled");
  else

    ## Compute the packages that will remain installed.
    idx = setdiff (1:num_packages, delete_idx);
    remaining_packages = installed_pkgs_lst(idx);
    to_delete_packages = installed_pkgs_lst(delete_idx);

    ## Check dependencies.
    if (handle_deps)
      error_text = "";
      for i = 1:numel (remaining_packages)
        desc = remaining_packages{i};
        bad_deps = get_unsatisfied_deps (desc, to_delete_packages, true);

        ## Will the uninstallation break any dependencies?
        if (! isempty (bad_deps))
          for i = 1:numel (bad_deps)
            dep = bad_deps{i};
            error_text = [error_text " " desc.name " needs " ...
                          dep.package " " dep.operator " " dep.version "\n"];
          endfor
        endif
      endfor

      if (! isempty (error_text))
        error ("the following dependencies where unsatisfied:\n  %s", error_text);
      endif
    endif

    ## Delete the directories containing the packages.
    for i = delete_idx
      desc = installed_pkgs_lst{i};
      ## If an 'on_uninstall.m' exist, call it!
      if (exist (fullfile (desc.dir, "packinfo", "on_uninstall.m"), "file"))
        wd = pwd ();
        cd (fullfile (desc.dir, "packinfo"));
        on_uninstall (desc);
        cd (wd);
      endif
      ## Do the actual deletion.
      if (desc.loaded)
        rmpath (desc.dir);
        if (isfolder (getarchdir (desc)))
          rmpath (getarchdir (desc));
        endif
      endif
      if (isfolder (desc.dir))
        ## FIXME: If first call to rmdir fails, then error() will
        ##        stop further processing of getarchdir & archprefix.
        ##        If this is, in fact, correct, then calls should
        ##        just be shortened to rmdir (...) and let rmdir()
        ##        report failure and reason for failure.
        [status, msg] = rmdir (desc.dir, "s");
        if (status != 1 && isfolder (desc.dir))
          error ("couldn't delete directory %s: %s", desc.dir, msg);
        endif
        [status, msg] = rmdir (getarchdir (desc), "s");
        if (status != 1 && isfolder (getarchdir (desc)))
          error ("couldn't delete directory %s: %s", getarchdir (desc), msg);
        endif
        if (dirempty (desc.archprefix))
          sts = rmdir (desc.archprefix, "s");
        endif
      else
        warning ("directory %s previously lost", desc.dir);
      endif
    endfor

    ## Write a new ~/.octave_packages.
    if (global_install)
      if (numel (remaining_packages) == 0)
        [~] = unlink (global_list);
      else
        global_packages = save_order (remaining_packages);
        if (ispc)
          ## On Windows ensure LFN paths are saved rather than 8.3 style paths
          global_packages = standardize_paths (global_packages);
        endif
        global_packages = make_rel_paths (global_packages);
        save (global_list, "global_packages");
      endif
    else
      if (numel (remaining_packages) == 0)
        [~] = unlink (local_list);
      else
        local_packages = save_order (remaining_packages);
        if (ispc)
          local_packages = standardize_paths (local_packages);
        endif
        save (local_list, "local_packages");
      endif
    endif
  endif

endfunction
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} unload_packages (@var{files}, @var{handle_deps}, @var{local_list}, @var{global_list})
## Undocumented internal function.
## @end deftypefn

function unload_packages (files, handle_deps, local_list, global_list)

  installed_pkgs_lst = installed_packages (local_list, global_list);
  num_packages = numel (installed_pkgs_lst);
  ## Add inverse dependencies to field "invdeps" of installed_pkgs_lst
  installed_pkgs_lst = get_inverse_dependencies (installed_pkgs_lst);

  ## Read package names and installdirs into a more convenient format.
  pnames = cellfun (@(x) x.name, installed_pkgs_lst, "UniformOutput", false);
  pdirs = cellfun (@(x) x.dir, installed_pkgs_lst, "UniformOutput", false);

  ## Get the current octave path.
  p = strtrim (ostrsplit (path (), pathsep ()));

  ## Unload package_name1 ...
  dirs = {};
  desc = {};
  idx = find (ismember (pnames, files));
  missing_pkgs = setdiff (files, pnames(idx));
  if (! isempty (missing_pkgs))
    missing_pkgs = strjoin (missing_pkgs, " & ");
    error ("pkg: package(s): %s not installed", missing_pkgs);
  endif
  dirs = pdirs(idx);
  desc = installed_pkgs_lst(idx);

  if (handle_deps)
    ## Check for loaded inverse dependencies of packages to be unloaded.
    ## First create a list of loaded packages.
    jdx = find (cellfun (@(x) x.loaded, installed_pkgs_lst));

    ## Exclude packages requested to be unloaded
    jdx = setdiff (jdx, idx);
    loaded_pkgs = installed_pkgs_lst(jdx);
    lpnames = pnames(jdx);
    p2unload = pnames(idx);
    linvdeps = {};
    for i = 1:numel (desc)
      ## Which inverse dependencies depend on this package-to-be-unloaded?
      linvdeps = [linvdeps, get_inv_deps(desc{i}, loaded_pkgs, lpnames){:}];
    endfor
    if (! isempty (linvdeps))
      linvdeps = unique (linvdeps);
      txt = strjoin (linvdeps, "\n\t - ");
      error (["pkg: the following loaded package(s):\n", ...
              "\t - %s\n", ...
              "depend on the one(s) you want to unload.\n", ...
              "Either unload any depender package(s), or use the '-nodeps' flag.\n", ...
              "Note: the '-nodeps' flag may affect functionality of these packages.\n"],
             txt);
    endif
  endif

  ## Check for architecture dependent directories.
  archdirs = {};
  for i = 1:numel (dirs)
    tmpdir = getarchdir (desc{i});
    if (isfolder (tmpdir))
      archdirs{end+1} = dirs{i};
      archdirs{end+1} = tmpdir;
    else
      archdirs{end+1} = dirs{i};
    endif
  endfor

  ## Unload the packages.
  for i = 1:numel (archdirs)
    d = archdirs{i};
    idx = strcmp (p, d);
    if (any (idx))
      rmpath (d);
      ## FIXME: We should also check if we need to remove items from EXEC_PATH.
      if (isguirunning)
        __event_manager_update_gui_lexer__;
      endif
    endif
  endfor

endfunction


function linvdeps = get_inv_deps (desc, loaded_pkgs, lpnames)

  ## Which nested loaded inverse dependencies depend on the package in desc?
  linvdeps = intersect (desc.invdeps, lpnames);
  for i = 1:numel (linvdeps)
    kdx = find (ismember (lpnames, linvdeps{i}));
    linvdeps = [ linvdeps (get_inv_deps (loaded_pkgs{kdx}, ...
                                         loaded_pkgs, lpnames)){:} ];
  endfor

endfunction
encoding=utf-8
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} compan (@var{c})
## Compute the companion matrix corresponding to polynomial coefficient vector
## @var{c}.
##
## The companion matrix is
## @tex
## $$
## A = \left[\matrix{
##  -c_2/c_1 & -c_3/c_1 & \cdots & -c_N/c_1 & -c_{N+1}/c_1\cr
##      1    &     0    & \cdots &     0    &         0   \cr
##      0    &     1    & \cdots &     0    &         0   \cr
##   \vdots  &   \vdots & \ddots &  \vdots  &      \vdots \cr
##      0    &     0    & \cdots &     1    &         0}\right].
## $$
## @end tex
## @ifnottex
## @c Set example in small font to prevent overfull line
##
## @smallexample
## @group
##      _                                                        _
##     |  -c(2)/c(1)   -c(3)/c(1)  @dots{}  -c(N)/c(1)  -c(N+1)/c(1)  |
##     |       1            0      @dots{}       0             0      |
##     |       0            1      @dots{}       0             0      |
## A = |       .            .      .         .             .      |
##     |       .            .       .        .             .      |
##     |       .            .        .       .             .      |
##     |_      0            0      @dots{}       1             0     _|
## @end group
## @end smallexample
##
## @end ifnottex
## The eigenvalues of the companion matrix are equal to the roots of the
## polynomial.
## @seealso{roots, poly, eig}
## @end deftypefn

function A = compan (c)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isvector (c))
    error ("compan: C must be a vector");
  endif

  n = length (c);

  if (n == 1)
    A = [];
  else
    A = diag (ones (n-2, 1), -1);
    A(1,:) = -c(2:n) / c(1);
  endif

endfunction


%!assert (compan ([1, 2, 3]), [-2, -3; 1, 0])
%!assert (compan ([1; 2; 3]), [-2, -3; 1, 0])
%!assert (isempty (compan (4)))
%!assert (compan ([3, 2, 1]), [-2/3, -1/3; 1, 0])

%!error compan ([1,2;3,4])
%!error compan ([])
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} conv (@var{a}, @var{b})
## @deftypefnx {} {} conv (@var{a}, @var{b}, @var{shape})
## Convolve two vectors @var{a} and @var{b}.
##
## When @var{a} and @var{b} are the coefficient vectors of two polynomials, the
## convolution represents the coefficient vector of the product polynomial.
##
## The size of the result is determined by the optional @var{shape} argument
## which takes the following values
##
## @table @asis
## @item @var{shape} = @qcode{"full"}
## Return the full convolution.  (default)
## The result is a vector with length equal to
## @code{length (@var{a}) + length (@var{b}) - 1}.
##
## @item @var{shape} = @qcode{"same"}
## Return the central part of the convolution with the same size as @var{a}.
##
## @item @var{shape} = @qcode{"valid"}
## Return only the parts which do not include zero-padded edges.
## The size of the result is
## @code{max (size (@var{a}) - size (@var{b}) + 1, 0)}.
## @end table
##
## @seealso{deconv, conv2, convn, fftconv}
## @end deftypefn

function y = conv (a, b, shape = "full")

  if (nargin < 2)
    print_usage ();
  endif

  if (! (isvector (a) && isvector (b)))
    error ("conv: both arguments A and B must be vectors");
  elseif (nargin == 3 && ! any (strcmpi (shape, {"full", "same", "valid"})))
    error ('conv: SHAPE argument must be "full", "same", or "valid"');
  endif

  y = conv2 (a(:), b(:), shape);

  if (strcmpi (shape, "full"))
    ## Adapt the shape to the longest input argument, if necessary.
    if ((length (a) > length (b) && isrow (a)) ...
        || (length (a) <= length (b) && isrow (b)))
      y = y.';
    endif
  elseif (isrow (a))
    ## Adapt the shape to the first input argument, if necessary.
    y = y.';
  endif

endfunction


%!test
%! x = ones (3,1);
%! y = ones (1,3);
%! b = 2;
%! c = 3;
%! assert (conv (x, x), [1; 2; 3; 2; 1]);
%! assert (conv (y, y), [1, 2, 3, 2, 1]);
%! assert (conv (x, y), [1, 2, 3, 2, 1]);
%! assert (conv (y, x), [1; 2; 3; 2; 1]);
%! assert (conv (c, x), [3; 3; 3]);
%! assert (conv (c, y), [3, 3, 3]);
%! assert (conv (x, c), [3; 3; 3]);
%! assert (conv (y, c), [3, 3, 3]);
%! assert (conv (b, c), 6);

%!shared a,b
%!test
%! a = 1:10;
%! b = 1:3;
%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])

%!test
%! a = (1:10).';
%!assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1])
%!assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1])

%!test
%! a = 1:10;
%! b = (1:3).';
%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])

%!test
%! a = 1:10;
%! b = 1:3;

%!assert (conv (a,b,"full"), conv (a,b))
%!assert (conv (b,a,"full"), conv (b,a))

%!assert (conv (a,b,"same"), [4, 10, 16, 22, 28, 34, 40, 46, 52, 47])
%!assert (conv (b,a,"same"), [28, 34, 40])

%!assert (conv (a,b,"valid"), [10, 16, 22, 28, 34, 40, 46, 52])
%!assert (conv (b,a,"valid"), zeros (1,0))


## Test input validation
%!error <Invalid call> conv (1)
%!error <A and B must be vectors> conv ([1, 2; 3, 4], 3)
%!error <A and B must be vectors> conv (3, [1, 2; 3, 4])
%!error <SHAPE argument must be> conv (2, 3, "INVALID_SHAPE")
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{b} =} deconv (@var{y}, @var{a})
## @deftypefnx {} {[@var{b}, @var{r}] =} deconv (@var{y}, @var{a})
## Deconvolve two vectors (polynomial division).
##
## @code{[@var{b}, @var{r}] = deconv (@var{y}, @var{a})} solves for @var{b} and
## @var{r} such that @code{@var{y} = conv (@var{a}, @var{b}) + @var{r}}.
##
## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
## contain the coefficients of the polynomial quotient and @var{r} will be
## a remainder polynomial of lowest order.
## @seealso{conv, residue}
## @end deftypefn

function [b, r] = deconv (y, a)

  if (nargin != 2)
    print_usage ();
  endif

  if (! (isvector (y) && isvector (a)))
    error ("deconv: Y and A must be vectors");
  endif

  ## Ensure A is oriented as Y.
  if ((isrow (y) && iscolumn (a)) || (iscolumn (y) && isrow (a)))
    a = a.';
  endif

  la = length (a);
  ly = length (y);

  lb = ly - la + 1;

  if (ly > la)
    x = zeros (size (y) - size (a) + 1);
    x(1) = 1;
    [b, r] = filter (y, a, x);
    r *= a(1);
  elseif (ly == la)
    [b, r] = filter (y, a, 1);
    r *= a(1);
  else
    b = 0;
    r = y;
  endif

  if (isargout (2))
    if (ly >= la)
      r = [zeros(ly - la + 1, 1); r(1:la - 1)];
      ## Respect the orientation of Y
      r = reshape (r, size (y));
    endif
  endif

endfunction


%!test
%! [b, r] = deconv ([3, 6, 9, 9], [1, 2, 3]);
%! assert (b, [3, 0]);
%! assert (r, [0, 0, 0, 9]);

%!test
%! [b, r] = deconv ([3, 6], [1, 2, 3]);
%! assert (b, 0);
%! assert (r, [3, 6]);

%!test
%! [b, r] = deconv ([3, 6], [1; 2; 3]);
%! assert (b, 0);
%! assert (r, [3, 6]);

%!test
%! [b,r] = deconv ([3; 6], [1; 2; 3]);
%! assert (b, 0);
%! assert (r, [3; 6]);

%!test
%! [b, r] = deconv ([3; 6], [1, 2, 3]);
%! assert (b, 0);
%! assert (r, [3; 6]);

%!assert (deconv ((1:3)',[1, 1]), [1; 1])

## Test input validation
%!error deconv (1)
%!error deconv (1,2,3)
%!error <Y .* must be vector> deconv ([3, 6], [1, 2; 3, 4])
%!error <A must be vector> deconv ([3, 6], [1, 2; 3, 4])

%!test
%! y = (10:-1:1);
%! a = (4:-1:1);
%! [b, r] = deconv (y, a);
%! assert (conv (a, b) + r, y, eps);

%!test <*51221>
%! a = [1.92306958582241e+15, 3.20449986572221e+24, 1.34271290136344e+32, ...
%!     2.32739765751038e+38];
%! b = [7.33727670161595e+27, 1.05919311870816e+36, 4.56169848520627e+42];
%! [div, rem] = deconv (a, b);
%! assert (rem, [0, 0, -2.89443678763879e+32  -1.58695290534499e+39], -10*eps);
%! a(2) = 3.204499865722215e+24;
%! [div, rem] = deconv (a, b);
%! assert (rem, [0, 0, -2.89443678763879e+32  -1.58695290534499e+39], -10*eps);

%!test
%! [b, r] = deconv ([1, 1], 1);
%! assert (r, [0, 0]);

%!test
%! [b, r] = deconv ([1; 1], 1);
%! assert (r, [0; 0]);
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{pp} =} mkpp (@var{breaks}, @var{coefs})
## @deftypefnx {} {@var{pp} =} mkpp (@var{breaks}, @var{coefs}, @var{d})
##
## Construct a piecewise polynomial (pp) structure from sample points
## @var{breaks} and coefficients @var{coefs}.
##
## @var{breaks} must be a vector of strictly increasing values.  The number of
## intervals is given by @code{@var{ni} = length (@var{breaks}) - 1}.
##
## When @var{m} is the polynomial order @var{coefs} must be of size:
## @w{@var{ni}-by-(@var{m} + 1)}.
##
## The i-th row of @var{coefs}, @code{@var{coefs}(@var{i},:)}, contains the
## coefficients for the polynomial over the @var{i}-th interval, ordered from
## highest (@var{m}) to lowest (@var{0}) degree.
##
## @var{coefs} may also be a multi-dimensional array, specifying a
## vector-valued or array-valued polynomial.  In that case the polynomial
## order @var{m} is defined by the length of the last dimension of @var{coefs}.
## The size of first dimension(s) are given by the scalar or vector @var{d}.
## If @var{d} is not given it is set to @code{1}.  In this case
## @code{@var{p}(@var{r}, @var{i}, :)} contains the coefficients for the
## @var{r}-th polynomial defined on interval @var{i}.  In any case @var{coefs}
## is reshaped to a 2-D matrix of size @code{[@var{ni}*prod(@var{d}) @var{m}]}.
##
## Programming Note: @code{ppval} evaluates polynomials at
## @code{@var{xi} - @var{breaks}(i)}, i.e., it subtracts the lower endpoint of
## the current interval from @var{xi}.  This must be taken into account when
## creating piecewise polynomials objects with @code{mkpp}.
## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
## @end deftypefn

function pp = mkpp (breaks, coefs, d)

  if (nargin < 2)
    print_usage ();
  endif

  ## Check BREAKS
  if (! isvector (breaks))
    error ("mkpp: BREAKS must be a vector");
  elseif (length (breaks) < 2)
    error ("mkpp: BREAKS must have at least one interval");
  endif

  len = length (breaks) - 1;

  pp = struct ("form", "pp",
               "breaks", breaks(:).',
               "coefs", [],
               "pieces", len,
               "order", prod (size (coefs)) / len,
               "dim", 1);

  if (nargin == 3)
    pp.dim = d;
    pp.order /= prod (d);
  endif

  dim_vec = [pp.pieces * prod(pp.dim), pp.order];
  pp.coefs = reshape (coefs, dim_vec);

endfunction


%!demo # linear interpolation
%! x = linspace (0, pi, 5)';
%! t = [sin(x), cos(x)];
%! m = diff (t) ./ (x(2)-x(1));
%! b = t(1:4,:);
%! pp = mkpp (x, [m(:),b(:)]);
%! xi = linspace (0, pi, 50);
%! plot (x, t, "x", xi, ppval (pp,xi));bb4af245dff7
%! legend ("control", "interp");

%!demo # piecewise polynomial shape
%! breaks = [0 1 2 3];
%! dim = 2;
%! coefs = zeros (dim, length (breaks) - 1, 4);
%! # 1st edge of the shape (x, x^2)
%! coefs(1,1,:) = [0 0 1 0];
%! coefs(2,1,:) = [0 1 0 0];
%! # 2nd edge of the shape (-3x, 1)
%! coefs(1,2,:) = [0 0 -3 1];
%! coefs(2,2,:) = [0 0 0 1];
%! # 3rd edge of the shape (2x - 2, -4(x -1/2)^3 + 1/2)
%! coefs(1,3,:) = [0 0 2 -2];
%! coefs(2,3,:) = [-4 6 -3 1];
%! pp = mkpp (breaks, coefs, dim);
%! t = linspace (0, 3, 100).';
%! xy = ppval (pp, t).';
%! patch (xy(:,1), xy(:,2), 'r');

%!shared b,c,pp
%! b = 1:3; c = 1:24; pp = mkpp (b,c);
%!assert (pp.pieces, 2)
%!assert (pp.order, 12)
%!assert (pp.dim, 1)
%!assert (size (pp.coefs), [2,12])
%! pp = mkpp (b,c,2);
%!assert (pp.pieces, 2)
%!assert (pp.order, 6)
%!assert (pp.dim, 2)
%!assert (size (pp.coefs), [4,6])
%! pp = mkpp (b,c,3);
%!assert (pp.pieces, 2)
%!assert (pp.order, 4)
%!assert (pp.dim, 3)
%!assert (size (pp.coefs), [6,4])
%! pp = mkpp (b,c,[2,3]);
%!assert (pp.pieces, 2)
%!assert (pp.order, 2)
%!assert (pp.dim, [2,3])
%!assert (size (pp.coefs), [12,2])
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{multp}, @var{idxp}] =} mpoles (@var{p})
## @deftypefnx {} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol})
## @deftypefnx {} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
## Identify unique poles in @var{p} and their associated multiplicity.
##
## The output is ordered from pole with largest magnitude to smallest
## magnitude.
##
## If the relative difference of two poles is less than @var{tol} then they are
## considered to be multiples.  The default value for @var{tol} is 0.001.
##
## If the optional parameter @var{reorder} is zero, poles are not sorted.
##
## The output @var{multp} is a vector specifying the multiplicity of the poles.
## @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
## @code{@var{p}(@var{idxp}(n))}.
##
## For example:
##
## @example
## @group
## p = [2 3 1 1 2];
## [m, n] = mpoles (p)
##    @result{} m = [1; 1; 2; 1; 2]
##    @result{} n = [2; 5; 1; 4; 3]
##    @result{} p(n) = [3, 2, 2, 1, 1]
## @end group
## @end example
##
## @seealso{residue, poly, roots, conv, deconv}
## @end deftypefn

function [multp, indx] = mpoles (p, tol, reorder)

  if (nargin < 1)
    print_usage ();
  endif

   if (nargin < 2 || isempty (tol))
     tol = 0.001;
   endif

   if (nargin < 3 || isempty (reorder))
     reorder = true;
   endif

  Np = numel (p);

  ## force poles to be a column vector

  p = p(:);

  if (reorder)
    ## sort with largest magnitude first
    [~, ordr] = sort (abs (p), "descend");
    p = p(ordr);
  else
    ordr = (1:Np).';
  endif

  ## find pole multiplicity by comparing relative difference of poles

  multp = zeros (Np, 1);
  indx = [];
  n = find (multp == 0, 1);
  while (n)
    dp = abs (p-p(n));
    if (p(n) == 0.0)
      if (any (abs (p) > 0 & isfinite (p)))
        p0 = mean (abs (p(abs (p) > 0 & isfinite (p))));
      else
        p0 = 1;
      endif
    else
      p0 = abs (p(n));
    endif
    k = find (dp < tol * p0);
    ## Poles can only be members of one multiplicity group.
    if (numel (indx))
      k = k(! ismember (k, indx));
    endif
    m = 1:numel (k);
    multp(k) = m;
    indx = [indx; k];
    n = find (multp == 0, 1);
  endwhile
  multp = multp(indx);
  indx = ordr(indx);

endfunction


%!test
%! [mp, n] = mpoles ([0 0], 0.01);
%! assert (mp, [1; 2]);

%!test
%! [mp, n] = mpoles ([-1e4, -0.1, 0]);
%! assert (mp, ones (3, 1));
%! assert (n, [1; 2; 3]);
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{num}, @var{den}] =} padecoef (@var{T})
## @deftypefnx {} {[@var{num}, @var{den}] =} padecoef (@var{T}, @var{N})
## Compute the @var{N}th-order Pad@'e approximant of the continuous-time
## delay @var{T} in transfer function form.
##
## @tex
## The Pad\'e approximant of $e^{-sT}$ is defined by the following equation
## $$ e^{-sT} \approx {P_n(s) \over Q_n(s)} $$
## where both $P_n(s)$ and $Q_n(s)$ are $N^{th}$-order rational functions
## defined by the following expressions
## $$ P_n(s)=\sum_{k=0}^N {(2N - k)!N!\over (2N)!k!(N - k)!}(-sT)^k $$
## $$ Q_n(s) = P_n(-s) $$
## @end tex
## @ifnottex
## The Pad@'e approximant of @nospell{@code{exp (-sT)}} is defined by the
## following equation
##
## @example
## @group
##              Pn(s)
## exp (-sT) ~ -------
##              Qn(s)
## @end group
## @end example
##
## Where both @nospell{Pn(s) and Qn(s)} are @var{N}th-order rational functions
## defined by the following expressions
##
## @example
## @group
##          N    (2N - k)!N!        k
## Pn(s) = SUM --------------- (-sT)
##         k=0 (2N)!k!(N - k)!
##
## Qn(s) = Pn(-s)
## @end group
## @end example
##
## @end ifnottex
##
## The inputs @var{T} and @var{N} must be non-negative numeric scalars.  If
## @var{N} is unspecified it defaults to 1.
##
## The output row vectors @var{num} and @var{den} contain the numerator and
## denominator coefficients in descending powers of s.  Both are
## @var{N}th-order polynomials.
##
## For example:
##
## @smallexample
## @group
## t = 0.1;
## n = 4;
## [num, den] = padecoef (t, n)
## @result{} num =
##
##       1.0000e-04  -2.0000e-02   1.8000e+00  -8.4000e+01   1.6800e+03
##
## @result{} den =
##
##       1.0000e-04   2.0000e-02   1.8000e+00   8.4000e+01   1.6800e+03
## @end group
## @end smallexample
## @end deftypefn

function [num, den] = padecoef (T, N = 1)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isscalar (T) && isnumeric (T) && T >= 0))
    error ("padecoef: T must be a non-negative scalar");
  elseif (! (isscalar (N) && isnumeric (N) && N >= 0))
    error ("padecoef: N must be a non-negative scalar");
  endif

  N = round (N);
  k = N : -1 : 0;
  num = prod (linspace ((N - k + 1), (2 * N - k), N)', ones (1, N)) ...
        / prod (N + 1 : 2 * N) ./ factorial (k);
  num /= num(1);
  den = num .* (T .^ k);
  num .*= ((-T) .^ k);

endfunction


%!test
%! T = 1;
%! [n_obs, d_obs] = padecoef (T);
%! n_exp = [1, 2] .* [-T, 1];
%! d_exp = [1, 2] .* [T, 1];
%! assert ([n_obs, d_obs], [n_exp, d_exp], eps);

%!test
%! T = 0.1;
%! [n_obs, d_obs] = padecoef (T);
%! n_exp = [1, 2] .* [-T, 1];
%! d_exp = [1, 2] .* [T, 1];
%! assert ([n_obs, d_obs], [n_exp, d_exp], eps);

%!test
%! T = 1;
%! N = 2;
%! k = N : -1 : 0;
%! [n_obs, d_obs] = padecoef (T, N);
%! n_exp = [1, 6, 12] .* ((-T) .^ k);
%! d_exp = [1, 6, 12] .* (T .^ k);
%! assert ([n_obs, d_obs], [n_exp, d_exp], eps);

%!test
%! T = 0.25;
%! N = 2;
%! k = N : -1 : 0;
%! [n_obs, d_obs] = padecoef (T, 2);
%! n_exp = [1, 6, 12] .* ((-T) .^ k);
%! d_exp = [1, 6, 12] .* (T .^ k);
%! assert ([n_obs, d_obs], [n_exp, d_exp], eps);

%!test
%! T = 0.47;
%! N = 3;
%! k = N : -1 : 0;
%! [n_obs, d_obs] = padecoef (T, N);
%! n_exp = [1, 12, 60, 120] .* ((-T) .^ k);
%! d_exp = [1, 12, 60, 120] .* (T .^ k);
%! assert ([n_obs, d_obs], [n_exp, d_exp], eps);

%!test
%! T = 1;
%! N = 7;
%! i = 0 : 2 * N;
%! b = ((-T) .^ i) ./ factorial (i);
%! A = [[eye(N + 1); zeros(N, N + 1)], ...
%!      [zeros(1, N); toeplitz(-b(1 : 2 * N), [-b(1), zeros(1, N-1)])]];
%! x = A \ b';
%! k = N : -1 : 0;
%! d_exp = [flipud(x(N + 2 : 2 * N + 1)); 1]';
%! n_exp = flipud (x(1 : N + 1))';
%! n_exp ./= d_exp(1);
%! d_exp ./= d_exp(1);
%! [n_obs, d_obs] = padecoef (T, N);
%! assert ([n_obs, d_obs], [n_exp, d_exp], 1e-2);

## For checking in Wolfram Alpha (look at Alternate forms -> more):
## PadeApproximant[Exp[-x * T], {x, 0, {n, n}}]

## Test input validation
%!error <Invalid call> padecoef ()
%!error <T must be a non-negative scalar> padecoef ([1,2])
%!error <T must be a non-negative scalar> padecoef ({1})
%!error <T must be a non-negative scalar> padecoef (-1)
%!error <N must be a non-negative scalar> padecoef (1, [1,2])
%!error <N must be a non-negative scalar> padecoef (1, {1})
%!error <N must be a non-negative scalar> padecoef (1, -1)
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{pp} =} pchip (@var{x}, @var{y})
## @deftypefnx {} {@var{yi} =} pchip (@var{x}, @var{y}, @var{xi})
## Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
## points @var{x} and @var{y}.
##
## If called with two arguments, return the piecewise polynomial @var{pp}
## that may be used with @code{ppval} to evaluate the polynomial at specific
## points.
##
## When called with a third input argument, @code{pchip} evaluates the pchip
## polynomial at the points @var{xi}.  The third calling form is equivalent to
## @code{ppval (pchip (@var{x}, @var{y}), @var{xi})}.
##
## The variable @var{x} must be a strictly monotonic vector (either increasing
## or decreasing) of length @var{n}.
##
## @var{y} can be either a vector or array.  If @var{y} is a vector then it
## must be the same length @var{n} as @var{x}.  If @var{y} is an array then
## the size of @var{y} must have the form
## @tex
## $$[s_1, s_2, \cdots, s_k, n]$$
## @end tex
## @ifnottex
## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
## @end ifnottex
## The array is reshaped internally to a matrix where the leading dimension is
## given by
## @tex
## $$s_1 s_2 \cdots s_k$$
## @end tex
## @ifnottex
## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
## @end ifnottex
## and each row of this matrix is then treated separately.  Note that this is
## exactly opposite to @code{interp1} but is done for @sc{matlab}
## compatibility.
##
## @seealso{spline, ppval, mkpp, unmkpp}
## @end deftypefn

## Algorithm:
## S_k = a_k + b_k*x + c_k*x^2 + d_k*x^3; (spline polynomial)
##
## 4 conditions:
## S_k(x_k) = y_k;
## S_k(x_k+1) = y_k+1;
## S_k'(x_k) = y_k';
## S_k'(x_k+1) = y_k+1';

function ret = pchip (x, y, xi)

  if (nargin < 2)
    print_usage ();
  endif

  ## make row vector
  x = x(:).';
  n = length (x);

  ## Check the size and shape of y
  if (isvector (y))
    y = y(:).';  # force row vector
    szy = size (y);
    if (! size_equal (x, y))
      error ("pchip: length of X and Y must match");
    endif
  else
    szy = size (y);
    if (n != szy(end))
      error ("pchip: length of X and last dimension of Y must match");
    endif
    y = reshape (y, [prod(szy(1:end-1)), szy(end)]);
  endif

  h = diff (x);
  if (all (h < 0))
    x = fliplr (x);
    h = diff (x);
    y = fliplr (y);
  elseif (any (h <= 0))
    error ("pchip: X must be strictly monotonic");
  endif

  f1 = y(:, 1:n-1);

  ## Compute derivatives.
  d = __pchip_deriv__ (x, y, 2);
  if (iscomplex (y))
    ## __pchip_deriv__ ignores imaginary part.  Do it again for imag part.
    ## FIXME: Adapt __pchip_deriv__ to correctly handle complex input.
    d += 1i * __pchip_deriv__ (x, imag (y), 2);
  endif
  d1 = d(:, 1:n-1);
  d2 = d(:, 2:n);

  ## This is taken from SLATEC.
  h = diag (h);

  delta = diff (y, 1, 2) / h;
  del1 = (d1 - delta) / h;
  del2 = (d2 - delta) / h;
  c3 = del1 + del2;
  c2 = -c3 - del1;
  c3 /= h;
  coeffs = cat (3, c3, c2, d1, f1);

  ret = mkpp (x, coeffs, szy(1:end-1));

  if (nargin == 3)
    ret = ppval (ret, xi);
  endif

endfunction


%!demo
%! x = 0:8;
%! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
%! xi = 0:0.01:8;
%! yspline = spline (x,y,xi);
%! ypchip = pchip (x,y,xi);
%! title ("pchip and spline fit to discontinuous function");
%! plot (xi,yspline, xi,ypchip,"-", x,y,"+");
%! legend ("spline", "pchip", "data");
%! %-------------------------------------------------------------------
%! % confirm that pchip agreed better to discontinuous data than spline

%!shared x, y, y2, pp, yi1, yi2, yi3
%! x = 0:8;
%! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
%!assert (pchip (x,y,x), y)
%!assert (pchip (x,y,x'), y')
%!assert (pchip (x',y',x'), y')
%!assert (pchip (x',y',x), y)
%!assert (isempty (pchip (x',y',[])))
%!assert (isempty (pchip (x,y,[])))
%!assert (pchip (x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
%!assert (pchip (x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
%!assert (pchip (x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
%!assert (pchip (x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
%!test
%! x = (0:8)*pi/4; y = [sin(x); cos(x)];
%! y2(:,:,1) = y; y2(:,:,2) = y+1; y2(:,:,3) = y-1;
%! pp = pchip (x, shiftdim (y2,2));
%! yi1 = ppval (pp, (1:4)*pi/4);
%! yi2 = ppval (pp, repmat ((1:4)*pi/4, [5,1]));
%! yi3 = ppval (pp, [pi/2,pi]);
%!assert (size (pp.coefs), [48,4])
%!assert (pp.pieces, 8)
%!assert (pp.order, 4)
%!assert (pp.dim, [3,2])
%!assert (ppval (pp,pi), [0,-1;1,0;-1,-2], 1e-14)
%!assert (yi3(:,:,2), ppval (pp,pi), 1e-14)
%!assert (yi3(:,:,1), [1,0;2,1;0,-1], 1e-14)
%!assert (squeeze (yi1(1,2,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
%!assert (size (yi2), [3,2,5,4])
%!assert (squeeze (yi2(1,2,3,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)

%!error pchip (1,2)
%!error pchip (1,2,3)
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} poly (@var{A})
## @deftypefnx {} {} poly (@var{x})
## If @var{A} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{A})}
## is the row vector of the coefficients of @code{det (z * eye (N) - A)},
## the characteristic polynomial of @var{A}.
##
## For example, the following code finds the eigenvalues of @var{A} which are
## the roots of @code{poly (@var{A})}.
##
## @example
## @group
## roots (poly (eye (3)))
##     @result{} 1.00001 + 0.00001i
##        1.00001 - 0.00001i
##        0.99999 + 0.00000i
## @end group
## @end example
##
## In fact, all three eigenvalues are exactly 1 which emphasizes that for
## numerical performance the @code{eig} function should be used to compute
## eigenvalues.
##
## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
## coefficients of the polynomial whose roots are the elements of @var{x}.
## That is, if @var{c} is a polynomial, then the elements of
## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.  The
## vectors @var{c} and @var{d} are not identical, however, due to sorting and
## numerical errors.
## @seealso{roots, eig}
## @end deftypefn

function y = poly (x)

  if (nargin < 1)
    print_usage ();
  endif

  m = min (size (x));
  n = max (size (x));
  if (m == 0)
    y = 1;
    return;
  elseif (m == 1)
    v = x;
  elseif (m == n)
    v = eig (x);
  else
    print_usage ();
  endif

  y = zeros (1, n+1);
  y(1) = 1;
  for j = 1:n
    y(2:(j+1)) -= v(j) .* y(1:j);
  endfor

  ## Real, or complex conjugate inputs, should result in real output
  if (isreal (x))
    y = real (y);
  else
    pos_imag = sort (v(imag (v) > 0));
    neg_imag = sort (conj (v(imag (v) < 0)));
    if (size_equal (pos_imag, neg_imag))
      is_equal = (pos_imag == neg_imag);
      if (! isempty (is_equal) && all (is_equal))
        y = real (y);
      endif
    endif
  endif

endfunction


%!assert (poly ([]), 1)
%!assert (poly ([1, 2, 3]), [1, -6, 11, -6])
%!assert (poly ([1, 2; 3, 4]), [1, -5, -2], sqrt (eps))

%!test <*53897>
%! x = [1, sqrt(2)/2+sqrt(2)/2*i, 1i, -sqrt(2)/2+sqrt(2)/2*i, -1, ...
%!      -sqrt(2)/2-sqrt(2)/2*i, -1i, sqrt(2)/2-sqrt(2)/2*i];
%! y = poly (x);
%! assert (isreal (y), true);

%!test <*53897>
%! x = [1 + 1i, 1 + 2i, 3, 4];
%! y = poly (x);
%! assert (y, [1 + 0i, -9 - 3i, 25 + 24i, -17 - 57i, -12 + 36i]);

%!error <Invalid call> poly ()
%!error poly ([1, 2, 3; 4, 5, 6])
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} polyaffine (@var{f}, @var{mu})
## Return the coefficients of the polynomial vector @var{f} after an affine
## transformation.
##
## If @var{f} is the vector representing the polynomial f(x), then
## @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector representing:
##
## @example
## g(x) = f( (x - @var{mu}(1)) / @var{mu}(2) )
## @end example
##
## @seealso{polyval, polyfit}
## @end deftypefn

function g = polyaffine (f, mu)

   if (nargin != 2)
      print_usage ();
   endif

   if (! isvector (f))
      error ("polyaffine: F must be a vector");
   endif

   if (! isvector (mu) || length (mu) != 2)
      error ("polyaffine: MU must be a two-element vector");
   endif

   lf = length (f);

   ## Ensure that f is a row vector
   if (rows (f) > 1)
      f = f.';
   endif

   g = f;

   ## Scale.
   if (mu(2) != 1)
     g ./= mu(2) .^ (lf-1:-1:0);
   endif

   ## Translate.
   if (mu(1) != 0)
     w = (-mu(1)) .^ (0:lf-1);
     ii = lf:-1:1;
     g = g(ii) * (toeplitz (w) .* pascal (lf, -1));
     g = g(ii);
   endif

endfunction


%!demo
%! f = [1/5 4/5 -7/5 -2];
%! g = polyaffine (f, [1, 1.2]);
%! x = linspace (-4,4,100);
%! plot (x,polyval (f, x), x,polyval (g, x));
%! legend ("original", "affine");
%! axis ([-4 4 -3 5]);
%! grid on;

%!test
%! f = [1/5 4/5 -7/5 -2];
%! mu = [1, 1.2];
%! g = polyaffine (f, mu);
%! x = linspace (-4,4,100);
%! assert (polyval (f, x, [], mu), polyval (g, x), 1e-10);
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} polyder (@var{p})
## @deftypefnx {} {[@var{k}] =} polyder (@var{a}, @var{b})
## @deftypefnx {} {[@var{q}, @var{d}] =} polyder (@var{b}, @var{a})
## Return the coefficients of the derivative of the polynomial whose
## coefficients are given by the vector @var{p}.
##
## If a pair of polynomials is given, return the derivative of the product
## @math{@var{a}*@var{b}}.
##
## If two inputs and two outputs are given, return the derivative of the
## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
## in @var{q} and the denominator in @var{d}.
## @seealso{polyint, polyval, polyreduce}
## @end deftypefn

function [q, d] = polyder (p, a)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isvector (p))
    error ("polyder: argument must be a vector");
  endif
  if (nargin == 2)
    if (! isvector (a))
      error ("polyder: argument must be a vector");
    endif
    if (nargout == 1)
      ## derivative of p*a returns a single polynomial
      q = polyder (conv (p, a));
    else
      ## derivative of p/a returns numerator and denominator
      d = conv (a, a);
      if (numel (p) == 1)
        q = -p * polyder (a);
      elseif (numel (a) == 1)
        q = a * polyder (p);
      else
        q = conv (polyder (p), a) - conv (p, polyder (a));
        q = polyreduce (q);
      endif

      ## remove common factors from numerator and denominator
      x = polygcd (q, d);
      if (length (x) != 1)
        q = deconv (q, x);
        d = deconv (d, x);
      endif

      ## move all the gain into the numerator
      q /= d(1);
      d /= d(1);
    endif
  else
    lp = numel (p);
    if (lp == 1)
      q = 0;
      return;
    elseif (lp == 0)
      q = [];
      return;
    endif

    ## Force P to be a row vector.
    p = p(:).';

    q = p(1:(lp-1)) .* [(lp-1):-1:1];
  endif

endfunction


%!assert (polyder ([1, 2, 3], [2, 2]))
%!assert (polyder (13), 0)

%!error polyder ([])
%!error polyder (1,2,3)
%!error <argument must be a vector> polyder ([1, 2; 3, 4])
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{z} =} polyeig (@var{C0}, @var{C1}, @dots{}, @var{Cl})
## @deftypefnx {} {[@var{v}, @var{z}] =} polyeig (@var{C0}, @var{C1}, @dots{}, @var{Cl})
##
## Solve the polynomial eigenvalue problem of degree @var{l}.
##
## Given an @var{n}x@var{n} matrix polynomial
##
## @code{@var{C}(@var{s}) = @var{C0} + @var{C1} @var{s} + @dots{} + @var{Cl}
## @var{s}^@var{l}}
##
## @code{polyeig} solves the eigenvalue problem
##
## @code{(@var{C0} + @var{C1} @var{z} + @dots{} + @var{Cl} @var{z}^@var{l})
## @var{v} = 0}.
##
## Note that the eigenvalues @var{z} are the zeros of the matrix polynomial.
## @var{z} is a row vector with @code{@var{n}*@var{l}} elements.  @var{v} is a
## matrix (@var{n} x @var{n}*@var{l}) with columns that correspond to the
## eigenvectors.
##
## @seealso{eig, eigs, compan}
## @end deftypefn

function [z, v] = polyeig (varargin)

  if (nargin < 1)
    print_usage ();
  endif

  n = rows (varargin{1});

  for i = 1 : nargin
    if (! issquare (varargin{i}))
      error ("polyeig: coefficients must be square matrices");
    endif
    if (rows (varargin{i}) != n)
      error ("polyeig: coefficients must have the same dimensions");
    endif
  endfor

  ## matrix polynomial degree
  l = nargin - 1;

  ## form needed matrices
  C = [ zeros(n * (l - 1), n), eye(n * (l - 1));
       -cell2mat(varargin(1:end-1)) ];

  D = [ eye(n * (l - 1)), zeros(n * (l - 1), n);
        zeros(n, n * (l - 1)), varargin{end} ];

  ## solve generalized eigenvalue problem
  if (nargout < 2)
    z = eig (C, D);
  else
    [z, v] = eig (C, D);
    v = diag (v);
    ## return n-element eigenvectors normalized so that the infinity-norm = 1
    z = z(1:n,:);
    t = max (z);    # max() takes the abs if complex.
    z ./= t;
  endif

endfunction


%!shared C0, C1
%! C0 = [8, 0; 0, 4];
%! C1 = [1, 0; 0, 1];

%!test
%! z = polyeig (C0, C1);
%! assert (z, [-8; -4]);

%!test
%! [v,z] = polyeig (C0, C1);
%! assert (z, [-8; -4]);
%! z = diag (z);
%! d = C0*v + C1*v*z;
%! assert (norm (d), 0.0);

## Test input validation
%!error <Invalid call> polyeig ()
%!error <coefficients must be square matrices> polyeig (ones (3,2))
%!error <coefficients must have the same dimensions>
%! polyeig (ones (3,3), ones (2,2))
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
## @deftypefnx {} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
## @deftypefnx {} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
## Return the coefficients of a polynomial @var{p}(@var{x}) of degree @var{n}
## that minimizes the least-squares-error of the fit to the points
## @code{[@var{x}(:), @var{y}(:)]}.
##
## @var{n} is typically an integer @geq{} 0 specifying the degree of the
## approximating polynomial.  If @var{n} is a logical vector, it is used as a
## mask to selectively force the corresponding polynomial coefficients to be
## used or ignored.
##
## The polynomial coefficients are returned in the row vector @var{p}.  The
## output @var{p} may be directly used with @code{polyval} to estimate values
## using the fitted polynomial.
##
## The optional output @var{s} is a structure containing the following fields:
##
## @table @samp
##
## @item yf
## The values of the polynomial for each value of @var{x}.
##
## @item X
## The @nospell{Vandermonde} matrix used to compute the polynomial
## coefficients.
##
## @item R
## Triangular factor R from the QR@tie{}decomposition.
##
## @item C
## The unscaled covariance matrix, formally equal to the inverse of
## @var{x'}*@var{x}, but computed in a way minimizing roundoff error
## propagation.
##
## @item df
## The degrees of freedom.
##
## @item normr
## The norm of the residuals.
## @end table
##
## The second output may be used by @code{polyval} to calculate the statistical
## error limits of the predicted values.  In particular, the standard deviation
## of @var{p} coefficients is given by
##
## @code{sqrt (diag (@var{s.C})/@var{s.df}) * @var{s.normr}}.
##
## When the third output, @var{mu}, is present the original data is centered
## and scaled which can improve the numerical stability of the fit.  The
## coefficients @var{p} are associated with a polynomial in
##
## @code{@var{xhat} = (@var{x} - @var{mu}(1)) / @var{mu}(2)} @*
## where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
##
## Example 1 : logical @var{n} and integer @var{n}
##
## @example
## @group
## f = @@(x) x.^2 + 5;   # data-generating function
## x = 0:5;
## y = f (x);
## ## Fit data to polynomial A*x^3 + B*x^1
## p = polyfit (x, y, logical ([1, 0, 1, 0]))
## @result{} p = [ 0.0680, 0, 4.2444, 0 ]
## ## Fit data to polynomial using all terms up to x^3
## p = polyfit (x, y, 3)
## @result{} p = [ -4.9608e-17, 1.0000e+00, -3.3813e-15, 5.0000e+00 ]
## @end group
## @end example
##
## @seealso{polyval, polyaffine, roots, vander, zscore}
## @end deftypefn

function [p, s, mu] = polyfit (x, y, n)

  if (nargin < 3)
    print_usage ();
  endif

  y_is_row_vector = isrow (y);

  ## Reshape x & y into column vectors.
  x = x(:);
  y = y(:);

  nx = numel (x);
  ny = numel (y);
  if (nx != ny)
    error ("polyfit: X and Y must have the same number of points");
  endif

  if (nargout > 2)
    ## Center and scale the x values.
    mu = [mean(x), std(x)];
    x = (x - mu(1)) / mu(2);
  endif

  ## n is the polynomial degree (an input, or deduced from the polymask size)
  ## m is the effective number of coefficients.
  if (islogical (n))
    polymask = n(:).';          # force to row vector
    n = numel (polymask) - 1;
    m = sum (polymask) - 1;
    pad_output = true;
  else
    if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == fix (n)))
      error ("polyfit: N must be a non-negative integer");
    endif
    polymask = true (1, n+1);
    m = n;
    pad_output = false;
  endif

  if (m >= nx)
    warning ("polyfit: degree of polynomial N is >= number of data points; solution is not unique");
    m = nx;
    pad_output = true;
    ## Keep the lowest m entries in polymask
    idx = find (polymask);
    idx((end-m+1):end) = [];
    polymask(idx) = false;
  endif

  ## Construct the Vandermonde matrix.
  X = vander (x, n+1);
  v = X(:, polymask);

  ## Solve by QR decomposition.
  [q, r, k] = qr (v, 0);
  p = r \ (q' * y);
  p(k) = p;

  if (isargout (2))
    yf = v*p;
    if (y_is_row_vector)
      s.yf = yf.';
    else
      s.yf = yf;
    endif

    s.X = X;

    ## r.'*r is positive definite if matrix v is of full rank.  Invert it by
    ## cholinv to avoid taking the square root of squared quantities.
    ## If cholinv fails, then v is rank deficient and not invertible.
    try
      C = cholinv (r.'*r)(k, k);
    catch
      C = NaN (m, m);
    end_try_catch

    if (pad_output)
      s.X(:, ! polymask) = 0;
      s.R = zeros (rows (r), n+1); s.R(:, polymask) = r;
      s.C = zeros (rows (C), n+1); s.C(:, polymask) = C;
    else
      s.R = r;
      s.C = C;
    endif

    s.df = max (0, nx - m - 1);
    s.normr = norm (yf - y);
  endif

  if (pad_output)
    ## Zero pad output
    q = p;
    p = zeros (n+1, 1);
    p(polymask) = q;
  endif
  p = p.';  # Return a row vector.

endfunction


%!shared x
%! x = [-2, -1, 0, 1, 2];

%!assert (polyfit (x, 3*x.^2 + 2*x + 1, 2), [3, 2, 1], 10*eps)
%!assert (polyfit (x, 3*x.^2 + 2*x + 1, logical ([1 1 1])), [3, 2, 1], 10*eps)
%!assert (polyfit (x, x.^2 + 2*x + 3, 3), [0, 1, 2, 3], 10*eps)
%!assert (polyfit (x, x.^2 + 2*x + 3, logical ([0 1 1 1])), [0 1 2 3], 10*eps)

## Test logical input N
%!test
%! x = [0:5];
%! y = 3*x.^3 + 2*x.^2 + 4;
%! [p, s] = polyfit (x, y, logical ([1, 0, 1, 1]));
%! assert (p(2), 0);
%! assert (all (p([1, 3, 4])));
%! assert (s.df, 3);

## Test difficult case where scaling is really needed.  This example
## demonstrates the rather poor result which occurs when the dependent
## variable is not normalized properly.
## Also check the usage of 2nd & 3rd output arguments.
%!test
%! warning ("off", "Octave:nearly-singular-matrix", "local");
%! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, ...
%!       -1186.8, -1185.6, -1184.4, -1183.2, -1182];
%! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966, ...
%!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201, ...
%!       315600.7143, 315602.9508, 315605.1765 ];
%! [p1, s1] = polyfit (x, y, 10);
%! [p2, s2, mu] = polyfit (x, y, 10);
%! assert (s2.normr < s1.normr);

%!test
%! warning ("off", "Octave:nearly-singular-matrix", "local");
%! x = 1000 + (-5:5);
%! xn = (x - mean (x)) / std (x);
%! pn = ones (1,5);
%! y = polyval (pn, xn);
%! n = numel (pn) - 1;
%! [p, s, mu] = polyfit (x, y, n);
%! [p2, s2] = polyfit (x, y, n);
%! assert (p, pn, s.normr);
%! assert (s.yf, y, s.normr);
%! assert (mu, [mean(x), std(x)]);
%! assert (s.normr/s2.normr < sqrt (eps));

## Complex polynomials
%!test
%! x = 1:4;
%! p0 = [1i, 0, 2i, 4];
%! y = polyval (p0, x);
%! n = numel (p0) - 1;
%! p = polyfit (x, y, n);
%! assert (p, p0, 1000*eps);

## Matrix input
%!test
%! x = [1, 2, 3; 4, 5, 6];
%! y = [0, 0, 1; 1, 0, 0];
%! p = polyfit (x, y, 5);
%! expected = [0, 1, -14, 65, -112, 60] / 12;
%! assert (p, expected, sqrt (eps));

## Orientation of output
%!test
%! x = 0:5;
%! y = x.^4 + 2*x + 5;
%! [p, s] = polyfit (x, y, 3);
%! assert (isrow (s.yf));
%! [p, s] = polyfit (x, y.', 3);
%! assert (iscolumn (s.yf));

## Insufficient data for fit
%!test
%! x = [1, 2];
%! y = [3, 4];
%! ## Disable warnings entirely because there is not a specific ID to disable.
%! wstate = warning ();
%! unwind_protect
%!   warning ("off", "all");
%!   p0 = polyfit (x, y, 4);
%!   [p1, s, mu] = polyfit (x, y, 4);
%! unwind_protect_cleanup
%!   warning (wstate);
%! end_unwind_protect
%! assert (p0, [0, 0, 0, 1, 2], 10*eps);
%! assert (p1, [0, 0, 0, sqrt(2)/2, 3.5], 10*eps);
%! assert (size (s.X), [2, 5]);
%! assert (s.X(:,1:3), zeros (2,3));
%! assert (size (s.R), [2, 5]);
%! assert (s.R(:,1:3), zeros (2,3));
%! assert (size (s.C), [2, 5]);
%! assert (s.C(:,1:3), zeros (2,3));
%! assert (s.df, 0);
%! assert (mu, [1.5, sqrt(2)/2]);

%!test
%! x = [1, 2, 3];
%! y = 2*x + 1;
%! ## Disable warnings entirely because there is not a specific ID to disable.
%! wstate = warning ();
%! unwind_protect
%!   warning ("off", "all");
%!   p0 = polyfit (x, y, logical ([1, 1, 1, 0 1]));
%!   [p1, s, mu] = polyfit (x, y, logical ([1, 1, 1, 0 1]));
%! unwind_protect_cleanup
%!   warning (wstate);
%! end_unwind_protect
%! assert (p0, [0, -2/11, 12/11, 0, 23/11], 10*eps);
%! assert (p1, [0, 2, 0, 0, 5], 10*eps);
%! assert (size (s.X), [3, 5]);
%! assert (s.X(:,[1,4]), zeros (3,2));
%! assert (size (s.R), [3, 5]);
%! assert (s.R(:,[1,4]), zeros (3,2));
%! assert (size (s.C), [3, 5]);
%! assert (s.C(:,[1,4]), zeros (3,2));
%! assert (s.df, 0);
%! assert (mu, [2, 1]);

%!test <*57964>
%! ## Disable warnings entirely because there is not a specific ID to disable.
%! wstate = warning ();
%! unwind_protect
%!   warning ("off", "all");
%!   [p, s] = polyfit ([1,2], [3,4], 2);
%! unwind_protect_cleanup
%!   warning (wstate);
%! end_unwind_protect
%! assert (size (p), [1, 3]);
%! assert (size (s.X), [2, 3]);
%! assert (s.X(:,1), [0; 0]);
%! assert (size (s.R), [2, 3]);
%! assert (s.R(:,1), [0; 0]);
%! assert (size (s.C), [2, 3]);
%! assert (s.C(:,1), [0; 0]);

## Test input validation
%!error <Invalid call> polyfit ()
%!error <Invalid call> polyfit (1)
%!error <Invalid call> polyfit (1,2)
%!error <X and Y must have the same number of points> polyfit ([1, 2], 1, 1)
%!error <X and Y must have the same number of points> polyfit (1, [1, 2], 1)
%!error <N must be a non-negative integer> polyfit (1, 2, [1,2])
%!error <N must be a non-negative integer> polyfit (1, 2, -1)
%!error <N must be a non-negative integer> polyfit (1, 2, Inf)
%!error <N must be a non-negative integer> polyfit (1, 2, 1.5)
%!test <*57964>
%! fail ("p = polyfit ([1,2], [3,4], 4)", "warning", "solution is not unique");
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} polygcd (@var{b}, @var{a})
## @deftypefnx {} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
##
## Find the greatest common divisor of two polynomials.
##
## This is equivalent to the polynomial found by multiplying together all the
## common roots.  Together with deconv, you can reduce a ratio of two
## polynomials.
##
## The tolerance @var{tol} defaults to @code{sqrt (eps)}.
##
## @strong{Caution:} This is a numerically unstable algorithm and should not
## be used on large polynomials.
##
## Example code:
##
## @example
## @group
## polygcd (poly (1:8), poly (3:12)) - poly (3:8)
## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
## deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly (1:2)
## @result{} [ 0, 0, 0 ]
## @end group
## @end example
## @seealso{poly, roots, conv, deconv, residue}
## @end deftypefn

function x = polygcd (b, a, tol)

  if (nargin < 2)
    print_usage ();
  endif

  if (nargin == 2)
    if (isa (a, "single") || isa (b, "single"))
      tol = sqrt (eps ("single"));
    else
      tol = sqrt (eps);
    endif
  endif
  ## FIXME: No input validation of tol if it was user-supplied


  if (length (a) == 1 || length (b) == 1)
    if (a == 0)
      x = b;
    elseif (b == 0)
      x = a;
    else
      x = 1;
    endif
  else
    a /= a(1);
    while (1)
      [d, r] = deconv (b, a);
      nz = find (abs (r) > tol);
      if (isempty (nz))
        x = a;
        break;
      else
        r = r(nz(1):length (r));
      endif
      b = a;
      a = r / r(1);
    endwhile
  endif

endfunction


%!test
%! poly1 = [1 6 11 6]; # (x+1)(x+2)(x+3);
%! poly2 = [1 3 2];    # (x+1)(x+2);
%! poly3 = polygcd (poly1, poly2);
%! assert (poly3, poly2, sqrt (eps));

%!assert (polygcd (poly (1:8), poly (3:12)), poly (3:8), sqrt (eps))
%!assert (deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))),
%!        poly (1:2), sqrt (eps))

%!test
%! for ii=1:100
%!   ## Exhibits numerical problems for multipliers of ~4 and greater.
%!   p  = (unique (randn (10, 1)) * 3).';
%!   p1 = p(3:end);
%!   p2 = p(1:end-2);
%!   assert (polygcd (poly (-p1), poly (-p2)),
%!           poly (- intersect (p1, p2)), sqrt (eps));
%! endfor
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} polyint (@var{p})
## @deftypefnx {} {} polyint (@var{p}, @var{k})
## Return the coefficients of the integral of the polynomial whose
## coefficients are represented by the vector @var{p}.
##
## The variable @var{k} is the constant of integration, which by default is
## set to zero.
## @seealso{polyder, polyval}
## @end deftypefn

function retval = polyint (p, k)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    k = 0;
  elseif (! isscalar (k))
    error ("polyint: the constant of integration must be a scalar");
  endif

  if (! (isvector (p) || isempty (p)))
    error ("polyint: argument must be a vector");
  endif

  lp = length (p);

  if (lp == 0)
    retval = [];
    return;
  endif

  if (rows (p) > 1)
    ## Convert to column vector
    p = p.';
  endif

  retval = [(p ./ [lp:-1:1]), k];

endfunction


%!test
%! A = [3, 2, 1];
%! assert (polyint (A), polyint (A,0));
%! assert (polyint (A), polyint (A'));
%! assert (polyint (A), [1, 1, 1, 0]);
%! assert (polyint (A,1), ones (1,4));

%!test
%! A = ones (1,8);
%! B = [length(A):-1:1];
%! assert (polyint (A), [1./B, 0]);

%!error <Invalid call> polyint ()
%!error polyint (ones (2,2))
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} polyout (@var{c})
## @deftypefnx {} {} polyout (@var{c}, @var{x})
## @deftypefnx {} {@var{str} =} polyout (@dots{})
## Display a formatted version of the polynomial @var{c}.
##
## The formatted polynomial
## @tex
## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
## @end tex
## @ifnottex
##
## @example
## c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
## @end example
##
## @end ifnottex
## is returned as a string or written to the screen if @code{nargout} is zero.
##
## The second argument @var{x} specifies the variable name to use for each term
## and defaults to the string @qcode{"s"}.
## @seealso{polyreduce}
## @end deftypefn

function y = polyout (c, x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isvector (c))
    error ("polyout: first argument must be a vector");
  endif

  if (nargin == 1)
    x = "s";
  elseif (! ischar (x))
    error ("polyout: second argument must be a string");
  endif

  n = length (c);
  if (n > 0)
    n1 = n+1;

    tmp = coeff (c(1));
    for ii = 2:n
      if (real (c(ii)) < 0)
        ns = " - ";
        c(ii) = -c(ii);
      else
        ns = " + ";
      endif

      tmp = sprintf ("%s*%s^%d%s%s", tmp, x, n1-ii, ns, coeff (c(ii)));

    endfor
  else
    tmp = " ";
  endif

  if (nargout == 0)
    disp (tmp);
  else
    y = tmp;
  endif

endfunction

function str = coeff (c)

  if (imag (c))
    if (real (c))
      str = sprintf ("(%s)", num2str (c, 5));
    else
      str = num2str (c, 5);
    endif
  else
    str = num2str (c, 5);
  endif

endfunction


%!assert (polyout ([3 2 1]), "3*s^2 + 2*s^1 + 1")
%!assert (polyout ([3 2 1], "x"), "3*x^2 + 2*x^1 + 1")
%!assert (polyout ([3 2 1], "wxyz"), "3*wxyz^2 + 2*wxyz^1 + 1")
%!assert (polyout ([5 4 3 2 1], "1"),"5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1")

%!error polyout ([])
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} polyreduce (@var{c})
## Reduce a polynomial coefficient vector to a minimum number of terms by
## stripping off any leading zeros.
## @seealso{polyout}
## @end deftypefn

function p = polyreduce (c)

  if (nargin < 1)
    print_usage ();
  elseif (! isvector (c) || isempty (c))
    error ("polyreduce: C must be a non-empty vector");
  endif

  idx = find (c != 0, 1);

  if (isempty (idx))
    p = 0;
  else
    p = c(idx:end);
  endif

endfunction


%!assert (polyreduce ([0, 0, 1, 2, 3]), [1, 2, 3])
%!assert (polyreduce ([1, 2, 3, 0, 0]), [1, 2, 3, 0, 0])
%!assert (polyreduce ([1, 0, 3]), [1, 0, 3])
%!assert (polyreduce ([0, 0, 0]), 0)

%!error <Invalid call> polyreduce ()
%!error <C must be a non-empty vector> polyreduce ([1, 2; 3, 4])
%!error <C must be a non-empty vector> polyreduce ([])
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} polyval (@var{p}, @var{x})
## @deftypefnx {} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
## @deftypefnx {} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
## @deftypefnx {} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
##
## Evaluate the polynomial @var{p} at the specified values of @var{x}.
##
## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
## the elements of @var{x}.
##
## When @var{mu} is present, evaluate the polynomial for
## @w{(@var{x} - @var{mu}(1)) / @var{mu}(2)}.
##
## In addition to evaluating the polynomial, the second output represents the
## prediction interval, @var{y} +/- @var{dy}, which contains at least 50% of
## the future predictions.  To calculate the prediction interval, the
## structured variable @var{s}, originating from @code{polyfit}, must be
## supplied.
##
## @seealso{polyvalm, polyaffine, polyfit, roots, poly}
## @end deftypefn

function [y, dy] = polyval (p, x, s = [], mu)

  if (nargin < 2 || (nargout == 2 && nargin < 3))
    print_usage ();
  endif

  ## Algorithm requires floating point values
  if (! isfloat (p) || (! isvector (p) && ! isempty (p)))
    error ("polyval: P must be a numeric floating point vector");
  endif
  if (! isfloat (x))
    error ("polyval: X must be numeric floating point");
  endif

  if (nargout > 1)
    if (isempty (s))
      error ("polyval: S input is required for DY output argument");
    elseif (isstruct (s))
      if (! all (ismember ({"R", "normr", "df"}, fieldnames (s))))
        error ("polyval: S input is missing required fields");
      endif
    else
      error ("polyval: S input must be a structure");
    endif
  endif

  if (nargin == 4 && (! isfloat (mu) || numel (mu) < 2))
    error ("polyval: MU must be numeric floating point with 2 values");
  endif

  if (isempty (p) || isempty (x))
    if (isa (p, "single") || isa (x, "single"))
      y = zeros (size (x), "single");
    else
      y = zeros (size (x));
    endif
    return;
  endif

  if (nargin == 4)
    x = (x - mu(1)) / mu(2);
  endif

  n = numel (p) - 1;
  y = p(1) * ones (size (x), class (x));
  for i = 2:n+1
    y = y .* x + p(i);
  endfor

  if (nargout > 1)
    ## Note: the F-Distribution is generally considered to be single-sided.
    ## http://www.itl.nist.gov/div898/handbook/eda/section3/eda3673.htm
    ##   t = finv (1-alpha, s.df, s.df);
    ##   dy = t * sqrt (1 + sumsq (A/s.R, 2)) * s.normr / sqrt (s.df)
    ## If my inference is correct, then t must equal 1 for polyval.
    ## This is because finv (0.5, n, n) = 1.0 for any n.
    k = numel (x);
    A = (x(:) * ones (1, n+1)) .^ (ones (k, 1) * (n:-1:0));
    dy = sqrt (1 + sumsq (A/s.R, 2)) * s.normr / sqrt (s.df);
    dy = reshape (dy, size (x));
  endif

endfunction


%!test
%! r = 0:10:50;
%! p = poly (r);
%! p = p / max (abs (p));
%! x = linspace (0,50,11);
%! y = polyval (p,x) + 0.25*sin (100*x);
%! [pf, s] = polyfit (x, y, numel (r));
%! [y1, delta] = polyval (pf, x, s);
%! expected = [0.37235, 0.35854, 0.32231, 0.32448, 0.31328, ...
%!             0.32036, 0.31328, 0.32448, 0.32231, 0.35854, 0.37235];
%! assert (delta, expected, 0.00001);

%!test
%! x = 10 + (-2:2);
%! y = [0, 0, 1, 0, 2];
%! p = polyfit (x, y, numel (x) - 1);
%! [pn, s, mu] = polyfit (x, y, numel (x) - 1);
%! y1 = polyval (p, x);
%! yn = polyval (pn, x, [], mu);
%! assert (y1, y, sqrt (eps));
%! assert (yn, y, sqrt (eps));

%!test
%! p = [0, 1, 0];
%! x = 1:10;
%! assert (x, polyval (p,x), eps);
%! x = x(:);
%! assert (x, polyval (p,x), eps);
%! x = reshape (x, [2, 5]);
%! assert (x, polyval (p,x), eps);
%! x = reshape (x, [5, 2]);
%! assert (x, polyval (p,x), eps);
%! x = reshape (x, [1, 1, 5, 2]);
%! assert (x, polyval (p,x), eps);

%!test
%! p = [1];
%! x = 1:10;
%! y = ones (size (x));
%! assert (y, polyval (p,x), eps);
%! x = x(:);
%! y = ones (size (x));
%! assert (y, polyval (p,x), eps);
%! x = reshape (x, [2, 5]);
%! y = ones (size (x));
%! assert (y, polyval (p,x), eps);
%! x = reshape (x, [5, 2]);
%! y = ones (size (x));
%! assert (y, polyval (p,x), eps);
%! x = reshape (x, [1, 1, 5, 2]);

## Test empty combinations
%!assert (polyval ([], 1:10), zeros (1, 10))
%!assert (class (polyval (single ([]), 1:10)), "single")
%!assert (class (polyval ([], single (1:10))), "single")
%!assert (polyval (1, []), [])
%!assert (polyval ([], []), [])
%!assert (polyval (1, zeros (0,3)), zeros (0, 3))
%!assert (class (polyval (single (1), [])), "single")
%!assert (class (polyval (1, single ([]))), "single")
%!assert (class (polyval (single ([]), [])), "single")
%!assert (class (polyval ([], single ([]))), "single")

## Test input validation
%!error <Invalid call> polyval ()
%!error <Invalid call> polyval (1)
%!error <Invalid call> [y, dy] = polyval (1, 2)
%!error <P must be a numeric floating point vector> polyval ({1, 0}, 0:10)
%!error <P must be a numeric floating point vector> polyval (int8 ([1]), 0:10)
%!error <P must be a numeric floating point vector> polyval ([1,0;0,1], 0:10)
%!error <X must be numeric floating point> polyval ([1,0], {0:10})
%!error <X must be numeric floating point> polyval ([1,0], int8 (0:10))
%!error <S input is required> [y, dy] = polyval (1, 1, [])
%!error <S input is missing required fields>
%! [y, dy] = polyval (1, 1, struct ("T", 0, "normr", 1, "df", 2));
%!error <S input must be a structure> [y, dy] = polyval (1, 1, 2)
%!error <MU must be numeric floating point with 2 values>
%! polyval (1, 1, [], {1, 2});
%!error <MU must be numeric floating point with 2 values>
%! polyval (1, 1, [], int8 ([1,2]));
%!error <MU must be numeric floating point with 2 values>
%! polyval (1, 1, [], [1]);
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} polyvalm (@var{c}, @var{x})
## Evaluate a polynomial in the matrix sense.
##
## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
## matrix sense, i.e., matrix multiplication is used instead of element by
## element multiplication as used in @code{polyval}.
##
## The argument @var{x} must be a square matrix.
## @seealso{polyval, roots, poly}
## @end deftypefn

function y = polyvalm (c, x)

  if (nargin != 2)
    print_usage ();
  endif

  if (! (isvector (c) || isempty (c)))
    error ("polyvalm: first argument must be a vector");
  endif

  if (! issquare (x))
    error ("polyvalm: second argument must be a square matrix");
  endif

  n = length (c);
  if (n == 0)
    y = zeros (rows (x), class (x));
  else
    id = eye (rows (x), class (x));
    y = c(1) * id;
    for i = 2:n
      y = y * x + c(i) * id;
    endfor
  endif

endfunction


%!assert (! any (polyvalm ([], [1, 2; 3, 4]))(:))
%!assert (polyvalm ([1, 2, 3, 4], [3, -4, 1; -2, 0, 2; -1, 4, -3]),
%!        [117, -124, 11; -70, 36, 38; -43, 92, -45])

%!error <must be a square matrix> polyvalm ([1, 1, 1], [1, 2; 3, 4; 5, 6])
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {ppd =} ppder (pp)
## @deftypefnx {} {ppd =} ppder (pp, m)
## Compute the piecewise @var{m}-th derivative of a piecewise polynomial
## struct @var{pp}.
##
## If @var{m} is omitted the first derivative is calculated.
## @seealso{mkpp, ppval, ppint}
## @end deftypefn

function ppd = ppder (pp, m = 1)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isstruct (pp) && strcmp (pp.form, "pp")))
    error ("ppder: PP must be a structure");
  endif

  [x, p, n, k, d] = unmkpp (pp);

  if (k - m <= 0)
    x = [x(1) x(end)];
    pd = zeros (prod (d), 1);
  else
    f = k : -1 : 1;
    ff = bincoeff (f, m + 1) .* factorial (m + 1) ./ f;
    k -= m;
    pd = p(:,1:k) * diag (ff(1:k));
  endif

  ppd = mkpp (x, pd, d);

endfunction


%!shared x,y,pp,ppd
%! x = 0:8;
%! y = [x.^2; x.^3+1];
%! pp = spline (x, y);
%! ppd = ppder (pp);
%!assert (ppval (ppd, x), [2*x; 3*x.^2], 1e-14)
%!assert (ppd.order, 3)
%! ppd = ppder (pp, 2);
%!assert (ppval (ppd, x), [2*ones(size (x)); 6*x], 1e-14)
%!assert (ppd.order, 2)
%! ppd = ppder (pp, 3);
%!assert (ppd.order, 1)
%!assert (ppd.pieces, 8)
%!assert (size (ppd.coefs), [16, 1])
%! ppd = ppder (pp, 4);
%!assert (ppd.order, 1)
%!assert (ppd.pieces, 1)
%!assert (size (ppd.coefs), [2, 1])
%!assert (ppval (ppd,x), zeros (size (y)), 1e-14)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{ppi} =} ppint (@var{pp})
## @deftypefnx {} {@var{ppi} =} ppint (@var{pp}, @var{c})
## Compute the integral of the piecewise polynomial struct @var{pp}.
##
## @var{c}, if given, is the constant of integration.
## @seealso{mkpp, ppval, ppder}
## @end deftypefn

function ppi = ppint (pp, c)

  if (nargin < 1)
    print_usage ();
  endif
  if (! (isstruct (pp) && strcmp (pp.form, "pp")))
    error ("ppint: PP must be a structure");
  endif

  [x, p, n, k, d] = unmkpp (pp);
  p = reshape (p, [], k);

  ## Get piecewise antiderivatives
  pi = p / diag (k:-1:1);
  k += 1;
  if (nargin == 1)
    pi(:, k) = 0;
  else
    pi(:, k) = repmat (c(:), n, 1);
  endif

  ppi = mkpp (x, pi, d);

  tmp = -cumsum (ppjumps (ppi), length (d) + 1);
  ppi.coefs(prod (d)+1 : end, k) = tmp(:);

endfunction


%!shared x,y,pp,ppi
%! x = 0:8;
%! y = [ ones(size(x)); x+1 ];
%! pp = spline (x, y);
%! ppi = ppint (pp);
%!assert (ppval (ppi, x), [x; 0.5*x.^2 + x], 1e-14)
%!assert (ppi.order, 5)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{jumps} =} ppjumps (@var{pp})
## Evaluate the boundary jumps of a piecewise polynomial.
##
## If there are @math{n} intervals, and the dimensionality of @var{pp} is
## @math{d}, the resulting array has dimensions @code{[d, n-1]}.
## @seealso{mkpp}
## @end deftypefn

function jumps = ppjumps (pp)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isstruct (pp) && strcmp (pp.form, "pp")))
    error ("ppjumps: PP must be a structure");
  endif

  ## Extract info.
  [x, P, n, k, d] = unmkpp (pp);
  nd = length (d) + 1;

  ## Offsets.
  dx = diff (x(1:n));
  dx = repmat (dx, [prod(d), 1]);
  dx = reshape (dx, [d, n-1]);
  dx = shiftdim (dx, nd - 1);

  ## Use Horner scheme.
  if (k>1)
    llim = shiftdim (reshape (P(1:(n-1) * prod (d), 1), [d, n-1]), nd - 1);
  endif

  for i = 2 : k
    llim .*= dx;
    llim += shiftdim (reshape (P(1:(n-1) * prod (d), i), [d, n-1]), nd - 1);
  endfor

  rlim = shiftdim (ppval (pp, x(2:end-1)), nd - 1);
  jumps = shiftdim (rlim - llim, 1);

endfunction


%!test
%! p = [1 6 11 6];
%! x = linspace (5, 6, 4);
%! y = polyval (p, x);
%! pp = spline (x, y);
%! jj = ppjumps (pp);
%! assert (jj, [0 0], eps);

%!test
%! breaks = [0 1 2];
%! pp1 = poly (-[1 2 3]);
%! pp2 = poly (-([1 2 3]+1));
%! pp = mkpp (breaks, [pp1;pp2]);
%! assert (ppjumps (pp), 0, eps);

%!test
%! breaks = [0 1 2];
%! pp1 = poly (-[1 2 3]);
%! pp2 = poly (([1 2 3]+1));
%! pp = mkpp (breaks, [pp1;pp2]);
%! j  = - 2 * polyval (pp1, 1);
%! assert (ppjumps (pp), j, eps);
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{yi} =} ppval (@var{pp}, @var{xi})
## Evaluate the piecewise polynomial structure @var{pp} at the points @var{xi}.
##
## If @var{pp} describes a scalar polynomial function, the result is an array
## of the same shape as @var{xi}.  Otherwise, the size of the result is
## @code{[pp.dim, length(@var{xi})]} if @var{xi} is a vector, or
## @code{[pp.dim, size(@var{xi})]} if it is a multi-dimensional array.
## @seealso{mkpp, unmkpp, spline, pchip}
## @end deftypefn

function yi = ppval (pp, xi)

  if (nargin != 2)
    print_usage ();
  endif
  if (! (isstruct (pp) && isfield (pp, "form") && strcmp (pp.form, "pp")))
    error ("ppval: first argument must be a pp-form structure");
  endif

  ## Extract info.
  [x, P, n, k, d] = unmkpp (pp);

  ## dimension checks
  sxi = size (xi);
  if (isvector (xi))
    xi = xi(:).';
  endif

  nd = length (d);

  ## Determine intervals.
  xn = numel (xi);
  idx = lookup (x, xi, "lr");

  P = reshape (P, [d, n * k]);
  P = shiftdim (P, nd);
  P = reshape (P, [n, k, d]);
  Pidx = P(idx(:), :);  # 2D matrix size: x = coefs*prod (d), y = prod (sxi)

  if (isvector (xi))
    Pidx = reshape (Pidx, [xn, k, d]);
    Pidx = shiftdim (Pidx, 1);
    dimvec = [d, xn];
  else
    Pidx = reshape (Pidx, [sxi, k, d]);
    Pidx = shiftdim (Pidx, length (sxi));
    dimvec = [d, sxi];
  endif
  ndv = length (dimvec);

  ## Offsets.
  dx = (xi - x(idx))(:)';
  dx = repmat (dx, [prod(d), 1]);
  dx = reshape (dx, dimvec);
  dx = shiftdim (dx, ndv - 1);

  ## Use Horner scheme.
  if (k > 1)
    yi = shiftdim (reshape (Pidx(1,:), dimvec), ndv - 1);
  else
    yi = shiftdim (reshape (Pidx, dimvec), ndv - 1);
  endif

  for i = 2 : k
    yi .*= dx;
    yi += shiftdim (reshape (Pidx(i,:), dimvec), ndv - 1);
  endfor

  ## Adjust shape.
  if ((numel (xi) > 1) || (length (d) == 1))
    yi = reshape (shiftdim (yi, 1), dimvec);
  endif

  if (isvector (xi) && (d == 1))
    yi = reshape (yi, sxi);
  elseif (isfield (pp, "orient") && strcmp (pp.orient, "first"))
    yi = shiftdim (yi, nd);
  endif

  if (d == 1)
    yi = reshape (yi, sxi);
  endif

endfunction


%!shared b, c, pp, pp2, xi, abserr
%! b = 1:3;
%! c = ones (2);
%! pp = mkpp (b, c);
%! abserr = 1e-14;
%! pp2 = mkpp (b, [c;c], 2);
%! xi = [1.1 1.3 1.9 2.1];
%!
%!assert (ppval (pp, 1.1), 1.1, abserr)
%!assert (ppval (pp, 2.1), 1.1, abserr)
%!assert (ppval (pp, xi), [1.1 1.3 1.9 1.1], abserr)
%!assert (ppval (pp, xi.'), [1.1 1.3 1.9 1.1].', abserr)
%!assert (ppval (pp2, 1.1), [1.1;1.1], abserr)
%!assert (ppval (pp2, 2.1), [1.1;1.1], abserr)
%!assert (ppval (pp2, xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
%!assert (ppval (pp2, xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
%!assert (size (ppval (pp2, [xi;xi])), [2 2 4])
%!assert (ppval (mkpp([0 1],1), magic (3)), ones(3,3))
%!
%!test
%! breaks = [0, 1, 2, 3];
%! coefs = rand (6, 4);
%! pp = mkpp (breaks, coefs, 2);
%! ret = zeros (2, 4, 2);
%! ret(:,:,1) = ppval (pp, breaks');
%! ret(:,:,2) = ppval (pp, breaks');
%! assert (ppval (pp, [breaks',breaks']), ret);

## Test input validation
%!error <Invalid call> ppval ()
%!error <Invalid call> ppval (1)
%!error <argument must be a pp-form structure> ppval (1,2)
%!error <argument must be a pp-form structure> ppval (struct ("a", 1), 2)
%!error <argument must be a pp-form structure> ppval (struct ("form", "ab"), 2)
## This function is private because it is maintained by Jonas Lundgren
## separately from Octave.  Please do not reformat to match Octave coding
## conventions as that would make it harder to integrate upstream changes.

% Copyright (c) 2010, Jonas Lundgren
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are
% met:
%
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in
%       the documentation and/or other materials provided with the distribution
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
function pp = __splinefit__(varargin)
%SPLINEFIT Fit a spline to noisy data.
%   PP = SPLINEFIT(X,Y,BREAKS) fits a piecewise cubic spline with breaks
%   (knots) BREAKS to the noisy data (X,Y). X is a vector and Y is a vector
%   or an ND array. If Y is an ND array, then X(j) and Y(:,...,:,j) are
%   matched. Use PPVAL to evaluate PP.
%
%   PP = SPLINEFIT(X,Y,P) where P is a positive integer interpolates the
%   breaks linearly from the sorted locations of X. P is the number of
%   spline pieces and P+1 is the number of breaks.
%
%   OPTIONAL INPUT
%   Argument places 4 to 8 are reserved for optional input.
%   These optional arguments can be given in any order:
%
%   PP = SPLINEFIT(...,'p') applies periodic boundary conditions to
%   the spline. The period length is MAX(BREAKS)-MIN(BREAKS).
%
%   PP = SPLINEFIT(...,'r') uses robust fitting to reduce the influence
%   from outlying data points. Three iterations of weighted least squares
%   are performed. Weights are computed from previous residuals.
%
%   PP = SPLINEFIT(...,BETA), where 0 < BETA < 1, sets the robust fitting
%   parameter BETA and activates robust fitting ('r' can be omitted).
%   Default is BETA = 1/2. BETA close to 0 gives all data equal weighting.
%   Increase BETA to reduce the influence from outlying data. BETA close
%   to 1 may cause instability or rank deficiency.
%
%   PP = SPLINEFIT(...,N) sets the spline order to N. Default is a cubic
%   spline with order N = 4. A spline with P pieces has P+N-1 degrees of
%   freedom. With periodic boundary conditions the degrees of freedom are
%   reduced to P.
%
%   PP = SPLINEFIT(...,CON) applies linear constraints to the spline.
%   CON is a structure with fields 'xc', 'yc' and 'cc':
%       'xc', x-locations (vector)
%       'yc', y-values (vector or ND array)
%       'cc', coefficients (matrix).
%
%   Constraints are linear combinations of derivatives of order 0 to N-2
%   according to
%
%     cc(1,j)*y(x) + cc(2,j)*y'(x) + ... = yc(:,...,:,j),  x = xc(j).
%
%   The maximum number of rows for 'cc' is N-1. If omitted or empty 'cc'
%   defaults to a single row of ones. Default for 'yc' is a zero array.
%
%   EXAMPLES
%
%       % Noisy data
%       x = linspace(0,2*pi,100);
%       y = sin(x) + 0.1*randn(size(x));
%       % Breaks
%       breaks = [0:5,2*pi];
%
%       % Fit a spline of order 5
%       pp = splinefit(x,y,breaks,5);
%
%       % Fit a spline of order 3 with periodic boundary conditions
%       pp = splinefit(x,y,breaks,3,'p');
%
%       % Constraints: y(0) = 0, y'(0) = 1 and y(3) + y"(3) = 0
%       xc = [0 0 3];
%       yc = [0 1 0];
%       cc = [1 0 1; 0 1 0; 0 0 1];
%       con = struct('xc',xc,'yc',yc,'cc',cc);
%
%       % Fit a cubic spline with 8 pieces and constraints
%       pp = splinefit(x,y,8,con);
%
%       % Fit a spline of order 6 with constraints and periodicity
%       pp = splinefit(x,y,breaks,con,6,'p');
%
%   See also SPLINE, PPVAL, PPDIFF, PPINT

%   2009-05-06  Original SPLINEFIT.
%   2010-06-23  New version of SPLINEFIT based on B-splines.
%   2010-09-01  Robust fitting scheme added.
%   2010-09-01  Support for data containing NaNs.
%   2011-07-01  Robust fitting parameter added.

% Check number of arguments
narginchk(3,7);

% Check arguments
[x,y,dim,breaks,n,periodic,beta,constr] = arguments(varargin{:});

% Evaluate B-splines
base = splinebase(breaks,n);
pieces = base.pieces;
A = ppval(base,x);

% Bin data
[junk,ibin] = histc(x,[-inf,breaks(2:end-1),inf]); %#ok

% Sparse system matrix
mx = numel(x);
ii = [ibin; ones(n-1,mx)];
ii = cumsum(ii,1);
jj = repmat(1:mx,n,1);
if periodic
    ii = mod(ii-1,pieces) + 1;
    A = sparse(ii,jj,A,pieces,mx);
else
    A = sparse(ii,jj,A,pieces+n-1,mx);
end

% Don't use the sparse solver for small problems
if pieces < 20*n/log(1.7*n)
    A = full(A);
end

% Solve
if isempty(constr)
    % Solve Min norm(u*A-y)
    u = lsqsolve(A,y,beta);
else
    % Evaluate constraints
    B = evalcon(base,constr,periodic);
    % Solve constraints
    [Z,u0] = solvecon(B,constr);
    % Solve Min norm(u*A-y), subject to u*B = yc
    y -= u0*A;
    A = Z*A;
    v = lsqsolve(A,y,beta);
    u = u0 + v*Z;
end

% Periodic expansion of solution
if periodic
    jj = mod(0:pieces+n-2,pieces) + 1;
    u = u(:,jj);
end

% Compute polynomial coefficients
ii = [repmat(1:pieces,1,n); ones(n-1,n*pieces)];
ii = cumsum(ii,1);
jj = repmat(1:n*pieces,n,1);
C = sparse(ii,jj,base.coefs,pieces+n-1,n*pieces);
coefs = u*C;
coefs = reshape(coefs,[],n);

% Make piecewise polynomial
pp = mkpp(breaks,coefs,dim);


%--------------------------------------------------------------------------
function [x,y,dim,breaks,n,periodic,beta,constr] = arguments(varargin)
%ARGUMENTS Lengthy input checking
%   x           Noisy data x-locations (1 x mx)
%   y           Noisy data y-values (prod(dim) x mx)
%   dim         Leading dimensions of y
%   breaks      Breaks (1 x (pieces+1))
%   n           Spline order
%   periodic    True if periodic boundary conditions
%   beta        Robust fitting parameter, no robust fitting if beta = 0
%   constr      Constraint structure
%   constr.xc   x-locations (1 x nx)
%   constr.yc   y-values (prod(dim) x nx)
%   constr.cc   Coefficients (?? x nx)

% Reshape x-data
x = varargin{1};
mx = numel(x);
x = reshape(x,1,mx);

% Remove trailing singleton dimensions from y
y = varargin{2};
dim = size(y);
while numel(dim) > 1 && dim(end) == 1
    dim(end) = [];
end
my = dim(end);

% Leading dimensions of y
if numel(dim) > 1
    dim(end) = [];
else
    dim = 1;
end

% Reshape y-data
pdim = prod(dim);
y = reshape(y,pdim,my);

% Check data size
if mx ~= my
    mess = 'Last dimension of array y must equal length of vector x.';
    error('arguments:datasize',mess)
end

% Treat NaNs in x-data
inan = find(isnan(x));
if ~isempty(inan)
    x(inan) = [];
    y(:,inan) = [];
    mess = 'All data points with NaN as x-location will be ignored.';
    warning('arguments:nanx',mess)
end

% Treat NaNs in y-data
inan = find(any(isnan(y),1));
if ~isempty(inan)
    x(inan) = [];
    y(:,inan) = [];
    mess = 'All data points with NaN in their y-value will be ignored.';
    warning('arguments:nany',mess)
end

% Check number of data points
mx = numel(x);
if mx == 0
    error('arguments:nodata','There must be at least one data point.')
end

% Sort data
if any(diff(x) < 0)
    [x,isort] = sort(x);
    y = y(:,isort);
end

% Breaks
if isscalar(varargin{3})
    % Number of pieces
    p = varargin{3};
    if ~isreal(p) || ~isfinite(p) || p < 1 || fix(p) < p
        mess = 'Argument #3 must be a vector or a positive integer.';
        error('arguments:breaks1',mess)
    end
    if x(1) < x(end)
        % Interpolate breaks linearly from x-data
        dx = diff(x);
        ibreaks = linspace(1,mx,p+1);
        [junk,ibin] = histc(ibreaks,[0,2:mx-1,mx+1]); %#ok
        breaks = x(ibin) + dx(ibin).*(ibreaks-ibin);
    else
        breaks = x(1) + linspace(0,1,p+1);
    end
else
    % Vector of breaks
    breaks = reshape(varargin{3},1,[]);
    if isempty(breaks) || min(breaks) == max(breaks)
        mess = 'At least two unique breaks are required.';
        error('arguments:breaks2',mess);
    end
end

% Unique breaks
if any(diff(breaks) <= 0)
    breaks = unique(breaks);
end

% Optional input defaults
n = 4;                      % Cubic splines
periodic = false;           % No periodic boundaries
robust = false;             % No robust fitting scheme
beta = 0.5;                 % Robust fitting parameter
constr = [];                % No constraints

% Loop over optional arguments
for k = 4:nargin
    a = varargin{k};
    if ischar(a) && isscalar(a) && lower(a) == 'p'
        % Periodic conditions
        periodic = true;
    elseif ischar(a) && isscalar(a) && lower(a) == 'r'
        % Robust fitting scheme
        robust = true;
    elseif isreal(a) && isscalar(a) && isfinite(a) && a > 0 && a < 1
        % Robust fitting parameter
        beta = a;
        robust = true;
    elseif isreal(a) && isscalar(a) && isfinite(a) && a > 0 && fix(a) == a
        % Spline order
        n = a;
    elseif isstruct(a) && isscalar(a)
        % Constraint structure
        constr = a;
    else
        error('arguments:nonsense','Failed to interpret argument #%d.',k)
    end
end

% No robust fitting
if ~robust
    beta = 0;
end

% Check exterior data
h = diff(breaks);
xlim1 = breaks(1) - 0.01*h(1);
xlim2 = breaks(end) + 0.01*h(end);
if x(1) < xlim1 || x(end) > xlim2
    if periodic
        % Move data inside domain
        P = breaks(end) - breaks(1);
        x = mod(x-breaks(1),P) + breaks(1);
        % Sort
        [x,isort] = sort(x);
        y = y(:,isort);
    else
        mess = 'Some data points are outside the spline domain.';
        warning('arguments:exteriordata',mess)
    end
end

% Return
if isempty(constr)
    return;
end

% Unpack constraints
xc = [];
yc = [];
cc = [];
names = fieldnames(constr);
for k = 1:numel(names)
    switch names{k}
        case {'xc'}
            xc = constr.xc;
        case {'yc'}
            yc = constr.yc;
        case {'cc'}
            cc = constr.cc;
        otherwise
            mess = 'Unknown field ''%s'' in constraint structure.';
            warning('arguments:unknownfield',mess,names{k})
    end
end

% Check xc
if isempty(xc)
    mess = 'Constraints contains no x-locations.';
    error('arguments:emptyxc',mess)
else
    nx = numel(xc);
    xc = reshape(xc,1,nx);
end

% Check yc
if isempty(yc)
    % Zero array
    yc = zeros(pdim,nx);
elseif numel(yc) == 1
    % Constant array
    yc = zeros(pdim,nx) + yc;
elseif numel(yc) ~= pdim*nx
    % Malformed array
    error('arguments:ycsize','Cannot reshape yc to size %dx%d.',pdim,nx)
else
    % Reshape array
    yc = reshape(yc,pdim,nx);
end

% Check cc
if isempty(cc)
    cc = ones(size(xc));
elseif numel(size(cc)) ~= 2
    error('arguments:ccsize1','Constraint coefficients cc must be 2-D.')
elseif size(cc,2) ~= nx
    mess = 'Last dimension of cc must equal length of xc.';
    error('arguments:ccsize2',mess)
end

% Check high order derivatives
if size(cc,1) >= n
    if any(any(cc(n:end,:)))
        mess = 'Constraints involve derivatives of order %d or larger.';
        error('arguments:difforder',mess,n-1)
    end
    cc = cc(1:n-1,:);
end

% Check exterior constraints
if min(xc) < xlim1 || max(xc) > xlim2
    if periodic
        % Move constraints inside domain
        P = breaks(end) - breaks(1);
        xc = mod(xc-breaks(1),P) + breaks(1);
    else
        mess = 'Some constraints are outside the spline domain.';
        warning('arguments:exteriorconstr',mess)
    end
end

% Pack constraints
constr = struct('xc',xc,'yc',yc,'cc',cc);


%--------------------------------------------------------------------------
function pp = splinebase(breaks,n)
%SPLINEBASE Generate B-spline base PP of order N for breaks BREAKS

breaks = breaks(:);     % Breaks
breaks0 = breaks';      % Initial breaks
h = diff(breaks);       % Spacing
pieces = numel(h);      % Number of pieces
deg = n - 1;            % Polynomial degree

% Extend breaks periodically
if deg > 0
    if deg <= pieces
        hcopy = h;
    else
        hcopy = repmat(h,ceil(deg/pieces),1);
    end
    % to the left
    hl = hcopy(end:-1:end-deg+1);
    bl = breaks(1) - cumsum(hl);
    % and to the right
    hr = hcopy(1:deg);
    br = breaks(end) + cumsum(hr);
    % Add breaks
    breaks = [bl(deg:-1:1); breaks; br];
    h = diff(breaks);
    pieces = numel(h);
end

% Initiate polynomial coefficients
coefs = zeros(n*pieces,n);
coefs(1:n:end,1) = 1;

% Expand h
ii = [1:pieces; ones(deg,pieces)];
ii = cumsum(ii,1);
ii = min(ii,pieces);
H = h(ii(:));

% Recursive generation of B-splines
for k = 2:n
    % Antiderivatives of splines
    for j = 1:k-1
        coefs(:,j) = coefs(:,j).*H/(k-j);
    end
    Q = sum(coefs,2);
    Q = reshape(Q,n,pieces);
    Q = cumsum(Q,1);
    c0 = [zeros(1,pieces); Q(1:deg,:)];
    coefs(:,k) = c0(:);
    % Normalize antiderivatives by max value
    fmax = repmat(Q(n,:),n,1);
    fmax = fmax(:);
    for j = 1:k
        coefs(:,j) = coefs(:,j)./fmax;
    end
    % Diff of adjacent antiderivatives
    coefs(1:end-deg,1:k) = coefs(1:end-deg,1:k) - coefs(n:end,1:k);
    coefs(1:n:end,k) = 0;
end

% Scale coefficients
scale = ones(size(H));
for k = 1:n-1
    scale = scale./H;
    coefs(:,n-k) = scale.*coefs(:,n-k);
end

% Reduce number of pieces
pieces -= 2*deg;

% Sort coefficients by interval number
ii = [n*(1:pieces); deg*ones(deg,pieces)];
ii = cumsum(ii,1);
coefs = coefs(ii(:),:);

% Make piecewise polynomial
pp = mkpp(breaks0,coefs,n);


%--------------------------------------------------------------------------
function B = evalcon(base,constr,periodic)
%EVALCON Evaluate linear constraints

% Unpack structures
breaks = base.breaks;
pieces = base.pieces;
n = base.order;
xc = constr.xc;
cc = constr.cc;

% Bin data
[junk,ibin] = histc(xc,[-inf,breaks(2:end-1),inf]); %#ok

% Evaluate constraints
nx = numel(xc);
B0 = zeros(n,nx);
for k = 1:size(cc,1)
    if any(cc(k,:))
        B0 += repmat(cc(k,:),n,1).*ppval(base,xc);
    end
    % Differentiate base
    coefs = base.coefs(:,1:n-k);
    for j = 1:n-k-1
        coefs(:,j) = (n-k-j+1)*coefs(:,j);
    end
    base.coefs = coefs;
    base.order = n-k;
end

% Sparse output
ii = [ibin; ones(n-1,nx)];
ii = cumsum(ii,1);
jj = repmat(1:nx,n,1);
if periodic
    ii = mod(ii-1,pieces) + 1;
    B = sparse(ii,jj,B0,pieces,nx);
else
    B = sparse(ii,jj,B0,pieces+n-1,nx);
end


%--------------------------------------------------------------------------
function [Z,u0] = solvecon(B,constr)
%SOLVECON Find a particular solution u0 and null space Z (Z*B = 0)
%         for constraint equation u*B = yc.

yc = constr.yc;
tol = 1000*eps;

% Remove blank rows
ii = any(B,2);
B2 = full(B(ii,:));

% Null space of B2
if isempty(B2)
    Z2 = [];
else
    % QR decomposition with column permutation
    [Q,R,dummy] = qr(B2); %#ok
    R = abs(R);
    jj = all(R < R(1)*tol, 2);
    Z2 = Q(:,jj)';
end

% Sizes
[m,ncon] = size(B);
m2 = size(B2,1);
nz = size(Z2,1);

% Sparse null space of B
Z = sparse(nz+1:nz+m-m2,find(~ii),1,nz+m-m2,m);
Z(1:nz,ii) = Z2;

% Warning rank deficient
if nz + ncon > m2
	mess = 'Rank deficient constraints, rank = %d.';
	warning('solvecon:deficient',mess,m2-nz);
end

% Particular solution
u0 = zeros(size(yc,1),m);
if any(yc(:))
    % Non-homogeneous case
	u0(:,ii) = yc/B2;
    % Check solution
	if norm(u0*B - yc,'fro') > norm(yc,'fro')*tol
        mess = 'Inconsistent constraints. No solution within tolerance.';
        error('solvecon:inconsistent',mess)
	end
end


%--------------------------------------------------------------------------
function u = lsqsolve(A,y,beta)
%LSQSOLVE Solve Min norm(u*A-y)

% Avoid sparse-complex limitations
if issparse(A) && ~isreal(y)
    A = full(A);
end

% Solution
u = y/A;

% Robust fitting
if beta > 0
    [m,n] = size(y);
    alpha = 0.5*beta/(1-beta)/m;
    for k = 1:3
        % Residual
        r = u*A - y;
        rr = r.*conj(r);
        rrmean = sum(rr,2)/n;
        rrmean(~rrmean) = 1;
        rrhat = (alpha./rrmean)'*rr;
        % Weights
        w = exp(-rrhat);
        spw = spdiags(w',0,n,n);
        % Solve weighted problem
        u = (y*spw)/(A*spw);
    end
end
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{r}, @var{p}, @var{k}, @var{e}] =} residue (@var{b}, @var{a})
## @deftypefnx {} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k})
## @deftypefnx {} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k}, @var{e})
## The first calling form computes the partial fraction expansion for the
## quotient of the polynomials, @var{b} and @var{a}.
##
## The quotient is defined as
## @tex
## $$
## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
##   + \sum_{i=1}^N k_i s^{N-i}.
## $$
## @end tex
## @ifnottex
##
## @example
## @group
## B(s)    M       r(m)        N
## ---- = SUM ------------- + SUM k(i)*s^(N-i)
## A(s)   m=1 (s-p(m))^e(m)   i=1
## @end group
## @end example
##
## @end ifnottex
## @noindent
## where @math{M} is the number of poles (the length of the @var{r}, @var{p},
## and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
## representing the direct contribution, and the @var{e} vector specifies the
## multiplicity of the m-th residue's pole.
##
## For example,
##
## @example
## @group
## b = [1, 1, 1];
## a = [1, -5, 8, -4];
## [r, p, k, e] = residue (b, a)
##    @result{} r = [-2; 7; 3]
##    @result{} p = [2; 2; 1]
##    @result{} k = [](0x0)
##    @result{} e = [1; 2; 1]
## @end group
## @end example
##
## @noindent
## which represents the following partial fraction expansion
## @tex
## $$
## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##         s^2 + s + 1       -2        7        3
##    ------------------- = ----- + ------- + -----
##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
## @end group
## @end example
##
## @end ifnottex
##
## The second calling form performs the inverse operation and computes the
## reconstituted quotient of polynomials, @var{b}(s)/@var{a}(s), from the
## partial fraction expansion; represented by the residues, poles, and a direct
## polynomial specified by @var{r}, @var{p} and @var{k}, and the pole
## multiplicity @var{e}.
##
## If the multiplicity, @var{e}, is not explicitly specified the multiplicity
## is determined by the function @code{mpoles}.
##
## For example:
##
## @example
## @group
## r = [-2; 7; 3];
## p = [2; 2; 1];
## k = [1, 0];
## [b, a] = residue (r, p, k)
##    @result{} b = [1, -5, 9, -3, 1]
##    @result{} a = [1, -5, 8, -4]
##
## where mpoles is used to determine e = [1; 2; 1]
## @end group
## @end example
##
## Alternatively the multiplicity may be defined explicitly, for example,
##
## @example
## @group
## r = [7; 3; -2];
## p = [2; 1; 2];
## k = [1, 0];
## e = [2; 1; 1];
## [b, a] = residue (r, p, k, e)
##    @result{} b = [1, -5, 9, -3, 1]
##    @result{} a = [1, -5, 8, -4]
## @end group
## @end example
##
## @noindent
## which represents the following partial fraction expansion
## @tex
## $$
## {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1} + s = {s^4-5s^3+9s^2-3s+1\over s^3-5s^2+8s-4}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##  -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
## ----- + ------- + ----- + s = --------------------------
## (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
## @end group
## @end example
##
## @end ifnottex
## @seealso{mpoles, poly, roots, conv, deconv}
## @end deftypefn

function [r, p, k, e] = residue (b, a, varargin)

  if (nargin < 2 || nargin > 4)
    print_usage ();
  endif

  tol = .001;

  if (nargin >= 3)
    if (nargin >= 4)
      e = varargin{2};
    else
      e = [];
    endif
    ## The inputs are the residue, pole, and direct part.
    ## Solve for the corresponding numerator and denominator polynomials.
    [r, p] = rresidue (b, a, varargin{1}, tol, e);
    return;
  endif

  ## Make sure both polynomials are in reduced form, and scaled.
  a = polyreduce (a);
  b = polyreduce (b);

  b /= a(1);
  a /= a(1);

  la = length (a);
  lb = length (b);

  ## Handle special cases here.
  if (la == 0 || lb == 0)
    k = r = p = e = [];
    return;
  elseif (la == 1)
    k = b / a;
    r = p = e = [];
    return;
  endif

  ## Find the poles.
  p = roots (a);
  lp = length (p);

  ## Sort poles so that multiplicity loop will work.
  [e, idx] = mpoles (p, tol, 1);
  p = p(idx);

  ## For each group of pole multiplicity, set the value of each
  ## pole to the average of the group.  This reduces the error in
  ## the resulting poles.
  p_group = cumsum (e == 1);
  for ng = 1:p_group(end)
    m = find (p_group == ng);
    p(m) = mean (p(m));
  endfor

  ## Find the direct term if there is one.
  if (lb >= la)
    ## Also return the reduced numerator.
    [k, b] = deconv (b, a);
    lb = length (b);
  else
    k = [];
  endif

  ## Determine if the poles are (effectively) zero.
  small = max (abs (p));
  if (isa (a, "single") || isa (b, "single"))
    small = max ([small, 1]) * eps ("single") * 1e4 * (1 + numel (p))^2;
  else
    small = max ([small, 1]) * eps * 1e4 * (1 + numel (p))^2;
  endif
  p(abs (p) < small) = 0;

  ## Determine if the poles are (effectively) real, or imaginary.
  idx = (abs (imag (p)) < small);
  p(idx) = real (p(idx));
  idx = (abs (real (p)) < small);
  p(idx) = 1i * imag (p(idx));

  ## The remainder determines the residues.  The case of one pole is trivial.
  if (lp == 1)
    r = polyval (b, p);
    return;
  endif

  ## Determine the order of the denominator and remaining numerator.
  ## With the direct term removed, the potential order of the numerator
  ## is one less than the order of the denominator.
  aorder = numel (a) - 1;
  border = aorder - 1;

  ## Construct a system of equations relating the individual
  ## contributions from each residue to the complete numerator.
  A = zeros (border+1, border+1);
  B = prepad (reshape (b, [numel(b), 1]), border+1, 0);
  for ip = 1:numel (p)
    ri = zeros (size (p));
    ri(ip) = 1;
    A(:,ip) = prepad (rresidue (ri, p, [], tol), border+1, 0).';
  endfor

  ## Solve for the residues.
  ## FIXME: Use a pre-conditioner d to make A \ B work better (bug #53869).
  ##        It would be better to construct A and B so they are not close to
  ##        singular in the first place.
  d = max (abs (A), [], 2);
  r = (diag (d) \ A) \ (B ./ d);

endfunction

## Reconstitute the numerator and denominator polynomials
## from the residues, poles, and direct term.
function [pnum, pden, e] = rresidue (r, p, k = [], tol = [], e = [])

  if (! isempty (e))
    idx = 1:numel (p);
  else
    [e, idx] = mpoles (p, tol, 0);
    p = p(idx);
    r = r(idx);
  endif

  idx = 1:numel (p);
  for n = idx
    pn = [1, -p(n)];
    if (n == 1)
      pden = pn;
    else
      pden = conv (pden, pn);
    endif
  endfor

  ## D is the order of the denominator
  ## K is the order of the direct polynomial
  ## N is the order of the resulting numerator
  ## pnum(1:(N+1)) is the numerator's polynomial
  ## pden(1:(D+1)) is the denominator's polynomial
  ## pm is the multiple pole for the nth residue
  ## pn is the numerator contribution for the nth residue

  D = numel (pden) - 1;
  K = numel (k) - 1;
  N = K + D;
  pnum = zeros (1, N+1);
  for n = idx(abs (r) > 0)
    p1 = [1, -p(n)];
    pn = 1;
    for j = 1:n - 1
      pn = conv (pn, [1, -p(j)]);
    endfor
    for j = n + 1:numel (p)
      pn = conv (pn, [1, -p(j)]);
    endfor
    for j = 1:e(n) - 1
      pn = deconv (pn, p1);
    endfor
    pn = r(n) * pn;
    pnum += prepad (pn, N+1, 0, 2);
  endfor

  ## Add the direct term.
  if (numel (k))
    pnum += conv (pden, k);
  endif

  pnum = polyreduce (pnum);
  pden = polyreduce (pden);

endfunction


%!test
%! b = [1, 1, 1];
%! a = [1, -5, 8, -4];
%! [r, p, k, e] = residue (b, a);
%! assert (r, [-2; 7; 3], 1e-12);
%! assert (p, [2; 2; 1], 1e-12);
%! assert (isempty (k));
%! assert (e, [1; 2; 1]);
%! k = [1 0];
%! b = conv (k, a) + prepad (b, numel (k) + numel (a) - 1, 0);
%! a = a;
%! [br, ar] = residue (r, p, k);
%! assert (br, b, 1e-12);
%! assert (ar, a, 1e-12);
%! [br, ar] = residue (r, p, k, e);
%! assert (br, b, 1e-12);
%! assert (ar, a, 1e-12);

%!test
%! b = [1, 0, 1];
%! a = [1, 0, 18, 0, 81];
%! [r, p, k, e] = residue (b, a);
%! r1 = [-5i; 12; +5i; 12]/54;
%! p1 = [+3i; +3i; -3i; -3i];
%! assert (r, r1, 1e-12);
%! assert (p, p1, 1e-12);
%! assert (isempty (k));
%! assert (e, [1; 2; 1; 2]);
%! [br, ar] = residue (r, p, k);
%! assert (br, b, 1e-12);
%! assert (ar, a, 1e-12);

%!test
%! r = [7; 3; -2];
%! p = [2; 1; 2];
%! k = [1 0];
%! e = [2; 1; 1];
%! [b, a] = residue (r, p, k, e);
%! assert (b, [1, -5, 9, -3, 1], 1e-12);
%! assert (a, [1, -5, 8, -4], 1e-12);
%! [rr, pr, kr, er] = residue (b, a);
%! [~, m] = mpoles (rr);
%! [~, n] = mpoles (r);
%! assert (rr(m), r(n), 1e-12);
%! assert (pr(m), p(n), 1e-12);
%! assert (kr, k, 1e-12);
%! assert (er(m), e(n), 1e-12);

%!test
%! b = [1];
%! a = [1, 10, 25];
%! [r, p, k, e] = residue (b, a);
%! r1 = [0; 1];
%! p1 = [-5; -5];
%! assert (r, r1, 1e-12);
%! assert (p, p1, 1e-12);
%! assert (isempty (k));
%! assert (e, [1; 2]);
%! [br, ar] = residue (r, p, k);
%! assert (br, b, 1e-12);
%! assert (ar, a, 1e-12);

## The following test is due to Bernard Grung
%!test <*34266>
%! z1 =  7.0372976777e6;
%! p1 = -3.1415926536e9;
%! p2 = -4.9964813512e8;
%! r1 = -(1 + z1/p1)/(1 - p1/p2)/p2/p1;
%! r2 = -(1 + z1/p2)/(1 - p2/p1)/p2/p1;
%! r3 = (1 + (p2 + p1)/p2/p1*z1)/p2/p1;
%! r4 = z1/p2/p1;
%! r = [r1; r2; r3; r4];
%! p = [p1; p2; 0; 0];
%! k = [];
%! e = [1; 1; 1; 2];
%! b = [1, z1];
%! a = [1, -(p1 + p2), p1*p2, 0, 0];
%! [br, ar] = residue (r, p, k, e);
%! assert (br, [0,0,b], 1e-7);
%! assert (ar, a, 1e-8);

%!test <*49291>
%! rf = [1e3, 2e3, 1e3, 2e3];
%! cf = [316.2e-9, 50e-9, 31.6e-9, 5e-9];
%! [num, den] = residue (1./cf,-1./(rf.*cf),0);
%! assert (numel (num), 4);
%! assert (numel (den), 5);
%! assert (den(1), 1);

%!test <*51148>
%! r = [1.0000e+18, 3.5714e+12, 2.2222e+11, 2.1739e+10];
%! pin = [-1.9231e+15, -1.6234e+09, -4.1152e+07, -1.8116e+06];
%! k = 0;
%! [p, q] = residue (r, pin, k);
%! assert (p(4), 4.6828e+42, -1e-5);

%!test <*60384>
%! B = [1315.789473684211];
%! A = [1, 1.100000536842105e+04, 1.703789473684211e+03, 0];
%! poles1 = roots (A);
%! [r, p, k, e] = residue (B, A);
%! [B1, A1] = residue (r, p, k, e);
%! assert (B, B1);
%! assert (A, A1);
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} roots (@var{c})
##
## Compute the roots of the polynomial @var{c}.
##
## For a vector @var{c} with @math{N} components, return the roots of the
## polynomial
## @tex
## $$
## c_1 x^{N-1} + \cdots + c_{N-1} x + c_N.
## $$
## @end tex
## @ifnottex
##
## @example
## c(1) * x^(N-1) + @dots{} + c(N-1) * x + c(N)
## @end example
##
## @end ifnottex
##
## As an example, the following code finds the roots of the quadratic
## polynomial
## @tex
## $$ p(x) = x^2 - 5. $$
## @end tex
## @ifnottex
##
## @example
## p(x) = x^2 - 5.
## @end example
##
## @end ifnottex
##
## @example
## @group
## c = [1, 0, -5];
## roots (c)
## @result{}  2.2361
## @result{} -2.2361
## @end group
## @end example
##
## Note that the true result is
## @tex
## $\pm \sqrt{5}$
## @end tex
## @ifnottex
## @math{+/- sqrt(5)}
## @end ifnottex
## which is roughly
## @tex
## $\pm 2.2361$.
## @end tex
## @ifnottex
## @math{+/- 2.2361}.
## @end ifnottex
## @seealso{poly, compan, fzero}
## @end deftypefn

function r = roots (c)

  if (nargin < 1 || (! isvector (c) && ! isempty (c)))
    print_usage ();
  elseif (any (! isfinite (c)))
    error ("roots: inputs must not contain Inf or NaN");
  endif

  c = c(:);
  n = numel (c);

  ## If c = [ 0 ... 0 c(k+1) ... c(k+l) 0 ... 0 ],
  ## we can remove the leading k zeros,
  ## and n - k - l roots of the polynomial are zero.

  c_max = max (abs (c));
  if (isempty (c) || c_max == 0)
    r = [];
    return;
  endif

  f = find (c ./ c_max);
  m = numel (f);

  c = c(f(1):f(m));
  l = numel (c);
  if (l > 1)
    A = diag (ones (1, l-2), -1);
    A(1,:) = -c(2:l) ./ c(1);
    r = eig (A);
    if (f(m) < n)
      r = [r; zeros(n - f(m), 1)];
    endif
  else
    r = zeros (n - f(m), 1);
  endif

endfunction


%!test
%! p = [poly([3 3 3 3]), 0 0 0 0];
%! r = sort (roots (p));
%! assert (r, [0; 0; 0; 0; 3; 3; 3; 3], 0.001);

%!assert (isempty (roots ([])))
%!assert (isempty (roots ([0 0])))
%!assert (isempty (roots (1)))
%!assert (roots ([1, -6, 11, -6]), [3; 2; 1], sqrt (eps))

%!assert (roots ([1e-200, -1e200, 1]), 1e-200)
%!assert (roots ([1e-200, -1e200 * 1i, 1]), -1e-200 * 1i)

%!error <Invalid call> roots ()
%!error roots ([1, 2; 3, 4])
%!error <inputs must not contain Inf or NaN> roots ([1 Inf 1])
%!error <inputs must not contain Inf or NaN> roots ([1 NaN 1])
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{pp} =} spline (@var{x}, @var{y})
## @deftypefnx {} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
## Return the cubic spline interpolant of points @var{x} and @var{y}.
##
## When called with two arguments, return the piecewise polynomial @var{pp}
## that may be used with @code{ppval} to evaluate the polynomial at specific
## points.
##
## When called with a third input argument, @code{spline} evaluates the spline
## at the points @var{xi}.  The third calling form
## @code{spline (@var{x}, @var{y}, @var{xi})} is equivalent to
## @code{ppval (spline (@var{x}, @var{y}), @var{xi})}.
##
## The variable @var{x} must be a vector of length @var{n}.
##
## @var{y} can be either a vector or array.  If @var{y} is a vector it must
## have a length of either @var{n} or @code{@var{n} + 2}.  If the length of
## @var{y} is @var{n}, then the @qcode{"not-a-knot"} end condition is used.
## If the length of @var{y} is @code{@var{n} + 2}, then the first and last
## values of the vector @var{y} are the values of the first derivative of the
## cubic spline at the endpoints.
##
## If @var{y} is an array, then the size of @var{y} must have the form
## @tex
## $$[s_1, s_2, \cdots, s_k, n]$$
## @end tex
## @ifnottex
## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
## @end ifnottex
## or
## @tex
## $$[s_1, s_2, \cdots, s_k, n + 2].$$
## @end tex
## @ifnottex
## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n} + 2]}.
## @end ifnottex
## The array is reshaped internally to a matrix where the leading
## dimension is given by
## @tex
## $$s_1 s_2 \cdots s_k$$
## @end tex
## @ifnottex
## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
## @end ifnottex
## and each row of this matrix is then treated separately.  Note that this is
## exactly the opposite of @code{interp1} but is done for @sc{matlab}
## compatibility.
##
## @seealso{pchip, ppval, mkpp, unmkpp}
## @end deftypefn

## This code is based on csape.m from Octave Forge, but has been
## modified to use the sparse solver code in octave that itself allows
## special casing of tri-diagonal matrices, modified for NDArrays and
## for the treatment of vectors y 2 elements longer than x as complete
## splines.

function ret = spline (x, y, xi)

  x = x(:);
  n = length (x);
  if (n < 2)
    error ("spline: requires at least 2 points");
  endif

  ## Check the size and shape of y
  ndy = ndims (y);
  szy = size (y);
  if (ndy == 2 && (any (szy == n) || any (szy == n+2)))
    if (szy(2) == n || szy(2) == n+2)
      a = y.';
    else
      a = y;
      szy = szy([2 1]);
    endif
  else
    a = shiftdim (reshape (y, [prod(szy(1:end-1)), szy(end)]), 1);
  endif

  for k = (1:columns (a))(any (isnan (a)))
    ok = ! isnan (a(:,k));
    a(! ok,k) = spline (x(ok), a(ok,k), x(! ok));
  endfor

  complete = false;
  if (rows (a) == n + 2)
    complete = true;
    dfs = a(1,:);
    dfe = a(end,:);
    a = a(2:end-1,:);
  endif

  if (! issorted (x))
    [x, idx] = sort (x);
    a = a(idx,:);
  endif

  b = c = zeros (size (a));
  h = diff (x);
  idx = ones (columns (a), 1);

  if (complete)

    if (n == 2)
      d = (dfs + dfe) / (x(2) - x(1)) ^ 2 + ...
          2 * (a(1,:) - a(2,:)) / (x(2) - x(1)) ^ 3;
      c = (-2 * dfs - dfe) / (x(2) - x(1)) - ...
          3 * (a(1,:) - a(2,:)) / (x(2) - x(1)) ^ 2;
      b = dfs;
      a = a(1,:);
    else
      g(1,:) = (a(2,:) - a(1,:)) / h(1) - dfs;
      g(2:n-1,:) = (a(3:n,:) - a(2:n-1,:)) ./ h(2:n-1) - ...
                   (a(2:n-1,:) - a(1:n-2,:)) ./ h(1:n-2);
      g(n,:) = dfe - (a(n,:) - a(n-1,:)) / h(n-1);
      c = spdiags ([[h/6;0],[h(1)/3;(h(1:n-2)+h(2:n-1))/3;h(n-1)/3],[0;h/6]],...
                   [-1,0,1],n,n) \ (g / 2);
      b = diff (a) ./ h(1:n-1, idx) ...
          - h(1:n-1,idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
      d = diff (c) ./ (3 * h(1:n-1, idx));

      d = d.'(:);
      c = c(1:n-1,:).'(:);
      b = b.'(:);
      a = a(1:n-1,:).'(:);
    endif
  else

    if (n == 2)
      b = (a(2,:) - a(1,:)) / (x(2) - x(1));
      a = a(1,:);
      d = [];
      c = [];
    elseif (n == 3)

      n = 2;
      c = (a(1,:) - a(3,:)) / ((x(3) - x(1)) * (x(2) - x(3))) ...
          + (a(2,:) - a(1,:)) / ((x(2) - x(1)) * (x(2) - x(3)));
      b = (a(2,:) - a(1,:)) * (x(3) - x(1)) ...
          / ((x(2) - x(1)) * (x(3) - x(2))) ...
          + (a(1,:) - a(3,:)) * (x(2) - x(1)) ...
          / ((x(3) - x(1)) * (x(3) - x(2)));
      a = a(1,:);
      d = [];
      x = [min(x), max(x)];
    else

      g = zeros (n-2, columns (a));
      g(1,:) = 3 / (h(1) + h(2)) ...
          * (a(3,:) - a(2,:) - h(2) / h(1) * (a(2,:) - a(1,:)));
      g(n-2,:) = 3 / (h(n-1) + h(n-2)) ...
          * (h(n-2) / h(n-1) * (a(n,:) - a(n-1,:)) - (a(n-1,:) - a(n-2,:)));

      if (n > 4)

        g(2:n - 3,:) = 3 * diff (a(3:n-1,:)) ./ h(3:n-2,idx) ...
            - 3 * diff (a(2:n-2,:)) ./ h(2:n - 3,idx);

        dg = 2 * (h(1:n-2) + h(2:n-1));
        dg(1) = dg(1) - h(1);
        dg(n-2) = dg(n-2) - h(n-1);

        ldg = udg = h(2:n-2);
        udg(1) = udg(1) - h(1);
        ldg(n - 3) = ldg(n-3) - h(n-1);
        c(2:n-1,:) = spdiags ([[ldg(:); 0], dg, [0; udg(:)]],
                              [-1, 0, 1], n-2, n-2) \ g;

      elseif (n == 4)

        dg = [h(1) + 2 * h(2); 2 * h(2) + h(3)];
        ldg = h(2) - h(3);
        udg = h(2) - h(1);
        c(2:n-1,:) = spdiags ([[ldg(:);0], dg, [0; udg(:)]],
                              [-1, 0, 1], n-2, n-2) \ g;

      endif

      c(1,:) = c(2,:) + h(1) / h(2) * (c(2,:) - c(3,:));
      c(n,:) = c(n-1,:) + h(n-1) / h(n-2) * (c(n-1,:) - c(n-2,:));
      b = diff (a) ./ h(1:n-1, idx) ...
          - h(1:n-1, idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
      d = diff (c) ./ (3 * h(1:n-1, idx));

      d = d.'(:);
      c = c(1:n-1,:).'(:);
      b = b.'(:);
      a = a(1:n-1,:).'(:);
    endif

  endif
  ret = mkpp (x, cat (2, d, c, b, a), szy(1:end-1));

  if (nargin == 3)
    ret = ppval (ret, xi);
  endif

endfunction


%!demo
%! x = 0:10; y = sin (x);
%! xspline = 0:0.1:10;  yspline = spline (x,y,xspline);
%! title ("spline fit to points from sin (x)");
%! plot (xspline,sin (xspline),"r", xspline,yspline,"g-", x,y,"b+");
%! legend ("original", "interpolation", "interpolation points");
%! %--------------------------------------------------------
%! % confirm that interpolated function matches the original

%!shared x,y,abserr
%! x = [0:10]; y = sin (x); abserr = 1e-14;
%!assert (spline (x,y,x), y, abserr)
%!assert (spline (x,y,x'), y', abserr)
%!assert (spline (x',y',x'), y', abserr)
%!assert (spline (x',y',x), y, abserr)
%!assert (isempty (spline (x',y',[])))
%!assert (isempty (spline (x,y,[])))
%!assert (spline (x,[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
%!assert (spline (x,[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
%!assert (spline (x',[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
%!assert (spline (x',[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
%! y = cos (x) + i*sin (x);
%!assert (spline (x,y,x), y, abserr)
%!assert (real (spline (x,y,x)), real (y), abserr)
%!assert (real (spline (x,y,x.')), real (y).', abserr)
%!assert (real (spline (x.',y.',x.')), real (y).', abserr)
%!assert (real (spline (x.',y,x)), real (y), abserr)
%!assert (imag (spline (x,y,x)), imag (y), abserr)
%!assert (imag (spline (x,y,x.')), imag (y).', abserr)
%!assert (imag (spline (x.',y.',x.')), imag (y).', abserr)
%!assert (imag (spline (x.',y,x)), imag (y), abserr)
%!test
%! xnan = 5;
%! y(x==xnan) = NaN;
%! ok = ! isnan (y);
%! assert (spline (x, y, x(ok)), y(ok), abserr);
%!test
%! ok = ! isnan (y);
%! assert (! isnan (spline (x, y, x(! ok))));
%!test
%! x = [1,2];
%! y = [1,4];
%! assert (spline (x,y,x), [1,4], abserr);
%!test
%! x = [2,1];
%! y = [1,4];
%! assert (spline (x,y,x), [1,4], abserr);
%!test
%! x = [1,2];
%! y = [1,2,3,4];
%! pp = spline (x,y);
%! [x,P] = unmkpp (pp);
%! assert (P, [3,-3,1,2], abserr);
%!test
%! x = [2,1];
%! y = [1,2,3,4];
%! pp = spline (x,y);
%! pp2 = spline (x', y');
%! [x,P] = unmkpp (pp);
%! assert (P, [7,-9,1,3], abserr);
%! assert (pp2, pp);
%!test
%! x = [0,1,2];
%! y = [0,0,1,0,0];
%! pp = spline (x,y);
%! pp2 = spline (x', y');
%! [x,P] = unmkpp (pp);
%! assert (P, [-2,3,0,0;2,-3,0,1], abserr);
%! assert (pp2, pp);
%!test
%! x = [0,1,2,3];
%! y = [0,0,1,1,0,0];
%! pp = spline (x,y);
%! pp2 = spline (x', y');
%! [x,P] = unmkpp (pp);
%! assert (P, [-1,2,0,0;0,-1,1,1;1,-1,-1,1], abserr);
%! assert (pp2, pp);
########################################################################
##
## Copyright (C) 2012-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{breaks})
## @deftypefnx {} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{p})
## @deftypefnx {} {@var{pp} =} splinefit (@dots{}, "periodic", @var{periodic})
## @deftypefnx {} {@var{pp} =} splinefit (@dots{}, "robust", @var{robust})
## @deftypefnx {} {@var{pp} =} splinefit (@dots{}, "beta", @var{beta})
## @deftypefnx {} {@var{pp} =} splinefit (@dots{}, "order", @var{order})
## @deftypefnx {} {@var{pp} =} splinefit (@dots{}, "constraints", @var{constraints})
##
## Fit a piecewise cubic spline with breaks (knots) @var{breaks} to the
## noisy data, @var{x} and @var{y}.
##
## @var{x} is a vector, and @var{y} is a vector or N-D array.  If @var{y} is an
## N-D array, then @var{x}(j) is matched to @var{y}(:,@dots{},:,j).
##
## @var{p} is a positive integer defining the number of intervals along
## @var{x}, and @var{p}+1 is the number of breaks.  The number of points in
## each interval differ by no more than 1.
##
## The optional property @var{periodic} is a logical value which specifies
## whether a periodic boundary condition is applied to the spline.  The
## length of the period is @code{max (@var{breaks}) - min (@var{breaks})}.
## The default value is @code{false}.
##
## The optional property @var{robust} is a logical value which specifies
## if robust fitting is to be applied to reduce the influence of outlying
## data points.  Three iterations of weighted least squares are performed.
## Weights are computed from previous residuals.  The sensitivity of outlier
## identification is controlled by the property @var{beta}.  The value of
## @var{beta} is restricted to the range, 0 < @var{beta} < 1.  The default
## value is @var{beta} = 1/2.  Values close to 0 give all data equal
## weighting.  Increasing values of @var{beta} reduce the influence of
## outlying data.  Values close to unity may cause instability or rank
## deficiency.
##
## The fitted spline is returned as a piecewise polynomial, @var{pp}, and
## may be evaluated using @code{ppval}.
##
## The splines are constructed of polynomials with degree @var{order}.
## The default is a cubic, @var{order}=3.  A spline with P pieces has
## P+@var{order} degrees of freedom.  With periodic boundary conditions
## the degrees of freedom are reduced to P.
##
## The optional property, @var{constraints}, is a structure specifying linear
## constraints on the fit.  The structure has three fields, @qcode{"xc"},
## @qcode{"yc"}, and @qcode{"cc"}.
##
## @table @asis
## @item @qcode{"xc"}
## Vector of the x-locations of the constraints.
##
## @item @qcode{"yc"}
## Constraining values at the locations @var{xc}.
## The default is an array of zeros.
##
## @item @qcode{"cc"}
## Coefficients (matrix).  The default is an array of ones.  The number of
## rows is limited to the order of the piecewise polynomials, @var{order}.
## @end table
##
## Constraints are linear combinations of derivatives of order 0 to
## @var{order}-1 according to
##
## @example
## @group
## @tex
## $cc(1,j) \cdot y(xc(j)) + cc(2,j) \cdot y\prime(xc(j)) + ... = yc(:,\dots,:,j)$.
## @end tex
## @ifnottex
## cc(1,j) * y(xc(j)) + cc(2,j) * y'(xc(j)) + ... = yc(:,...,:,j).
## @end ifnottex
## @end group
## @end example
##
## @seealso{interp1, unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
## @end deftypefn

function pp = splinefit (x, y, breaks, varargin)

  if (nargin > 3)
    n = cellfun ("isclass", varargin, "char");
    varargin(n) = lower (varargin(n));
    try
      props = struct (varargin{:});
    catch
      print_usage ();
    end_try_catch
  else
    props = struct ();
  endif

  fields = fieldnames (props);
  for f = 1:numel (fields)
    if (! any (strcmp (fields{f},
                       {"periodic", "robust", "beta", "order", "constraints"})))
      error ("Octave:splinefit:invalidproperty",
             "unrecognized property '%s'", fields{f});
    endif
  endfor

  args = {};
  if (isfield (props, "periodic") && props.periodic)
    args{end+1} = "p";
  endif
  if (isfield (props, "robust") && props.robust)
    args{end+1} = "r";
  endif
  if (isfield (props, "beta"))
    if (0 < props.beta && props.beta < 1)
      args{end+1} = props.beta;
    else
      error ("Octave:splinefit:invalidbeta", "invalid beta parameter (0 < BETA < 1)");
    endif
  endif
  if (isfield (props, "order"))
    if (props.order >= 0)
      args{end+1} = props.order + 1;
    else
      error ("Octave:splinefit:invalidorder", "invalid ORDER");
    endif
  endif
  if (isfield (props, "constraints"))
    args{end+1} = props.constraints;
  endif
  if (nargin < 3)
    print_usage ();
  elseif (! isnumeric (breaks) || ! isvector (breaks))
    print_usage ();
  endif

  pp = __splinefit__ (x, y, breaks, args{:});

endfunction


%!demo
%! % Noisy data
%! x = linspace (0, 2*pi, 100);
%! y = sin (x) + 0.1 * randn (size (x));
%! % Breaks
%! breaks = [0:5, 2*pi];
%! % Fit a spline of order 5
%! pp = splinefit (x, y, breaks, "order", 4);
%! clf;
%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
%! xlabel ("Independent Variable");
%! ylabel ("Dependent Variable");
%! title ("Fit a piece-wise polynomial of order 4");
%! legend ({"data", "fit", "breaks"});
%! axis tight
%! ylim auto

%!demo
%! % Noisy data
%! x = linspace (0,2*pi, 100);
%! y = sin (x) + 0.1 * randn (size (x));
%! % Breaks
%! breaks = [0:5, 2*pi];
%! % Fit a spline of order 3 with periodic boundary conditions
%! pp = splinefit (x, y, breaks, "order", 2, "periodic", true);
%! clf;
%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
%! xlabel ("Independent Variable");
%! ylabel ("Dependent Variable");
%! title ("Fit a periodic piece-wise polynomial of order 2");
%! legend ({"data", "fit", "breaks"});
%! axis tight
%! ylim auto

%!demo
%! % Noisy data
%! x = linspace (0, 2*pi, 100);
%! y = sin (x) + 0.1 * randn (size (x));
%! % Breaks
%! breaks = [0:5, 2*pi];
%! % Constraints: y(0) = 0, y'(0) = 1 and y(3) + y"(3) = 0
%! xc = [0 0 3];
%! yc = [0 1 0];
%! cc = [1 0 1; 0 1 0; 0 0 1];
%! con = struct ("xc", xc, "yc", yc, "cc", cc);
%! % Fit a cubic spline with 8 pieces and constraints
%! pp = splinefit (x, y, 8, "constraints", con);
%! clf;
%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
%! xlabel ("Independent Variable");
%! ylabel ("Dependent Variable");
%! title ("Fit a cubic spline with constraints");
%! legend ({"data", "fit", "breaks"});
%! axis tight
%! ylim auto

%!demo
%! % Noisy data
%! x = linspace (0, 2*pi, 100);
%! y = sin (x) + 0.1 * randn (size (x));
%! % Breaks
%! breaks = [0:5, 2*pi];
%! xc = [0 0 3];
%! yc = [0 1 0];
%! cc = [1 0 1; 0 1 0; 0 0 1];
%! con = struct ("xc", xc, "yc", yc, "cc", cc);
%! % Fit a spline of order 6 with constraints and periodicity
%! pp = splinefit (x, y, breaks, "constraints", con, "order", 5, "periodic", true);
%! clf;
%! plot (x, y, "s", x, ppval (pp, x), "r", breaks, ppval (pp, breaks), "+r");
%! xlabel ("Independent Variable");
%! ylabel ("Dependent Variable");
%! title ("Fit a 5th order piece-wise periodic polynomial with constraints");
%! legend ({"data", "fit", "breaks"});
%! axis tight
%! ylim auto

%!shared xb, yb, x
%! xb = 0:2:10;
%! yb = 2*rand (size (xb)) - 1;
%! x = 0:0.1:10;

%!test
%! y = interp1 (xb, yb, x, "linear");
%! assert (ppval (splinefit (x, y, xb, "order", 1), x), y, 20 * eps ());
%!test
%! y = interp1 (xb, yb, x, "spline");
%! assert (ppval (splinefit (x, y, xb, "order", 3), x), y, 20 * eps ());
%!test
%! y = interp1 (xb, yb, x, "spline");
%! assert (ppval (splinefit (x, y, xb), x), y, 20 * eps ());
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{x}, @var{p}, @var{n}, @var{k}, @var{d}] =} unmkpp (@var{pp})
##
## Extract the components of a piecewise polynomial structure @var{pp}.
##
## This function is the inverse of @code{mkpp}: it extracts the inputs to
## @code{mkpp} needed to create the piecewise polynomial structure @var{pp}.
## The code below makes this relation explicit:
##
## @example
## @group
## [breaks, coefs, numinter, order, dim] = unmkpp (pp);
## pp2  = mkpp (breaks, coefs, dim);
## @end group
## @end example
##
## The piecewise polynomial structure @code{pp2} obtained in this way, is
## identical to the original @code{pp}.  The same can be obtained by directly
## accessing the fields of the structure @code{pp}.
##
## The components are:
##
## @table @asis
## @item @var{x}
## Sample points or breaks.
##
## @item @var{p}
## Polynomial coefficients for points in sample interval.
## @code{@var{p}(@var{i}, :)} contains the coefficients for the polynomial
## over interval @var{i} ordered from highest to lowest degree.
## If @code{@var{d} > 1}, then @var{p} is a matrix of size
## @code{[@var{n}*prod(@var{d}) @var{m}]}, where the
## @code{@var{i} + (1:@var{d})} rows are the coefficients of all the @var{d}
## polynomials in the interval @var{i}.
##
## @item @var{n}
## Number of polynomial pieces or intervals,
## @code{@var{n} = length (@var{x}) - 1}.
##
## @item @var{k}
## Order of the polynomial plus 1.
##
## @item @var{d}
## Number of polynomials defined for each interval.
## @end table
##
## @seealso{mkpp, ppval, spline, pchip}
## @end deftypefn

function [x, P, n, k, d] = unmkpp (pp)

  if (nargin < 1)
    print_usage ();
  endif
  if (! (isstruct (pp) && isfield (pp, "form") && strcmp (pp.form, "pp")))
    error ("unmkpp: PP must be a piecewise polynomial structure");
  endif
  x = pp.breaks;
  P = pp.coefs;
  n = pp.pieces;
  k = pp.order;
  d = pp.dim;

endfunction


%!test
%! b = 1:3;
%! c = 1:24;
%! pp = mkpp (b,c);
%! [x, P, n, k, d] = unmkpp (pp);
%! assert (x, b);
%! assert (P, reshape (c, [2 12]));
%! assert (n, 2);
%! assert (k, 12);
%! assert (d, 1);

## Test input validation
%!error <Invalid call> unmkpp ()
%!error <piecewise polynomial structure> unmkpp (1)
%!error <piecewise polynomial structure> unmkpp (struct ("field1", "pp"))
%!error <piecewise polynomial structure> unmkpp (struct ("form", "not_a_pp"))
encoding=utf-8
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} intersect (@var{a}, @var{b})
## @deftypefnx {} {@var{c} =} intersect (@var{a}, @var{b}, "rows")
## @deftypefnx {} {@var{c} =} intersect (@dots{}, "sorted")
## @deftypefnx {} {@var{c} =} intersect (@dots{}, "stable")
## @deftypefnx {} {@var{c} =} intersect (@dots{}, "legacy")
## @deftypefnx {} {[@var{c}, @var{ia}, @var{ib}] =} intersect (@dots{})
##
## Return the unique elements common to both @var{a} and @var{b}.
##
## If @var{a} and @var{b} are both row vectors then return a row vector;
## Otherwise, return a column vector.  The inputs may also be cell arrays of
## strings.
##
## If the optional input @qcode{"rows"} is given then return the common rows of
## @var{a} and @var{b}.  The inputs must be 2-D numeric matrices to use this
## option.
##
## The optional argument @qcode{"sorted"}/@qcode{"stable"} controls the order
## in which unique values appear in the output.  The default is
## @qcode{"sorted"} and values in the output are placed in ascending order.
## The alternative @qcode{"stable"} preserves the order found in the input.
##
## If requested, return column index vectors @var{ia} and @var{ib} such that
## @code{@var{c} = @var{a}(@var{ia})} and @code{@var{c} = @var{b}(@var{ib})}.
##
## Programming Note: The input flag @qcode{"legacy"} changes the algorithm
## to be compatible with @sc{matlab} releases prior to R2012b.
##
## @seealso{unique, union, setdiff, setxor, ismember}
## @end deftypefn

function [c, ia, ib] = intersect (a, b, varargin)

  if (nargin < 2 || nargin > 4)
    print_usage ();
  endif

  [a, b] = validsetargs ("intersect", a, b, varargin{:});

  ## Special case of empty matrices
  if (isempty (a) || isempty (b))
    ## Lots of type checking required for Matlab compatibility.
    if (isnumeric (a) && isnumeric (b))
      c = [];
    elseif (iscell (b))
      c = {};
    else
      c = "";
    endif
    ia = ib = [];
    return;
  endif

  by_rows = any (strcmp ("rows", varargin));
  optsorted = ! any (strcmp ("stable", varargin));
  optlegacy = any (strcmp ("legacy", varargin));

  if (optlegacy)
    isrowvec = ! iscolumn (a) || ! iscolumn (b);
  else
    isrowvec = isrow (a) && isrow (b);
  endif

  ## Form A and B into sets
  if (nargout > 1 || ! optsorted)
    [a, ia] = unique (a, varargin{:});
    ia = ia(:);
    [b, ib] = unique (b, varargin{:});
    ib = ib(:);
  else
    a = unique (a, varargin{:});
    b = unique (b, varargin{:});
  endif

  if (by_rows)
    c = [a; b];
    if (nargout > 1 || ! optsorted)
      [c, ic] = sortrows (c);
    else
      c = sortrows (c);
    endif
    match = find (all (c(1:end-1,:) == c(2:end,:), 2));
    if (optsorted)
      c = c(match, :);
    else
      c = [a; b];
      ## FIXME: Is there a way to avoid a call to sort?
      c = c(sort (ic(match)), :);
    endif
    len_a = rows (a);
  else
    c = [a(:); b(:)];
    if (nargout > 1 || ! optsorted)
      [c, ic] = sort (c);
    else
      c = sort (c);
    endif
    if (iscellstr (c))
      match = find (strcmp (c(1:end-1), c(2:end)));
    else
      match = find (c(1:end-1) == c(2:end));
    endif
    len_a = length (a);
    if (optsorted)
      c = c(match);
    else
      c = [a(:); b(:)];
      ## FIXME: Is there a way to avoid a call to sort?
      c = c(sort (ic(match)));
    endif

    ## Adjust output orientation for Matlab compatibility
    if (isrowvec)
      c = c.';
    endif
  endif

  if (nargout > 1)
    ia = ia(ic(match));            # a(ia) == c
    ib = ib(ic(match+1) - len_a);  # b(ib) == c
    if (! optsorted)
      ## FIXME: Is there a way to avoid a call to sort?
      ia = sort (ia);
      [~, idx] = min (ib);
      ib = [ib(idx:end); ib(1:idx-1)];
    endif
    if (optlegacy && isrowvec && ! by_rows)
      ia = ia.';
      ib = ib.';
    endif
  endif

endfunction


%!assert (intersect ([1 2 3 4], [9 8 4 2]), [2, 4])
%!assert (intersect ([1 2; 2 3; 4 5], [2 3; 3 4; 5 6], "rows"), [2 3])
%!assert (intersect ([1 NaN], [NaN NaN 5]), zeros (1,0))

%!test
%! a = [1 1 1 2 2 2];
%! b = [1 2 3 4 5 6];
%! c = intersect (a, b);
%! assert (c, [1,2]);

## Test multi-dimensional arrays
%!test
%! a = rand (3,3,3);
%! b = a;
%! b(1,1,1) = 2;
%! assert (intersect (a, b), sort (a(2:end)'));

## Test the routine for index vectors ia and ib
%!test
%! a = [3 2 4 5 7 6 5 1 0 13 13];
%! b = [3 5 12 1 1 7];
%! [c, ia, ib] = intersect (a, b);
%! assert (c, [1, 3, 5, 7]);
%! assert (ia, [8; 1; 4; 5]);
%! assert (ib, [4; 1; 2; 6]);
%! assert (a(ia), c);
%! assert (b(ib), c);

## Test "rows" argument
%!test
%! a = [1,1,2;1,4,5;2,1,7];
%! b = [1,4,5;2,3,4;1,1,2;9,8,7];
%! [c,ia,ib] = intersect (a, b, "rows");
%! assert (c, [1,1,2;1,4,5]);
%! assert (ia, [1;2]);
%! assert (ib, [3;1]);
%! assert (a(ia,:), c);
%! assert (b(ib,:), c);

%!test
%! a = [1 2 3 4; 5 6 7 8; 9 10 11 12];
%! [b, ia, ib] = intersect (a, a, "rows");
%! assert (b, a);
%! assert (ia, [1:3]');
%! assert (ib, [1:3]');

## Test "stable" argument
%!test
%! a = [2 2 2 1 1 1];
%! b = [1 2 3 4 5 6];
%! c = intersect (a, b, "stable");
%! assert (c, [2,1]);

%!test
%! a = [3 2 4 5 7 6 5 1 0 13 13];
%! b = [3 5 12 1 1 7];
%! [c, ia, ib] = intersect (a, b, "stable");
%! assert (c, [3, 5, 7, 1]);
%! assert (ia, [1; 4; 5; 8]);
%! assert (ib, [1; 2; 6; 4]);
%! assert (a(ia), c);
%! assert (b(ib), c);

%!test
%! a = [1,4,5;1,1,2;2,1,7];
%! b = [1,4,5;2,3,4;1,1,2;9,8,7];
%! [c, ia, ib] = intersect (a, b, "rows", "stable");
%! assert (c, [1,4,5; 1,1,2]);
%! assert (ia, [1;2]);
%! assert (ib, [1;3]);
%! assert (a(ia,:), c);
%! assert (b(ib,:), c);

%!test
%! a = [1 2 3 4; 5 6 7 8; 9 10 11 12];
%! [b, ia, ib] = intersect (a, a, "rows", "stable");
%! assert (b, a);
%! assert (ia, [1:3]');
%! assert (ib, [1:3]');

## Test "legacy" argument
%!test
%! a = [7 1 7 7 4];
%! b = [7 0 4 4 0];
%! [c, ia, ib] = intersect (a, b);
%! assert (c, [4, 7]);
%! assert (ia, [5; 1]);
%! assert (ib, [3; 1]);
%! [c, ia, ib] = intersect (a, b, "legacy");
%! assert (c, [4, 7]);
%! assert (ia, [5, 4]);
%! assert (ib, [4, 1]);

%!test  # "legacy" + "rows"
%! A = [ 1 2; 3 4; 5 6; 3 4; 7 8 ];
%! B = [ 3 4; 7 8; 9 10 ];
%! [c, ia, ib] = intersect (A, B, "rows");
%! assert (c, [3, 4; 7, 8]);
%! assert (ia, [2; 5]);
%! assert (ib, [1; 2]);
%! [c, ia, ib] = intersect (A, B, "rows", "legacy");
%! assert (c, [3, 4; 7, 8]);
%! assert (ia, [4; 5]);
%! assert (ib, [1; 2]);

## Test orientation of output
%!shared a,b
%! a = 1:4;
%! b = 2:5;

%!assert (size (intersect (a, b)), [1, 3])
%!assert (size (intersect (a', b)), [3, 1])
%!assert (size (intersect (a, b')), [3, 1])
%!assert (size (intersect (a', b')), [3, 1])
%!assert (size (intersect (a, b, "legacy")), [1, 3])
%!assert (size (intersect (a', b, "legacy")), [1, 3])
%!assert (size (intersect (a, b', "legacy")), [1, 3])
%!assert (size (intersect (a', b', "legacy")), [3, 1])

## Test return type of empty intersections
%!assert (intersect (['a', 'b'], {}), {})
%!assert (intersect ([], {'a', 'b'}), {})
%!assert (intersect ([], {}), {})
%!assert (intersect ({'a', 'b'}, []), {})
%!assert (intersect ([], ['a', 'b']), "")
%!assert (intersect ({}, []), {})
%!assert (intersect (['a', 'b'], []), "")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{tf} =} ismember (@var{a}, @var{s})
## @deftypefnx {} {@var{tf} =} ismember (@var{a}, @var{s}, "rows")
## @deftypefnx {} {[@var{tf}, @var{s_idx}] =} ismember (@dots{})
##
## Return a logical matrix @var{tf} with the same shape as @var{a} which is
## true (1) if the element in @var{a} is found in @var{s} and false (0) if it
## is not.
##
## If a second output argument is requested then the index into @var{s} of each
## matching element is also returned.
##
## @example
## @group
## a = [3, 10, 1];
## s = [0:9];
## [tf, s_idx] = ismember (a, s)
##      @result{} tf = [1, 0, 1]
##      @result{} s_idx = [4, 0, 2]
## @end group
## @end example
##
## The inputs @var{a} and @var{s} may also be cell arrays.
##
## @example
## @group
## a = @{"abc"@};
## s = @{"abc", "def"@};
## [tf, s_idx] = ismember (a, s)
##      @result{} tf = 1
##      @result{} s_idx = 1
## @end group
## @end example
##
## If the optional third argument @qcode{"rows"} is given then compare rows
## in @var{a} with rows in @var{s}.  The inputs must be 2-D matrices with the
## same number of columns to use this option.
##
## @example
## @group
## a = [1:3; 5:7; 4:6];
## s = [0:2; 1:3; 2:4; 3:5; 4:6];
## [tf, s_idx] = ismember (a, s, "rows")
##      @result{} tf = logical ([1; 0; 1])
##      @result{} s_idx = [2; 0; 5];
## @end group
## @end example
##
## @seealso{lookup, unique, union, intersect, setdiff, setxor}
## @end deftypefn

function [tf, s_idx] = ismember (a, s, varargin)

  if (nargin < 2 || nargin > 3)
    print_usage ();
  endif

  ## lookup() uses absolute values for complex input so we handle the
  ## real and imaginary parts separately (bug #52437)
  if (iscomplex (a) || iscomplex (s))
    real_argout = cell (nargout, 1);
    imag_argout = cell (nargout, 1);
    [real_argout{:}] = ismember (real (a), real (s), varargin{:});
    [imag_argout{:}] = ismember (imag (a), imag (s), varargin{:});
    tf = real_argout{1} & imag_argout{1};
    if (isargout (2))
      s_idx = zeros (size (real_argout{2}));
      s_idx(tf) = min (real_argout{2}(tf), imag_argout{2}(tf));
    endif
    return;
  endif

  ## lookup() does not handle logical values
  if (islogical (a))
    a = uint8 (a);
  endif
  if (islogical (s))
    s = uint8 (s);
  endif

  ## Matlab-compatible behavior (R2016b).  See bug #51187.
  if (ischar (a) && rows (a) == 1 && iscell (s))
    a = {a};
  endif

  ## Another Matlab-compatible behavior.  See bug #53924.
  if (isnumeric (a) && ischar (s))
    s = double (s);
  elseif (ischar (a) && isnumeric (s))
    a = double (a);
  endif

  if (any (strcmp ("stable", varargin)) || any (strcmp ("sorted", varargin)))
    error ('ismember: "stable" or "sorted" are not valid options');
  endif
  [a, s] = validsetargs ("ismember", a, s, varargin{:});

  by_rows = any (strcmp ("rows", varargin));
  ## FIXME: uncomment if bug #56692 is addressed.
  ##optlegacy = any (strcmp ("legacy", varargin));

  if (! by_rows)
    s = s(:);
    ## Check sort status, because we expect the array will often be sorted.
    if (issorted (s))
      is = [];
    else
      [s, is] = sort (s);
    endif

    ## Remove NaNs from table because lookup can't handle them
    if (isreal (s) && ! isempty (s) && isnan (s(end)))
      s = s(1:(end - sum (isnan (s))));
    endif

    if (nargout > 1)
      s_idx = lookup (s, a, "m");
      tf = logical (s_idx);
      if (! isempty (is))
        s_idx(tf) = is(s_idx(tf));
      endif
    else
      tf = lookup (s, a, "b");
    endif

  else  # "rows" argument
    if (isempty (a) || isempty (s))
      tf = false (rows (a), 1);
      s_idx = zeros (rows (a), 1);
    else
      if (rows (s) == 1)
        tf = all (bsxfun (@eq, a, s), 2);
        s_idx = double (tf);
      else
        ## FIXME: lookup does not support "rows", so we just use unique.
        [~, ii, jj] = unique ([a; s], "rows", "last");
        na = rows (a);
        jj = ii(jj(1:na));
        tf = jj > na;

        if (nargout > 1)
          s_idx = max (0, jj - na);
        endif
      endif
    endif
  endif

endfunction


%!assert (ismember ({""}, {"abc", "def"}), false)
%!assert (ismember ("abc", {"abc", "def"}), true)
%!assert (isempty (ismember ([], [1, 2])), true)
%!assert (isempty (ismember ({}, {'a', 'b'})), true)
%!assert (isempty (ismember ([], 'a')), true)
%!assert (ismember ("", {"abc", "def"}), false)
%!assert (ismember (1, 'abc'), false)
%!assert (ismember ("abc", 1), [false false false])
%!assert (ismember ("abc", 99), [false false true])
%!fail ("ismember ([], {1, 2})")
%!fail ("ismember ({[]}, {1, 2})")
%!fail ("ismember ({}, {1, 2})")
%!fail ("ismember ({1}, {'1', '2'})")
%!fail ("ismember ({'1'}, {'1' '2'},'rows')")
%!fail ("ismember ([1 2 3], [5 4 3 1], 'rows')")
%!assert (ismember ({"foo", "bar"}, {"foobar"}), [false false])
%!assert (ismember ({"foo"}, {"foobar"}), false)
%!assert (ismember ({"bar"}, {"foobar"}), false)
%!assert (ismember ({"bar"}, {"foobar", "bar"}), true)
%!assert (ismember ({"foo", "bar"}, {"foobar", "bar"}), [false true])
%!assert (ismember ({"xfb", "f", "b"}, {"fb", "b"}), [false false true])
%!assert (ismember ("1", "0123456789."), true)

%!test
%! [result, s_idx] = ismember ([1, 2], []);
%! assert (result, [false false]);
%! assert (s_idx, [0, 0]);

%!test
%! [result, s_idx] = ismember ([], [1, 2]);
%! assert (result, logical ([]));
%! assert (s_idx, []);

%!test
%! [result, s_idx] = ismember ({"a", "b"}, "");
%! assert (result, [false false]);
%! assert (s_idx, [0, 0]);

%!test
%! [result, s_idx] = ismember ({"a", "b"}, {});
%! assert (result, [false false]);
%! assert (s_idx, [0, 0]);

%!test
%! [result, s_idx] = ismember ("", {"a", "b"});
%! assert (result, false);
%! assert (s_idx, 0);

%!test
%! [result, s_idx] = ismember ({}, {"a", "b"});
%! assert (result, logical ([]));
%! assert (s_idx, []);

%!test
%! [result, s_idx] = ismember ([1 2 3 4 5], [3]);
%! assert (result, logical ([0 0 1 0 0]));
%! assert (s_idx , [0 0 1 0 0]);

%!test
%! [result, s_idx] = ismember ([1 6], [1 2 3 4 5 1 6 1]);
%! assert (result, [true true]);
%! assert (s_idx(2), 7);

%!test
%! [result, s_idx] = ismember ([3,10,1], [0,1,2,3,4,5,6,7,8,9]);
%! assert (result, [true false true]);
%! assert (s_idx, [4, 0, 2]);

%!test
%! [result, s_idx] = ismember ("1.1", "0123456789.1");
%! assert (result, [true true true]);
%! assert (s_idx, [12, 11, 12]);

%!test
%! [result, s_idx] = ismember ([1:3; 5:7; 4:6], [0:2; 1:3; 2:4; 3:5; 4:6], "rows");
%! assert (result, [true; false; true]);
%! assert (s_idx, [2; 0; 5]);

%!test
%! [result, s_idx] = ismember ([1.1,1.2,1.3; 2.1,2.2,2.3; 10,11,12], [1.1,1.2,1.3; 10,11,12; 2.12,2.22,2.32], "rows");
%! assert (result, [true; false; true]);
%! assert (s_idx, [1; 0; 2]);

%!test
%! [result, s_idx] = ismember ([1:3; 5:7; 4:6; 0:2; 1:3; 2:4], [1:3], "rows");
%! assert (result, logical ([1 0 0 0 1 0]'));
%! assert (s_idx, [1 0 0 0 1 0]');

%!test <*51187>
%! assert (ismember ('b ', {'a ', 'b '}), true);

%!test <*51187>
%! abc = ['a '; 'b '; 'c '];
%! assert (ismember (abc, {abc}), [false; false; false]);

%!test <*52437>
%! [tf, s_idx] = ismember ([5, 4-3j, 3+4j], [5, 4-3j, 3+4j]);
%! assert (tf, logical ([1, 1, 1]));
%! assert (s_idx, [1, 2, 3]);
%!
%! [tf, s_idx] = ismember ([5, 4-3j, 3+4j], 5);
%! assert (tf, logical ([1, 0, 0]));
%! assert (s_idx, [1, 0, 0]);
%!
%! [tf, s_idx] = ismember ([5, 5, 5], 4-3j);
%! assert (tf, logical ([0, 0, 0]));
%! assert (s_idx, [0, 0, 0]);
%!
%! [tf, s_idx] = ismember ([5, 4-3j, 3+4j; 5i, 6, 6i], [5, 6]);
%! assert (tf, logical ([1, 0, 0; 0, 1, 0]));
%! assert (s_idx, [1, 0, 0; 0, 2, 0]);
%!
%! [tf, s_idx] = ismember ([5, 4-3j, 3+4j; 5, 4-3j, 3+4j], [5, 5, 5], "rows");
%! assert (tf, logical ([0; 0]));
%! assert (s_idx, [0; 0]);
%!
%! [tf, s_idx] = ismember ([5, 5, 5], [5, 4-3j, 3+4j; 5, 5, 5], "rows");
%! assert (tf, true);
%! assert (s_idx, 2);
%!
%! tf = ismember ([5, 4-3j, 3+4j], 5);
%! assert (tf, logical ([1, 0, 0]));
%! [~, s_idx] = ismember ([5, 4-3j, 3+4j], 5);
%! assert (s_idx, [1, 0, 0]);
%!
%! [tf, s_idx] = ismember (-1-1j, [-1-1j, -1+3j, -1+1j]);
%! assert (tf, true);
%! assert (s_idx, 1);

## Test input validation
%!error <Invalid call> ismember ()
%!error <Invalid call> ismember (1)
%!error <Invalid call> ismember (1,2,3,4)
%!error <"stable" or "sorted" are not valid options> ismember (1,2, "sorted")
%!error <"stable" or "sorted" are not valid options> ismember (1,2, "stable")
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} powerset (@var{a})
## @deftypefnx {} {} powerset (@var{a}, "rows")
## Compute the powerset (all subsets) of the set @var{a}.
##
## The set @var{a} must be a numerical matrix or a cell array of strings.  The
## output will always be a cell array of either vectors or strings.
##
## With the optional argument @qcode{"rows"}, each row of the set @var{a} is
## considered one element of the set.  The input must be a 2-D numeric matrix
## to use this argument.
##
## @seealso{unique, union, intersect, setdiff, setxor, ismember}
## @end deftypefn

function p = powerset (a, byrows_arg)

  if (nargin < 1)
    print_usage ();
  endif

  byrows = false;
  if (nargin == 2)
    if (! strcmpi (byrows_arg, "rows"))
      error ('powerset: optional second argument must be "rows"');
    elseif (iscell (a))
      error ('powerset: "rows" not valid for cell arrays');
    else
      byrows = true;
    endif
  endif

  if (iscell (a) && ! iscellstr (a))
    error ("powerset: cell arrays can only be used for character strings");
  endif

  if (byrows)
    a = unique (a, "rows");
    n = rows (a);
  else
    a = unique (a);
    n = numel (a);
  endif

  if (n == 0)
    p = {};
  else
    if (n > 32)
      error ("powerset: not implemented for more than 32 elements");
    endif

    ## Logical rep
    m = uint32 (0:2^n-1);
    ## FIXME: better test for endianness?
    if (bitunpack (uint16 (1))(1) == 0)
      m = swapbytes (m);
    endif
    b = reshape (bitunpack (m), 32, 2^n)(1:n,:);
    ## Convert to indices and lengths.
    [i, k] = find (b);
    k = sum (b, 1);

    ## Index and split.
    if (byrows)
      p = mat2cell (a(i,:), k, columns (a));
    else
      if (rows (a) == 1)
        p = mat2cell (a(i), 1, k);
      else
        p = mat2cell (a(i), k, 1);
      endif
    endif
  endif

endfunction


%!test
%! c = sort (cellstr ({[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]}));
%! p = sort (cellstr (powerset ([1, 2, 3])));
%! assert (p, c);

%!test
%! c = sort (cellstr ({ [], [1:3], [2:4], [3:5], [1:3; 2:4], [1:3; 3:5], [2:4; 3:5], [1:3; 2:4; 3:5]}));
%! p = sort (cellstr (powerset ([1:3;2:4;3:5], "rows")));
%! assert (p,c);

%!assert (powerset([]), {});  # always return a cell array

## Test input validation
%!error <Invalid call> powerset ()
%!error <second argument must be "rows"> powerset (1, "cols")
%!error <"rows" not valid for cell arrays> powerset ({1}, "rows")
%!error <cell arrays can only be used for character> powerset ({1})
%!error <not implemented for more than 32 elements> powerset (1:33)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## Validate arguments for binary set operation.

function [x, y] = validsetargs (caller, x, y, varargin)

  isallowedarraytype = @(x) isnumeric (x) || ischar (x) || islogical (x);

  if (nargin == 3)
    icx = iscellstr (x);
    icy = iscellstr (y);
    if (icx || icy)
      if (icx && ischar (y))
        y = cellstr (y);
      elseif (icy && ischar (x))
        x = cellstr (x);
      elseif (icy && isempty (x))
        x = {};
      elseif (icx && isempty (y))
        y = {};
      elseif (! (icx && icy))
        error ("%s: cell array of strings cannot be combined with a nonstring value", caller);
      endif
    elseif (! (isallowedarraytype (x) && isallowedarraytype (y)))
      error ("%s: A and B must be arrays or cell arrays of strings", caller);
    endif
  else
    optlegacy = false;
    optsorted = false;
    optstable = false;

    for arg = varargin
      switch (arg{1})
        case "legacy"
          optlegacy = true;

        case "rows"
          if (iscell (x) || iscell (y))
            error ('%s: cells not supported with "rows" flag', caller);
          elseif (! (isallowedarraytype (x) && isallowedarraytype (y)))
            error ("%s: A and B must be arrays or cell arrays of strings", caller);
          else
            if (ndims (x) > 2 || ndims (y) > 2)
              error ('%s: A and B must be 2-dimensional matrices with "rows" flag', caller);
            elseif (columns (x) != columns (y) && ! (isempty (x) || isempty (y)))
              error ("%s: number of columns in A and B must match", caller);
            endif
          endif

        case "sorted"
          optsorted = true;

        case "stable"
          optstable = true;

        otherwise
          error ("%s: invalid option: %s", caller, arg{1});

      endswitch
    endfor

    if (optsorted + optstable + optlegacy > 1)
      error ('%s: only one of "sorted", "stable", or "legacy" may be specified',
             caller);
    endif

  endif

endfunction


## BIST tests for function are in union.m
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} setdiff (@var{a}, @var{b})
## @deftypefnx {} {@var{c} =} setdiff (@var{a}, @var{b}, "rows")
## @deftypefnx {} {@var{c} =} setdiff (@dots{}, "sorted")
## @deftypefnx {} {@var{c} =} setdiff (@dots{}, "stable")
## @deftypefnx {} {@var{c} =} setdiff (@dots{}, "legacy")
## @deftypefnx {} {[@var{c}, @var{ia}] =} setdiff (@dots{})
## Return the unique elements in @var{a} that are not in @var{b}.
##
## If @var{a} is a row vector return a row vector; Otherwise, return a
## column vector.  The inputs may also be cell arrays of strings.
##
## If the optional input @qcode{"rows"} is given then return the rows in
## @var{a} that are not in @var{b}.  The inputs must be 2-D numeric matrices to
## use this option.
##
## The optional argument @qcode{"sorted"}/@qcode{"stable"} controls the order
## in which unique values appear in the output.  The default is
## @qcode{"sorted"} and values in the output are placed in ascending order.
## The alternative @qcode{"stable"} preserves the order found in the input.
##
## If requested, return the index vector @var{ia} such that
## @code{@var{c} = @var{a}(@var{ia})}.
##
## Programming Note: The input flag @qcode{"legacy"} changes the algorithm
## to be compatible with @sc{matlab} releases prior to R2012b.
##
## @seealso{unique, union, intersect, setxor, ismember}
## @end deftypefn

function [c, ia] = setdiff (a, b, varargin)

  if (nargin < 2 || nargin > 4)
    print_usage ();
  endif

  [a, b] = validsetargs ("setdiff", a, b, varargin{:});

  by_rows = any (strcmp ("rows", varargin));
  optlegacy = any (strcmp ("legacy", varargin));

  if (optlegacy)
    isrowvec = ! iscolumn (a) || ! iscolumn (b);
  else
    isrowvec = isrow (a);
  endif

  if (by_rows)
    if (nargout > 1)
      [c, ia] = unique (a, varargin{:});
    else
      c = unique (a, varargin{:});
    endif
    if (! isempty (c) && ! isempty (b))
      ## Form A and B into combined set.
      b = unique (b, varargin{:});
      [csort, idx] = sortrows ([c; b]);
      ## Eliminate those elements of A that are the same as in B.
      dups = find (all (csort(1:end-1,:) == csort(2:end,:), 2));
      c(idx(dups),:) = [];
      if (nargout > 1)
        ia(idx(dups),:) = [];
      endif
    endif
  else
    if (nargout > 1)
      [c, ia] = unique (a, varargin{:});
    else
      c = unique (a, varargin{:});
    endif
    if (! isempty (c) && ! isempty (b))
      ## Form a and b into combined set.
      b = unique (b);
      [csort, idx] = sort ([c(:); b(:)]);
      ## Eliminate those elements of a that are the same as in b.
      if (iscellstr (csort))
        dups = find (strcmp (csort(1:end-1), csort(2:end)));
      else
        dups = find (csort(1:end-1) == csort(2:end));
      endif
      c(idx(dups)) = [];

      ## Reshape if necessary for Matlab compatibility.
      if (isrowvec)
        c = c(:).';
      else
        c = c(:);
      endif

      if (nargout > 1)
        ia(idx(dups)) = [];
        if (optlegacy && isrowvec)
          ia = ia(:).';
        endif
      endif
    endif
  endif

endfunction


%!assert (setdiff (["bb";"zz";"bb";"zz"], ["bb";"cc";"bb"], "rows"), "zz")
%!assert (setdiff (["b";"z";"b";"z"], ["b";"c";"b"], "rows"), "z")
%!assert (setdiff (["b";"z";"b";"z"], ["b";"c";"b"]), "z")
%!assert (setdiff ([1, 1; 2, 2; 3, 3; 4, 4], [1, 1; 2, 2; 4, 4], "rows"), [3 3])
%!assert (setdiff ([1; 2; 3; 4], [1; 2; 4], "rows"), 3)
%!assert (setdiff ([1, 2; 3, 4], [1, 2; 3, 6], "rows"), [3, 4])
%!assert (setdiff ({"one","two";"three","four"}, {"one","two";"three","six"}),
%!        {"four"})

## Test multi-dimensional input
%!test
%! a = rand (3,3,3);
%! b = a(1);
%! assert (setdiff (a, b), sort (a(2:end)'));

## Test "rows"
%!test
%! a = [7 9 7; 0 0 0; 7 9 7; 5 5 5; 1 4 5];
%! b = [0 0 0; 5 5 5];
%! [c, ia] = setdiff (a, b, "rows");
%! assert (c, [1, 4 ,5; 7, 9 7]);
%! assert (ia, [5; 1]);

%!test
%! a = [7 9 7; 0 0 0; 7 9 7; 5 5 5; 1 4 5];
%! b = [0 0 0; 5 5 5];
%! [c, ia] = setdiff (a, b, "rows", "stable");
%! assert (c, [7, 9 7; 1, 4 ,5]);
%! assert (ia, [1; 5]);

## Test sorting order
%!test
%! a = [5, 1, 4, 1, 3];
%! b = [1; 2; 4];
%! [c, ia] = setdiff (a, b, "sorted");
%! assert (c, [3, 5]);
%! assert (ia, [5; 1]);

%!test
%! a = [5, 1, 4, 1, 3];
%! b = [1; 2; 4];
%! [c, ia] = setdiff (a, b, "stable");
%! assert (c, [5, 3]);
%! assert (ia, [1; 5]);

## Test output orientation compatibility
%!assert <*42577> (setdiff ([1:5], 2), [1,3,4,5])
%!assert <*42577> (setdiff ([1:5]', 2), [1;3;4;5])
%!assert <*42577> (setdiff ([1:5], [2:3]), [1,4,5])
%!assert <*42577> (setdiff ([1:5], [2:3]'), [1,4,5])
%!assert <*42577> (setdiff ([1:5]', [2:3]), [1;4;5])
%!assert <*42577> (setdiff ([1:5]', [2:3]'), [1;4;5])

## Test "legacy" option
%!test
%! a = [3, 6, 2, 1, 5, 1, 1];
%! b = [2, 4, 6];
%! [c, ia] = setdiff (a, b);
%! assert (c, [1, 3, 5]);
%! assert (ia, [4; 1; 5]);
%! [c, ia] = setdiff (a, b, "legacy");
%! assert (c, [1, 3, 5]);
%! assert (ia, [7, 1, 5]);

## "legacy" + "rows" compatibility
%!test
%! a = [7 9 7; 0 0 0; 7 9 7; 5 5 5; 1 4 5];
%! b = [0 0 0; 5 5 5];
%! [c, ia] = setdiff (a, b, "rows");
%! assert (c, [1, 4 ,5; 7, 9 7]);
%! assert (ia, [5; 1]);
%! [c, ia] = setdiff (a, b, "rows", "legacy");
%! assert (c, [1, 4 ,5; 7, 9 7]);
%! assert (ia, [5; 3]);

## Output orientation with "legacy" option
%!assert (size (setdiff ([1:5], [2:3], "legacy")), [1, 3])
%!assert (size (setdiff ([1:5]', [2:3], "legacy")), [1, 3])
%!assert (size (setdiff ([1:5], [2:3]', "legacy")), [1, 3])
%!assert (size (setdiff ([1:5]', [2:3]', "legacy")), [3, 1])
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} setxor (@var{a}, @var{b})
## @deftypefnx {} {@var{c} =} setxor (@var{a}, @var{b}, "rows")
## @deftypefnx {} {@var{c} =} setxor (@dots{}, "sorted")
## @deftypefnx {} {@var{c} =} setxor (@dots{}, "stable")
## @deftypefnx {} {@var{c} =} setxor (@dots{}, "legacy")
## @deftypefnx {} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@dots{})
##
## Return the unique elements exclusive to sets @var{a} or @var{b}.
##
## If @var{a} and @var{b} are both row vectors then return a row vector;
## Otherwise, return a column vector.  The inputs may also be cell arrays of
## strings.
##
## If the optional input @qcode{"rows"} is given then return the rows exclusive
## to sets @var{a} and @var{b}.  The inputs must be 2-D numeric matrices to use
## this option.
##
## The optional argument @qcode{"sorted"}/@qcode{"stable"} controls the order
## in which unique values appear in the output.  The default is
## @qcode{"sorted"} and values in the output are placed in ascending order.
## The alternative @qcode{"stable"} preserves the order found in the input.
##
## The optional outputs @var{ia} and @var{ib} are column index vectors such
## that @code{@var{a}(@var{ia})} and @code{@var{b}(@var{ib})} are disjoint sets
## whose union is @var{c}.
##
## Programming Note: The input flag @qcode{"legacy"} changes the algorithm
## to be compatible with @sc{matlab} releases prior to R2012b.
##
## @seealso{unique, union, intersect, setdiff, ismember}
## @end deftypefn

function [c, ia, ib] = setxor (a, b, varargin)

  if (nargin < 2 || nargin > 4)
    print_usage ();
  endif

  [a, b] = validsetargs ("setxor", a, b, varargin{:});

  by_rows = any (strcmp ("rows", varargin));
  optsorted = ! any (strcmp ("stable", varargin));
  optlegacy = any (strcmp ("legacy", varargin));

  if (optlegacy)
    isrowvec = ! iscolumn (a) || ! iscolumn (b);
  else
    isrowvec = isrow (a) && isrow (b);
  endif

  ## Form A and B into sets.
  if (nargout > 1 || ! optsorted)
    [a, ia] = unique (a, varargin{:});
    [b, ib] = unique (b, varargin{:});
  else
    a = unique (a, varargin{:});
    b = unique (b, varargin{:});
  endif

  if (isempty (a))
    c = b;
  elseif (isempty (b))
    c = a;
  else
    ## Reject duplicates.
    if (by_rows)
      na = rows (a);  nb = rows (b);
      [c, i] = sortrows ([a; b]);
      n = rows (c);
      idx = find (all (c(1:n-1, :) == c(2:n, :), 2));
      if (optsorted)
        if (! isempty (idx))
          c([idx, idx+1],:) = [];
          i([idx, idx+1],:) = [];
        endif
      else
        c = [a; b];
        c(i([idx, idx+1]), :) = [];
        if (nargout > 1)
          i([idx, idx+1]) = [];
          ## FIXME: Is there a way to avoid a call to sort?
          i = sort (i);
        endif
      endif
    else
      na = numel (a);  nb = numel (b);
      [c, i] = sort ([a(:); b(:)]);
      if (iscell (c))
        idx = find (strcmp (c(1:end-1), c(2:end)));
      else
        idx = find (c(1:end-1) == c(2:end));
      endif
      if (optsorted)
        if (! isempty (idx))
          c([idx, idx+1]) = [];
          i([idx, idx+1]) = [];
        endif
      else
        c = [a(:); b(:)];
        c(i([idx, idx+1])) = [];
        if (nargout > 1)
          i([idx, idx+1]) = [];
          ## FIXME: Is there a way to avoid a call to sort?
          i = sort (i);
        endif
      endif

      ## Adjust output orientation for Matlab compatibility
      if (isrowvec)
        c = c.';
      endif
    endif

    if (nargout > 1)
      ia = ia(i(i <= na));
      ib = ib(i(i > na) - na);
      if (optlegacy && isrowvec && ! by_rows)
        ia = ia(:).';
        ib = ib(:).';
      endif
    endif
  endif

endfunction


%!assert (setxor ([3,1,2], [4,3,2]), [1,4])
%!assert (setxor ({'a'}, {'a', 'b'}), {'b'})
%!assert (setxor ([5, NaN, NaN], [NaN, NaN, 5]), [NaN NaN NaN NaN])

%!test
%! a = [3, 1, 4, 1, 5];
%! b = [1; 2; 3; 4];
%! [c, ia, ib] = setxor (a, b);
%! assert (c, [2; 5]);
%! assert (ia, [5]);
%! assert (ib, [2]);

## Test multi-dimensional arrays
%!test
%! a = rand (3,3,3);
%! b = a;
%! b(1,1,1) = 2;
%! assert (intersect (a, b), sort (a(2:end)'));

## Test "rows" input
%!test
%! a = [1 2; 4 5; 1 3];
%! b = [1 1; 1 2; 4 5; 2 10];
%! [c, ia, ib] = setxor (a, b, "rows");
%! assert (c, [1 1; 1 3; 2 10]);
%! assert (ia, [3]);
%! assert (ib, [1; 4]);

## Test "stable" sort order
%!test
%! a = [3, 1, 4, 1, 5];
%! b = [1; 2; 3; 4];
%! [c, ia, ib] = setxor (a, b, "stable");
%! assert (c, [5; 2]);
%! assert (ia, [5]);
%! assert (ib, [2]);

%!test
%! a = [1 2; 4 5; 1 3];
%! b = [1 1; 1 2; 4 5; 2 10];
%! [c, ia, ib] = setxor (a, b, "rows", "stable");
%! assert (c, [1 3; 1 1; 2 10]);
%! assert (ia, [3]);
%! assert (ib, [1; 4]);

## Test various empty matrix inputs
%!assert (setxor (1, []), 1)
%!assert (setxor ([], 1), 1)

%!test
%! [c, ia, ib] = setxor ([3 1], []);
%! assert (c, [1 3]);
%! assert (ia, [2; 1]);
%! assert (ib, []);
%!test
%! [c, ia, ib] = setxor ([], [3 1]);
%! assert (c, [1 3]);
%! assert (ia, []);
%! assert (ib, [2; 1]);

%!test
%! a = [2 1; 4 3];  b = [];
%! [c, ia, ib] = setxor (a, b);
%! assert (c, [1; 2; 3; 4]);
%! assert (ia, [3; 1; 4; 2]);
%! assert (isempty (ib));

%!test
%! a = [];  b = [2 1; 4 3];
%! [c, ia, ib] = setxor (a, b);
%! assert (c, [1; 2; 3; 4]);
%! assert (isempty (ia));
%! assert (ib, [3; 1; 4; 2]);

## Test orientation of output
%!shared x,y
%! x = 1:3;
%! y = 2:5;

%!assert (size (setxor (x, y)), [1 3])
%!assert (size (setxor (x', y)), [3 1])
%!assert (size (setxor (x, y')), [3 1])
%!assert (size (setxor (x', y')), [3 1])
%!assert (size (setxor (x, y, "legacy")), [1, 3])
%!assert (size (setxor (x', y, "legacy")), [1, 3])
%!assert (size (setxor (x, y', "legacy")), [1, 3])
%!assert (size (setxor (x', y', "legacy")), [3, 1])

## Test "legacy" input
%!test
%! a = [5 1 3 3 3];
%! b = [4 1 2 2];
%! [c,ia,ib] = setxor (a,b);
%! assert (c, [2, 3, 4, 5]);
%! assert (ia, [3; 1]);
%! assert (ib, [3; 1]);
%! [c,ia,ib] = setxor (a,b, "legacy");
%! assert (c, [2, 3, 4, 5]);
%! assert (ia, [5, 1]);
%! assert (ib, [4, 1]);

%!test  # "legacy" + "rows"
%! A = [1 2; 3 4; 5 6; 3 4; 7 8];
%! B = [3 4; 7 8; 9 10];
%! [c, ia, ib] = setxor (A, B, "rows");
%! assert (c, [1, 2; 5, 6; 9, 10]);
%! assert (ia, [1; 3]);
%! assert (ib, [3]);
%! [c, ia, ib] = setxor (A, B, "rows", "legacy");
%! assert (c, [1, 2; 5, 6; 9, 10]);
%! assert (ia, [1; 3]);
%! assert (ib, [3]);
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} union (@var{a}, @var{b})
## @deftypefnx {} {@var{c} =} union (@var{a}, @var{b}, "rows")
## @deftypefnx {} {@var{c} =} union (@dots{}, "sorted")
## @deftypefnx {} {@var{c} =} union (@dots{}, "stable")
## @deftypefnx {} {@var{c} =} union (@dots{}, "legacy")
## @deftypefnx {} {[@var{c}, @var{ia}, @var{ib}] =} union (@dots{})
##
## Return the unique elements that are in either @var{a} or @var{b}.
##
## If @var{a} and @var{b} are both row vectors then return a row vector;
## Otherwise, return a column vector.  The inputs may also be cell arrays of
## strings.
##
## If the optional input @qcode{"rows"} is given then return rows that are in
## either @var{a} or @var{b}.  The inputs must be 2-D numeric matrices to use
## this option.
##
## The optional argument @qcode{"sorted"}/@qcode{"stable"} controls the order
## in which unique values appear in the output.  The default is
## @qcode{"sorted"} and values in the output are placed in ascending order.
## The alternative @qcode{"stable"} preserves the order found in the input.
##
## The optional outputs @var{ia} and @var{ib} are column index vectors such
## that @code{@var{a}(@var{ia})} and @code{@var{b}(@var{ib})} are disjoint sets
## whose union is @var{c}.
##
## Programming Note: The input flag @qcode{"legacy"} changes the algorithm
## to be compatible with @sc{matlab} releases prior to R2012b.
##
## @seealso{unique, intersect, setdiff, setxor, ismember}
## @end deftypefn

function [y, ia, ib] = union (a, b, varargin)

  if (nargin < 2 || nargin > 4)
    print_usage ();
  endif

  [a, b] = validsetargs ("union", a, b, varargin{:});

  by_rows = any (strcmp ("rows", varargin));
  optlegacy = any (strcmp ("legacy", varargin));

  if (optlegacy)
    isrowvec = ! iscolumn (a) || ! iscolumn (b);
  else
    isrowvec = isrow (a) && isrow (b);
  endif

  if (by_rows)
    y = [a; b];
  else
    y = [a(:); b(:)];
    ## Adjust output orientation for Matlab compatibility
    if (isrowvec)
      y = y.';
    endif
  endif

  if (nargout <= 1)
    y = unique (y, varargin{:});
  else
    [y, idx] = unique (y, varargin{:});
    if (by_rows)
      na = rows (a);
    else
      na = numel (a);
    endif
    ia = idx(idx <= na);
    ib = idx(idx > na) - na;
  endif

endfunction


%!assert (union ([1, 2, 4], [2, 3, 5]), [1, 2, 3, 4, 5])
%!assert (union ([1; 2; 4], [2, 3, 5]), [1; 2; 3; 4; 5])
%!assert (union ([1; 2; 4], [2; 3; 5]), [1; 2; 3; 4; 5])
%!assert (union ([1, 2, 3], [5; 7; 9]), [1; 2; 3; 5; 7; 9])
%!assert (union ([1 2; 2 3; 4 5], [2 3; 3 4; 5 6], "rows"),
%!        [1 2; 2 3; 3 4; 4 5; 5 6])

## Test multi-dimensional arrays
%!test
%! a = rand (3,3,3);
%! b = a;
%! b(1,1,1) = 2;
%! assert (union (a, b), sort ([a(1:end)'; 2]));

%!test
%! a = [3, 1, 4, 1, 5];
%! b = [1; 2; 3; 4];
%! [y, ia, ib] = union (a, b);
%! assert (y, [1; 2; 3; 4; 5]);
%! assert (y, sort ([a(ia)'; b(ib)']));

## Test "stable" sorting order
%!assert (union ([1, 2, 4], [2, 3, 5], "stable"), [1, 2, 4, 3, 5])
%!assert (union ([1, 2, 4]', [2, 3, 5], "stable"), [1; 2; 4; 3; 5])
%!assert (union ([1, 2, 4], [2, 3, 5]', "stable"), [1; 2; 4; 3; 5])

%!test
%! a = [3, 1, 4, 1, 5];
%! b = [1; 2; 3; 4];
%! [y, ia, ib] = union (a, b, "stable");
%! assert (y, [3; 1; 4; 5; 2]);
%! assert (ia, [1; 2; 3; 5]);
%! assert (ib, [2]);

## Test indexing outputs
%!test
%! a = [1, 4, 2];
%! b = [2, 3, 5];
%! [~, ia, ib] = union (a, b);
%! assert (ia, [1; 3; 2]);
%! assert (ib, [2; 3]);
%! [~, ia, ib] = union (a, b, "stable");
%! assert (ia, [1; 2; 3]);
%! assert (ib, [2; 3]);

%!test
%! a = [1 2; 4 5; 2 3];
%! b = [2 3; 3 4; 5 6];
%! [~, ia, ib] = union (a, b, "rows");
%! assert (ia, [1; 3; 2]);
%! assert ([2; 3]);
%! [~, ia, ib] = union (a, b, "rows", "stable");
%! assert (ia, [1; 2; 3]);
%! assert ([2; 3]);

## Test "legacy" option
%!test
%! a = [5, 7, 1];
%! b = [3, 1, 1];
%! [c, ia, ib] = union (a,b);
%! assert (c, [1, 3, 5, 7]);
%! assert (ia, [3; 1; 2]);
%! assert (ib, [1]);
%! [c, ia, ib] = union (a,b, "legacy");
%! assert (c, [1, 3, 5, 7]);
%! assert (ia, [1, 2]);
%! assert (ib, [3, 1]);

%!test  # "legacy" + "rows"
%! A = [1 2; 3 4; 5 6; 3 4; 7 8];
%! B = [3 4; 7 8; 9 10];
%! [c, ia, ib] = union (A, B, "rows");
%! assert (c, [1, 2; 3, 4; 5, 6; 7, 8; 9, 10]);
%! assert (ia, [1; 2; 3; 5]);
%! assert (ib, [3]);
%! [c, ia, ib] = union (A, B, "rows", "legacy");
%! assert (c, [1, 2; 3, 4; 5, 6; 7, 8; 9, 10]);
%! assert (ia, [1; 3]);
%! assert (ib, [1; 2; 3]);

## Test orientation of output
%!shared x,y
%! x = 1:3;
%! y = 2:5;

%!assert (size (union (x, y)), [1 5])
%!assert (size (union (x', y)), [5 1])
%!assert (size (union (x, y')), [5 1])
%!assert (size (union (x', y')), [5 1])
%!assert (size (union (x, y, "legacy")), [1, 5])
%!assert (size (union (x', y, "legacy")), [1, 5])
%!assert (size (union (x, y', "legacy")), [1, 5])
%!assert (size (union (x', y', "legacy")), [5, 1])

## Clear shared variables
%!shared

## Test empty cell string array unions
%!assert (union ({}, []), cell (0,1))
%!assert (union ([], {}), cell (0,1))
%!assert (union ([], {'a', 'b'}), {'a';'b'})
%!assert (union ({'a', 'b'}, []), {'a';'b'})
%!assert (union (['a', 'b'], {}), {'ab'})
%!assert (union ({}, ['a', 'b']), {'ab'})

## Test common input validation for set routines contained in validsetargs
%!error <cell array of strings cannot be combined> union ({"a"}, 1)
%!error <A and B must be arrays or cell arrays> union (@sin, 1)
%!error <cells not supported with "rows"> union ({"a"}, {"b"}, "rows")
%!error <cells not supported with "rows"> union ({"a"}, {"b"}, "rows","legacy")
%!error <A and B must be arrays or cell arrays> union (@sin, 1, "rows")
%!error <A and B must be arrays or cell arrays> union (@sin,1,"rows","legacy")
%!error <A and B must be 2-dimensional matrices> union (rand (2,2,2), 1, "rows")
%!error <A and B must be 2-dimensional matrices> union (1, rand (2,2,2), "rows")
%!error <A and B must be 2-dimensional matrices>
%! union (rand (2,2,2), 1, "rows", "legacy");
%!error <A and B must be 2-dimensional matrices>
%! union (1, rand (2,2,2), "rows", "legacy");
%!error <number of columns in A and B must match> union ([1 2], 1, "rows")
%!error <number of columns in A and B must match> union (1, [1 2], "rows")
%!error <number of columns in A and B must match>
%! union ([1 2], 1, "rows", "legacy");
%!error <number of columns in A and B must match>
%! union (1, [1 2], "rows", "legacy");
%!error <invalid option: columns> union (1, 2, "columns")
%!error <invalid option: columns> union (1, 2, "legacy", "columns")
%!error <only one of "sorted", "stable", or "legacy" may be specified>
%! union (1, 2, "sorted", "stable");
%!error <only one of "sorted", "stable", or "legacy" may be specified>
%! union (1, 2, "sorted", "legacy");
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} unique (@var{x})
## @deftypefnx {} {} unique (@var{x}, "rows")
## @deftypefnx {} {} unique (@dots{}, "sorted")
## @deftypefnx {} {} unique (@dots{}, "stable")
## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "legacy")
## Return the unique elements of @var{x}.
##
## If the input @var{x} is a column vector then return a column vector;
## Otherwise, return a row vector.  @var{x} may also be a cell array of
## strings.
##
## If the optional argument @qcode{"rows"} is given then return the unique
## rows of @var{x}.  The input must be a 2-D numeric matrix to use this option.
##
## The optional argument @qcode{"sorted"}/@qcode{"stable"} controls the order
## in which unique values appear in the output.  The default is
## @qcode{"sorted"} and values in the output are placed in ascending order.
## The alternative @qcode{"stable"} preserves the order found in the input
## @var{x}.
##
## If requested, return column index vectors @var{i} and @var{j} such that
## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
##
## Additionally, if @var{i} is a requested output then one of the flags
## @qcode{"first"} or @qcode{"last"} may be given.  If @qcode{"last"} is
## specified, return the highest possible indices in @var{i}, otherwise, if
## @qcode{"first"} is specified, return the lowest.  The default is
## @qcode{"first"}.
##
## Example 1 : sort order
##
## @example
## @group
## unique ([3, 1, 1, 2])
## @result{} [1, 2, 3]
## unique ([3, 1, 1, 2], "stable")
## @result{} [3, 1, 2]
## @end group
## @end example
##
## Example 2 : index selection
##
## @example
## @group
## [~, @var{i}] = unique ([3, 1, 1, 2], "first")
## @result{} @var{i} = [2; 4; 1]
## [~, @var{i}] = unique ([3, 1, 1, 2], "last")
## @result{} @var{i} = [3; 4; 1]
## @end group
## @end example
##
## Programming Notes: The input flag @qcode{"legacy"} changes the algorithm
## to be compatible with @sc{matlab} releases prior to R2012b.  Specifically,
## The index ordering flag is changed to @qcode{"last"}, and the shape of the
## outputs @var{i}, @var{j} will follow the shape of the input @var{x} rather
## than always being column vectors.
##
## The third output, @var{j}, has not been implemented yet when the sort
## order is @qcode{"stable"}.
##
## @seealso{union, intersect, setdiff, setxor, ismember}
## @end deftypefn

function [y, i, j] = unique (x, varargin)

  if (nargin < 1)
    print_usage ();
  elseif (! (isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
    error ("unique: X must be an array or cell array of strings");
  endif

  if (nargin > 1)
    ## parse options
    if (! iscellstr (varargin))
      error ("unique: options must be strings");
    endif

    optrows   = any (strcmp ("rows", varargin));
    optfirst  = any (strcmp ("first", varargin));
    optlast   = any (strcmp ("last", varargin));
    optsorted = any (strcmp ("sorted", varargin));
    optstable = any (strcmp ("stable", varargin));
    optlegacy = any (strcmp ("legacy", varargin));
    if (optfirst && optlast)
      error ('unique: cannot specify both "first" and "last"');
    elseif (optsorted && optstable)
      error ('unique: cannot specify both "sorted" and "stable"');
    elseif ((optfirst || optlast) && (optsorted || optstable))
      error ('unique: cannot specify "first"/"last" with "sorted"/"stable"');
    elseif (optlegacy && (optsorted || optstable))
      error ('unique: cannot specify "sorted" or "stable" with "legacy"');
    elseif (optrows + optfirst + optlast + optsorted + optstable + optlegacy
            != nargin-1)
      error ("unique: invalid option");
    endif

    ## Set defaults if not set earlier.
    if (! optfirst && ! optlast)
      optfirst = true;
    endif
    if (! optsorted && ! optstable)
      optsorted = true;
    endif

    if (optrows && iscellstr (x))
      warning ('unique: "rows" is ignored for cell arrays');
      optrows = false;
    endif
  else
    optrows = false;
    optfirst = true;
    optsorted = true;
    optlegacy = false;
  endif

  ## FIXME: The operations
  ##
  ##   match = (y(1:n-1) == y(2:n));
  ##   y(idx) = [];
  ##
  ## are very slow on sparse matrices.  Until they are fixed to be as
  ## fast as for full matrices, operate on the nonzero elements of the
  ## sparse array as long as we are not operating on rows.
  if (issparse (x) && ! optrows && nargout <= 1)
    if (nnz (x) < numel (x))
      y = unique ([0; nonzeros(x)], varargin{:});
    else
      ## Corner case where sparse matrix is actually full
      y = unique (full (x), varargin{:});
    endif
    return;
  endif

  if (optrows)
    n = rows (x);
    isrowvec = false;
  else
    n = numel (x);
    isrowvec = isrow (x);
  endif

  ## Special cases 0 and 1
  if (n == 0)
    y = x;
    if (! optrows && any (size (x)))
      if (iscellstr (x))
        y = cell (0, 1);
      else
        y = zeros (0, 1, class (x));
      endif
    endif
    i = j = [];
    return;
  elseif (n == 1)
    y = x;
    i = j = 1;
    return;
  endif

  ## Calculate y output
  if (optrows)
    if (nargout > 1 || ! optsorted)
      [y, i] = sortrows (x);
      i = i(:);
    else
      y = sortrows (x);
    endif
    match = all (y(1:n-1,:) == y(2:n,:), 2);
    if (optsorted)
      y(match,:) = [];
    else
      y = x;
      y(i([false; match]), :) = [];
    endif
  else
    if (isvector (x))
      y = x;
    else
      y = x(:);
    endif
    if (nargout > 1 || ! optsorted)
      [y, i] = sort (y);
      i = i(:);
    else
      y = sort (y);
    endif
    if (iscellstr (y))
      match = strcmp (y(1:n-1), y(2:n));
    else
      match = (y(1:n-1) == y(2:n));
    endif
    if (optsorted)
      y(match) = [];
    else
      if (isvector (x))
        y = x;
      else
        y = x(:);
      endif
      y(i([false; match(:)])) = [];
    endif
  endif

  ## Calculate j output (3rd output)
  if (isargout (3))
    j = i;  # cheap way to copy dimensions
    j(i) = cumsum ([1; ! match(:)]);
    if (! optsorted)
      warning ("unique: third output J is not yet implemented");
      j = [];
    endif

    if (optlegacy && isrowvec)
      j = j.';
    endif
  endif

  ## Calculate i output (2nd output)
  if (isargout (2))
    if (optsorted)
      idx = find (match);
      if (! optlegacy && optfirst)
        idx += 1;   # in-place is faster than other forms of increment
      endif
      i(idx) = [];
    else
      i([false; match(:)]) = [];
      ## FIXME: Is there a way to avoid a call to sort?
      i = sort (i);
    endif

    if (optlegacy && isrowvec)
      i = i.';
    endif
  endif

endfunction


%!assert (unique ([1 1 2; 1 2 1; 1 1 2]), [1;2])
%!assert (unique ([1 1 2; 1 0 1; 1 1 2],"rows"), [1 0 1; 1 1 2])
%!assert (unique ([]), [])
%!assert (unique ([1]), [1])
%!assert (unique ([1 2]), [1 2])
%!assert (unique ([1;2]), [1;2])
%!assert (unique ([1,NaN,Inf,NaN,Inf]), [1,Inf,NaN,NaN])
%!assert (unique ([1,NaN,Inf,NaN,Inf], "stable"), [1,NaN,Inf,NaN])
%!assert (unique ({"Foo","Bar","Foo"}), {"Bar","Foo"})
%!assert (unique ({"Foo","Bar","Foo"}, "stable"), {"Foo", "Bar"})
%!assert (unique ({"Foo","Bar","FooBar"}'), {"Bar","Foo","FooBar"}')
%!assert (unique (zeros (1,0)), zeros (0,1))
%!assert (unique (zeros (1,0), "rows"), zeros (1,0))
%!assert (unique (cell (1,0)), cell (0,1))
%!assert (unique ({}), {})
%!assert (unique ([1,2,2,3,2,4], "rows"), [1,2,2,3,2,4])
%!assert (unique ([1,2,2,3,2,4]), [1,2,3,4])
%!assert (unique ([1,2,2,3,2,4]', "rows"), [1;2;3;4])
%!assert (unique (sparse ([2,0;2,0])), [0;2])
%!assert (unique (sparse ([1,2;2,3])), [1;2;3])
%!assert (unique ([1,2,2,3,2,4]', "rows"), [1;2;3;4])
%!assert (unique (single ([1,2,2,3,2,4]), "rows"), single ([1,2,2,3,2,4]))
%!assert (unique (single ([1,2,2,3,2,4])), single ([1,2,3,4]))
%!assert (unique (single ([1,2,2,3,2,4]'), "rows"), single ([1;2;3;4]))
%!assert (unique (uint8 ([1,2,2,3,2,4]), "rows"), uint8 ([1,2,2,3,2,4]))
%!assert (unique (uint8 ([1,2,2,3,2,4])), uint8 ([1,2,3,4]))
%!assert (unique (uint8 ([1,2,2,3,2,4]'), "rows"), uint8 ([1;2;3;4]))

## Test options with numeric inputs
%!test
%! [y,i,j] = unique ([1,1,2,3,3,3,4], "sorted");
%! assert (y, [1,2,3,4]);
%! assert (i, [1;3;4;7]);
%! assert (j, [1;1;2;3;3;3;4]);

%!test
%! [y,i,~] = unique ([4,4,2,2,2,3,1], "stable");
%! assert (y, [4,2,3,1]);
%! assert (i, [1;3;6;7]);
%! ##assert (j, []);

%!test
%! [y,i,j] = unique ([1,1,2,3,3,3,4]', "last");
%! assert (y, [1,2,3,4]');
%! assert (i, [2;3;6;7]);
%! assert (j, [1;1;2;3;3;3;4]);

## Test options with cellstr inputs
%!test
%! [y,i,j] = unique ({"z"; "z"; "z"});
%! assert (y, {"z"});
%! assert (i, [1]);
%! assert (j, [1;1;1]);

%!test
%! [y,i,~] = unique ({"B"; "A"; "B"}, "stable");
%! assert (y, {"B"; "A"});
%! assert (i, [1; 2]);

%!test
%! A = [1,2,3; 1,2,3];
%! [y,i,j] = unique (A, "rows");
%! assert (y, [1,2,3]);
%! assert (A(i,:), y);
%! assert (y(j,:), A);

%!test
%! A = [4,5,6; 1,2,3; 4,5,6];
%! [y,i,~] = unique (A, "rows", "stable");
%! assert (y, [4,5,6; 1,2,3]);
%! assert (A(i,:), y);
%! ##assert (y(j,:), A);

## Test "legacy" option
%!test
%! [y,i,j] = unique ([1,1,2,3,3,3,4], "legacy");
%! assert (y, [1,2,3,4]);
%! assert (i, [2,3,6,7]);
%! assert (j, [1,1,2,3,3,3,4]);

%!test
%! A = [7 9 7; 0 0 0; 7 9 7; 5 5 5; 1 4 5];
%! [y,i,j] = unique (A, "rows", "legacy");
%! assert (y, [0 0 0; 1 4 5; 5 5 5; 7 9 7]);
%! assert (i, [2; 5; 4; 3]);
%! assert (j, [4; 1; 4; 3; 2]);

## Test input validation
%!error <Invalid call> unique ()
%!error <X must be an array or cell array of strings> unique ({1})
%!error <options must be strings> unique (1, 2)
%!error <cannot specify both "first" and "last"> unique (1, "first", "last")
%!error <cannot specify both "sorted" and "stable">
%! unique (1, "sorted", "stable");
%!error <cannot specify "first"/"last" with "sorted"/"stable">
%! unique (1, "first", "sorted");
%!error <cannot specify "first"/"last" with "sorted"/"stable">
%! unique (1, "last", "stable");
%!error <cannot specify "sorted" or "stable" with "legacy">
%! unique (1, "sorted", "legacy");
%!error <cannot specify "sorted" or "stable" with "legacy">
%! unique (1, "stable", "legacy");
%!error <invalid option> unique (1, "middle")
%!error <invalid option> unique ({"a", "b", "c"}, "UnknownOption")
%!error <invalid option> unique ({"a", "b", "c"}, "UnknownOption1", "UnknownOption2")
%!error <invalid option> unique ({"a", "b", "c"}, "rows", "UnknownOption2")
%!error <invalid option> unique ({"a", "b", "c"}, "UnknownOption1", "last")
%!warning <"rows" is ignored for cell arrays> unique ({"1"}, "rows");
%!warning <third output J is not yet implemented>
%! [y,i,j] = unique ([2,1], "stable");
%! assert (j, []);
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} uniquetol (@var{A})
## @deftypefnx {} {@var{c} =} uniquetol (@var{A}, @var{tol})
## @deftypefnx {} {@var{c} =} uniquetol (@dots{}, @var{property}, @var{value})
## @deftypefnx {} {[@var{c}, @var{ia}, @var{ic}] =} uniquetol (@dots{})
## Return the unique elements of @var{A} within tolerance @var{tol}.
##
## Two values, @var{x} and @var{y}, are within relative tolerance if
## @code{abs (@var{x} - @var{y}) <= @var{tol} * max (abs (@var{A}(:)))}.
##
## The input @var{A} must be a floating point type (double or single).
##
## If @var{tol} is unspecified, the default tolerance is 1e-12 for double
## precision input or 1e-6 for single precision input.
##
## The function may also be called with the following optional property/value
## pairs.  Property/value pairs must be passed after other input arguments:
##
## @table @asis
## @item @qcode{"ByRows"} (default: @code{false})
## When true, return the unique rows of @var{A}.  @var{A} must be a 2-D array
## to use this option.  For rows, the criteria for uniqueness is changed to
## @code{all (abs (@var{x} - @var{y}) <= @var{tol}*max (abs (@var{A}),[],1))}
## which compares each column component of a row against a column-specific
## tolerance.
##
## @item @qcode{"DataScale"}
## The tolerance test is changed to
## @code{abs (@var{x} - @var{y}) <= @var{tol}*@var{DS}} where @var{DS} is a
## scalar unless the property @qcode{"ByRows"} is true.  In that case, @var{DS}
## can either be a scalar or a vector with a length equal to the number of
## columns in @var{A}.  Using a value of @code{1.0} for @var{DS} will change
## the tolerance from a relative one to an absolute tolerance.  Using a value
## of @code{Inf} will disable testing.
##
## @item @qcode{"OutputAllIndices"} (default: @code{false})
## When true, @var{ia} is a cell array (not a vector) that contains the indices
## for @emph{all} elements in @var{A} that are within tolerance of a value in
## @var{C}.  That is, each cell in @var{ia} corresponds to a single unique
## value in @var{C}, and the values in each cell correspond to locations in
## @var{A}.
## @end table
##
## The output @var{c} is a row vector if the input @var{A} is a row vector.
## For all other cases, a column vector is returned.
##
## The optional output @var{ia} is a column index vector such that
## @code{@var{c} = @var{A}(@var{ia})}.  If the @qcode{"ByRows"} property is
## true, the condition is @code{@var{c} = @var{A}(@var{ia}, :)}.  If the
## @qcode{"OutputAllIndices"} property is true, then the values
## @code{@var{A}(@var{ia}@{@var{i}@})} are all within tolerance of the unique
## value @code{@var{c}(@var{i})}.
##
## The optional output @var{ic} is a column index vector such that
## @code{@var{A} = @var{c}(@var{ic})} when @var{A} is a vector.  When @var{A}
## is a matrix, @code{@var{A}(:) = @var{c}(@var{ic})}.  If the @qcode{"ByRows"}
## property is true then @code{@var{A} = @var{c}(@var{ic},:)}.
##
## Example: small round-off errors require @code{uniquetol}, not @code{unique}
##
## @example
## @group
## x = [1:5];
## ## Inverse_Function (Function (x)) should return exactly x
## y = exp (log (x));
## D = unique ([x, y])
## @result{} [1.0000   2.0000   3.0000   3.0000   4.0000   5.0000   5.0000]
## C = uniquetol ([x, y])
## @result{} [1   2   3   4   5]
## @end group
## @end example
##
## @seealso{unique, union, intersect, setdiff, setxor, ismember}
## @end deftypefn


function [c, ia, ic] = uniquetol (A, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (A))
    c = A;
    ia = [];
    ic = [];
    return;
  endif

  if (! isfloat (A) || iscomplex (A))
    error ("Octave:uniquetol:unsupported-type",
           "uniquetol: A must be a double or single precision non-complex array");
  endif

  if (nargin == 1 || ischar (varargin{1}))
    tol = ifelse (isa (A, "double"), 1e-12, 1e-6);
  elseif (! (isfloat (varargin{1}) && isscalar (varargin{1}))
          || iscomplex (varargin{1}))
    error ("Octave:uniquetol:unsupported-type",
           "uniquetol: TOL must be a double or single precision non-complex scalar");
  else
    tol = varargin{1};
    varargin(1) = [];
  endif

  if (mod (numel (varargin), 2))
    error ("uniquetol: PROPERTY/VALUE arguments must be passed in pairs");
  endif

  by_rows = false;
  output_all_indices = false;
  data_scale = [];

  for k = 1:2:numel (varargin)
    if (! ischar (varargin{k}))
      error ("uniquetol: PROPERTY must be a string");
    endif

    if (strcmpi (varargin{k}, "ByRows"))
      by_rows = logical (varargin{k+1});
      if (by_rows && ndims (A) > 2)
        error ('uniquetol: A must be a 2-D array when "ByRows" is true');
      endif
    elseif (strcmpi (varargin{k}, "OutputAllIndices"))
      output_all_indices = logical (varargin{k+1});
    elseif (strcmpi (varargin{k}, "DataScale"))
      data_scale = varargin{k+1}(:).';
      if (! isfloat (data_scale) || iscomplex (data_scale)
          || any (data_scale(:) < 0) || any (isnan (data_scale(:))))
        error ("uniquetol: DataScale must be a non-NaN, positive floating point scalar or vector");
      endif
      cols_data_scale = columns (data_scale);
      if (cols_data_scale != 1 && cols_data_scale != columns (A))
        error ("uniquetol: invalid DataScale size");
      endif
    else
      error ("uniquetol: unknown property '%s'", varargin{k});
    endif
  endfor

  if (isempty (data_scale))
    data_scale = max (abs (A(! isinf (A))(:)));
  endif

  tol *= data_scale;

  if (by_rows)

    nr = rows (A);
    nc = columns (A);
    Iall = zeros (nr, 1);
    I = NaN (nc, 1);
    ia = {};
    J = NaN (nc, 1);
    j = 1;
    ii = 0;

    for i = 1:nr
      if (any (Iall == i))
        continue;
      else
        equ = all (abs (A - A(i,:)) <= tol, 2);
        equ(i,1) = equ(i,1) || any (! isfinite (A(i,:)), 2);
        sumeq = sum (equ);
        ia_tmp = find (equ);
        if (output_all_indices)
          ia{end+1} = ia_tmp;
        endif
        Iall(ii+(1:sumeq)) = ia_tmp;
        I(j) = ia_tmp(1);
        J(equ) = j;
        ii += sumeq;
        j += 1;
      endif
    endfor

    I(isnan (I)) = [];
    J(isnan (J)) = [];
    c = A(I,:);

    if (! output_all_indices)
      ia = I(1:j-1);
    endif
    ic = J;

  else
    isrowvec = isrow (A);
    A = A(:);
    nr = rows (A);
    isnanA = isnan (A);
    anyisnanA = any (isnanA);
    [sortA, sAi] = sort (A);
    diffsortA = diff (sortA);
    isinfsortA = isinf (sortA);
    isnansortA = isnan (sortA);
    numnan = sum (isnansortA);
    if (any (isinfsortA))
      sAnin = sortA(! (isinfsortA | isnansortA));
      diffsortA(isinf (diffsortA)) = abs (sAnin(end) - sAnin(1)) + 10;
    endif
    csdx = cumsum (diffsortA);
    ue = [true; diff([0; csdx-mod(csdx,tol)]) > eps(max(csdx))];
    ueold = NaN;
    while (any (ueold != ue))
      ueold = ue;
      belowtol = [false; diff(sortA(ue)) < tol];
      if (any (belowtol))
        needstomove = find (ue)(belowtol);
        ue(needstomove) = false;
        needstomove(needstomove >= nr-numnan) = [];
        ue(needstomove+1) = true;
      endif
    endwhile
    c = sortA(ue);
    [~, sortsAi] = sort (sAi);
    cumsumue = cumsum (ue);
    ic = cumsumue(sortsAi);
    if (anyisnanA)
      findisnanA = find (isnanA);
    else
      findisnanA = [];
    endif
    if (output_all_indices)
      nu = cumsumue(end);
      ia = cell (1, nu);
      for k = 1:nu
        ia{k} = setdiff (sAi(cumsumue==k), findisnanA);
      endfor
    else
      ia = sAi(ue);
    endif

    if (anyisnanA)
      rowsc1 = rows (c) + (1:sum (isnanA));
      c(rowsc1) = NaN;
      ia(rowsc1) = findisnanA;
      ic(isnanA) = rowsc1;
    endif

    ## FIXME: Matlab-compatible orientation of output
    ## Actually, Matlab prefers row vectors (2021/03/24), but this is different
    ## from all the other set functions which prefer column vectors.  Assume
    ## that this is a bug in Matlab's implementation and prefer column vectors.
    if (isrowvec)
      c = c.';
    endif

  endif

endfunction


%!assert (uniquetol ([1 1 2; 1 2 1; 1 1 2+10*eps]), [1;2])
%!assert (uniquetol ([1 1 2; 1 0 1; 1 1 2+10*eps], "byrows", true),
%!        [1 1 2; 1 0 1])
%!assert (uniquetol ([]), [])
%!assert (uniquetol ([1]), [1])
%!assert (uniquetol ([2, 1]), [1, 2]);
%!assert (uniquetol ([1; 2]), [1; 2])
%!assert (uniquetol ([-Inf, 1, NaN, Inf, NaN, Inf]), [-Inf, 1, Inf, NaN, NaN]);
%!assert (uniquetol (zeros (1, 0)), zeros (1, 0));
%!assert (uniquetol (zeros (1, 0), "byrows", true), zeros (1, 0))
%!assert (uniquetol ([1,2,2,3,2,4], "byrows", true), [1,2,2,3,2,4])
%!assert (uniquetol ([1,2,2,3,2,4]), [1,2,3,4])
%!assert (uniquetol ([1,2,2,3,2,4].', "byrows", true), [1;2;3;4])
%!assert (uniquetol (sparse ([2,0;2,0])), sparse ([0;2]))
%!assert (uniquetol (sparse ([1,2;2,3])), sparse ([1;2;3]))
%!assert (uniquetol (single ([1,2,2,3,2,4]), "byrows", true),
%!        single ([1,2,2,3,2,4]))
%!assert (uniquetol (single ([1,2,2,3,2,4])), single ([1,2,3,4]))
%!assert (uniquetol (single ([1,2,2,3,2,4].'), "byrows", true),
%!        single ([1;2;3;4]))

## Matlab compatibility of output
%!test
%! x = 1:0.045:3;
%! y = uniquetol (x, 0.1, "datascale", 1);
%! assert (y(1:4), [1, 1.135, 1.27, 1.405]);

## Test index vector return arguments
%!test
%! [c, ia, ic] = uniquetol ([1,1,2,3,3,3,4]);
%! assert (c, [1,2,3,4]);
%! assert (ia, [1;3;4;7]);
%! assert (ic, [1;1;2;3;3;3;4]);

## Test index vector return arguments with "ByRows"
%!test
%! A = [2, 3, 4; 2, 3, 4];
%! [c, ia, ic] = uniquetol (A, "byrows", true);
%! assert (c, [2, 3, 4]);
%! assert (A(ia,:), c);
%! assert (c(ic,:), A);

%!test
%! x = (2:7)'*pi;
%! y = exp (log (x));
%! C = uniquetol ([x; y]);
%! assert (C, x, 1e-12);

## Test "ByRows" Property
%!test
%! A = [0.06, 0.21, 0.38; 0.38, 0.21, 0.39; 0.54, 0.56, 0.41; 0.46, 0.52, 0.95];
%! B = log (exp (A));
%! C = uniquetol ([A; B], "ByRows", true);
%! assert (C, A);

## Test "DataScale" Property
%!test
%! x = 10^11;
%! C = uniquetol ([x, exp(log(x))], 1e-6, "DataScale", 1);
%! assert (C, [x, exp(log(x))]);

## Test "OutputAllIndices" Property
%!test
%! A = [.1 .2 .3 10];
%! [C, ia, ic] = uniquetol (A, .1, "OutputAllIndices", true);
%! assert (C, [.1, 10]);
%! assert (ia, {(1:3)', 4});
%! assert (ic, [1; 1; 1; 2]);

## Test input validation
%!error <Invalid call> uniquetol ()
%!error <A must be a double or single precision> uniquetol (int8 (1))
%!error <A must be .* non-complex> uniquetol (1i)
%!error <TOL must be a double .* precision> uniquetol (1, int8 (1))
%!error <TOL must be a .* scalar> uniquetol (1, [1, 2])
%!error <TOL must be .* non-complex> uniquetol (1, 1i)
%!error <arguments must be passed in pairs> uniquetol (1, 2, "byrows")
%!error <PROPERTY must be a string> uniquetol (1, 2, 3, "bar")
%!error <A must be a 2-D array> uniquetol (ones (2,2,2), "byrows", true)
%!error <DataScale must be a .* floating point> uniquetol (1, "DataScale", '1')
%!error <DataScale must be .* positive> uniquetol (1, "DataScale", -1)
%!error <DataScale must be .* positive> uniquetol (1, "DataScale", 1i)
%!error <DataScale must be a non-NaN> uniquetol (1, "DataScale", NaN)
%!error <invalid DataScale size> uniquetol (1, "DataScale", [1 2])
%!error <unknown property 'foo'> uniquetol (1, "foo", "bar")
%!error <unknown property 'foo'> uniquetol (1, 2, "foo", "bar")
encoding=utf-8
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} bicg (@var{A}, @var{b})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, @dots{})
## Solve the linear system of equations @w{@code{@var{A} * @var{x} = @var{b}}}
## by means of the Bi-Conjugate Gradient iterative method.
##
## The input arguments are:
##
## @itemize
##
## @item @var{A} is the matrix of the linear system and it must be square.
## @var{A} can be passed as a matrix, function handle, or inline function
## @code{Afun} such that @w{@code{Afun (x, "notransp") = A * x}} and
## @w{@code{Afun (x, "transp") = A' * x}}.  Additional parameters to
## @code{Afun} may be passed after @var{x0}.
##
## @item @var{b} is the right-hand side vector.  It must be a column vector
## with the same number of rows as @var{A}.
##
## @item
## @var{tol} is the required relative tolerance for the residual error,
## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
## @w{@code{@var{tol} * norm (@var{b})}}}.
## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
##
## @item
## @var{maxit} is the maximum allowed number of iterations; if @var{maxit}
## is omitted or empty then a value of 20 is used.
##
## @item
## @var{M1}, @var{M2} are the preconditioners.  The preconditioner @var{M} is
## given as @code{@var{M} = @var{M1} * @var{M2}}.  Both @var{M1} and @var{M2}
## can be passed as a matrix or as a function handle or inline function
## @code{g} such that @w{@code{g (@var{x}, "notransp") = @var{M1} \ @var{x}}}
## or @w{@code{g (@var{x}, "notransp") = @var{M2} \ @var{x}}} and
## @w{@code{g (@var{x}, "transp") = @var{M1}' \ @var{x}}} or
## @w{@code{g (@var{x}, "transp") = @var{M2}' \ @var{x}}}.
## If @var{M1} is omitted or empty, then preconditioning is not applied.
## The preconditioned system is theoretically equivalent to applying the
## @code{bicg} method to the linear system
## @code{inv (@var{M1}) * A * inv (@var{M2}) * @var{y} = inv
## (@var{M1}) * @var{b}} and
## @code{inv (@var{M2'}) * A' * inv (@var{M1'}) * @var{z} =
## inv (@var{M2'}) * @var{b}} and then setting
## @code{@var{x} = inv (@var{M2}) * @var{y}}.
##
## @item
## @var{x0} is the initial guess.  If @var{x0} is omitted or empty then the
## function sets @var{x0} to a zero vector by default.
## @end itemize
##
## Any arguments which follow @var{x0} are treated as parameters, and passed in
## an appropriate manner to any of the functions (@var{Afun} or @var{Mfun}) or
## that have been given to @code{bicg}.
##
## The output parameters are:
##
## @itemize
##
## @item
## @var{x} is the computed approximation to the solution of
## @w{@code{@var{A} * @var{x} = @var{b}}}.  If the algorithm did not converge,
## then @var{x} is the iteration which has the minimum residual.
##
## @item
## @var{flag} indicates the exit status:
##
## @itemize
## @item 0: The algorithm converged to within the prescribed tolerance.
##
## @item 1: The algorithm did not converge and it reached the maximum number of
## iterations.
##
## @item 2: The preconditioner matrix is singular.
##
## @item 3: The algorithm stagnated, i.e., the absolute value of the
## difference between the current iteration @var{x} and the previous is less
## than @code{eps * norm (@var{x},2)}.
##
## @item 4: The algorithm could not continue because intermediate values
## became too small or too large for reliable computation.
## @end itemize
##
## @item
## @var{relres} is the ratio of the final residual to its initial value,
## measured in the Euclidean norm.
##
## @item
## @var{iter} is the iteration which @var{x} is computed.
##
## @item
## @var{resvec} is a vector containing the residual at each iteration.
## The total number of iterations performed is given by
## @code{length (@var{resvec}) - 1}.
## @end itemize
##
## Consider a trivial problem with a tridiagonal matrix
##
## @example
## @group
## n = 20;
## A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n)) + ...
##     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
##               sparse (1, 2, 1, 1, n) * n / 2);
## b = A * ones (n, 1);
## restart = 5;
## [M1, M2] = ilu (A);  # in this tridiag case, it corresponds to lu (A)
## M = M1 * M2;
## Afun = @@(x, string) strcmp (string, "notransp") * (A * x) + ...
##                      strcmp (string, "transp") * (A' * x);
## Mfun = @@(x, string) strcmp (string, "notransp") * (M \ x) + ...
##                      strcmp (string, "transp") * (M' \ x);
## M1fun = @@(x, string) strcmp (string, "notransp") * (M1 \ x) + ...
##                      strcmp (string, "transp") * (M1' \ x);
## M2fun = @@(x, string) strcmp (string, "notransp") * (M2 \ x) + ...
##                      strcmp (string, "transp") * (M2' \ x);
## @end group
## @end example
##
## @sc{Example 1:} simplest usage of @code{bicg}
##
## @example
## x = bicg (A, b)
## @end example
##
## @sc{Example 2:} @code{bicg} with a function that computes
## @code{@var{A}*@var{x}} and @code{@var{A'}*@var{x}}
##
## @example
## x = bicg (Afun, b, [], n)
## @end example
##
## @sc{Example 3:} @code{bicg} with a preconditioner matrix @var{M}
##
## @example
## x = bicg (A, b, 1e-6, n, M)
## @end example
##
## @sc{Example 4:} @code{bicg} with a function as preconditioner
##
## @example
## x = bicg (Afun, b, 1e-6, n, Mfun)
## @end example
##
## @sc{Example 5:} @code{bicg} with preconditioner matrices @var{M1}
## and @var{M2}
##
## @example
## x = bicg (A, b, 1e-6, n, M1, M2)
## @end example
##
## @sc{Example 6:} @code{bicg} with functions as preconditioners
##
## @example
## x = bicg (Afun, b, 1e-6, n, M1fun, M2fun)
## @end example
##
## @sc{Example 7:} @code{bicg} with as input a function requiring an argument
##
## @example
## @group
## function y = Ap (A, x, string, z)
##   ## compute A^z * x or (A^z)' * x
##   y = x;
##   if (strcmp (string, "notransp"))
##     for i = 1:z
##       y = A * y;
##     endfor
##   elseif (strcmp (string, "transp"))
##     for i = 1:z
##       y = A' * y;
##     endfor
##   endif
## endfunction
##
## Apfun = @@(x, string, p) Ap (A, x, string, p);
## x = bicg (Apfun, b, [], [], [], [], [], 2);
## @end group
## @end example
##
## Reference:
##
## @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
## Second edition, 2003, SIAM.
##
## @seealso{bicgstab, cgs, gmres, pcg, qmr, tfqmr}
## @end deftypefn

function [x_min, flag, relres, iter_min, resvec] = ...
         bicg (A, b, tol = [], maxit = [], M1 = [], M2 = [], x0 = [], varargin)

  [Afun, M1fun, M2fun] =  __alltohandles__ (A, b, M1, M2, "bicg");

  [tol, maxit, x0] = __default__input__ ({1e-06, min(rows(b), 20), ...
                                          zeros(rows (b),1)}, tol, maxit, x0);

  if (columns (b) == 2)
    c = b(:,2);
    b = b(:,1);
  else
    c = b;
  endif
  norm_b = norm (b, 2);

  if (norm_b == 0)  # the only (only iff det (A) == 0) solution is x = 0
    if (nargout < 2)
      printf ("The right hand side vector is all zero so bicg\n")
      printf ("returned an all zero solution without iterating.\n")
    endif
    x_min = zeros (numel (b), 1);
    flag = 0;
    relres = 0;
    iter_min = 0;
    resvec = 0;
    return;
  endif

  x = x_min = x_pr = x0;
  iter = iter_min = 0;
  flag = 1;  # Default flag is "maximum number of iterations reached"
  resvec = zeros (maxit + 1, 1);
  r0 = b - Afun (x, "notransp", varargin{:});  # Residual of the system
  s0 = c - Afun (x, "transp", varargin{:});    # Res. of the "dual system"
  resvec(1) = norm (r0, 2);

  try
    warning ("error", "Octave:singular-matrix", "local");
    prec_r0 = M1fun (r0, "notransp", varargin{:});  # r0 preconditioned
    prec_s0 = s0;
    prec_r0 = M2fun (prec_r0, "notransp", varargin{:});
    prec_s0 = M2fun (prec_s0, "transp", varargin{:});
    prec_s0 = M1fun (prec_s0, "transp", varargin{:});  # s0 preconditioned
    p = prec_r0;  # Direction of the system
    q = prec_s0;  # Direction of the "dual system"
  catch
    flag = 2;
  end_try_catch

  while ((flag != 2) && (iter < maxit) && (resvec(iter+1) >= norm_b * tol))
    v = Afun (p, "notransp", varargin{:});
    prod_qv = q' * v;
    alpha = (s0' * prec_r0);
    if (abs (prod_qv) <= eps * abs (alpha))
      flag = 4;
      break;
    endif
    alpha ./= prod_qv;
    x += alpha * p;
    prod_rs = (s0' * prec_r0);  # Product between r0 and s0
    r0 -= alpha * v;
    s0 -= conj (alpha) * Afun (q, "transp", varargin{:});
    prec_r0 = M1fun (r0, "notransp", varargin{:});
    prec_s0 = s0;
    prec_r0 = M2fun (prec_r0, "notransp", varargin{:});
    beta = s0' * prec_r0;
    if (abs (prod_rs) <= abs (beta))
      flag = 4;
      break;
    endif
    beta ./= prod_rs;
    prec_s0 = M2fun (prec_s0, "transp", varargin{:});
    prec_s0 = M1fun (prec_s0, "transp", varargin{:});
    iter += 1;
    resvec(iter+1) = norm (r0);
    if (resvec(iter+1) <= resvec(iter_min+1))
      x_min = x;
      iter_min = iter;
    endif
    if (norm (x - x_pr) <= norm (x) * eps)
      flag = 3;
      break;
    endif
    p = prec_r0 + beta*p;
    q = prec_s0 + conj (beta) * q;
  endwhile
  resvec = resvec(1:iter+1,1);

  if (flag == 2)
    relres = 1;
  else
    relres = resvec(iter_min+1) / norm_b;
  endif

  if ((flag == 1) && (relres <= tol))
    flag = 0;
  endif

  if (nargout < 2)
    switch (flag)
      case 0
        printf ("bicg converged at iteration %i ", iter_min);
        printf ("to a solution with relative residual %e\n", relres);
      case 1
        printf ("bicg stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the maximum number of iterations was reached. ");
        printf ("The iterate returned (number %i) has ", iter_min);
        printf ("relative residual %e\n", relres);
      case 2
        printf ("bicg stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the preconditioner matrix is singular.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case 3
        printf ("bicg stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method stagnated.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case 4
        printf ("bicg stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method can't continue.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
    endswitch
  endif

endfunction


%!demo
%! ## simplest use case
%! n = 20;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n)) + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!               sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.1 * eye (n));
%! M = M1 * M2;
%! x = bicg (A, b, [], n);
%! function y = Ap (A, x, string, z)
%!   ## compute A^z * x or (A^z)' * x
%!   y = x;
%!   if (strcmp (string, "notransp"))
%!     for i = 1:z
%!       y = A * y;
%!   endfor
%!   elseif (strcmp (string, "transp"))
%!     for i = 1:z
%!       y = A' * y;
%!     endfor
%!   endif
%! endfunction
%!
%! Afun = @(x, string) Ap (A, x, string, 1);
%! x = bicg (Afun, b, [], n);
%! x = bicg (A, b, 1e-6, n, M);
%! x = bicg (A, b, 1e-6, n, M1, M2);
%! function y = Mfun (M, x, string)
%!   if (strcmp (string, "notransp"))
%!     y = M \ x;
%!   else
%!     y = M' \ x;
%!   endif
%! endfunction
%!
%! M1fun = @(x, string) Mfun (M, x, string);
%! x = bicg (Afun, b, 1e-6, n, M1fun);
%! M1fun = @(x, string) Mfun (M1, x, string);
%! M2fun = @(x, string) Mfun (M2, x, string);
%! x = bicg (Afun, b, 1e-6, n, M1fun, M2fun);
%! Afun = @(x, string, p) Ap (A, x, string, p);
%! ## Solution of A^2 * x = b
%! x = bicg (Afun, b, [], 2*n, [], [], [], 2);

%!test
%! ## Check that all type of inputs work
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = A * ones (5, 1);
%! M1 = diag (sqrt (diag (A)));
%! M2 = M1;
%! Afun = @(z, string) strcmp (string, "notransp") * (A * z) + ...
%!                     strcmp (string, "transp") * (A' * z);
%! M1_fun = @(z, string) strcmp (string,"notransp") * (M1 \ z) + ...
%!                         strcmp (string, "transp") * (M1' \ z);
%! M2_fun = @(z, string) strcmp (string, "notransp") * (M2 \ z) + ...
%!                         strcmp (string, "transp") * (M2' \ z);
%! [x, flag] = bicg (A, b);
%! assert (flag, 0);
%! [x, flag] = bicg (A, b, [], [], M1, M2);
%! assert (flag, 0);
%! [x, flag] = bicg (A, b, [], [], M1_fun, M2_fun);
%! assert (flag, 0);
%! [x, flag] = bicg (A, b,[], [], M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = bicg (A, b,[], [], M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = bicg (Afun, b);
%! assert (flag, 0);
%! [x, flag] = bicg (Afun, b,[], [], M1, M2);
%! assert (flag, 0);
%! [x, flag] = bicg (Afun, b,[], [], M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = bicg (Afun, b,[], [], M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = bicg (Afun, b,[], [], M1_fun, M2_fun);
%! assert (flag, 0);

%!test
%! n = 100;
%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! tol = 1e-8;
%! maxit = 15;
%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
%! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!function y = afun (x, t, a)
%!  switch (t)
%!    case "notransp"
%!      y = a * x;
%!    case "transp"
%!      y = a' * x;
%!  endswitch
%!endfunction
%!
%!test
%! n = 100;
%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! tol = 1e-8;
%! maxit = 15;
%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
%!
%! [x, flag, relres, iter, resvec] = bicg (@(x, t) afun (x, t, A),
%!                                         b, tol, maxit, M1, M2);
%! assert (x, ones (size (b)), 1e-7);

%!test
%! n = 100;
%! tol = 1e-8;
%! a = sprand (n, n, .1);
%! A = a' * a + 100 * eye (n);
%! b = sum (A, 2);
%! [x, flag, relres, iter, resvec] = bicg (A, b, tol, [], diag (diag (A)));
%! assert (x, ones (size (b)), 1e-7);

%!test
%! ## Check that if the preconditioner is singular, the method doesn't work
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = ones (5,1);
%! M = ones (5);
%! [x, flag] = bicg (A, b, [], [], M);
%! assert (flag, 2);

%!test
%! ## If A singular, the algorithm doesn't work due to division by zero
%! A = ones (5);
%! b = [1:5]';
%! [x, flag] = bicg (A, b);
%! assert (flag, 4);

%!test
%! ## test for a complex linear system
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]) + ...
%!             1i * toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! [x, flag] = bicg (A, b);
%! assert (flag, 0);

%!test
%! A = single (1);
%! b = 1;
%! [x, flag] = bicg (A, b);
%! assert (class (x), "single");

%!test
%! A = 1;
%! b = single (1);
%! [x, flag] = bicg (A, b);
%! assert (class (x), "single");

%!test
%! A = single (1);
%! b = single (1);
%! [x, flag] = bicg (A, b);
%! assert (class (x), "single");

%!test
%!function y = Afun (x, trans)
%!  A = sparse (toeplitz ([2, 1, 0, 0], [2, -1, 0, 0]));
%!  if (strcmp (trans, "notransp"))
%!     y = A * x;
%!  else
%!     y = A' * x;
%!  endif
%!endfunction
%!
%! [x, flag] = bicg ("Afun", [1; 2; 2; 3]);
%! assert (x, ones (4, 1), 1e-6);

%!test
%! ## unpreconditioned residual
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = magic (5);
%! [x, flag, relres] = bicg (A, b, [], 2, M);
%! assert (norm (b - A * x) / norm (b), 0, relres + eps);

## Preconditioned technique
%!testif HAVE_UMFPACK
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! warning ("off", "Octave:lu:sparse_input", "local");
%! [M1, M2] = lu (A + eye (5));
%! [x, flag] = bicg (A, b, [], 1, M1, M2);
%! ## b has two columns!
%! [y, flag]  = bicg (M1 \ A / M2, [M1 \ b, M2' \ b], [], 1);
%! assert (x, M2 \ y, 8 * eps);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
## @deftypefnx {} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicgstab (@var{A}, @var{b}, @dots{})
## Solve @code{A x = b} using the stabilized Bi-conjugate gradient iterative
## method.
##
## The input parameters are:
##
## @itemize @minus
##
## @item @var{A} is the matrix of the linear system and it must be square.
## @var{A} can be passed as a matrix, function handle, or inline
## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
## parameters to @code{Afun} are passed after @var{x0}.
##
## @item @var{b} is the right hand side vector.  It must be a column vector
## with the same number of rows as @var{A}.
##
## @item
## @var{tol} is the required relative tolerance for the residual error,
## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
## @w{@code{@var{tol} * norm (@var{b})}}}.
## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
##
## @item @var{maxit} the maximum number of outer iterations, if not given or
## set to [] the default value @code{min (20, numel (b))} is used.
##
## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
## @var{M} is given as @code{@var{M} = @var{M1} * @var{M2}}.
## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
## handle or inline function @code{g} such that
## @code{g(@var{x}) = @var{M1} \ @var{x}} or
## @code{g(@var{x}) = @var{M2} \ @var{x}}.
## The technique used is the right preconditioning, i.e., it is
## solved @code{@var{A} * inv (@var{M}) * @var{y} = @var{b}} and then
## @code{@var{x} = inv (@var{M}) * @var{y}}.
##
## @item @var{x0} the initial guess, if not given or set to [] the default
## value @code{zeros (size (@var{b}))} is used.
##
## @end itemize
##
## The arguments which follow @var{x0} are treated as parameters, and passed in
## a proper way to any of the functions (@var{A} or @var{M}) which are passed
## to @code{bicstab}.
##
## The output parameters are:
##
## @itemize @minus
##
## @item @var{x} is the approximation computed.  If the method doesn't
## converge then it is the iterated with the minimum residual.
##
## @item @var{flag} indicates the exit status:
##
## @itemize @minus
## @item 0: iteration converged to the within the chosen tolerance
##
## @item 1: the maximum number of iterations was reached before convergence
##
## @item 2: the preconditioner matrix is singular
##
## @item 3: the algorithm reached stagnation
##
## @item 4: the algorithm can't continue due to a division by zero
## @end itemize
##
## @item @var{relres} is the relative residual obtained with as
## @code{(@var{A}*@var{x}-@var{b}) / @code{norm(@var{b})}}.
##
## @item @var{iter} is the (possibly half) iteration which @var{x} is
## computed.  If it is an half iteration then it is @code{@var{iter} + 0.5}
##
## @item @var{resvec} is a vector containing the residual of each half and
## total iteration (There are also the half iterations since @var{x} is
## computed in two steps at each iteration).
## Doing @code{(length(@var{resvec}) - 1) / 2} is possible to see the
## total number of (total) iterations performed.
##
## @end itemize
##
## Let us consider a trivial problem with a tridiagonal matrix
##
## @example
## @group
## n = 20;
## A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
##     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
##     sparse (1, 2, 1, 1, n) * n / 2);
## b = A * ones (n, 1);
## restart = 5;
## [M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
## M = M1 * M2;
## Afun = @@(x) A * x;
## Mfun = @@(x) M \ x;
## M1fun = @@(x) M1 \ x;
## M2fun = @@(x) M2 \ x;
## @end group
## @end example
##
## @sc{Example 1:} simplest usage of @code{bicgstab}
##
## @example
## x = bicgstab (A, b, [], n)
## @end example
##
## @sc{Example 2:} @code{bicgstab} with a function which computes
## @code{@var{A} * @var{x}}
##
## @example
## x = bicgstab (Afun, b, [], n)
## @end example
##
## @sc{Example 3:} @code{bicgstab} with a preconditioner matrix @var{M}
##
## @example
## x = bicgstab (A, b, [], 1e-06, n, M)
## @end example
##
## @sc{Example 4:} @code{bicgstab} with a function as preconditioner
##
## @example
## x = bicgstab (Afun, b, 1e-6, n, Mfun)
## @end example
##
## @sc{Example 5:} @code{bicgstab} with preconditioner matrices @var{M1}
## and @var{M2}
##
## @example
## x = bicgstab (A, b, [], 1e-6, n, M1, M2)
## @end example
##
## @sc{Example 6:} @code{bicgstab} with functions as preconditioners
##
## @example
## x = bicgstab (Afun, b, 1e-6, n, M1fun, M2fun)
## @end example
##
## @sc{Example 7:} @code{bicgstab} with as input a function requiring
## an argument
##
## @example
## @group
## function y = Ap (A, x, z) # compute A^z * x
##    y = x;
##    for i = 1:z
##      y = A * y;
##    endfor
##  endfunction
## Apfun = @@(x, string, p) Ap (A, x, string, p);
## x = bicgstab (Apfun, b, [], [], [], [], [], 2);
## @end group
## @end example
##
## @sc{Example 8:} explicit example to show that @code{bicgstab} uses a
## right preconditioner
##
## @example
## @group
## [M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
## M = M1 * M2;
##
## ## reference solution computed by bicgstab after one iteration
## [x_ref, fl] = bicgstab (A, b, [], 1, M)
##
## ## right preconditioning
## [y, fl] = bicgstab (A / M, b, [], 1)
## x = M \ y # compare x and x_ref
##
## @end group
## @end example
##
## Reference:
##
## @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear
## Systems}, Second edition, 2003, SIAM
##
## @seealso{bicg, cgs, gmres, pcg, qmr, tfqmr}
##
## @end deftypefn

function [x_min, flag, relres, iter_min, resvec] = ...
         bicgstab (A, b, tol = [], maxit = [], M1 = [], M2 = [], ...
                   x0 = [], varargin)

  ## Check consistency and  type of A, M1, M2
  [Afun, M1fun, M2fun] =  __alltohandles__ (A, b, M1, M2, "bicgstab");

  ## Check if input tol are empty (set them to default if necessary)
  [tol, maxit, x0] = __default__input__ ({1e-06, min(rows(b), 20), ...
                    zeros(rows (b), 1)}, tol, maxit, x0);

  norm_b = norm (b, 2);
  if (norm_b == 0)
    if (nargout < 2)
      printf ("The right hand side vector is all zero so bicgstab \n")
      printf ("returned an all zero solution without iterating.\n")
    endif
    x_min = zeros (numel (b), 1);
    iter_min = 0;
    flag = 0;
    resvec = 0;
    relres = 0;
    return;
  endif

  ## Double maxit to mind also the "half iterations"
  d_maxit = 2 * maxit;
  iter = iter_min = 0;
  resvec = zeros (d_maxit,1);
  x = x_min = x_pr = x0;
  iter = iter_min = 0;
  ## default setting of flag is 1 (i.e. max number of iterations reached)
  flag = 1;

  res = b - feval (Afun, x, varargin{:});
  rr = p = res; # rr is r_star
  rho_1 = rr' * res;
  resvec (1) = norm (res,2);
  real_tol = norm_b * tol;

  ## To check if the preconditioners are singular or they have some NaN
  try
    warning ("error", "Octave:singular-matrix", "local");
    p_hat = feval (M1fun, p, varargin{:});
    p_hat = feval (M2fun, p_hat, varargin{:});
  catch
    flag = 2;
  end_try_catch

  while (flag !=2) && (iter < d_maxit) && (resvec (iter + 1) >= real_tol)
    v = feval (Afun, p_hat, varargin{:});
    prod_tmp = (rr' * v);
    if (prod_tmp == 0)
      flag = 4;
      break;
    endif
    alpha = rho_1 / (prod_tmp);
    x += alpha * p_hat;
    s = res - alpha * v;
    iter += 1;
    resvec (iter+1) = norm (s,2);
    if (resvec (iter + 1) <= real_tol) # reached the tol
      x_min = x;
      iter_min = iter;
      break;
    elseif (resvec (iter + 1) <= resvec (iter_min + 1)) # Found min residual
      x_min = x;
      iter_min = iter;
    endif
    s_hat = feval (M1fun, s, varargin{:});
    s_hat = feval (M2fun, s_hat, varargin{:});
    t = feval (Afun, s_hat, varargin{:});
    omega = (t' * s) / (t' * t);
    if (omega == 0) # x and residual don't change and the next it will be NaN
      flag = 4;
      break;
    endif
    x += omega * s_hat;
    res = s - omega * t;
    iter += 1;
    resvec (iter + 1) = norm (res);
    if (resvec (iter + 1) <= resvec (iter_min + 1))
      x_min = x;
      iter_min = iter;
    endif
    if (norm (x - x_pr) <= norm (x) * eps)
      flag = 3;
      break;
    endif
    x_pr = x;
    rho_2 = rho_1;
    rho_1 = rr' * res;
    if (rho_1 == 0) # x and residual don't change and the next it will be NaN
      flag = 4;
      break;
    endif
    beta = (rho_1 / rho_2) * (alpha / omega);
    p = res + beta * (p - omega*  v);
    p_hat = feval (M1fun, p, varargin{:});
    p_hat = feval (M2fun, p_hat, varargin{:});
  endwhile
  resvec = resvec (1:iter+1,1);

  relres = resvec (iter_min + 1) / norm_b;  # I set the relative residual
  iter /=  2;
  iter_min /= 2;

  if (flag == 1) && (relres <= tol)
    flag = 0;
  endif

  ## output strings to print when the outputs requested are less than 2
  if (nargout < 2)
    switch (flag)
      case {0}
        printf ("bicgstab converged at iteration %i ", iter_min);
        printf ("to a solution with relative residual %e\n", relres);
      case {1}
        printf ("bicgstab stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the maximum number of iterations was reached.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {2}
        printf ("bicgstab stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the preconditioner matrix is singular.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {3}
        printf ("bicgstab stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method stagnated.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {4}
        printf ("bicgstab stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method can't continue.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
    endswitch
  endif

endfunction


%!demo # simplest use
%! n = 20;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!               sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.1 * eye (n));
%! M = M1 * M2;
%! x = bicgstab (A, b, [], n);
%! Afun = @(x) A * x;
%! x = bicgstab (Afun, b, [], n);
%! x = bicgstab (A, b, 1e-6, n, M);
%! x = bicgstab (A, b, 1e-6, n, M1, M2);
%! Mfun = @(z) M \ z;
%! x = bicgstab (Afun, b, 1e-6, n, Mfun);
%! M1fun = @(z) M1 \ z;
%! M2fun = @(z) M2 \ z;
%! x = bicgstab (Afun, b, 1e-6, n, M1fun, M2fun);
%! function y = Ap (A, x, z)
%!   ## compute A^z * x or (A^z)' * x
%!   y = x;
%!   for i = 1:z
%!     y = A * y;
%!   endfor
%! endfunction
%! Afun = @(x, p) Ap (A, x, p);
%! x = bicgstab (Afun, b, [], 2 * n, [], [], [], 2); # solution of A^2 * x = b

%!demo
%! n = 10;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!               sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.3 * eye (n));  # factorization of A perturbed
%! M = M1 * M2;
%!
%! ## Reference solution computed by bicgstab after one iteration
%! [x_ref, fl] = bicgstab (A, b, [], 1, M);
%! x_ref
%!
%! ## right preconditioning
%! [y, fl] = bicgstab (A / M, b, [], 1);
%! ## Compare x and x_ref
%! x = M \ y

%!test
%! ## Check that all type of inputs work
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M1 = diag (sqrt (diag (A)));
%! M2 = M1;
%! maxit = 20;
%! Afun = @(z) A*z;
%! M1_fun = @(z) M1 \ z;
%! M2_fun = @(z) M2 \ z;
%! [x, flag] = bicgstab (A,b );
%! assert (flag, 0);
%! [x, flag] = bicgstab (A, b, [], maxit, M1, M2);
%! assert (flag, 0);
%! [x, flag] = bicgstab (A, b, [], maxit, M1_fun, M2_fun);
%! assert (flag, 0);
%! [x, flag] = bicgstab (A, b, [], maxit, M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = bicgstab (A, b, [], maxit, M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = bicgstab (Afun, b);
%! assert (flag, 0);
%! [x, flag] = bicgstab (Afun, b, [], maxit, M1, M2);
%! assert (flag, 0);
%! [x, flag] = bicgstab (Afun, b, [], maxit, M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = bicgstab (Afun, b, [], maxit, M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = bicgstab (Afun, b, [], maxit, M1_fun, M2_fun);
%! assert (flag, 0);

%!shared n, A, b, tol, maxit, M1, M2
%! n = 100;
%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! tol = 1e-8;
%! maxit = 15;
%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);

%!test
%! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, M1, M2);
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!function y = afun (x, a)
%!  y = a * x;
%!endfunction
%!
%!test
%! [x, flag, relres, iter, resvec] = bicgstab (@(x) afun (x, A), b,
%!                                             tol, maxit, M1, M2);
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!test
%! a = sprand (n, n, .1);
%! A = a'*a + 100 * speye (n);
%! b = sum (A, 2);
%! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!test
%! ## bicgstab solves complex linear systems
%! A = [1 + 1i, 1 + 1i; 2 - 1i, 2 + 1i];
%! b = A * [1; 1];
%! [x, flag, relres, iter, resvec] = bicgstab (A, b);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);

%!test
%! ## test with a non-symmetric matrix
%! A = diag (1:50);
%! A(1,50) = 10000;
%! b = ones (50,1);
%! [x, flag, relres, iter, resvec] = bicgstab (A, b, [], 100);
%! assert (flag, 0);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);

%!test
%! ## test that bicgstab detects a singular preconditioner
%! M = ones (50);
%! M(1,1) = 0;
%! [x, flag] = bicgstab (A, b, [], 100, M);
%! assert (flag, 2);

%!test
%! A = single (1);
%! b = 1;
%! [x, flag] = bicgstab (A, b);
%! assert (class (x), "single");

%!test
%! A = 1;
%! b = single (1);
%! [x, flag] = bicgstab (A, b);
%! assert (class (x), "single");

%!test
%! A = single (1);
%! b = single (1);
%! [x, flag] = bicgstab (A, b);
%! assert (class (x), "single");

%!test
%!function y = Afun (x)
%!  A = sparse (toeplitz ([2, 1, 0, 0], [2, -1, 0, 0]));
%!  y = A * x;
%!endfunction
%!
%! b = [1; 2; 2; 3];
%! [x, flag] = bicgstab ("Afun", b);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);

%!test
%! ## unpreconditioned residual
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = magic (5);
%! [x, flag, relres] = bicgstab (A, b, [], 2, M);
%! assert (norm (b - A * x) / norm (b), relres, 8*eps);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} cgs (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
## @deftypefnx {} {@var{x} =} cgs (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} cgs (@var{A}, @var{b}, @dots{})
## Solve @code{A x = b}, where @var{A} is a square matrix, using the
## Conjugate Gradients Squared method.
##
## The input arguments are:
##
## @itemize @minus
##
## @item @var{A} is the matrix of the linear system and it must be square.
## @var{A} can be passed as a matrix, function handle, or inline
## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
## parameters to @code{Afun} are passed after @var{x0}.
##
## @item @var{b} is the right hand side vector.  It must be a column vector
## with same number of rows of @var{A}.
##
## @item @var{tol} is the relative tolerance, if not given or set to [] the
## default value 1e-6 is used.
##
## @item @var{maxit} the maximum number of outer iterations, if not given or
## set to [] the default value @code{min (20, numel (b))} is used.
##
## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
## matrix is given as @code{M = M1 * M2}.  Both @var{M1}
## and @var{M2} can be passed as a matrix or as a function handle or inline
## function @code{g} such that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.
## If M1 is empty or not passed then no preconditioners are applied.
## The technique used is the right preconditioning, i.e., it is solved
## @code{@var{A}*inv(@var{M})*y = b} and then @code{@var{x} = inv(@var{M})*y}.
##
## @item @var{x0} the initial guess, if not given or set to [] the default
## value @code{zeros (size (b))} is used.
## @end itemize
##
## The arguments which follow @var{x0} are treated as parameters, and passed in
## a proper way to any of the functions (@var{A} or @var{P}) which are passed
## to @code{cgs}.
##
## The output parameters are:
##
## @itemize @minus
##
## @item @var{x} is the approximation computed.  If the method doesn't
## converge then it is the iterated with the minimum residual.
##
## @item @var{flag} indicates the exit status:
##
## @itemize @minus
## @item 0: iteration converged to the within the chosen tolerance
##
## @item 1: the maximum number of iterations was reached before convergence
##
## @item 2: the preconditioner matrix is singular
##
## @item 3: the algorithm reached stagnation
##
## @item 4: the algorithm can't continue due to a division by zero
## @end itemize
##
## @item @var{relres} is the relative residual obtained with as
## @code{(@var{A}*@var{x}-@var{b}) / @code{norm(@var{b})}}.
##
## @item @var{iter} is the iteration which @var{x} is computed.
##
## @item @var{resvec} is a vector containing the residual at each iteration.
## Doing @code{length(@var{resvec}) - 1} is possible to see the total number
## of iterations performed.
## @end itemize
##
## Let us consider a trivial problem with a tridiagonal matrix
##
## @example
## @group
## n = 20;
## A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
##     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
##     sparse (1, 2, 1, 1, n) * n / 2);
## b = A * ones (n, 1);
## restart = 5;
## [M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
## M = M1 * M2;
## Afun = @@(x) A * x;
## Mfun = @@(x) M \ x;
## M1fun = @@(x) M1 \ x;
## M2fun = @@(x) M2 \ x;
## @end group
## @end example
##
## @sc{Example 1:} simplest usage of @code{cgs}
##
## @example
## x = cgs (A, b, [], n)
## @end example
##
## @sc{Example 2:} @code{cgs} with a function which computes
## @code{@var{A} * @var{x}}
##
## @example
## x = cgs (Afun, b, [], n)
## @end example
##
## @sc{Example 3:} @code{cgs} with a preconditioner matrix @var{M}
##
## @example
## x = cgs (A, b, [], 1e-06, n, M)
## @end example
##
## @sc{Example 4:} @code{cgs} with a function as preconditioner
##
## @example
## x = cgs (Afun, b, 1e-6, n, Mfun)
## @end example
##
## @sc{Example 5:} @code{cgs} with preconditioner matrices @var{M1}
## and @var{M2}
##
## @example
## x = cgs (A, b, [], 1e-6, n, M1, M2)
## @end example
##
## @sc{Example 6:} @code{cgs} with functions as preconditioners
##
## @example
## x = cgs (Afun, b, 1e-6, n, M1fun, M2fun)
## @end example
##
## @sc{Example 7:} @code{cgs} with as input a function requiring an argument
##
## @example
## @group
## function y = Ap (A, x, z) # compute A^z * x
##    y = x;
##    for i = 1:z
##      y = A * y;
##    endfor
##  endfunction
## Apfun = @@(x, string, p) Ap (A, x, string, p);
## x = cgs (Apfun, b, [], [], [], [], [], 2);
## @end group
## @end example
##
## @sc{Example 8:} explicit example to show that @code{cgs} uses a
## right preconditioner
##
## @example
## @group
## [M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
## M = M1 * M2;
##
## ## reference solution computed by cgs after one iteration
## [x_ref, fl] = cgs (A, b, [], 1, M)
##
## ## right preconditioning
## [y, fl] = cgs (A / M, b, [], 1)
## x = M \ y # compare x and x_ref
##
## @end group
## @end example
##
## References:
##
## @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
## Second edition, 2003, SIAM
##
## @seealso{pcg, bicgstab, bicg, gmres, qmr, tfqmr}
## @end deftypefn

function [x_min, flag, relres, iter_min, resvec] = ...
         cgs (A, b, tol = [], maxit = [], M1 = [] , M2 = [], x0 = [], varargin)

  [Afun, M1fun, M2fun] = __alltohandles__ (A, b, M1, M2, "cgs");

  [tol, maxit, x0] = __default__input__ ({1e-06, min( rows(b), 20), ...
                                          zeros(size (b))}, tol, maxit, x0);

  norm_b = norm (b, 2);
  if (norm_b == 0)
    if (nargout < 2)
      printf ("The right hand side vector is all zero so cgs \n")
      printf ("returned an all zero solution without iterating.\n")
    endif
    x_min = zeros (numel (b), 1);
    iter_min = 0;
    flag = 0;
    resvec = 0;
    relres = 0;
    return;
  endif

  resvec = zeros (maxit, 1); # Preallocation of resvec

  flag = 1; # Default flag is 1, i.e. maximum number of iterations reached
  iter = iter_min = 0;
  x = x_min = x_pr = x0;
  ## x approximation at the actual iteration
  ## x_min approximation with the minimum residual
  ## x_pr approximation at the previous iteration (to check stagnation)

  r0 = rr = u = p = b - feval (Afun, x, varargin{:});
  resvec (1) = norm (r0, 2);
  rho_1 = rr' * r0;

  try
    warning ("error","Octave:singular-matrix","local");
    p_hat = feval (M1fun, p, varargin{:});
    p_hat = feval (M2fun, p_hat, varargin {:});
  catch
    flag = 2;
  end_try_catch

  while ((flag != 2) && (iter < maxit) && ...
         (resvec (iter + 1) >= tol * norm_b))
    v = feval (Afun, p_hat, varargin{:});
    prod_tmp = (rr' * v);
    if (prod_tmp == 0)
      flag = 4;
      break;
    endif
    alpha = rho_1 / prod_tmp;
    q = u - alpha * v;
    u_hat = feval(M1fun, u + q, varargin{:});
    u_hat = feval (M2fun, u_hat, varargin{:});
    x += alpha*u_hat;
    r0 -= alpha* feval (Afun, u_hat, varargin{:});
    iter += 1;
    resvec (iter + 1) = norm (r0, 2);
    if (norm (x - x_pr, 2) <= norm (x, 2) * eps) # Stagnation
      flag = 3;
      break;
    endif
    if (resvec (iter + 1) <= resvec (iter_min + 1)) # Check min residual
      x_min = x;
      iter_min = iter;
    endif
    x_pr = x;
    rho_2 = rho_1;
    rho_1 = rr' * r0;
    if (rho_1 == 0)
      flag = 4;
      break;
    endif
    beta = rho_1 / rho_2;
    u = r0 + beta * q;
    p = u + beta * (q + beta * p);
    p_hat = feval (M1fun, p, varargin {:});
    p_hat = feval (M2fun, p_hat, varargin{:});
  endwhile
  resvec = resvec (1: (iter + 1));

  relres = resvec (iter_min + 1) / norm_b;
  if (relres <= tol) && (flag = 1)
    flag = 0;
  endif

  if (nargout < 2)
    switch (flag)
      case {0}
        printf ("cgs converged at iteration %i ", iter_min);
        printf ("to a solution with relative residual %e\n", relres);
      case {1}
        printf ("cgs stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the maximum number of iterations was reached.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {2}
        printf ("cgs stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the preconditioner matrix is singular.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {3}
        printf ("cgs stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method stagnated.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {4}
        printf ("cgs stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method can't continue.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
    endswitch
  endif

endfunction


%!demo
%! ## Solve system of A*x=b
%! A = [5 -1 3;-1 2 -2;3 -2 3];
%! b = [7;-1;4];
%! [a,b,c,d,e] = cgs (A,b)

%!demo
%! ## simplest use case
%! n = 20;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!               sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.1 * eye (n));
%! M = M1 * M2;
%! x = cgs (A, b, [], n);
%! Afun = @(x) A * x;
%! x = cgs (Afun, b, [], n);
%! x = cgs (A, b, 1e-6, n, M);
%! x = cgs (A, b, 1e-6, n, M1, M2);
%! Mfun = @(z) M \ z;
%! x = cgs (Afun, b, 1e-6, n, Mfun);
%! M1fun = @(z) M1 \ z;
%! M2fun = @(z) M2 \ z;
%! x = cgs (Afun, b, 1e-6, n, M1fun, M2fun);
%! function y = Ap (A, x, z)
%!   ## compute A^z * x or (A^z)' * x
%!   y = x;
%!   for i = 1:z
%!     y = A * y;
%!   endfor
%! endfunction
%! Afun = @(x, p) Ap (A, x, p);
%! x = cgs (Afun, b, [], 2*n, [], [], [], 2); # solution of A^2 * x = b

%!demo
%! n = 10;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!               sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.3 * speye (n));  # factorization of A perturbed
%! M = M1 * M2;
%!
%! ## Reference solution computed by cgs after one iteration
%! [x_ref, fl] = cgs (A, b, [], 1, M);
%! x_ref
%!
%! ## right preconditioning
%! [y, fl] = cgs (A / M, b, [], 1);
%! ## Compare x and x_ref
%! x = M \ y

%!test
%! ## Check that all type of inputs work
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M1 = diag (sqrt (diag (A)));
%! M2 = M1;
%! maxit = 10;
%! Afun = @(z) A * z;
%! M1_fun = @(z) M1 \ z;
%! M2_fun = @(z) M2 \ z;
%! [x, flag] = cgs (A,b);
%! assert (flag, 0);
%! [x, flag] = cgs (A, b, [], maxit, M1, M2);
%! assert (flag, 0);
%! [x, flag] = cgs (A, b, [], maxit, M1_fun, M2_fun);
%! assert (flag, 0);
%! [x, flag] = cgs (A, b, [], maxit, M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = cgs (A, b, [], maxit, M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = cgs (Afun, b);
%! assert (flag, 0);
%! [x, flag] = cgs (Afun, b, [], maxit, M1, M2);
%! assert (flag, 0);
%! [x, flag] = cgs (Afun, b, [], maxit, M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = cgs (Afun, b, [], maxit, M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = cgs (Afun, b, [], maxit, M1_fun, M2_fun);
%! assert (flag, 0);

%!shared n, A, b, tol, maxit, M
%!
%!test
%! n = 100;
%! A = spdiags ([-ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! tol = 1e-8;
%! maxit = 1000;
%! M = 4 * eye (n);
%! [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M);
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!
%!test
%! maxit = 15;
%! [x, flag, relres, iter, resvec] = cgs (@(x) A * x, b, tol, maxit, M);
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!test
%! a = sprand (n, n, .1);
%! A = a'*a + 100 * eye (n);
%! b = sum (A, 2);
%! [x, flag, relres, iter, resvec] = cgs (A, b, tol, [], diag (diag (A)));
%! assert (norm (b - A*x) / norm (b), 0, tol);

%!test
%! n = 5;
%! A = sparse (toeplitz ([2, 1, 0, 0, 0], [2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = ones (n);
%! [x, flag] = cgs (A, b, [], [], M);
%! assert (flag, 2);

%!test
%! A = single (1);
%! b = 1;
%! [x, flag] = cgs (A, b);
%! assert (class (x), "single");

%!test
%! A = 1;
%! b = single (1);
%! [x, flag] = cgs (A, b);
%! assert (class (x), "single");

%!test
%! A = single (1);
%! b = single (1);
%! [x, flag] = cgs (A, b);
%! assert (class (x), "single");

%!test
%!function y = Afun (x)
%!  A = toeplitz ([2, 1, 0, 0], [2, -1, 0, 0]);
%!  y = A * x;
%!endfunction
%! [x, flag] = cgs ("Afun", [1; 2; 2; 3]);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);

%!test
%! ## test a complex linear system
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0])) + ...
%! 1i * toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! [x, flag] = cgs (A, b);
%! assert (flag, 0);

%!test
%! ## unpreconditioned residual
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = magic (5);
%! [x, flag, relres] = cgs (A, b, [], 3, M);
%! assert (norm (b - A * x) / norm (b), relres, 8 * eps);
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{p} =} colperm (@var{s})
## Return the column permutations such that the columns of
## @code{@var{s}(:, @var{p})} are ordered in terms of increasing number of
## nonzero elements.
##
## If @var{s} is symmetric, then @var{p} is chosen such that
## @code{@var{s}(@var{p}, @var{p})} orders the rows and columns with
## increasing number of nonzero elements.
## @end deftypefn

function p = colperm (s)

  if (nargin < 1)
    print_usage ();
  endif

  [~, p] = sort (sum (s != 0, 1));

endfunction


%!assert <*59226> (colperm ([1,0;0,0]), [2, 1])
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{d} =} eigs (@var{A})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{k})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma}, @var{opts})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{B})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{B}, @var{k})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma})
## @deftypefnx {} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{k})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{k}, @var{sigma})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{k}, @var{sigma}, @var{opts})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{B})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{B}, @var{k})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{B}, @var{k}, @var{sigma})
## @deftypefnx {} {@var{d} =} eigs (@var{Af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})
## @deftypefnx {} {[@var{V}, @var{D}] =} eigs (@dots{})
## @deftypefnx {} {[@var{V}, @var{D}, @var{flag}] =} eigs (@dots{})
## Calculate a limited number of eigenvalues and eigenvectors based on a
## selection criteria.
##
## By default, @code{eigs} solve the equation
## @tex
## $A \nu = \lambda \nu$,
## @end tex
## @ifinfo
## @code{A * v = lambda * v},
## @end ifinfo
## where
## @tex
## $\lambda$ is a scalar representing one of the eigenvalues, and $\nu$
## @end tex
## @ifinfo
## @code{lambda} is a scalar representing one of the eigenvalues, and @code{v}
## @end ifinfo
## is the corresponding eigenvector.  If given the positive definite matrix
## @var{B} then @code{eigs} solves the general eigenvalue equation
## @tex
## $A \nu = \lambda B \nu$.
## @end tex
## @ifinfo
## @code{A * v = lambda * B * v}.
## @end ifinfo
##
## The input @var{A} is a square matrix of dimension @var{n}-by-@var{n}.
## Typically, @var{A} is also large and sparse.
##
## The input @var{B} for the generalized eigenvalue problem is a square matrix
## with the same size as @var{A} (@var{n}-by-@var{n}).  Typically, @var{B} is
## also large and sparse.
##
## The number of eigenvalues and eigenvectors to calculate is given by @var{k}
## and defaults to 6.
##
## The argument @var{sigma} determines which eigenvalues are returned.
## @var{sigma} can be either a scalar or a string.  When @var{sigma} is a
## scalar, the @var{k} eigenvalues closest to @var{sigma} are returned.  If
## @var{sigma} is a string, it must be one of the following values.
##
## @table @asis
## @item @nospell{@qcode{"lm"}}
## Largest Magnitude (default).
##
## @item @nospell{@qcode{"sm"}}
## Smallest Magnitude.
##
## @item @nospell{@qcode{"la"}}
## Largest Algebraic (valid only for real symmetric problems).
##
## @item @nospell{@qcode{"sa"}}
## Smallest Algebraic (valid only for real symmetric problems).
##
## @item @nospell{@qcode{"be"}}
## Both Ends, with one more from the high-end if @var{k} is odd (valid only for
## real symmetric problems).
##
## @item @nospell{@qcode{"lr"}}
## Largest Real part (valid only for complex or unsymmetric problems).
##
## @item @nospell{@qcode{"sr"}}
## Smallest Real part (valid only for complex or unsymmetric problems).
##
## @item @nospell{@qcode{"li"}}
## Largest Imaginary part (valid only for complex or unsymmetric problems).
##
## @item @nospell{@qcode{"si"}}
## Smallest Imaginary part (valid only for complex or unsymmetric problems).
## @end table
##
## If @var{opts} is given, it is a structure defining possible options that
## @code{eigs} should use.  The fields of the @var{opts} structure are:
##
## @table @code
## @item issym
## If @var{Af} is given then this flag (true/false) determines whether the
## function @var{Af} defines a symmetric problem.  It is ignored if a matrix
## @var{A} is given.  The default is false.
##
## @item isreal
## If @var{Af} is given then this flag (true/false) determines whether the
## function @var{Af} defines a real problem.  It is ignored if a matrix @var{A}
## is given.  The default is true.
##
## @item tol
## Defines the required convergence tolerance, calculated as
## @code{tol * norm (A)}.  The default is @code{eps}.
##
## @item maxit
## The maximum number of iterations.  The default is 300.
##
## @item p
## The number of @nospell{Lanczos} basis vectors to use.  More vectors will
## result in faster convergence, but a greater use of memory.  The optimal
## value of @code{p} is problem dependent and should be in the range
## @code{@var{k} + 1} to @var{n}.  The default value is @code{2 * @var{k}}.
##
## @item v0
## The starting vector for the algorithm.  An initial vector close to the final
## vector will speed up convergence.  The default is for @sc{arpack} to
## randomly generate a starting vector.  If specified, @code{v0} must be
## an @var{n}-by-1 vector where @code{@var{n} = rows (@var{A})}.
##
## @item disp
## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then
## diagnostics are disabled.  The default value is 0.
##
## @item cholB
## If the generalized eigenvalue problem is being calculated, this flag
## (true/false) specifies whether the @var{B} input represents
## @code{chol (@var{B})} or simply the matrix @var{B}.  The default is false.
##
## @item permB
## The permutation vector of the Cholesky@tie{}factorization for @var{B} if
## @code{cholB} is true.  It is obtained by
## @code{[R, ~, permB] = chol (@var{B}, @qcode{"vector"})}.  The default is
## @code{1:@var{n}}.
##
## @end table
##
## It is also possible to represent @var{A} by a function denoted @var{Af}.
## @var{Af} must be followed by a scalar argument @var{n} defining the length
## of the vector argument accepted by @var{Af}.  @var{Af} can be a function
## handle, an inline function, or a string.  When @var{Af} is a string it
## holds the name of the function to use.
##
## @var{Af} is a function of the form @code{y = Af (x)} where the required
## return value of @var{Af} is determined by the value of @var{sigma}.
## The four possible forms are
##
## @table @code
## @item A * x
## if @var{sigma} is not given or is a string other than "sm".
##
## @item A \ x
## if @var{sigma} is 0 or "sm".
##
## @item (A - sigma * I) \ x
## if @var{sigma} is a scalar not equal to 0; @code{I} is the identity matrix
## of the same size as @var{A}.
##
## @item (A - sigma * B) \ x
## for the general eigenvalue problem.
## @end table
##
## The return arguments and their form depend on the number of return arguments
## requested.  For a single return argument, a column vector @var{d} of length
## @var{k} is returned containing the @var{k} eigenvalues that have been
## found.  For two return arguments, @var{V} is an @var{n}-by-@var{k} matrix
## whose columns are the @var{k} eigenvectors corresponding to the returned
## eigenvalues.  The eigenvalues themselves are returned in @var{D} in the
## form of a @var{k}-by-@var{k} matrix, where the elements on the diagonal
## are the eigenvalues.
##
## The third return argument @var{flag} returns the status of the convergence.
## If @var{flag} is 0 then all eigenvalues have converged.  Any other value
## indicates a failure to converge.
##
## Programming Notes: For small problems, @var{n} < 500, consider using
## @code{eig (full (@var{A}))}.
##
## If @sc{arpack} fails to converge consider increasing the number of
## @nospell{Lanczos} vectors (@var{opt}.p), increasing the number of iterations
## (@var{opt}.maxiter), or decreasing the tolerance (@var{opt}.tol).
##
## Reference:
## This function is based on the @sc{arpack} package, written by
## @nospell{R. Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang}.  For more
## information see @url{http://www.caam.rice.edu/software/ARPACK/}.
##
## @seealso{eig, svds}
## @end deftypefn

## Programming Note: For compatibility with Matlab, handle small matrix cases
## and all-zero matrices in this m-file which ARPACK can not.

function varargout = eigs (varargin)

  if (nargin == 0)
    print_usage ();
  endif

  call_eig = false;  # flag whether to take shortcut path with eig()
  have_A = false;
  have_B = false;
  offset = 0;
  k = 6;
  sigma = "lm";

  ## FIXME: Input validation is split between eigs.m and __eigs__.cc.
  ##        It would be simpler if all input validation was done in the m-file
  ##        and then the internal function __eigs__ could be simplified to
  ##        rely on having "good" inputs.
  if (isnumeric (varargin{1}) && issquare (varargin{1}))
    A = varargin{1};
    have_A = true;
    k = min (k, rows (A));  # reduce default k if necessary
    if (nargin > 1)
      if (! isnumeric (varargin{2}))
        error ("eigs: second argument must be numeric");
      endif
      if (size_equal (A, varargin{2}))
        B = varargin{2};
        have_B = true;
        offset = 1;
      elseif (isempty (varargin{2}))
        ## Special syntax to do regular eigenvalue decomposition rather
        ## than generalized eigenvalue decomposition (B = []).
        offset = 1;
      endif
    endif

    if (rows (A) <= 12)  # p = 2*k criteria
      call_eig = true;
    endif

    if (nargin > 1 + offset)
      ## FIXME: Input validation should recognize improper inputs.
      ##        Code below only checks for what it expects to find.
      ##        Sample bad input: eigs (magic (5), [], {1})
      arg = varargin{2+offset};
      if (isnumeric (arg) && isscalar (arg) && isreal (arg)
          && fix (arg) == arg)
        k = arg;
        p = 2 * k;
      elseif (isfield (arg, "p"))
        p = arg.p;
      endif

      if (nargin > 2 + offset)
        arg = varargin{3+offset};
        if (ischar (arg))
          sigma = tolower (arg);
        elseif (isnumeric (arg) && isscalar (arg))
          sigma = arg;
        elseif (isfield (arg, "p"))
          p = arg.p;
        endif

        if (nargin > 3 + offset)
          arg = varargin{4+offset};
          if (isfield (arg, "p"))
            p = arg.p;
          else
            p = 2 * k;
          endif
        endif
      endif

      if (p >= rows (A))
        call_eig = true;
      else
        call_eig = false;
      endif
    endif
  endif

  if (call_eig)
    ## Special code path for small matrices which ARPACK does not handle.
    varargout = cell (1, min (2, max (1, nargout)));
    if (have_B)
      real_valued = isreal (A) && isreal (B);
      symmetric = issymmetric (A) && issymmetric (B);
      [varargout{:}] = eig (A, B);
    else
      real_valued = isreal (A);
      symmetric = issymmetric (A);
      [varargout{:}] = eig (A);
    endif
    varargout = select_eig (varargout, k, sigma, real_valued, symmetric);
    if (nargout == 3)
      varargout{3} = 0;  # Flag value is always 0 (success) for eig() code path
    endif

  else
    varargout = cell (1, max (1, nargout));
    if (have_A && nnz (A) == 0)
      ## Special case of zeros matrix which ARPACK handles badly.
      switch (nargout)
        case 3
          V = diag (ones ([k,1]), rows (A), k);
          varargout = { V, diag(zeros (k,1)), 0.0 };

        case 2
          V = diag (ones ([k,1]), rows (A), k);
          varargout = { V, diag(zeros (k,1)) };

        case {0, 1}
          varargout = { zeros(k,1) };
      endswitch
    else
      ## Call ARPACK
      [varargout{:}] = __eigs__ (varargin{:});
    endif
  endif

endfunction

## For cases which do not go through ARPACK, but rather through eig() shortcut
## code path, select which values to return based on input parameters and
## number of outputs.
function out = select_eig (args, k, sigma, real_valued, symmetric)

  if (numel (args) == 1)
    d = args{1};
  else
    d = diag (args{2});
  endif

  n = numel (d);
  if (k > n)
    error ("eigs: requested number of eigenvalues K (%d) exceeds available eigenvalues (%d)", k, n);
  endif

  if (ischar (sigma))
    switch (sigma)
      case "lm"
        [~, idx] = sort (abs (d), "descend");

      case "sm"
        [~, idx] = sort (abs (d), "ascend");

      case "la"
        if (real_valued && symmetric)
          [~, idx] = sort (real (d), "descend");
        else
          error ('eigs: SIGMA = "la" requires real symmetric problem');
        endif

      case "sa"
        if (real_valued && symmetric)
          [~, idx] = sort (real (d), "ascend");
        else
          error ('eigs: SIGMA = "sa" requires real symmetric problem');
        endif

      case "be"
        if (real_valued && symmetric)
          [~, idx] = sort (real (d), "ascend");
        else
          error ('eigs: SIGMA = "be" requires real symmetric problem');
        endif

      case "lr"
        if (! (real_valued && symmetric))
          [~, idx] = sort (real (d), "descend");
        else
          error ('eigs: SIGMA = "lr" requires complex or unsymmetric problem');
        endif

      case "sr"
        if (! (real_valued && symmetric))
          [~, idx] = sort (real (d), "ascend");
        else
          error ('eigs: SIGMA = "sr" requires complex or unsymmetric problem');
        endif

      case "li"
        if (! (real_valued && symmetric))
          [~, idx] = sort (imag (d), "descend");
        else
          error ('eigs: SIGMA = "li" requires complex or unsymmetric problem');
        endif

      case "si"
        if (! (real_valued && symmetric))
          [~, idx] = sort (imag (d), "ascend");
        else
          error ('eigs: SIGMA = "si" requires complex or unsymmetric problem');
        endif

      otherwise
        error ("eigs: unrecognized value for SIGMA: %s", sigma);
    endswitch
  else
    ## numeric sigma, find k closest values
    [~, idx] = sort (abs (d - sigma));
  endif

  d = d(idx);

  if (strcmp (sigma, "be"))
    n1 = floor (k/2);
    n2 = n - (k - n1) + 1;
    selection = [1:n1, n2:n];
  else
    selection = 1:k;
  endif

  d = d(selection);

  if (numel (args) == 1)
    out{1} = d;
  else
    out{2} = diag (d);

    V = args{1};
    V = V(:,idx);
    out{1} = V(:,selection);
  endif

endfunction


### TRIVIAL TESTS ###

%!test
%! for i = 1:20
%!   assert (eigs (i, 1), i, 1e-11);
%!   assert (eigs (zeros (i), 1), 0, 1e-11);
%!   assert (eigs (sparse (i), 1), i, 1e-11);
%!   assert (eigs (sparse (i, i), 1), 0, 1e-11);
%! endfor

%!testif HAVE_ARPACK
%! for i = 1:20
%!   assert (eigs (ones (i), 1), i, 1e-11);
%!   assert (eigs (sparse (ones (i)), 1), i, 1e-11);
%! endfor

### SPARSE MATRIX TESTS ###

## Real positive definite tests, n must be even
%!shared n, k, A, d0, d2, old_state, restore_state
%! n = 20;
%! k = 4;
%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
%! d0 = eig (A);
%! d2 = sort (d0);
%! [~, idx] = sort (abs (d0));
%! d0 = d0(idx);
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
%!testif HAVE_ARPACK
%! d1 = eigs (A, k);
%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1);
%! assert (d1, d0(end:-1:(end-k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lm");
%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! d1 = eigs (A, k, "sm");
%! assert (d1, d0(k:-1:1), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "la");
%! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sa");
%! assert (d1, d2(1:k), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "be");
%! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1, "be");
%! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! d1 = eigs (A, k, 4.1);
%! [~, idx0] = sort (abs (d0 - 4.1));
%! [~, idx1] = sort (abs (d1 - 4.1));
%! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
%!testif HAVE_ARPACK, HAVE_CHOLMOD
%! d1 = eigs (A, speye (n), k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, speye (n), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! opts.cholB = true;
%! d1 = eigs (A, speye (n), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A * x;
%! opts.issym = 1;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "lm", opts);
%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A \ x;
%! opts.issym = 1;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "sm", opts);
%! assert (d1, d0(k:-1:1), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! fn = @(x) (A - 4.1 * eye (n)) \ x;
%! opts.issym = 1;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, 4.1, opts);
%! assert (d1, eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! AA = speye (10);
%! fn = @(x) AA * x;
%! opts.issym = 1;  opts.isreal = 1;
%! assert (eigs (fn, 10, AA, 3, "lm", opts), [1; 1; 1], 10*eps);
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! [v1,d1] = eigs (A, k, "sm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "la");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sa");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "be");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor

## Real unsymmetric tests
%!shared n, k, A, d0, old_state, restore_state
%! n = 20;
%! k = 4;
%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
%! d0 = eig (A);
%! [~, idx] = sort (abs (d0));
%! d0 = d0(idx);
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
%!testif HAVE_ARPACK
%! d1 = eigs (A, k);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1);
%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! d1 = eigs (A, k, "sm");
%! assert (abs (d1), abs (d0(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lr");
%! [~, idx] = sort (real (d0));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sr");
%! [~, idx] = sort (real (abs (d0)));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "li");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "si");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! d1 = eigs (A, k, 4.1);
%! [~, idx0] = sort (abs (d0 - 4.1));
%! [~, idx1] = sort (abs (d1 - 4.1));
%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
%!testif HAVE_ARPACK, HAVE_CHOLMOD
%! d1 = eigs (A, speye (n), k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, speye (n), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! opts.cholB = true;
%! d1 = eigs (A, speye (n), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! assert (sort (imag (eigs (A, k, 4.1))),
%!         sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A * x;
%! opts.issym = 0;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A \ x;
%! opts.issym = 0;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "sm", opts);
%! assert (abs (d1), d0(1:k), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! fn = @(x) (A - 4.1 * eye (n)) \ x;
%! opts.issym = 0;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! [v1,d1] = eigs (A, k, "sm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "li");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "si");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor


## Complex hermitian tests
%!shared n, k, A, d0, old_state, restore_state
%! n = 20;
%! k = 4;
%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
%! d0 = eig (A);
%! [~, idx] = sort (abs (d0));
%! d0 = d0(idx);
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
%!testif HAVE_ARPACK
%! d1 = eigs (A, k);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1);
%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! d1 = eigs (A, k, "sm");
%! assert (abs (d1), abs (d0(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lr");
%! [~, idx] = sort (real (abs (d0)));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sr");
%! [~, idx] = sort (real (abs (d0)));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "li");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "si");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! d1 = eigs (A, k, 4.1);
%! [~, idx0] = sort (abs (d0 - 4.1));
%! [~, idx1] = sort (abs (d1 - 4.1));
%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
%!testif HAVE_ARPACK, HAVE_CHOLMOD
%! d1 = eigs (A, speye (n), k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, speye (n), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! opts.cholB = true;
%! d1 = eigs (A, speye (n), k, 4.1, opts);
%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! assert (sort (imag (eigs (A, k, 4.1))),
%!         sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A * x;
%! opts.issym = 0;  opts.isreal = 0;
%! d1 = eigs (fn, n, k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A \ x;
%! opts.issym = 0;  opts.isreal = 0;
%! d1 = eigs (fn, n, k, "sm", opts);
%! assert (abs (d1), d0(1:k), 1e-11);
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! fn = @(x) (A - 4.1 * eye (n)) \ x;
%! opts.issym = 0;  opts.isreal = 0;
%! d1 = eigs (fn, n, k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK, HAVE_UMFPACK
%! [v1,d1] = eigs (A, k, "sm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "li");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "si");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = toeplitz (sparse (1:10));
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [v, d] = eigs (A, B, 4, "lm");
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%! ddiag = diag (d);
%! [ddiag, idx] = sort (ddiag);
%! v = v(:, idx);
%! R = chol (B);
%! [v1, d1] = eigs (R' \ A / R, 4, "lm");
%! d1diag = diag (d1);
%! [d1diag, idx] = sort (d1diag);
%! v1 = v1(:, idx);
%! assert (abs (v), abs (R \ v1), 1e-12);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = spdiags ([[1./(2:11)]',[-5:-2:-23]',[1:10]'],-1:1,10,10);
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [v, d] = eigs (A, B, 4, "lm");
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%! ddiag = diag (d);
%! [ddiag, idx] = sort (ddiag);
%! v = v(:, idx);
%! R = chol (B);
%! [v1, d1] = eigs (R' \ A / R, 4, "lm");
%! d1diag = diag (d1);
%! [d1diag, idx] = sort (d1diag);
%! v1 = v1(:, idx);
%! assert (abs (v), abs (R \ v1), 1e-12);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = spdiags ([[1./(2:11)]',[-5:-2:-23]',[1:10]'],-1:1,10,10) -...
%! 1i * spdiags ([[1./(2:11)]',[-5:-2:-23]',[1:10]'],-1:1,10,10);
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [v, d] = eigs (A, B, 4, "lm");
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%! ddiag = diag (d);
%! [ddiag, idx] = sort (ddiag);
%! v = v(:, idx);
%! R = chol (B);
%! [v1, d1] = eigs (R' \ A / R, 4, "lm");
%! d1diag = diag (d1);
%! [d1diag, idx] = sort (d1diag);
%! v1 = v1(:, idx);
%! assert (abs (v), abs (R \ v1), 1e-12);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = toeplitz (sparse (1:10));
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [v, d] = eigs (A, B, 4, 1);
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%! ddiag = diag (d);
%! [ddiag, idx] = sort (ddiag);
%! v = v(:, idx);
%! R = chol (B);
%! [v1, d1] = eigs (R' \ A / R, 4, 1);
%! d1diag = diag (d1);
%! [d1diag, idx] = sort (d1diag);
%! v1 = v1(:, idx);
%! assert (abs (v), abs (R \ v1), 1e-12);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = spdiags ([[1./(2:11)]',[-5:-2:-23]',[1:10]'],-1:1,10,10);
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [v, d] = eigs (A, B, 4, 1);
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%! ddiag = diag (d);
%! [ddiag, idx] = sort (ddiag);
%! v = v(:, idx);
%! R = chol (B);
%! [v1, d1] = eigs (R' \ A / R, 4, 1);
%! d1diag = diag (d1);
%! [d1diag, idx] = sort (d1diag);
%! v1 = v1(:, idx);
%! assert (abs (v), abs (R \ v1), 1e-12);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = spdiags ([[1./(2:11)]',[-5:-2:-23]',[1:10]'],-1:1,10,10) -...
%! 1i * spdiags ([[1./(2:11)]',[-5:-2:-23]',[1:10]'],-1:1,10,10);
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [v, d] = eigs (A, B, 4, 1);
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%! ddiag = diag (d);
%! [ddiag, idx] = sort (ddiag);
%! v = v(:, idx);
%! R = chol (B);
%! [v1, d1] = eigs (R' \ A / R, 4, 1);
%! d1diag = diag (d1);
%! [d1diag, idx] = sort (d1diag);
%! v1 = v1(:, idx);
%! assert (abs (v), abs (R \ v1), 1e-12);
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = toeplitz (sparse (1:10));
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! R = chol (B);
%! opts.cholB = true;
%! [v, d] = eigs (A, R, 4, "lm", opts);
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor
%!testif HAVE_ARPACK, HAVE_UMFPACK, HAVE_CHOLMOD
%! A = toeplitz (sparse (1:10));
%! B = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, 10));
%! [R, ~, permB] = chol (B, "vector");
%! opts.cholB = true;
%! opts.permB = permB;
%! [v, d] = eigs (A, R, 4, "lm", opts);
%! for i = 1:4
%!   assert (A * v(:,i), d(i, i) * B * v(:,i), 1e-12);
%! endfor

### FULL MATRIX TESTS ###

## Real positive definite tests, n must be even
%!shared n, k, A, d0, d2, old_state, restore_state
%! n = 20;
%! k = 4;
%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
%! d0 = eig (A);
%! d2 = sort (d0);
%! [~, idx] = sort (abs (d0));
%! d0 = d0(idx);
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
%!testif HAVE_ARPACK
%! d1 = eigs (A, k);
%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1);
%! assert (d1, d0(end:-1:(end-k)),1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lm");
%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sm");
%! assert (d1, d0(k:-1:1), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "la");
%! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sa");
%! assert (d1, d2(1:k), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "be");
%! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1, "be");
%! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, 4.1);
%! [~, idx0] = sort (abs (d0 - 4.1));
%! [~, idx1] = sort (abs (d1 - 4.1));
%! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, eye (n), k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, eye (n), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, eye (n), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A * x;
%! opts.issym = 1;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "lm", opts);
%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A \ x;
%! opts.issym = 1;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "sm", opts);
%! assert (d1, d0(k:-1:1), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) (A - 4.1 * eye (n)) \ x;
%! opts.issym = 1;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, 4.1, opts);
%! assert (d1, eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "la");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sa");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "be");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor

## Real unsymmetric tests
%!shared n, k, A, d0, old_state, restore_state
%! n = 20;
%! k = 4;
%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
%! d0 = eig (A);
%! [~, idx] = sort (abs (d0));
%! d0 = d0(idx);
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
%!testif HAVE_ARPACK
%! d1 = eigs (A, k);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1);
%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sm");
%! assert (abs (d1), abs (d0(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lr");
%! [~, idx] = sort (real (d0));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sr");
%! [~, idx] = sort (real (abs (d0)));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "li");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "si");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, 4.1);
%! [~, idx0] = sort (abs (d0 - 4.1));
%! [~, idx1] = sort (abs (d1 - 4.1));
%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, eye (n), k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, eye (n), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, eye (n), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
%!testif HAVE_ARPACK
%! assert (sort (imag (eigs (A, k, 4.1))),
%!         sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A * x;
%! opts.issym = 0;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A \ x;
%! opts.issym = 0;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, "sm", opts);
%! assert (abs (d1), d0(1:k), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) (A - 4.1 * eye (n)) \ x;
%! opts.issym = 0;  opts.isreal = 1;
%! d1 = eigs (fn, n, k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "li");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "si");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor

## Complex hermitian tests
%!shared n, k, A, d0, old_state, restore_state
%! n = 20;
%! k = 4;
%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
%! d0 = eig (A);
%! [~, idx] = sort (abs (d0));
%! d0 = d0(idx);
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
%!testif HAVE_ARPACK
%! d1 = eigs (A, k);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k+1);
%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sm");
%! assert (abs (d1), abs (d0(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "lr");
%! [~, idx] = sort (real (abs (d0)));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "sr");
%! [~, idx] = sort (real (abs (d0)));
%! d2 = d0(idx);
%! assert (real (d1), real (d2(1:k)), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "li");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, "si");
%! [~, idx] = sort (imag (abs (d0)));
%! d2 = d0(idx);
%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, k, 4.1);
%! [~, idx0] = sort (abs (d0 - 4.1));
%! [~, idx1] = sort (abs (d1 - 4.1));
%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
%!testif HAVE_ARPACK
%! d1 = eigs (A, eye (n), k, "lm");
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, eye (n), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! d1 = eigs (A, eye (n), k, 4.1, opts);
%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
%!testif HAVE_ARPACK
%! opts.cholB = true;
%! q = [2:n,1];
%! opts.permB = q;
%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
%!testif HAVE_ARPACK
%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
%!testif HAVE_ARPACK
%! assert (sort (imag (eigs (A, k, 4.1))),
%!         sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A * x;
%! opts.issym = 0;  opts.isreal = 0;
%! d1 = eigs (fn, n, k, "lm", opts);
%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) A \ x;
%! opts.issym = 0;  opts.isreal = 0;
%! d1 = eigs (fn, n, k, "sm", opts);
%! assert (abs (d1), d0(1:k), 1e-11);
%!testif HAVE_ARPACK
%! fn = @(x) (A - 4.1 * eye (n)) \ x;
%! opts.issym = 0;  opts.isreal = 0;
%! d1 = eigs (fn, n, k, 4.1, opts);
%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sm");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "lr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "sr");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "li");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "si");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor
%!testif HAVE_ARPACK
%! [v1,d1] = eigs (A, k, "li");
%! d1 = diag (d1);
%! for i=1:k
%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
%! endfor

%!testif HAVE_ARPACK
%! A = 2 * diag (ones (10, 1)) - diag (ones (9, 1), 1) - diag (ones (9, 1), -1);
%! B = eye (10);
%! reseig = eig (A, B);
%! [~, idx] = sort (abs (reseig), "ascend");
%! assert (eigs (A, B, 4, 0), reseig (idx(4:-1:1)), 8 * eps);
%!testif HAVE_ARPACK
%! A = eye (9);
%! A(1, 1) = 0;
%! A(1, 9) = 1;
%! [V, L] = eigs (A, 4, -1);
%! assert (! any (isnan (diag (L))));
%! assert (any (abs (diag (L)) <= 2 * eps));
%!testif HAVE_ARPACK
%! A = diag (ones (9, 1), 1);
%! A(10,:) = [-1, zeros(1, 8), -1];
%! opts.v0 = (1:10)';
%! typ = "lr";
%! [v, m] = eigs (A, 4, typ, opts);
%! assert (sort (real (diag (m))), ...
%!         [0.514038; 0.514038; 0.880290; 0.880290], 1e-4);
%! m = eigs (A, 4, typ, opts);
%! assert (sort (real (m)), ...
%!         [0.514038; 0.514038; 0.880290; 0.880290], 1e-4);
%! typ = "li";
%! [v, m] = eigs (A, 4, typ, opts);
%! assert (sort (abs (imag (diag (m)))), ...
%!         [0.78972; 0.78972; 0.96518; 0.96518], 1e-4);
%! m = eigs (A, 4, typ, opts);
%! assert (sort (abs (imag (m))), ...
%!         [0.78972; 0.78972; 0.96518; 0.96518], 1e-4);
%! typ = "sr";
%! [v, m] = eigs (A, 4, typ, opts);
%! assert (sort (real (diag (m))), ...
%!         [-1.12180; -1.12180; -0.69077; -0.69077], 1e-4);
%! m = eigs (A, 4, typ, opts);
%! assert (sort (real (m)), ...
%!         [-1.12180; -1.12180; -0.69077; -0.69077], 1e-4);
%! typ = "si";
%! [v, m] = eigs (A, 4, typ, opts);
%! assert (sort (abs (imag (diag (m)))), ...
%!         [0.25552; 0.25552; 0.30282; 0.30282], 1e-4);
%! m = eigs (A, 4, typ, opts);
%! assert (sort (abs (imag (m))), ...
%!         [0.25552; 0.25552; 0.30282; 0.30282], 1e-4);
%! typ = "lm";
%! [v, m] = eigs (A, 4, typ, opts);
%! assert (sort (abs (diag (m))), ...
%!         [1.02294;  1.02294; 1.15054; 1.15054], 1e-4);
%! m = eigs (A, 4, typ, opts);
%! assert (sort (abs (m)), ...
%!         [1.02294; 1.02294; 1.15054; 1.15054], 1e-4);
%! typ = "sm";
%! [v, m] = eigs (A, 4, typ, opts);
%! assert (sort (abs (diag (m))), ...
%!         [0.93092; 0.93092; 0.94228; 0.94228], 1e-4);
%! m = eigs (A, 4, typ, opts);
%! assert (sort (abs (m)), ...
%!         [0.93092; 0.93092; 0.94228; 0.94228], 1e-4);
%!testif HAVE_ARPACK
%! A = toeplitz (sparse ([2, 1, zeros(1,8)]));
%! opts.v0 = (1:10)';
%! [v, m] = eigs (A, 3, "sa", opts);
%! assert (diag (m), [0.081014; 0.317493; 0.690279], 1e-4);
%! m = eigs (A, 3, "sa", opts);
%! assert (m, [0.081014; 0.317493; 0.690279], 1e-4);

%!test
%! X = [70 47 42 39 50 73 79 23;
%!      19 52 61 80 36 76 63 68;
%!      14 34 66 65 29  4 72  9;
%!      24  8 78 49 58 54 43 33;
%!      62 69 32 31 40 46 22 28;
%!      48 12 45 59 10 17 15 25;
%!      64 67 77 56 13 55 41 74;
%!      37 38 18 21 11  3 71  7;
%!       5 35 16  1 51 27 26 44;
%!      30 57 60 75  2 53 20  6];
%! Z = X * X';
%! r = rank (Z);
%! assert (r, 8);
%! [V, D] = eigs (Z, r, "lm"); # call_eig is true
%! ZZ = V * D * V';
%! tmp = abs (Z - ZZ);
%! assert (max (tmp(:)) < 5e-11);

%!assert (eigs (diag (1:5), 5, "sa"), [1;2;3;4;5]) # call_eig is true
%!assert (eigs (diag (1:5), 5, "la"), [5;4;3;2;1]) # call_eig is true
%!assert (eigs (diag (1:5), 3, "be"), [1;4;5]) # call_eig is true
%!testif HAVE_ARPACK
%! A = toeplitz ([-2, 1, zeros(1, 8)]);
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! opts.v0 = (1:100)';
%! opts.maxit = 3;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 4, "lm", opts);
%! assert (d(3:4), [NaN; NaN]);
%!testif HAVE_ARPACK
%! A = toeplitz ([-2, 1, zeros(1, 8)]);
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! opts.v0 = (1:100)';
%! opts.maxit = 1;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 4, "sm", opts);
%! assert (d(4), NaN);
%!testif HAVE_ARPACK
%! A = toeplitz ([-2, 1, zeros(1, 8)]);
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! Afun = @(x) A * x;
%! opts.v0 = (1:100)';
%! opts.maxit = 3;
%! opts.issym = true;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (Afun, 100, 4, "sm", opts);
%! assert (d(3:4), [NaN; NaN]);
%!testif HAVE_ARPACK
%! A = toeplitz ([-2, 1, zeros(1, 8)]);
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! A(1, 2) = 10;
%! opts.v0 = (1:100)';
%! opts.maxit = 5;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 4, "lm", opts);
%! assert (d(3:4), [NaN; NaN]);
%!testif HAVE_ARPACK
%! A = toeplitz ([0, 1, zeros(1, 8)], [0, -1, zeros(1, 8)]);
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! opts.v0 = (1:100)';
%! opts.maxit = 4;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 4, "lm", opts);
%! assert (d(3:4), [NaN+1i*NaN; NaN+1i*NaN]);
%!testif HAVE_ARPACK
%! A = magic (100);
%! opts.v0 = (1:100)';
%! opts.maxit = 1;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 10, "lm", opts);
%! assert (d(9:10), [NaN; NaN]);
%!testif HAVE_ARPACK
%! A = toeplitz ([0, 1, zeros(1, 8)], [0, -1, zeros(1, 8)]);
%! A(1, 1) = 1;
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! opts.v0 = (1:100)';
%! opts.maxit = 1;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 4, "sm", opts);
%! if (isreal (d))
%!   assert (d(4), NaN);
%! else
%!   assert (d(4), NaN +1i*NaN);
%! endif
%!testif HAVE_ARPACK
%! A = magic (100) / 10 + eye (100);
%! opts.v0 = (1:100)';
%! opts.maxit = 10;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 10, "sm", opts);
%! if (isreal (d))
%!   assert (d(10), NaN);
%! else
%!   assert (d(10), NaN +1i*NaN);
%! endif
%!testif HAVE_ARPACK
%! A = toeplitz ([0, 1, zeros(1, 8)], [0, -1, zeros(1, 8)]);
%! A = kron (A, eye (10)) + kron (eye (10), A);
%! Afun = @(x) A * x;
%! opts.v0 = (1:100)';
%! opts.maxit = 4;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (Afun, 100, 4, "lm", opts);
%! assert (d(3:4), [NaN+1i*NaN; NaN+1i*NaN]);
%!testif HAVE_ARPACK
%! A = 1i * magic (100);
%! opts.v0 = (1:100)';
%! opts.maxit = 1;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 5, "lm", opts);
%! assert (d(5), NaN+1i*NaN);
%!testif HAVE_ARPACK
%! A = 1i * magic (100) + eye (100);
%! opts.v0 = (1:100)';
%! opts.maxit = 7;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (A, 10, "sm", opts);
%! assert (d(9:10), [NaN+1i*NaN; NaN+1i*NaN]);
%!testif HAVE_ARPACK
%! A = 1i * magic (100);
%! Afun = @(x) A * x;
%! opts.v0 = (1:100)';
%! opts.maxit = 1;
%! opts.isreal = false;
%! warning ("off", "Octave:eigs:UnconvergedEigenvalues", "local");
%! d = eigs (Afun, 100, 6, "lm", opts);
%! assert (d(6), NaN+1i*NaN);
%!testif HAVE_ARPACK, HAVE_CHOLMOD
%! A = sparse (magic (10));
%! B = sparse (magic (10)); # not HPD
%! fail ("eigs (A, B, 4)", "eigs: The matrix B is not positive definite")
%!testif HAVE_ARPACK
%! i_A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
%! j_A = [1, 2, 3, 4, 5, 6, 7,  8, 9, 10];
%! v_A = [1, 2i, 3, 4i, 5, 6i, 7, 8, 9, 10i];
%! A = sparse (i_A, j_A, v_A);
%! i_B = [1,2, 3, 4, 5, 6, 7, 8, 9, 10];
%! j_B = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
%! v_B = [3, 10i, 1, 8i, 7, 6i, 5, 4i, 9, 7i];
%! B = sparse (i_B, j_B, v_B); # not SPD
%! [Evectors, Evalues] = eigs(A, B, 5, "SM"); # call_eig is true
%! ResidualVectors = A * Evectors - B * Evectors * Evalues;
%! RelativeErrors = norm (ResidualVectors, "columns") ./ ...
%! norm (A * Evectors, "columns");
%! assert (RelativeErrors, zeros (1, 5));
%!testif HAVE_ARPACK
%! A = rand (8);
%! eigs (A, 6, "lr"); # this failed on 4.2.x
%!testif HAVE_ARPACK
%! M = magic (10);
%! A = sin (M);
%! B = cos (M);
%! B = B * B';
%! opts.v0 = (1:10)';
%! [Evector, Evalues] = eigs (A, B, 4, "LM", opts);
%! Afun = @(x) A * x;
%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "LM", opts);
%! assert (Evector, Evector_f);
%! assert (Evalues, Evalues_f);
%!testif HAVE_ARPACK
%! M = magic (10);
%! A = sin (M);
%! B = cos (M);
%! B = B * B';
%! opts.v0 = (1:10)';
%! [Evector, Evalues] = eigs (A, B, 4, "SM", opts);
%! [L, U, P] = lu (A);
%! Afun = @(x) U \ (L \ (P * x));
%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "SM", opts);
%! assert (Evector, Evector_f);
%! assert (Evalues, Evalues_f);
%!testif HAVE_ARPACK
%! M = magic (10);
%! A = sin (M);
%! A = A * A';
%! B = cos (M);
%! B = B * B';
%! opts.v0 = (1:10)';
%! [Evector, Evalues] = eigs (A, B, 4, "LM", opts);
%! Afun = @(x) A * x;
%! opts.issym = true;
%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "LM", opts);
%! assert (Evector, Evector_f);
%! assert (Evalues, Evalues_f);
%!testif HAVE_ARPACK
%! M = magic (10);
%! A = sin (M);
%! A = A * A';
%! B = cos (M);
%! B = B * B';
%! opts.v0 = (1:10)';
%! [Evector, Evalues] = eigs (A, B, 4, "SM", opts);
%! [L, U, P] = lu (A);
%! Afun = @(x) U \ (L \ (P * x));
%! opts.issym = true;
%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "SM", opts);
%! assert (Evector, Evector_f);
%! assert (Evalues, Evalues_f);
%!testif HAVE_ARPACK
%! M = magic (10);
%! A = sin (M) + 1i * cos (M);
%! B = cos (M) + 1i * sin (M);
%! B = B * B';
%! opts.v0 = (1:10)';
%! [Evector, Evalues] = eigs (A, B, 4, "LM", opts);
%! Afun = @(x) A * x;
%! opts.isreal = false;
%! [Evector_f Evalues_f] = eigs (Afun, 10, B, 4, "LM", opts);
%! assert (Evector, Evector_f);
%! assert (Evalues, Evalues_f);
%!testif HAVE_ARPACK
%! M = magic (10);
%! A = sin (M) + 1i * cos (M);
%! B = cos (M) + 1i * sin (M);
%! B = B * B';
%! opts.v0 = (1:10)';
%! [Evector, Evalues] = eigs (A, B, 4, "SM", opts);
%! [L, U, P] = lu (A);
%! Afun = @(x) U \ (L \ (P *x));
%! opts.isreal = false;
%! [Evector_f, Evalues_f] = eigs (Afun, 10, B, 4, "SM", opts);
%! assert (Evector, Evector_f);
%! assert (Evalues, Evalues_f);

%!testif HAVE_ARPACK <*57196>
%! x = ones (10, 10);
%! z = complex (x, x);
%! A = [sparse(10,10), z; z', sparse(10,10)];
%! d = eigs (A);
%! assert (isreal (d));
%! [~, d] = eigs (A);
%! assert (isreal (d));

%!testif HAVE_ARPACK <*59486>
%! A = magic (5);
%! d = eigs (A, [], 1);
%! assert (d, 65, 5 * eps (65));

%!testif HAVE_ARPACK <*59488>
%! A = zeros (20);
%! d = eigs (A, 4);
%! assert (d, zeros (4, 1));
%! [V, d, flag] = eigs (A, 4);
%! Vexp = zeros (20, 4);
%! Vexp(sub2ind (size (Vexp), 1:4, 1:4)) = 1;
%! assert (V, Vexp);
%! assert (d, diag (zeros (4,1)));
%! assert (flag, 0.0);

## Test input validation
%!error <Invalid call> eigs ()
%!error <second argument must be numeric> eigs (1, "foobar")
%!error <requested number of eigenvalues K \(2\) exceeds available eigenvalues \(1\)>
%! eigs (1, [], 2);
%!error <"la" requires real symmetric problem> eigs ([i,0;0,1], 1, "la")
%!error <"la" requires real symmetric problem> eigs ([1,1;0,1], 1, "la")
%!error <"sa" requires real symmetric problem> eigs ([i,0;0,1], 1, "sa")
%!error <"sa" requires real symmetric problem> eigs ([1,1;0,1], 1, "sa")
%!error <"be" requires real symmetric problem> eigs ([i,0;0,1], 1, "be")
%!error <"be" requires real symmetric problem> eigs ([1,1;0,1], 1, "be")
%!error <"lr" requires complex or unsymmetric> eigs ([1,0;0,1], 1, "lr")
%!error <"sr" requires complex or unsymmetric> eigs ([1,0;0,1], 1, "sr")
%!error <"li" requires complex or unsymmetric> eigs ([1,0;0,1], 1, "li")
%!error <"si" requires complex or unsymmetric> eigs ([1,0;0,1], 1, "si")
%!error <unrecognized value for SIGMA: foobar> eigs (eye (2), 1, "foobar")
%!testif HAVE_ARPACK
%! A = rand (10);
%! opts.v0 = ones (8, 1);
%! fail ("eigs (A, 4, 'sm', opts)", "opts.v0 must be n-by-1");
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} etreeplot (@var{A})
## @deftypefnx {} {} etreeplot (@var{A}, @var{node_style}, @var{edge_style})
## Plot the elimination tree of the matrix @var{A} or
## @tcode{@var{A}+@var{A}'} if @var{A} in not symmetric.
##
## The optional parameters @var{node_style} and @var{edge_style} define the
## output style.
## @seealso{treeplot, gplot}
## @end deftypefn

function etreeplot (A, varargin)

  if (nargin < 1 || nargin > 3)
    print_usage ();
  endif

  treeplot (etree (A+A'), varargin{:});

endfunction


## Test input validation
%!error <Invalid call> etreeplot ()
%!error <Invalid call> etreeplot (1,2,3,4)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
## @deftypefnx {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} gmres (@var{A}, @var{b}, @dots{})
## Solve @code{A x = b} using the Preconditioned GMRES iterative method with
## restart, a.k.a. PGMRES(restart).
##
## The input arguments are:
##
## @itemize @minus
##
## @item @var{A} is the matrix of the linear system and it must be square.
## @var{A} can be passed as a matrix, function handle, or inline
## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
## parameters to @code{Afun} are passed after @var{x0}.
##
## @item @var{b} is the right hand side vector.  It must be a column vector
## with the same numbers of rows as @var{A}.
##
## @item @var{restart} is the number of iterations before that the
## method restarts.  If it is [] or N = numel (b), then the restart
## is not applied.
##
## @item @var{tol} is the required relative tolerance for the
## preconditioned residual error,
## @code{inv (@var{M}) * (@var{b} - @var{a} * @var{x})}.  The iteration
## stops if @code{norm (inv (@var{M}) * (@var{b} - @var{a} * @var{x}))
## @leq{} @var{tol} * norm (inv (@var{M}) * @var{B})}.  If @var{tol} is
## omitted or empty, then a tolerance of 1e-6 is used.
##
## @item @var{maxit} is the maximum number of outer iterations, if not given or
## set to [], then the default value @code{min (10, @var{N} / @var{restart})}
## is used.
## Note that, if @var{restart} is empty, then @var{maxit} is the maximum number
## of iterations.  If @var{restart} and @var{maxit} are not empty, then
## the maximum number of iterations is @code{@var{restart} * @var{maxit}}.
## If both @var{restart} and @var{maxit} are empty, then the maximum
## number of iterations is set to @code{min (10, @var{N})}.
##
## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
## @var{M} is given as @code{M = M1 * M2}.  Both @var{M1} and @var{M2} can
## be passed as a matrix, function handle, or inline function @code{g} such
## that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.  If @var{M1} is [] or not
## given, then the preconditioner is not applied.
## The technique used is the left-preconditioning, i.e., it is solved
## @code{inv(@var{M}) * @var{A} * @var{x} = inv(@var{M}) * @var{b}} instead of
## @code{@var{A} * @var{x} = @var{b}}.
##
## @item @var{x0} is the initial guess,
## if not given or set to [], then the default value
## @code{zeros (size (@var{b}))} is used.
##
## @end itemize
##
## The arguments which follow @var{x0} are treated as parameters, and passed in
## a proper way to any of the functions (@var{A} or @var{M} or
## @var{M1} or @var{M2}) which are passed to @code{gmres}.
##
## The outputs are:
##
## @itemize @minus
##
## @item @var{x} the computed approximation.  If the method does not
## converge, then it is the iterated with minimum residual.
##
## @item @var{flag} indicates the exit status:
##
## @table @asis
## @item 0 : iteration converged to within the specified tolerance
##
## @item 1 : maximum number of iterations exceeded
##
## @item 2 : the preconditioner matrix is singular
##
## @item 3 : algorithm reached stagnation (the relative difference between two
## consecutive iterations is less than eps)
## @end table
##
## @item @var{relres} is the value of the relative preconditioned
## residual of the approximation @var{x}.
##
## @item @var{iter} is a vector containing the number of outer iterations and
## inner iterations performed to compute @var{x}.  That is:
##
## @itemize
## @item @var{iter(1)}: number of outer iterations, i.e., how many
## times the method restarted.  (if @var{restart} is empty or @var{N},
## then it is 1, if not 1 @leq{} @var{iter(1)} @leq{} @var{maxit}).
##
## @item @var{iter(2)}: the number of iterations performed before the
## restart, i.e., the method restarts when
## @code{@var{iter(2)} = @var{restart}}.  If @var{restart} is empty or
## @var{N}, then 1 @leq{} @var{iter(2)} @leq{} @var{maxit}.
## @end itemize
##
## To be more clear, the approximation @var{x} is computed at the iteration
## @code{(@var{iter(1)} - 1) * @var{restart} + @var{iter(2)}}.
## Since the output @var{x} corresponds to the minimal preconditioned
## residual solution, the total number of iterations that
## the method performed is given by @code{length (resvec) - 1}.
##
## @item @var{resvec} is a vector containing the preconditioned
## relative residual at each iteration, including the 0-th iteration
## @code{norm (@var{A} * @var{x0} - @var{b})}.
## @end itemize
##
## Let us consider a trivial problem with a tridiagonal matrix
##
## @example
## @group
## n = 20;
## A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
##     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
##     sparse (1, 2, 1, 1, n) * n / 2);
## b = A * ones (n, 1);
## restart = 5;
## [M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
## M = M1 * M2;
## Afun = @@(x) A * x;
## Mfun = @@(x) M \ x;
## M1fun = @@(x) M1 \ x;
## M2fun = @@(x) M2 \ x;
## @end group
## @end example
##
## @sc{Example 1:} simplest usage of @code{gmres}
##
## @example
## x = gmres (A, b, [], [], n)
## @end example
##
## @sc{Example 2:} @code{gmres} with a function which computes
## @code{@var{A} * @var{x}}
##
## @example
## x = gmres (Afun, b, [], [], n)
## @end example
##
## @sc{Example 3:} usage of @code{gmres} with the restart
##
## @example
## x = gmres (A, b, restart);
## @end example
##
## @sc{Example 4:} @code{gmres} with a preconditioner matrix @var{M}
## with and without restart
##
## @example
## @group
## x = gmres (A, b, [], 1e-06, n, M)
## x = gmres (A, b, restart, 1e-06, n, M)
## @end group
## @end example
##
## @sc{Example 5:} @code{gmres} with a function as preconditioner
##
## @example
## x = gmres (Afun, b, [], 1e-6, n, Mfun)
## @end example
##
## @sc{Example 6:} @code{gmres} with preconditioner matrices @var{M1}
## and @var{M2}
##
## @example
## x = gmres (A, b, [], 1e-6, n, M1, M2)
## @end example
##
## @sc{Example 7:} @code{gmres} with functions as preconditioners
##
## @example
## x = gmres (Afun, b, 1e-6, n, M1fun, M2fun)
## @end example
##
## @sc{Example 8:} @code{gmres} with as input a function requiring an argument
##
## @example
## @group
##   function y = Ap (A, x, p) # compute A^p * x
##      y = x;
##      for i = 1:p
##        y = A * y;
##      endfor
##   endfunction
## Apfun = @@(x, p) Ap (A, x, p);
## x = gmres (Apfun, b, [], [], [], [], [], [], 2);
## @end group
## @end example
##
## @sc{Example 9:} explicit example to show that @code{gmres} uses a
## left preconditioner
##
## @example
## @group
## [M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
## M = M1 * M2;
##
## ## reference solution computed by gmres after two iterations
## [x_ref, fl] = gmres (A, b, [], [], 1, M)
##
## ## left preconditioning
## [x, fl] = gmres (M \ A, M \ b, [], [], 1)
## x # compare x and x_ref
##
## @end group
## @end example
##
## Reference:
##
## @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear
## Systems}, Second edition, 2003, SIAM
##
## @seealso{bicg, bicgstab, cgs, pcg, pcr, qmr, tfqmr}
## @end deftypefn


function [x_min, flag, relres, it, resvec] = ...
         gmres (A, b, restart = [], tol = [], maxit = [], M1 = [],
                M2 = [], x0 = [], varargin)

  if (strcmp (class (A), "single") || strcmp (class (b), "single"))
    class_name = "single";
  else
    class_name = "double";
  endif

  [Afun, M1fun, M2fun] = __alltohandles__ (A, b, M1, M2, "gmres");

  ## Check if the inputs are empty, and in case set them
  [tol, x0] = __default__input__ ({1e-06, zeros(size (b))}, tol, x0);

  empty_restart = isempty (restart);
  empty_maxit = isempty (maxit);
  size_b = rows (b);

  if (tol >= 1)
    warning ("Input tol is bigger than 1. \n Try to use a smaller tolerance.");
  elseif (tol <= eps / 2)
    warning ("Input tol may not be achievable by gmres. \n Try to use a bigger tolerance.");
  endif

  ## This big "if block" is to set maxit and restart in the proper way

  if ((empty_restart) && (empty_maxit))
    restart = size_b;
    maxit = 1;
    max_iter_number = min (size_b, 10);
  elseif (restart <= 0) || (maxit <= 0)
    error ("gmres: MAXIT and RESTART must be positive integers");
  elseif (restart < size_b) && (empty_maxit)
    maxit = min (size_b / restart, 10);
    max_iter_number = maxit * restart;
  elseif (restart == size_b) && (empty_maxit)
    maxit = 1;
    max_iter_number = min (size_b, 10);
  elseif (restart > size_b) && (empty_maxit)
    warning ("RESTART is %d but it should be bounded by SIZE(A,2).\n Setting restart to %d. \n", restart, size_b);
    restart = size_b;
    maxit = 1;
    max_iter_number = restart;
  elseif (empty_restart) && (maxit <= size_b)
    restart = size_b;
    max_iter_number = maxit;
  elseif (empty_restart) && (maxit > size_b)
    warning ("MAXIT is %d but it should be bounded by SIZE(A,2). \n Setting MAXIT to %d", maxit, size_b);
    restart = size_b;
    maxit = size_b;
    max_iter_number = size_b;
  elseif (restart > size_b) && (! empty_maxit)
    warning ("RESTART is %d but it should be bounded by SIZE(A,2).\n Setting restart to %d. \n", restart, size_b);
    restart = size_b;
    max_iter_number = restart * maxit;
  elseif (restart == size_b) && (maxit <= size_b)
    max_iter_number = maxit;
  else
    max_iter_number = restart*maxit;
  endif

  prec_b_norm = norm (b, 2);
  if (prec_b_norm == 0)
    if (nargout < 2)
      printf ("The right hand side vector is all zero so gmres\nreturned an all zero solution without iterating.\n")
    endif
    x_min = b;
    flag = 0;
    relres = 0;
    resvec = 0;
    it = [0, 0];
    return;
  endif

  ## gmres: function handle case

  x_old = x_pr = x_min = x = x0;
  B = zeros (restart + 1, 1);
  V = zeros (rows (x), restart, class_name);
  H = zeros (restart + 1, restart);

  iter = 1; # total number of iterations
  iter_min = 0; # iteration with minimum residual
  outer_it = 1; # number of outer iterations
  restart_it  =  1; # number of inner iterations
  it = zeros (1, 2);
  resvec = zeros (max_iter_number + 1, 1);
  flag = 1; # Default flag is maximum # of iterations exceeded

  ## begin loop
  u = feval (Afun, x_old, varargin{:});
  try
    warning ("error", "Octave:singular-matrix", "local");
    prec_res = feval (M1fun, b - u, varargin{:});  # M1*(b-u)
    prec_res = feval (M2fun, prec_res, varargin{:});
    presn = norm (prec_res, 2);
    resvec(1) = presn;
    z = feval (M1fun, b, varargin{:});
    z = feval (M2fun, z, varargin{:});
    prec_b_norm = norm (z, 2);
    B (1) = presn;
    V(:, 1) = prec_res / presn;
  catch
    flag = 2;
  end_try_catch

  while (flag != 2) && (iter <= max_iter_number) && ...
        (presn > tol * prec_b_norm)
    ## restart
    if (restart_it > restart)
      restart_it = 1;
      outer_it += 1;
      x_old = x;
      u = feval (Afun, x_old, varargin{:});
      prec_res = feval (M1fun, b - u, varargin{:});
      prec_res = feval (M2fun, prec_res, varargin{:});
      presn = norm (prec_res, 2);
      B(1) = presn;
      H(:) = 0;
      V(:, 1) = prec_res / presn;
    endif
    ## basic iteration
    u = feval (Afun, V(:, restart_it), varargin{:});
    tmp = feval (M1fun, u, varargin{:});
    tmp = feval (M2fun, tmp, varargin{:});
    [V(:,restart_it + 1), H(1:restart_it + 1, restart_it)] = ...
      mgorth (tmp, V(:,1:restart_it));
    Y = (H(1:restart_it + 1, 1:restart_it) \ B(1:restart_it + 1));
    little_res = B(1:restart_it + 1) - ...
                 H(1:restart_it + 1, 1:restart_it) * Y(1:restart_it);
    presn = norm (little_res, 2);
    x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
    resvec(iter + 1) = presn;
    if (norm (x - x_pr) <= eps*norm (x))
      flag = 3; # Stagnation: little change between iterations
      break;
    endif
    if (resvec (iter + 1) <= resvec (iter_min + 1))
      x_min = x;
      iter_min = iter;
      it = [outer_it, restart_it];
    endif
    x_pr = x;
    restart_it += 1;
    iter += 1;
  endwhile

  if (flag == 2)
    resvec = norm (b);
    relres = 1;
  else
    resvec = resvec (1:iter);
    relres = resvec (iter) / prec_b_norm;
  endif

  if ((relres <= tol) && (flag == 1))
    flag = 0;  # Converged to solution within tolerance
  endif

  if ((nargout < 2) && (restart != size_b)) # restart applied
    switch (flag)
      case {0} # gmres converged
        printf ("gmres (%d) converged at outer iteration %d (inner iteration %d) ",restart, it (1), it (2));
        printf ("to a solution with relative residual %d \n", relres);
      case {1} # max number of iteration reached
        printf ("gmres (%d) stopped at outer iteration %d (inner iteration %d) ", restart, outer_it, restart_it-1);
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because the maximum number of iterations was reached \n");
        printf ("The iterated returned (number %d(%d)) ", it(1), it(2));
        printf ("has relative residual %d \n", relres);
      case {2} # preconditioner singular
        printf ("gmres (%d) stopped at outer iteration %d (inner iteration %d) ",restart, outer_it, restart_it-1);
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because the preconditioner matrix is singular \n");
        printf ("The iterated returned (number %d(%d)) ", it(1), it(2));
        printf ("has relative residual %d \n", relres);
      case {3} # stagnation
        printf ("gmres (%d) stopped at outer iteration %d (inner iteration %d) ", restart, outer_it, restart_it - 1);
        printf ("without converging to the desired tolerance %d", tol);
        printf ("because it stagnates. \n");
        printf ("The iterated returned (number %d(%d)) ", it(1), it(2));
        printf ("has relative residual %d \n", relres);
    endswitch
  elseif ((nargout < 2) && (restart == size_b)) # no restart
    switch (flag)
      case {0} # gmres converged
        printf ("gmres converged at iteration %d ", it(2));
        printf ("to a solution with relative residual %d \n", relres);
      case {1} # max number of iteration reached
        printf ("gmres stopped at iteration %d ", restart_it - 1);
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because the maximum number of iterations was reached \n");
        printf ("The iterated returned (number %d) ", it(2));
        printf ("has relative residual %d \n", relres);
      case {2} # preconditioner ill-conditioned
        printf ("gmres stopped at iteration %d ", restart_it - 1);
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because the preconditioner matrix is singular \n")
        printf ("The iterated returned (number %d) ", it (2));
        printf ("has relative residual %d \n", relres);
      case {3} # stagnation
        printf ("gmres stopped at iteration %d ", restart_it - 1);
        printf ("without converging at the desired tolerance %d ", tol);
        printf ("because it stagnates\n");
        printf ("The iterated returned (number %d) ", it(2));
        printf ("has relative residual %d \n", relres);
    endswitch
  endif

endfunction


%!demo
%! dim = 20;
%! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
%! b = ones (dim, 1);
%! [x, flag, relres, iter, resvec] = ...
%!   gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b)

%!demo # simplest use
%! n = 20;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!     sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! restart = 5;
%! [M1, M2] = ilu (A + 0.1 * eye (n));
%! M = M1 * M2;
%! x = gmres (A, b, [], [], n);
%! x = gmres (A, b, restart, [], n);  # gmres with restart
%! Afun = @(x) A * x;
%! x = gmres (Afun, b, [], [], n);
%! x = gmres (A, b, [], 1e-6, n, M);  # gmres without restart
%! x = gmres (A, b, [], 1e-6, n, M1, M2);
%! Mfun = @(x) M \ x;
%! x = gmres (Afun, b, [], 1e-6, n, Mfun);
%! M1fun = @(x) M1 \ x;
%! M2fun = @(x) M2 \ x;
%! x = gmres (Afun, b, [], 1e-6, n, M1fun, M2fun);
%! function y = Ap (A, x, p)  # compute A^p * x
%!    y = x;
%!    for i = 1:p
%!      y = A * y;
%!    endfor
%!  endfunction
%! Afun = @(x, p) Ap (A, x, p);
%! x = gmres (Afun, b, [], [], n, [], [], [], 2);  # solution of A^2 * x = b

%!demo
%! n = 10;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!     sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.1 * eye (n));  # factorization of A perturbed
%! M = M1 * M2;
%!
%! ## reference solution computed by gmres after one iteration
%! [x_ref, fl] = gmres (A, b, [], [], 1, M);
%! x_ref
%!
%! ## left preconditioning
%! [x, fl] = gmres (M \ A, M \ b, [], [], 1);
%! x # compare x and x_ref

%!test
%! ## Check that all type of inputs work
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M1 = diag (sqrt (diag (A)));
%! M2 = M1;
%! Afun = @(z) A * z;
%! M1_fun = @(z) M1 \ z;
%! M2_fun = @(z) M2 \ z;
%! [x, flag] = gmres (A, b);
%! assert (flag, 0);
%! [x, flag] = gmres (A, b, [], [], [], M1, M2);
%! assert (flag, 0);
%! [x, flag] = gmres (A, b, [], [], [], M1_fun, M2_fun);
%! assert (flag, 0);
%! [x, flag] = gmres (A, b, [], [], [], M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = gmres (A, b, [], [], [], M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = gmres (Afun, b);
%! assert (flag, 0);
%! [x, flag] = gmres (Afun, b, [],[],[], M1, M2);
%! assert (flag, 0);
%! [x, flag] = gmres (Afun, b, [],[],[], M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = gmres (Afun, b, [],[],[], M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = gmres (Afun, b, [],[],[], M1_fun, M2_fun);
%! assert (flag, 0);

%!test
%! dim = 100;
%! A = spdiags ([-ones(dim,1), 2*ones(dim,1), ones(dim,1)], [-1:1], dim, dim);
%! b = ones (dim, 1);
%! [x, flag] = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b);
%! assert (x, A\b, 1e-9*norm (x, Inf));
%! [x, flag] = gmres (A, b, dim, 1e-10, 1e4, @(x) diag (diag (A)) \ x, [], b);
%! assert (x, A\b, 1e-7*norm (x, Inf));

%!test
%! dim = 100;
%! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); ...
%!               [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
%! A = A'*A;
%! b = rand (dim, 1);
%! [x, resvec] = gmres (@(x) A*x, b, dim, 1e-10, dim, ...
%!                      @(x) x./diag (A), [], []);
%! assert (x, A\b, 1e-9*norm (x, Inf));
%! [x, flag] = gmres (@(x) A*x, b, dim, 1e-10, 1e5, ...
%!                    @(x) diag (diag (A)) \ x, [], []);
%! assert (x, A\b, 1e-9*norm (x, Inf));
%! [x, flag] = gmres (@(x) A*x, b, dim, 1e-10, 1e5, ...
%!                    @(x) x ./ diag (A), [], []);
%! assert (x, A\b, 1e-7*norm (x, Inf));

%!test
%! ## gmres solves complex linear systems
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0])) + ...
%!     1i * toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! [x, flag] = gmres(A, b, [], [], 5);
%! assert (flag, 0);
%! assert (x, ones (5, 1), -1e-6);

%!test
%! ## Maximum number of iteration reached
%! A = hilb (100);
%! b = sum (A, 2);
%! [x, flag, relres, iter] = gmres (A, b, [], 1e-14);
%! assert (flag, 1);

%!test
%! ## gmres recognizes that the preconditioner matrix is singular
%! AA = 2 * eye (3);
%! bb = ones (3, 1);
%! I = eye (3);
%! M = [1 0 0; 0 1 0; 0 0 0];  # the last row is zero
%! [x, flag] = gmres (@(y) AA * y, bb, [], [], [], @(y) M \ y, @(y) y);
%! assert (flag, 2);

%!test
%! A = rand (4);
%! A = A' * A;
%! [x, flag] = gmres (A, zeros (4, 1), [], [], [], [], [], ones (4, 1));
%! assert (x, zeros (4, 1));

%!test
%! A = rand (4);
%! b = zeros (4, 1);
%! [x, flag, relres, iter] = gmres (A, b);
%! assert (relres, 0);

%!test
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = A * ones (5, 1);
%! [x, flag, relres, iter] = gmres (A, b, [], [], [], [], [], ...
%!                                  ones (5, 1) + 1e-8);
%! assert (iter, [0, 0]);

%!test
%! A = rand (20);
%! b = A * ones (20, 1);
%! [x, flag, relres, iter, resvec] = gmres (A, b, [], [], 1);
%! assert (iter, [1, 1]);

%!test
%! A = hilb (20);
%! b = A * ones (20, 1);
%! [x, flag, relres, iter, resvec] = gmres (A, b ,5, 1e-14);
%! assert (iter, [4, 5]);

%!test
%! A = single (1);
%! b = 1;
%! [x, flag] = gmres (A, b);
%! assert (class (x), "single");

%!test
%! A = 1;
%! b = single (1);
%! [x, flag] = gmres (A, b);
%! assert (class (x), "single");

%!test
%! A = single (1);
%! b = single (1);
%! [x, flag] = gmres (A, b);
%! assert (class (x), "single");

%!test
%!function y = Afun (x)
%!   A = toeplitz ([2, 1, 0, 0], [2, -1, 0, 0]);
%!   y = A * x;
%!endfunction
%! [x, flag] = gmres ("Afun", [1; 2; 2; 3]);
%! assert (x, ones (4, 1), 1e-6);

%!test # preconditioned residual
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = magic (5);
%! [x, flag, relres] = gmres (A, b, [], [], 2, M);
%! assert (relres, norm (M \ (b - A * x)) / norm (M \ b), 8 * eps);
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} gplot (@var{A}, @var{xy})
## @deftypefnx {} {} gplot (@var{A}, @var{xy}, @var{line_style})
## @deftypefnx {} {[@var{x}, @var{y}] =} gplot (@var{A}, @var{xy})
## Plot a graph defined by @var{A} and @var{xy} in the graph theory sense.
##
## @var{A} is the adjacency matrix of the array to be plotted and @var{xy} is
## an @var{n}-by-2 matrix containing the coordinates of the nodes of the graph.
##
## The optional parameter @var{line_style} defines the output style for the
## plot.  Called with no output arguments the graph is plotted directly.
## Otherwise, return the coordinates of the plot in @var{x} and @var{y}.
## @seealso{treeplot, etreeplot, spy}
## @end deftypefn

function [x, y] = gplot (A, xy, line_style)

  if (nargin < 2)
    print_usage ();
  endif

  if (nargin == 2)
    line_style = "-";
  endif

  [i, j] = find (A);
  xcoord = [xy(i,1), xy(j,1), NaN(length(i),1) ]'(:);
  ycoord = [xy(i,2), xy(j,2), NaN(length(i),1) ]'(:);

  if (nargout == 0)
    plot (xcoord, ycoord, line_style);
  else
    x = xcoord;
    y = ycoord;
  endif

endfunction


%!demo
%! ## Binary Tree Representation
%! A = [0 1 0 0 0 0 0
%!      1 0 1 1 0 0 0
%!      0 1 0 0 0 0 0
%!      0 1 0 0 1 0 0
%!      0 0 0 1 0 1 1
%!      0 0 0 0 1 0 0
%!      0 0 0 0 1 0 0];
%!
%! xy = [1  , 0
%!       1.5, 1
%!       2  , 0
%!       2.5, 2
%!       3.5, 1
%!       3  , 0
%!       4  , 0];
%!
%! clf;
%! gplot (A, xy, "o-");
%! set (get (gca, ("children")), "markersize", 12);
%! title ("gplot() of Binary Tree Adjacency matrix");

## Mark graphical function as tested by demo block
%!assert (1)
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{L} =} ichol (@var{A})
## @deftypefnx {} {@var{L} =} ichol (@var{A}, @var{opts})
##
## Compute the incomplete Cholesky factorization of the sparse square matrix
## @var{A}.
##
## By default, @code{ichol} uses only the lower triangle of @var{A} and
## produces a lower triangular factor @var{L} such that @tcode{L*L'}
## approximates @var{A}.
##
## The factor given by this routine may be useful as a preconditioner for a
## system of linear equations being solved by iterative methods such as
## PCG (Preconditioned Conjugate Gradient).
##
## The factorization may be modified by passing options in a structure
## @var{opts}.  The option name is a field of the structure and the setting
## is the value of field.  Names and specifiers are case sensitive.
##
## @table @asis
## @item type
## Type of factorization.
##
## @table @asis
## @item @qcode{"nofill"} (default)
## Incomplete Cholesky factorization with no fill-in (@nospell{IC(0)}).
##
## @item @qcode{"ict"}
## Incomplete Cholesky factorization with threshold dropping (@nospell{ICT}).
## @end table
##
## @item diagcomp
## A non-negative scalar @var{alpha} for incomplete Cholesky factorization of
## @code{@var{A} + @var{alpha} * diag (diag (@var{A}))} instead of @var{A}.
## This can be useful when @var{A} is not positive definite.  The default value
## is 0.
##
## @item droptol
## A non-negative scalar specifying the drop tolerance for factorization if
## performing @nospell{ICT}@.  The default value is 0 which produces the
## complete Cholesky factorization.
##
## Non-diagonal entries of @var{L} are set to 0 unless
##
## @code{abs (@var{L}(i,j)) >= droptol * norm (@var{A}(j:end, j), 1)}.
##
## @item michol
## Modified incomplete Cholesky factorization:
##
## @table @asis
## @item @qcode{"off"} (default)
## Row and column sums are not necessarily preserved.
##
## @item @qcode{"on"}
## The diagonal of @var{L} is modified so that row (and column) sums are
## preserved even when elements have been dropped during the factorization.
## The relationship preserved is: @code{@var{A} * e = @var{L} * @var{L}' * e},
## where e is a vector of ones.
## @end table
##
## @item shape
##
## @table @asis
## @item @qcode{"lower"} (default)
## Use only the lower triangle of @var{A} and return a lower triangular factor
## @var{L} such that @tcode{L*L'} approximates @var{A}.
##
## @item @qcode{"upper"}
## Use only the upper triangle of @var{A} and return an upper triangular factor
## @var{U} such that @code{U'*U} approximates @var{A}.
## @end table
## @end table
##
## EXAMPLES
##
## The following problem demonstrates how to factorize a sample symmetric
## positive definite matrix with the full Cholesky decomposition and with the
## incomplete one.
##
## @example
## @group
## A = [ 0.37, -0.05,  -0.05,  -0.07;
##      -0.05,  0.116,  0.0,   -0.05;
##      -0.05,  0.0,    0.116, -0.05;
##      -0.07, -0.05,  -0.05,   0.202];
## A = sparse (A);
## nnz (tril (A))
## ans =  9
## L = chol (A, "lower");
## nnz (L)
## ans =  10
## norm (A - L * L', "fro") / norm (A, "fro")
## ans =  1.1993e-16
## opts.type = "nofill";
## L = ichol (A, opts);
## nnz (L)
## ans =  9
## norm (A - L * L', "fro") / norm (A, "fro")
## ans =  0.019736
## @end group
## @end example
##
## Another example for decomposition is a finite difference matrix used to
## solve a boundary value problem on the unit square.
##
## @example
## @group
## nx = 400; ny = 200;
## hx = 1 / (nx + 1); hy = 1 / (ny + 1);
## Dxx = spdiags ([ones(nx, 1), -2*ones(nx, 1), ones(nx, 1)],
##                [-1 0 1 ], nx, nx) / (hx ^ 2);
## Dyy = spdiags ([ones(ny, 1), -2*ones(ny, 1), ones(ny, 1)],
##                [-1 0 1 ], ny, ny) / (hy ^ 2);
## A = -kron (Dxx, speye (ny)) - kron (speye (nx), Dyy);
## nnz (tril (A))
## ans =  239400
## opts.type = "nofill";
## L = ichol (A, opts);
## nnz (tril (A))
## ans =  239400
## norm (A - L * L', "fro") / norm (A, "fro")
## ans =  0.062327
## @end group
## @end example
##
## References for implemented algorithms:
##
## [1] @nospell{Y. Saad}. "Preconditioning Techniques." @cite{Iterative
## Methods for Sparse Linear Systems}, @nospell{PWS} Publishing Company, 1996.
##
## [2] @nospell{M. Jones, P. Plassmann}: @cite{An Improved Incomplete
## Cholesky Factorization}, 1992.
## @seealso{chol, ilu, pcg}
## @end deftypefn

function L = ichol (A, opts = struct ())

  if (nargin < 1)
    print_usage ();
  endif

  if (! (issparse (A) && issquare (A)))
    error ("ichol: A must be a sparse square matrix");
  endif

  if (! isstruct (opts))
    error ("ichol: OPTS must be a structure");
  endif

  ## If A is empty then return empty L for Matlab compatibility
  if (isempty (A))
    L = A;
    return;
  endif

  ## Parse input options
  if (! isfield (opts, "type"))
    opts.type = "nofill";  # set default
  else
    type = tolower (getfield (opts, "type"));
    if (! strcmp (type, "nofill") && ! strcmp (type, "ict"))
      error ('ichol: TYPE must be "nofill" or "ict"');
    endif
    opts.type = type;
  endif

  if (! isfield (opts, "droptol"))
    opts.droptol = 0;      # set default
  else
    if (! (isreal (opts.droptol) && isscalar (opts.droptol)
           && opts.droptol >= 0))
      error ("ichol: DROPTOL must be a non-negative real scalar");
    endif
  endif

  michol = "";
  if (! isfield (opts, "michol"))
    opts.michol = "off";   # set default
  else
    michol = tolower (getfield (opts, "michol"));
    if (! strcmp (michol, "off") && ! strcmp (michol, "on"))
      error ('ichol: MICHOL must be "on" or "off"');
    endif
    opts.michol = michol;
  endif

  if (! isfield (opts, "diagcomp"))
    opts.diagcomp = 0;     # set default
  else
    if (! (isreal (opts.diagcomp) && isscalar (opts.diagcomp)
           && opts.diagcomp >= 0))
      error ("ichol: DIAGCOMP must be a non-negative real scalar");
    endif
  endif

  if (! isfield (opts, "shape"))
    opts.shape = "lower";  # set default
  else
    shape = tolower (getfield (opts, "shape"));
    if (! strcmp (shape, "lower") && ! strcmp (shape, "upper"))
      error ('ichol: SHAPE must be "lower" or "upper"');
    endif
    opts.shape = shape;
  endif

  ## Prepare input for specialized ICHOL
  A_in = [];
  if (opts.diagcomp > 0)
    A += opts.diagcomp * diag (diag (A));
  endif
  if (strcmp (opts.shape, "upper"))
    A_in = triu (A);
    A_in = A_in';
  else
    A_in = tril (A);
  endif

  ## Delegate to specialized ICHOL
  switch (opts.type)
    case "nofill"
      L = __ichol0__ (A_in, opts.michol);
    case "ict"
      L = __icholt__ (A_in, opts.droptol, opts.michol);
  endswitch

  if (strcmp (opts.shape, "upper"))
    L = L';
  endif

endfunction


%!shared A1, A2, A3, A4, A5, A6, A7
%! A1 = [ 0.37, -0.05,  -0.05,  -0.07;
%!       -0.05,  0.116,  0.0,   -0.05;
%!       -0.05,  0.0,    0.116, -0.05;
%!       -0.07, -0.05,  -0.05,   0.202];
%! A1 = sparse (A1);
%! A2 = gallery ("poisson", 30);
%! A3 = gallery ("tridiag", 50);
%! nx = 400; ny = 200;
%! hx = 1 / (nx + 1); hy = 1 / (ny + 1);
%! Dxx = spdiags ([ones(nx, 1), -2*ones(nx, 1), ones(nx, 1)],
%!                [-1 0 1 ], nx, nx) / (hx ^ 2);
%! Dyy = spdiags ([ones(ny, 1), -2*ones(ny, 1), ones(ny, 1)],
%!                [-1 0 1 ], ny, ny) / (hy ^ 2);
%! A4 = -kron (Dxx, speye (ny)) - kron (speye (nx), Dyy);
%! A5 = [ 0.37, -0.05,         -0.05,  -0.07;
%!       -0.05,  0.116,         0.0,   -0.05 + 0.05i;
%!       -0.05,  0.0,           0.116, -0.05;
%!       -0.07, -0.05 - 0.05i, -0.05,   0.202];
%! A5 = sparse (A5);
%! A6 = [ 0.37,     -0.05 - i, -0.05,  -0.07;
%!       -0.05 + i,  0.116,     0.0,   -0.05;
%!       -0.05,      0.0,       0.116, -0.05;
%!       -0.07,     -0.05,     -0.05,   0.202];
%! A6 = sparse (A6);
%! A7 = A5;
%! A7(1) = 2i;

## ICHOL0 tests

%!test
%! opts.type = "nofill";
%! opts.michol = "off";
%! assert (nnz (tril (A1)), nnz (ichol (A1, opts)));
%! assert (nnz (tril (A2)), nnz (ichol (A2, opts)));
%! assert (nnz (tril (A3)), nnz (ichol (A3, opts)));
%! assert (nnz (tril (A4)), nnz (ichol (A4, opts)));
%! assert (nnz (tril (A5)), nnz (ichol (A5, opts)));
%!
%!test
%! opts.type = "nofill";
%! opts.michol = "off";
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.0197, 1e-4);
%! opts.shape = "upper";
%! U = ichol (A1, opts);
%! assert (norm (A1 - U' * U, "fro") / norm (A1, "fro"), 0.0197, 1e-4);
%! opts.shape = "lower";
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.0197, 1e-4);
%!
%!test
%! opts.michol = "on";
%! opts.shape = "lower";
%! opts.type = "nofill";
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.0279, 1e-4);
%! opts.shape = "upper";
%! U = ichol (A1, opts);
%! assert (norm (A1 - U' * U, "fro") / norm (A1, "fro"), 0.0279, 1e-4);
%! opts.shape = "lower";
%! opts.diagcomp = 3e-3;
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.0272, 1e-4);
%!
%!test
%! opts.type = "nofill";
%! opts.michol = "off";
%! L = ichol (A2, opts);
%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.0893, 1e-4);
%! opts.michol = "on";
%! L = ichol (A2, opts);
%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.2377, 1e-4);
%!
%!test
%! opts.type = "nofill";
%! opts.michol = "off";
%! L = ichol (A3, opts);
%! assert (norm (A3 - L*L', "fro") / norm (A3, "fro"), eps, eps);
%! opts.michol = "on";
%! L = ichol (A3, opts);
%! assert (norm (A3 - L*L', "fro") / norm (A3, "fro"), eps, eps);
%!
%!test
%! opts.type = "nofill";
%! opts.michol = "off";
%! L = ichol (A4, opts);
%! assert (norm (A4 - L*L', "fro") / norm (A4, "fro"), 0.0623, 1e-4);
%! opts.michol = "on";
%! L = ichol (A4, opts);
%! assert (norm (A4 - L*L', "fro") / norm (A4, "fro"), 0.1664, 1e-4);
%!
%!test
%! opts.type = "nofill";
%! opts.michol = "off";
%! L = ichol (A5, opts);
%! assert (norm (A5 - L*L', "fro") / norm (A5, "fro"), 0.0195, 1e-4);
%! opts.michol = "on";
%! L = ichol (A5, opts);
%! assert (norm (A5 - L*L', "fro") / norm (A5, "fro"), 0.0276, 1e-4);

## Negative pivot
%!error <negative pivot> ichol (A6)
%!error ichol (A6)
## Complex entry in the diagonal
%!error <non-real pivot> ichol (A7)

## ICHOLT tests

#%!test
%! opts.type = "ict";
%! opts.droptol = 1e-1;
%! opts.michol = "off";
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.2065, 1e-4);
%! opts.shape = "upper";
%! U = ichol (A1, opts);
%! assert (norm (A1 - U' * U, "fro") / norm (A1, "fro"), 0.2065, 1e-4);
%! opts.shape = "lower";
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.2065, 1e-4);
%!
#%!test
%! opts.type = "ict";
%! opts.droptol = 1e-1;
%! opts.michol = "on";
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.3266, 1e-4);
%! opts.shape = "upper";
%! U = ichol (A1, opts);
%! assert (norm (A1 - U' * U, "fro") / norm (A1, "fro"), 0.3266, 1e-4);
%! opts.shape = "lower";
%! opts.diagcomp = 3e-3;
%! L = ichol (A1, opts);
%! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.3266, 1e-4);
%!
%!test
%! opts.type = "ict";
%! opts.droptol = 1e-1;
%! opts.michol = "off";
%! L = ichol (A2, opts);
%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"),  0.0893, 1e-4);
%! opts.michol = "on";
%! L = ichol (A2, opts);
%! assert (norm (A2 - L*L', "fro") / norm (A2, "fro"), 0.2377, 1e-4);
%!
%!test
%! opts.type = "ict";
%! opts.droptol = 1e-1;
%! opts.michol = "off";
%! L = ichol (A3, opts);
%! assert (norm (A3 - L*L', "fro") / norm (A3, "fro"), eps, eps);
%! opts.michol = "on";
%! L = ichol (A3, opts);
%! assert (norm (A3 - L*L', "fro") / norm (A3, "fro"), eps, eps);
%!
%!test
%! opts.type = "ict";
%! opts.droptol = 1e-1;
%! opts.michol = "off";
%! L = ichol (A4, opts);
%! assert (norm (A4 - L*L', "fro") / norm (A4, "fro"), 0.1224, 1e-4);
%! opts.michol = "on";
%! L = ichol (A4, opts);
%! assert (norm (A4 - L*L', "fro") / norm (A4, "fro"), 0.2118, 1e-4);
%!
%!test
%! opts.type = "ict";
%! opts.droptol = 1e-1;
%! opts.michol = "off";
%! L = ichol (A5, opts);
%! assert (norm (A5 - L*L', "fro") / norm (A5, "fro"), 0.2044, 1e-4);
%! opts.michol = "on";
%! L = ichol (A5, opts);
%! assert (norm (A5 - L*L', "fro") / norm (A5, "fro"), 0.3231, 1e-4);

## Test input validation
%!error <A must be a sparse square matrix> ichol ([])
%!error <A must be a sparse square matrix> ichol (0)
%!error <pivot equal to 0> ichol (sparse (0))
%!error <pivot equal to 0> ichol (sparse (-0))
%!error <negative pivot> ichol (sparse (-1))
%!test
%! opts.type = "foo";
%! fail ("ichol (A1, opts)", 'TYPE must be "nofill"');
%! opts.type = 1;
%! fail ("ichol (A1, opts)", 'TYPE must be "nofill"');
%! opts.type = [];
%! fail ("ichol (A1, opts)", 'TYPE must be "nofill"');
%!test
%! opts.droptol = -1;
%! fail ("ichol (A1, opts)", "DROPTOL must be a non-negative real scalar");
%! opts.droptol = 0.5i;
%! fail ("ichol (A1, opts)", "DROPTOL must be a non-negative real scalar");
%! opts.droptol = [];
%! fail ("ichol (A1, opts)", "DROPTOL must be a non-negative real scalar");
%!test
%! opts.michol = "foo";
%! fail ("ichol (A1, opts)", 'MICHOL must be "on"');
%! opts.michol = 1;
%! fail ("ichol (A1, opts)", 'MICHOL must be "on"');
%! opts.michol = [];
%! fail ("ichol (A1, opts)", 'MICHOL must be "on"');
%!test
%! opts.diagcomp = -1;
%! fail ("ichol (A1, opts)", "DIAGCOMP must be a non-negative real scalar");
%! opts.diagcomp = 0.5i;
%! fail ("ichol (A1, opts)", "DIAGCOMP must be a non-negative real scalar");
%! opts.diagcomp = [];
%! fail ("ichol (A1, opts)", "DIAGCOMP must be a non-negative real scalar");
%!test
%! opts.shape = "foo";
%! fail ("ichol (A1, opts)", 'SHAPE must be "lower"');
%! opts.shape = 1;
%! fail ("ichol (A1, opts)", 'SHAPE must be "lower"');
%! opts.shape = [];
%! fail ("ichol (A1, opts)", 'SHAPE must be "lower"');
########################################################################
##
## Copyright (C) 2013-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} ilu (@var{A})
## @deftypefnx {} {} ilu (@var{A}, @var{opts})
## @deftypefnx {} {[@var{L}, @var{U}] =} ilu (@dots{})
## @deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} ilu (@dots{})
##
## Compute the incomplete LU factorization of the sparse square matrix @var{A}.
##
## @code{ilu} returns a unit lower triangular matrix @var{L}, an upper
## triangular matrix @var{U}, and optionally a permutation matrix @var{P}, such
## that @code{@var{L}*@var{U}} approximates @code{@var{P}*@var{A}}.
##
## The factors given by this routine may be useful as preconditioners for a
## system of linear equations being solved by iterative methods such as BICG
## (BiConjugate Gradients) or GMRES (Generalized Minimum Residual Method).
##
## The factorization may be modified by passing options in a structure
## @var{opts}.  The option name is a field of the structure and the setting
## is the value of field.  Names and specifiers are case sensitive.
##
## @table @code
## @item type
## Type of factorization.
##
## @table @asis
## @item @qcode{"nofill"} (default)
## ILU factorization with no fill-in (ILU(0)).
##
## Additional supported options: @code{milu}.
##
## @item @qcode{"crout"}
## Crout version of ILU factorization (@nospell{ILUC}).
##
## Additional supported options: @code{milu}, @code{droptol}.
##
## @item @qcode{"ilutp"}
## ILU factorization with threshold and pivoting.
##
## Additional supported options: @code{milu}, @code{droptol}, @code{udiag},
## @code{thresh}.
## @end table
##
## @item droptol
## A non-negative scalar specifying the drop tolerance for factorization.  The
## default value is 0 which produces the complete LU factorization.
##
## Non-diagonal entries of @var{U} are set to 0 unless
##
## @code{abs (@var{U}(i,j)) >= droptol * norm (@var{A}(:,j))}.
##
## Non-diagonal entries of @var{L} are set to 0 unless
##
## @code{abs (@var{L}(i,j)) >= droptol * norm (@var{A}(:,j))/@var{U}(j,j)}.
##
## @item milu
## Modified incomplete LU factorization:
##
## @table @asis
## @item @qcode{"row"}
## Row-sum modified incomplete LU factorization.
## The factorization preserves row sums:
## @code{@var{A} * e = @var{L} * @var{U} * e}, where e is a vector of ones.
##
## @item @qcode{"col"}
## Column-sum modified incomplete LU factorization.
## The factorization preserves column sums:
## @code{e' * @var{A} = e' * @var{L} * @var{U}}.
##
## @item @qcode{"off"} (default)
## Row and column sums are not necessarily preserved.
## @end table
##
## @item udiag
## If true, any zeros on the diagonal of the upper triangular factor are
## replaced by the local drop tolerance
## @code{droptol * norm (@var{A}(:,j))/@var{U}(j,j)}.  The default is false.
##
## @item thresh
## Pivot threshold for factorization.  It can range between 0 (diagonal
## pivoting) and 1 (default), where the maximum magnitude entry in the column
## is chosen to be the pivot.
## @end table
##
## If @code{ilu} is called with just one output, the returned matrix is
## @code{@var{L} + @var{U} - speye (size (@var{A}))}, where @var{L} is unit
## lower triangular and @var{U} is upper triangular.
##
## With two outputs, @code{ilu} returns a unit lower triangular matrix @var{L}
## and an upper triangular matrix @var{U}.  For @var{opts}.type ==
## @qcode{"ilutp"}, one of the factors is permuted based on the value of
## @var{opts}.milu.  When @var{opts}.milu == @qcode{"row"}, @var{U} is a
## column permuted upper triangular factor.  Otherwise, @var{L} is a
## row-permuted unit lower triangular factor.
##
## If there are three named outputs and @var{opts}.milu != @qcode{"row"},
## @var{P} is returned such that @var{L} and @var{U} are incomplete factors
## of @code{@var{P}*@var{A}}.  When @var{opts}.milu == @qcode{"row"}, @var{P}
## is returned such that @var{L} and @var{U} are incomplete factors of
## @code{@var{A}*@var{P}}.
##
## EXAMPLES
##
## @example
## @group
## A = gallery ("neumann", 1600) + speye (1600);
## opts.type = "nofill";
## nnz (A)
## ans = 7840
##
## nnz (lu (A))
## ans = 126478
##
## nnz (ilu (A, opts))
## ans = 7840
## @end group
## @end example
##
## This shows that @var{A} has 7,840 nonzeros, the complete LU factorization
## has 126,478 nonzeros, and the incomplete LU factorization, with 0 level of
## fill-in, has 7,840 nonzeros, the same amount as @var{A}.  Taken from:
## @url{https://www.mathworks.com/help/matlab/ref/ilu.html}
##
## @example
## @group
## A = gallery ("wathen", 10, 10);
## b = sum (A, 2);
## tol = 1e-8;
## maxit = 50;
## opts.type = "crout";
## opts.droptol = 1e-4;
## [L, U] = ilu (A, opts);
## x = bicg (A, b, tol, maxit, L, U);
## norm (A * x - b, inf)
## @end group
## @end example
##
## This example uses ILU as preconditioner for a random FEM-Matrix, which has a
## large condition number.  Without @var{L} and @var{U} BICG would not
## converge.
##
## @seealso{lu, ichol, bicg, gmres}
## @end deftypefn

function [L, U, P] = ilu (A, opts = struct ())

  if (nargin < 1)
    print_usage ();
  endif

  if (! (issparse (A) && issquare (A)))
    error ("ilu: A must be a sparse square matrix");
  endif

  if (! isstruct (opts))
    error ("ilu: OPTS must be a structure");
  endif

  ## If A is empty then return empty L, U and P for Matlab compatibility
  if (isempty (A))
    L = U = P = A;
    return;
  endif

  ## Parse input options
  if (! isfield (opts, "type"))
    opts.type = "nofill";  # set default
  else
    type = tolower (getfield (opts, "type"));
    if (! any (strcmp (type, {"nofill", "crout", "ilutp"})))
      error ("ilu: invalid TYPE specified");
    endif
    opts.type = type;
  endif

  if (! isfield (opts, "droptol"))
    opts.droptol = 0;      # set default
  else
    if (! (isreal (opts.droptol) && isscalar (opts.droptol)
           && opts.droptol >= 0))
      error ("ilu: DROPTOL must be a non-negative real scalar");
    endif
  endif

  if (! isfield (opts, "milu"))
    opts.milu = "off";     # set default
  else
    milu = tolower (getfield (opts, "milu"));
    if (! any (strcmp (milu, {"off", "col", "row"})))
      error ('ilu: MILU must be one of "off", "col", or "row"');
    endif
    opts.milu = milu;
  endif

  if (! isfield (opts, "udiag"))
    opts.udiag = 0;        # set default
  else
    if (! isscalar (opts.udiag) || (opts.udiag != 0 && opts.udiag != 1))
      error ("ilu: UDIAG must be 0 or 1");
    endif
  endif

  if (! isfield (opts, "thresh"))
    opts.thresh = 1;       # set default
  else
    if (! (isreal (opts.thresh) && isscalar (opts.thresh))
        || opts.thresh < 0 || opts.thresh > 1)
      error ("ilu: THRESH must be a scalar in the range [0, 1]");
    endif
  endif

  n = length (A);

  ## Delegate to specialized ILU
  switch (opts.type)
    case "nofill"
        [L, U] = __ilu0__ (A, opts.milu);
        if (nargout == 3)
          P = speye (length (A));
        endif
    case "crout"
        [L, U] = __iluc__ (A, opts.droptol, opts.milu);
        if (nargout == 3)
          P = speye (length (A));
        endif
    case "ilutp"
        if (nargout == 3)
          [L, U, P] = __ilutp__ (A, opts.droptol, opts.thresh,
                                    opts.milu, opts.udiag);
        else
          [L, U] = __ilutp__ (A, opts.droptol, opts.thresh,
                                 opts.milu, opts.udiag);
        endif
  endswitch

  if (nargout == 1)
    L = L + U - speye (n);
  endif

endfunction


%!shared n, dtol, A
%! n = 1600;
%! dtol = 0.1;
%! A = gallery ("neumann", n) + speye (n);

%!test
%! opts.type = "nofill";
%! assert (nnz (ilu (A, opts)), 7840);

## This test has been verified in both Matlab and Octave.
%!test
%! opts.type = "crout";
%! opts.milu = "row";
%! opts.droptol = dtol;
%! [L, U] = ilu (A, opts);
%! e = ones (columns (A),1);
%! assert (norm (A*e - L*U*e), 1e-14, 1e-14);
%!test
%! opts.type = "crout";
%! opts.droptol = dtol;
%! [L, U] = ilu (A, opts);
%! assert (norm (A - L * U, "fro") / norm (A, "fro"), 0.05, 1e-2);

## Check if the elements in U satisfy the non-dropping condition.
%!test
%! opts.type = "crout";
%! opts.droptol = dtol;
%! [L, U] = ilu (A, opts);
%! for j = 1:n
%!   cmp_value = dtol * norm (A(:, j));
%!   non_zeros = nonzeros (U(:, j));
%!   assert (abs (non_zeros) >= cmp_value);
%! endfor
%!test
%! opts.type = "ilutp";
%! opts.droptol = dtol;
%! [L, U] = ilu (A, opts);
%! for j = 1:n
%!   cmp_value = dtol * norm (A(:, j));
%!   non_zeros = nonzeros (U(:, j));
%!   assert (abs (non_zeros) >= cmp_value);
%! endfor

## Check that the complete LU factorisation with crout and ilutp algorithms
## produce the same result.
%!test
%! opts.type = "crout";
%! opts.droptol = 0;
%! [L1, U1] = ilu (A, opts);
%! opts.type = "ilutp";
%! opts.thresh = 0;
%! [L2, U2] = ilu (A, opts);
%! assert (norm (L1 - L2, "fro") / norm (L1, "fro"), 0, eps);
%! assert (norm (U1 - U2, "fro") / norm (U1, "fro"), 0, eps);

## Restore rand "state" value
%!shared old_rand_state, restore_state
%! ## Save and restore the state of the random number generator that is used by
%! ## the unit tests in this file.
%! old_rand_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_rand_state));

## Tests for real matrices of different sizes for ilu0, iluc and ilutp.
## The difference A - L*U should be not greater than eps because with droptol
## equal to 0, the LU complete factorization is performed.
%!shared n_tiny, n_small, n_medium, n_large, A_tiny, A_small, A_medium, A_large
%! n_tiny = 5;
%! n_small = 40;
%! n_medium = 600;
%! n_large = 10000;
%! A_tiny = spconvert ([1 4 2 3 3 4 2 5; 1 1 2 3 4 4 5 5; 1 2 3 4 5 6 7 8]');
%! ## initialize generator to make behavior reproducible
%! rand ("state", 42);
%! A_small = sprand (n_small, n_small, 1/n_small) + speye (n_small);
%! A_medium = sprand (n_medium, n_medium, 1/n_medium) + speye (n_medium);
%! A_large = sprand (n_large, n_large, 1/n_large/10) + speye (n_large);

%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_tiny);
%! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), 0, n_tiny * eps);
%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_small);
%! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), 0, 1);
%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_medium);
%! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), 0, 1);
%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_large);
%! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), 0, 1);

%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_tiny, opts);
%! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_small, opts);
%! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_medium, opts);
%! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_large, opts);
%! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);

%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_tiny, opts);
%! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_small, opts);
%! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_medium, opts);
%! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_large, opts);
%! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);

## Tests for complex matrices of different sizes for ilu0, iluc and ilutp.
%!shared n_tiny, n_small, n_medium, n_large, A_tiny, A_small, A_medium, A_large
%! n_tiny = 5;
%! n_small = 40;
%! n_medium = 600;
%! n_large = 10000;
%! A_tiny = spconvert ([1 4 2 3 3 4 2 5; 1 1 2 3 4 4 5 5; 1 2 3 4 5 6 7 8]');
%! A_tiny(1,1) += 1i;
%! ## initialize generator to make behavior reproducible
%! rand ("state", 42);
%! A_small = sprand (n_small, n_small, 1/n_small) + ...
%!   i * sprand (n_small, n_small, 1/n_small) + speye (n_small);
%! A_medium = sprand (n_medium, n_medium, 1/n_medium) + ...
%!   i * sprand (n_medium, n_medium, 1/n_medium) + speye (n_medium);
%! A_large = sprand (n_large, n_large, 1/n_large/10) + ...
%!   i * sprand (n_large, n_large, 1/n_large/10) + speye (n_large);

%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_tiny);
%! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), 0, n_tiny * eps);
%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_small);
%! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), 0, 1);
%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_medium);
%! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), 0, 1);
%!test
%! opts.type = "nofill";
%! [L, U] = ilu (A_large);
%! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), 0, 1);

%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_tiny, opts);
%! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_small, opts);
%! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_medium, opts);
%! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
%!test
%! opts.type = "crout";
%! [L, U] = ilu (A_large, opts);
%! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);

%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_tiny, opts);
%! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_small, opts);
%! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_medium, opts);
%! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
%!test
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! [L, U] = ilu (A_large, opts);
%! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);

## Specific tests for ilutp
%!shared A
%! A = sparse ([0 0 4 3 1; 5 1 2.3 2 4.5; 0 0 0 2 1;0 0 8 0 2.2; 0 0 9 9 1 ]);

%!test
%! opts.udiag = 1;
%! opts.type = "ilutp";
%! opts.droptol = 0.2;
%! [L, U, P] = ilu (A, opts);
%! assert (norm (U, "fro"), 17.4577, 1e-4);
%! assert (norm (L, "fro"), 2.4192, 1e-4);

%!error <encountered a pivot equal to 0>
%! opts.type = "ilutp";
%! opts.udiag = 0;
%! opts.droptol = 0.2;
%! ilu (A, opts);

## Matlab R2017b doesn't error, but returns a singular L which isn't helpful.
%!error <encountered a pivot equal to 0>
%! A = sparse ([3 1 0 0 4; 3 1 0 0 -2;0 0 8 0 0; 0 4 0 4 -4.5; 0 -1 0 0 1]);
%! opts.type = "ilutp";
%! opts.droptol = 0;
%! opts.thresh = 0;
%! opts.milu = "row";
%! [L, U, P] = ilu (A, opts);

%!test <*53440>
%! A = sparse (magic (4));
%! opts.type = "ilutp";
%! [L, U] = ilu (A, opts);
%! assert (L * U, A, eps);

## Tests for input validation
%!shared A_tiny, opts
%! A_tiny = spconvert ([1 4 2 3 3 4 2 5; 1 1 2 3 4 4 5 5; 1 2 3 4 5 6 7 8]');

%!test
%! [L, U] = ilu (sparse ([]));
%! assert (isempty (L));
%! assert (isempty (U));
%! opts.type = "crout";
%! [L, U] = ilu (sparse ([]), opts);
%! assert (isempty (L));
%! assert (isempty (U));
%! opts.type = "ilutp";
%! [L, U] = ilu (sparse ([]), opts);
%! assert (isempty (L));
%! assert (isempty (U));

%!error <A must be a sparse square matrix> ilu (0)
%!error <A must be a sparse square matrix> ilu ([])
%!error <zero on the diagonal> ilu (sparse (0))

%!error <invalid TYPE specified>
%! opts.type = "foo";
%! ilu (A_tiny, opts);
%!error <invalid TYPE specified>
%! opts.type = 1;
%! ilu (A_tiny, opts);
%!error <invalid TYPE specified>
%! opts.type = [];
%! ilu (A_tiny, opts);

%!error <DROPTOL must be a non-negative real scalar>
%! clear opts;
%! opts.droptol = -1;
%! ilu (A_tiny, opts);
%!error <DROPTOL must be a non-negative real scalar>
%! opts.droptol = 0.5i;
%! ilu (A_tiny, opts);
%!error <DROPTOL must be a non-negative real scalar>
%! opts.droptol = [];
%! ilu (A_tiny, opts);

%!error <MILU must be one of "off", "col", or "row">
%! clear opts;
%! opts.milu = "foo";
%! ilu (A_tiny, opts);
%!error <MILU must be one of "off", "col", or "row">
%! opts.milu = 1;
%! ilu (A_tiny, opts);
%!error <MILU must be one of "off", "col", or "row">
%! opts.milu = [];
%! ilu (A_tiny, opts);

%!error <UDIAG must be 0 or 1>
%! clear opts;
%! opts.udiag = -1;
%! ilu (A_tiny, opts);
%!error <UDIAG must be 0 or 1>
%! opts.udiag = 0.5i;
%! ilu (A_tiny, opts);
%!error <UDIAG must be 0 or 1>
%! opts.udiag = [];
%! ilu (A_tiny, opts);

%!error <THRESH must be a scalar in the range \[0, 1\]>
%! clear opts;
%! opts.thresh = -1;
%! ilu (A_tiny, opts);
%!error <THRESH must be a scalar in the range \[0, 1\]>
%! opts.thresh = 0.5i;
%! ilu (A_tiny, opts);
%!error <THRESH must be a scalar in the range \[0, 1\]>
%! opts.thresh = [];
%! ilu (A_tiny, opts);
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{v} =} nonzeros (@var{A})
## Return a column vector of the nonzero values of the matrix @var{A}.
## @seealso{find, nnz}
## @end deftypefn

function v = nonzeros (A)

  if (nargin < 1)
    print_usage ();
  endif

  if (issparse (A))
    [~, ~, v] = find (A);
    v = v(:);
  else
    v = A(find (A));
    v = v(:);
  endif

endfunction


%!assert (nonzeros ([1,2;3,0]), [1;3;2])
%!assert (nonzeros ([1,2,3,0]), [1;2;3])
%!assert (nonzeros (sparse ([1,2;3,0])), [1;3;2])
%!assert (nonzeros (sparse ([1,2,3,0])), [1;2;3])

## Test input validation
%!error <Invalid call> nonzeros ()
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
## @deftypefnx {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@var{A}, @var{b}, @dots{})
##
## Solve the linear system of equations @w{@code{@var{A} * @var{x} = @var{b}}}
## by means of the Preconditioned Conjugate Gradient iterative method.
##
## The input arguments are:
##
## @itemize
## @item @var{A} is the matrix of the linear system and it must be square.
## @var{A} can be passed as a matrix, function handle, or inline function
## @code{Afun} such that @code{Afun(x) = A * x}.  Additional parameters to
## @code{Afun} may be passed after @var{x0}.
##
## @var{A} has to be Hermitian and Positive Definite (@nospell{HPD})@.  If
## @code{pcg} detects @var{A} not to be positive definite, a warning is printed
## and the @var{flag} output is set.
##
## @item
## @var{b} is the right-hand side vector.
##
## @item
## @var{tol} is the required relative tolerance for the residual error,
## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
## @w{@code{@var{tol} * norm (@var{b})}}}.
## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
##
## @item
## @var{maxit} is the maximum allowed number of iterations; if @var{maxit}
## is omitted or empty then a value of 20 is used.
##
## @item
## @var{m} is a @nospell{HPD} preconditioning matrix.  For any decomposition
## @code{@var{m} = @var{p1} * @var{p2}} such that
## @w{@code{inv (@var{p1}) * @var{A} * inv (@var{p2})}} is @nospell{HPD}, the
## conjugate gradient method is formally applied to the linear system
## @w{@code{inv (@var{p1}) * @var{A} * inv (@var{p2}) * @var{y} = inv
## (@var{p1}) * @var{b}}},
## with @code{@var{x} = inv (@var{p2}) * @var{y}} (split preconditioning).
## In practice, at each iteration of the conjugate gradient method a
## linear system with matrix @var{m} is solved with @code{mldivide}.
## If a particular factorization
## @code{@var{m} = @var{m1} * @var{m2}} is available (for instance, an
## incomplete Cholesky factorization of @var{a}), the two matrices
## @var{m1} and @var{m2} can be passed and the relative linear systems
## are solved with the @code{mldivide} operator.
## Note that a proper choice of the preconditioner may dramatically improve
## the overall performance of the method.  Instead of matrices @var{m1} and
## @var{m2}, the user may pass two functions which return the results of
## applying the inverse of @var{m1} and @var{m2} to a vector.
## If @var{m1} is omitted or empty @code{[]}, then no preconditioning
## is applied.  If no factorization of @var{m} is available, @var{m2}
## can be omitted or left [], and the input variable @var{m1} can be
## used to pass the preconditioner @var{m}.
##
## @item
## @var{x0} is the initial guess.  If @var{x0} is omitted or empty then the
## function sets @var{x0} to a zero vector by default.
## @end itemize
##
## The arguments which follow @var{x0} are treated as parameters, and passed in
## an appropriate manner to any of the functions (@var{A} or @var{m1} or
## @var{m2}) that have been given to @code{pcg}.
## See the examples below for further details.
##
## The output arguments are:
##
## @itemize
## @item
## @var{x} is the computed approximation to the solution of
## @w{@code{@var{A} * @var{x} = @var{b}}}.  If the algorithm did not converge,
## then @var{x} is the iteration which has the minimum residual.
##
## @item
## @var{flag} reports on the convergence:
##
## @itemize
## @item 0: The algorithm converged to within the prescribed tolerance.
##
## @item 1: The algorithm did not converge and it reached the maximum
## number of iterations.
##
## @item 2: The preconditioner matrix is singular.
##
## @item 3: The algorithm stagnated, i.e., the absolute value of the
## difference between the current iteration @var{x} and the previous is less
## than @code{@var{eps} * norm (@var{x},2)}.
##
## @item 4: The algorithm detects that the input (preconditioned) matrix is not
## @nospell{HPD}.
## @end itemize
##
## @item
## @var{relres} is the ratio of the final residual to its initial value,
## measured in the Euclidean norm.
##
## @item
## @var{iter} indicates the iteration of @var{x} which it was
## computed.  Since the output @var{x} corresponds to the minimal
## residual solution, the total number of iterations that
## the method performed is given by @code{length(resvec) - 1}.
##
## @item
## @var{resvec} describes the convergence history of the method.
## @code{@var{resvec} (@var{i}, 1)} is the Euclidean norm of the residual, and
## @code{@var{resvec} (@var{i}, 2)} is the preconditioned residual
## norm, after the
## (@var{i}-1)-th iteration, @code{@var{i} = 1, 2, @dots{}, @var{iter}+1}.
## The preconditioned residual norm is defined as
## @code{@var{r}' * (@var{m} \ @var{r})} where
## @code{@var{r} = @var{b} - @var{A} * @var{x}}, see also the
## description of @var{m}.  If @var{eigest} is not required, only
## @code{@var{resvec} (:, 1)} is returned.
##
## @item
## @var{eigest} returns the estimate for the smallest @code{@var{eigest}(1)}
## and largest @code{@var{eigest}(2)} eigenvalues of the preconditioned matrix
## @w{@code{@var{P} = @var{m} \ @var{A}}}.  In particular, if no
## preconditioning is used, the estimates for the extreme eigenvalues of
## @var{A} are returned.  @code{@var{eigest}(1)} is an overestimate and
## @code{@var{eigest}(2)} is an underestimate, so that
## @code{@var{eigest}(2) / @var{eigest}(1)} is a lower bound for
## @code{cond (@var{P}, 2)}, which nevertheless in the limit should
## theoretically be equal to the actual value of the condition number.
## @end itemize
##
##
## Let us consider a trivial problem with a tridiagonal matrix
##
## @example
## @group
## n = 10;
## A = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, n));
## b = A * ones (n, 1);
## M1 = ichol (A); # in this tridiagonal case it corresponds to chol (A)'
## M2 = M1';
## M = M1 * M2;
## Afun = @@(x) A * x;
## Mfun = @@(x) M \ x;
## M1fun = @@(x) M1 \ x;
## M2fun = @@(x) M2 \ x;
## @end group
## @end example
##
## @sc{Example 1:} Simplest use of @code{pcg}
##
## @example
## x = pcg (A, b)
## @end example
##
## @sc{Example 2:} @code{pcg} with a function which computes
## @code{@var{A} * @var{x}}
##
## @example
## x = pcg (Afun, b)
## @end example
##
## @sc{Example 3:} @code{pcg} with a preconditioner matrix @var{M}
##
## @example
## x = pcg (A, b, 1e-06, 100, M)
## @end example
##
## @sc{Example 4:} @code{pcg} with a function as preconditioner
##
## @example
## x = pcg (Afun, b, 1e-6, 100, Mfun)
## @end example
##
## @sc{Example 5:} @code{pcg} with preconditioner matrices @var{M1}
## and @var{M2}
##
## @example
## x = pcg (A, b, 1e-6, 100, M1, M2)
## @end example
##
## @sc{Example 6:} @code{pcg} with functions as preconditioners
##
## @example
## x = pcg (Afun, b, 1e-6, 100, M1fun, M2fun)
## @end example
##
## @sc{Example 7:} @code{pcg} with as input a function requiring an argument
##
## @example
## @group
##   function y = Ap (A, x, p) # compute A^p * x
##      y = x;
##      for i = 1:p
##        y = A * y;
##      endfor
##   endfunction
## Apfun = @@(x, p) Ap (A, x, p);
## x = pcg (Apfun, b, [], [], [], [], [], 2);
## @end group
## @end example
##
## @sc{Example 8:} explicit example to show that @code{pcg} uses a
## split preconditioner
##
## @example
## @group
## M1 = ichol (A + 0.1 * eye (n)); # factorization of A perturbed
## M2 = M1';
## M = M1 * M2;
##
## ## reference solution computed by pcg after two iterations
## [x_ref, fl] = pcg (A, b, [], 2, M)
##
## ## split preconditioning
## [y, fl] = pcg ((M1 \ A) / M2, M1 \ b, [], 2)
## x = M2 \ y # compare x and x_ref
##
## @end group
## @end example
##
## References:
##
## @enumerate
## @item
## C.T. Kelley, @cite{Iterative Methods for Linear and Nonlinear Equations},
## SIAM, 1995. (the base PCG algorithm)
##
## @item
## @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
## @nospell{PWS} 1996. (condition number estimate from PCG)
## Revised version of this book is available online at
## @url{https://www-users.cs.umn.edu/~saad/books.html}
## @end enumerate
##
## @seealso{sparse, pcr, gmres, bicg, bicgstab, cgs}
## @end deftypefn

function [x_min, flag, relres, iter_min, resvec, eigest] =...
         pcg (A, b, tol = [], maxit = [], M1 = [], M2 = [], x0 = [], varargin)

  ## Insert the default input (if necessary)
  [tol, maxit, x0] = __default__input__ ({1e-6, min(rows (b), 20),...
                                          zeros(size (b))}, tol, maxit, x0);

  if (tol >= 1)
    warning ("Input tol is bigger than 1. \n Try to use a smaller tolerance.");
  elseif (tol <= eps / 2)
    warning ("Input tol may not be achievable by pcg. \n Try to use a bigger tolerance");
  endif

  ## Check if the input data A,b,m1,m2 are consistent (i.e. if they are
  ## matrix or function handle)

  [Afun, M1fun, M2fun] = __alltohandles__ (A, b, M1, M2, "pcg");

  maxit += 2;
  n_arg_out = nargout;

  ## Set Initial data
  b_norm = norm (b);
  if (b_norm == 0)
     if (n_arg_out < 2)
       printf ("The right hand side vector is all zero so pcg \n");
       printf ("returned an all zero solution without iterating.\n");
     endif
     x_min = b;
     flag = 0;
     relres = 0;
     resvec = 0;
     iter_min = 0;
     eigest = [NaN, NaN];
     return;
  endif

  x = x_pr = x_min = x0;

  ## x_pr (x previous) needs to check the stagnation
  ## x_min needs to save the iterated with minimum residual

  r = b - feval (Afun, x, varargin{:});
  iter = 2;
  iter_min = 0;
  flag = 1;
  resvec = zeros (maxit + 1, 2);
  resvec(1, 1) = norm (r);
  p = zeros (size (b));
  alpha = old_tau = 1;

  if (n_arg_out > 5)
    T = zeros (maxit, maxit);
  else
    T = [];
  endif

  while (resvec(iter-1,1) > tol * b_norm && iter < maxit)
    if (iter == 2) # Check whether M1 or M2 are singular
      try
        warning ("error","Octave:singular-matrix","local");
        z = feval (M1fun, r, varargin{:});
        z = feval (M2fun, z, varargin{:});
      catch
        flag = 2;
        break;
      end_try_catch
    else
      z = feval (M1fun, r, varargin{:});
      z = feval (M2fun, z, varargin{:});
    endif

    tau = z' * r;
    resvec(iter - 1, 2) = sqrt (tau);
    beta = tau / old_tau;
    old_tau = tau;
    p = z + beta * p;
    w = feval (Afun, p, varargin{:});

    ## Needed only for eigest.

    old_alpha = alpha;
    den = p' * w;
    alpha = tau / den;

    ## Check if alpha is negative and/or if it has a consistent
    ## imaginary part: if yes then A probably is not positive definite
    if ((abs (imag (tau)) >= abs (real (tau)) * tol) || ...
        real (tau) <= 0 || ...
        (abs (imag (den)) >= abs (real (den)) * tol) || ...
        (real (den) <= 0))
      flag = 4;
      break;
    endif

    x += alpha * p;
    r -= alpha * w;
    resvec(iter, 1) = norm (r);
    ## Check if the iterated has minimum residual
    if (resvec (iter,1) <= resvec (iter_min + 1,1))
      x_min = x;
      iter_min = iter - 1;
    endif
    if (n_arg_out > 5 && iter > 2)
      T(iter-1:iter, iter-1:iter) = T(iter-1:iter, iter-1:iter) + ...
                                    [1, sqrt(beta); sqrt(beta), beta] ./ ...
                                    old_alpha;
    endif
    iter += 1;
    if (norm (x - x_pr) <= eps * norm (x)) # Check the stagnation
      flag = 3;
      break;
    endif
    x_pr = x;
  endwhile

  if (n_arg_out > 5)
  ## Apply the preconditioner once more and finish with the precond
  ## residual.
    z = feval (M1fun, r, varargin{:});
    z = feval (M2fun, z, varargin{:});
  endif

  ## (Eventually) computes the eigenvalue of inv(m2)*inv(m1)*A
  if (n_arg_out > 5)
    if (flag != 4)
      if (iter > 3)
        T = T(2:iter-2,2:iter-2);
        l = eig (T);
        eigest = [min(l), max(l)];
      else
        eigest = [NaN, NaN];
        warning ("pcg: eigenvalue estimate failed: iteration converged too fast");
      endif
    else
      eigest = [NaN, NaN];
      warning ('pcg: eigenvalue estimate failed: matrix not positive definite?');
    endif
    resvec(iter - 1, 2) = sqrt (r' * z);
    resvec  = resvec (1:(iter-1), :);
  else
    eigest = [NaN, NaN];
    resvec = resvec(1:(iter-1),1);
  endif

  ## Set the last variables

  if (flag == 2)
    relres = 1;
  elseif (resvec (1, 1) == 0)
    relres = 0;
  else
    relres = resvec(iter_min+1, 1) ./ b_norm;
  endif

  iter -= 2; # compatibility

  ## Set the flag in the proper way if flag not 3, 4 or 2
  if (flag == 2)
    flag = 2;
  elseif (flag == 1) && (relres <= tol)
    flag = 0;
  endif

  if (n_arg_out < 2)
    switch (flag)
      case {0}
        printf ("pcg converged at iteration %d ", iter_min);
        printf ("with relative residual %d\n", relres);
      case {1}
        printf ("pcg stopped at iteration %d ", iter+1);
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because the maximum number of iteration was reached, \n");
        printf ("The iterated returned (number %d) ",iter_min);
        printf ("has relative residual %d \n", relres);
      case {2}
        printf ("pcg stopped at iteration %d ", iter+1)
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because the preconditioned matrix is singular.\n");
        printf ("The iterated returned (number %d) ", iter_min);
        printf ("has relative residual %d \n", relres);
      case {3}
        printf ("pcg stopped at iteration %d ", iter+1);
        printf ("without converging to the desired tolerance %d ", tol);
        printf ("because of stagnation. \n");
        printf ("The iterated returned (number %d) ", iter_min);
        printf ("has relative residual %d.\n", relres);
      case {4}
        printf ("pcg stopped at iteration %d ", iter + 1);
        printf ("without converging to the desired tolerance %d ",tol);
        printf ("because the (preconditioned) matrix is not positive definite. \n");
        printf ("The iterate returned (number %d) ", iter_min);
        printf ("has relative residual %d \n", relres);
    endswitch
  endif

endfunction


%!demo # simplest use
%! n = 10;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, n));
%! b = A * ones (n, 1);
%! M1 = ichol (A);  # for this tridiagonal case it corresponds to chol (A)'
%! M2 = M1';
%! M = M1 * M2;
%! x = pcg (A, b);
%! Afun = @(x) A * x;
%! x = pcg (Afun, b);
%! x = pcg (A, b, 1e-6, 100, M);
%! x = pcg (A, b, 1e-6, 100, M1, M2);
%! Mfun = @(x) M \ x;
%! x = pcg (Afun, b, 1e-6, 100, Mfun);
%! M1fun = @(x) M1 \ x;
%! M2fun = @(x) M2 \ x;
%! x = pcg (Afun, b, 1e-6, 100, M1fun, M2fun);
%! function y = Ap (A, x, p)  # compute A^p * x
%!    y = x;
%!    for i = 1:p
%!      y = A * y;
%!    endfor
%!  endfunction
%! Afun = @(x, p) Ap (A, x, p);
%! ## solution of A^2 * x = b
%! x = pcg (Afun, b, [], [], [], [], [], 2);

%!demo
%! n = 10;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, n));
%! b = A * ones (n, 1);
%! M1 = ichol (A + 0.1 * eye (n));  # Perturb the factorization of A
%! M2 = M1';
%! M = M1 * M2;
%!
%! ## Reference solution computed by pcg after two iterations
%! [x_ref, fl] = pcg (A, b, [], 2, M);
%! x_ref
%!
%! ## Split preconditioning
%! [y, fl] = pcg ((M1 \ A) / M2, M1 \ b, [], 2);
%! x = M2 \ y  # compare x and x_ref
%!test
%! ## Check that all type of inputs work
%! A = toeplitz (sparse ([2, 1 ,0, 0, 0]));
%! b = A * ones (5, 1);
%! M1 = diag (sqrt (diag (A)));
%! M2 = M1;  # M1 * M2 is the Jacobi preconditioner
%! Afun = @(z) A*z;
%! M1_fun = @(z) M1 \ z;
%! M2_fun = @(z) M2 \ z;
%! [x, flag, ~, iter] = pcg (A,b);
%! assert (flag, 0);
%! [x, flag, ~ , iter] = pcg (A, b, [], [], M1 * M2);
%! assert (flag, 0);
%! [x, flag, ~ , iter] = pcg (A, b, [], [], M1, M2);
%! assert (flag, 0);
%! [x, flag] = pcg (A, b, [], [], M1_fun, M2_fun);
%! assert (flag, 0);
%! [x, flag] = pcg (A, b,[],[], M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = pcg (A, b,[],[], M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = pcg (Afun, b);
%! assert (flag, 0);
%! [x, flag] = pcg (Afun, b,[],[], M1 * M2);
%! assert (flag, 0);
%! [x, flag] = pcg (Afun, b,[],[], M1, M2);
%! assert (flag, 0);
%! [x, flag] = pcg (Afun, b,[],[], M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = pcg (Afun, b,[],[], M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = pcg (Afun, b,[],[], M1_fun, M2_fun);
%! assert (flag, 0);

%!test
%! ## solve a small diagonal system
%! N = 10;
%! A = diag ([1:N]);  b = rand (N, 1);
%! [x, flag] = pcg (A, b, [], N+1);
%! assert (flag, 0);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);

%!test
%! ## A is not positive definite
%! ## The indefiniteness of A is detected.
%! N = 10;
%! A = -diag ([1:N]);  b = sum (A, 2);
%! [x, flag] = pcg (A, b, [], N + 1);
%! assert (flag, 4);

%!test
%! ## solve tridiagonal system, do not converge in default 20 iterations
%! N = 100;
%! ## Form 1-D Laplacian matrix
%! A = 2 * eye (N,N);
%! A(2:(N+1):end) = -1;
%! A((N+1):(N+1):end) = -1;
%! b = ones (N, 1);
%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
%! assert (flag);
%! assert (relres >= 1.0);

%!warning <iteration converged too fast>
%! ## solve tridiagonal system with "perfect" preconditioner which converges
%! ## in one iteration, so the eigest does not work and issues a warning.
%! N = 100;
%! ## Form 1-D Laplacian matrix
%! A = 2 * eye (N,N);
%! A(2:(N+1):end) = -1;
%! A((N+1):(N+1):end) = -1;
%! b = ones (N, 1);
%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
%! assert (flag, 0);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);
%!
%! assert (isnan (eigest), isnan ([NaN, NaN]));

%!test
%! ## pcg detect a non-Hermitian matrix, with a considerable imaginary part.
%! ## In this example, Matlab does not recognize the wrong type of matrix and
%! ## makes iterations until it reaches maxit.
%! N = 10;
%! A = diag (1:N) + 1e-4*i;
%! b = ones (N, 1);
%! [x, flag] = pcg (A, b, []);
%! assert (flag, 4);

%!test
%! ## The imaginary part is not influent (it is too small), so pcg doesn't stop
%! N = 10;
%! A = diag (1:N) + 1e-10*i;
%! b = ones (N, 1);
%! [x, flag] = pcg (A, b, [], N+1);
%! assert (flag, 0);
%! assert (norm (b - A*x) / norm (b), 0, 1e-6);

%!test
%! ## pcg solves linear system with A Hermitian positive definite
%! N = 20;
%! A = sparse (toeplitz ([4, 1, zeros(1, 18)])) + ...
%!     i * sparse (toeplitz ([0, 1, zeros(1, 18)], [0, -1, zeros(1,18)]));
%! b = A * ones (N, 1);
%! Hermitian_A = ishermitian (A);
%! [x, flag] = pcg (A, b, [], 2*N);
%! assert (Hermitian_A, true);
%! assert (flag, 0);
%! assert (x, ones (N, 1), -1e-4);

%!testif HAVE_CHOLMOD
%! ## pcg solves preconditioned linear system with A HPD
%! N = 20;
%! A = sparse (toeplitz ([4, 1, zeros(1, 18)])) + ...
%!     i * sparse (toeplitz ([0, 1, zeros(1, 18)], [0, -1, zeros(1,18)]));
%! b = A * ones (N, 1);
%! M2 = chol (A + 0.1 * eye (N));  # Factor of a perturbed matrix
%! M = M2' * M2;
%! Hermitian_A = ishermitian (A);
%! Hermitian_M = ishermitian (M);
%! [x, flag] = pcg (A, b, [], 2*N, M);
%! assert (Hermitian_A, true);
%! assert (Hermitian_M, true);
%! assert (flag, 0);
%! assert (x, ones (N, 1), -1e-4);

%!test
%! ## pcg recognizes that the preconditioner matrix is singular
%! N = 3;
%! A = toeplitz ([2, 1, 0]);
%! M = [1 0 0; 0 1 0; 0 0 0];  # the last row is zero
%! [x, flag] = pcg (A, ones (3, 1), [], [], M);
%! assert (flag, 2);

%!test
%! A = rand (4);
%! A = A' * A;
%! [x, flag] = pcg (A, zeros (4, 1), [], [], [], [], ones (4, 1));
%! assert (x, zeros (4, 1));

## Test return types
%!test
%! A = single (1);
%! b = 1;
%! [x, flag] = pcg (A, b);
%! assert (class (x), "single");

%!test
%! A = 1;
%! b = single (1);
%! [x, flag] = pcg (A, b);
%! assert (class (x), "single");

%!test
%! A = single (1);
%! b = single (1);
%! [x, flag] = pcg (A, b);
%! assert (class (x), "single");

%!test
%!function y = Afun (x)
%!   A = toeplitz ([2, 1, 0, 0]);
%!   y = A * x;
%!endfunction
%! [x, flag] = pcg ("Afun", [3; 4; 4; 3]);
%! assert (x, ones (4, 1), 1e-6);

%!test
%! ## unpreconditioned residual
%! A = toeplitz (sparse ([4, 1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = toeplitz (sparse ([2, 1, 0, 0, 0]));
%! [x, flag, relres] = pcg (A, b, [], 2, M);
%! assert (norm (b - A * x) / norm (b), relres,  8 * eps);

%!test <*59776>
%! A = [ 1.00000000  -0.00054274  -0.00066848;
%!      -0.00054274   1.00000000  -0.00060330;
%!      -0.00066848  -0.00060330   1.00000000];
%! b = [1 1 1]';
%! [x, flag, relres, iter, resvec] = pcg (A, b, 1e-6, 4, [], [], [1; 1; 1]);
%! assert (flag, 0);
%! assert (relres, resvec(2) / norm (b));
%! assert (iter, 1);

########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} pcr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})
##
## Solve the linear system of equations @code{@var{A} * @var{x} = @var{b}} by
## means of the Preconditioned Conjugate Residuals iterative method.
##
## The input arguments are
##
## @itemize
## @item
## @var{A} can be either a square (preferably sparse) matrix or a function
## handle, inline function or string containing the name of a function which
## computes @code{@var{A} * @var{x}}.  In principle @var{A} should be
## symmetric and non-singular; if @code{pcr} finds @var{A} to be numerically
## singular, you will get a warning message and the @var{flag} output
## parameter will be set.
##
## @item
## @var{b} is the right hand side vector.
##
## @item
## @var{tol} is the required relative tolerance for the residual error,
## @code{@var{b} - @var{A} * @var{x}}.  The iteration stops if
## @code{norm (@var{b} - @var{A} * @var{x}) <=
##       @var{tol} * norm (@var{b} - @var{A} * @var{x0})}.
## If @var{tol} is empty or is omitted, the function sets
## @code{@var{tol} = 1e-6} by default.
##
## @item
## @var{maxit} is the maximum allowable number of iterations; if @code{[]} is
## supplied for @var{maxit}, or @code{pcr} has less arguments, a default
## value equal to 20 is used.
##
## @item
## @var{m} is the (left) preconditioning matrix, so that the iteration is
## (theoretically) equivalent to solving by
## @code{pcr} @code{@var{P} * @var{x} = @var{m} \ @var{b}}, with
## @code{@var{P} = @var{m} \ @var{A}}.  Note that a proper choice of the
## preconditioner may dramatically improve the overall performance of the
## method.  Instead of matrix @var{m}, the user may pass a function which
## returns the results of applying the inverse of @var{m} to a vector
## (usually this is the preferred way of using the preconditioner).  If
## @code{[]} is supplied for @var{m}, or @var{m} is omitted, no
## preconditioning is applied.
##
## @item
## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the
## function sets @var{x0} to a zero vector by default.
## @end itemize
##
## The arguments which follow @var{x0} are treated as parameters, and passed
## in a proper way to any of the functions (@var{A} or @var{m}) which are
## passed to @code{pcr}.  See the examples below for further details.
##
## The output arguments are
##
## @itemize
## @item
## @var{x} is the computed approximation to the solution of
## @code{@var{A} * @var{x} = @var{b}}.
##
## @item
## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means the
## solution converged and the tolerance criterion given by @var{tol} is
## satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit for the
## iteration count was reached.  @code{@var{flag} = 3} reports a @code{pcr}
## breakdown, see [1] for details.
##
## @item
## @var{relres} is the ratio of the final residual to its initial value,
## measured in the Euclidean norm.
##
## @item
## @var{iter} is the actual number of iterations performed.
##
## @item
## @var{resvec} describes the convergence history of the method, so that
## @code{@var{resvec} (i)} contains the Euclidean norms of the residual after
## the (@var{i}-1)-th iteration, @code{@var{i} = 1,2, @dots{}, @var{iter}+1}.
## @end itemize
##
## Let us consider a trivial problem with a diagonal matrix (we exploit the
## sparsity of A)
##
## @example
## @group
## n = 10;
## A = sparse (diag (1:n));
## b = rand (N, 1);
## @end group
## @end example
##
## @sc{Example 1:} Simplest use of @code{pcr}
##
## @example
## x = pcr (A, b)
## @end example
##
## @sc{Example 2:} @code{pcr} with a function which computes
## @code{@var{A} * @var{x}}.
##
## @example
## @group
## function y = apply_a (x)
##   y = [1:10]' .* x;
## endfunction
##
## x = pcr ("apply_a", b)
## @end group
## @end example
##
## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
## preconditioner (quite strange, because even the original matrix
## @var{A} is trivial) is defined as a function
##
## @example
## @group
## function y = apply_m (x)
##   k = floor (length (x) - 2);
##   y = x;
##   y(1:k) = x(1:k) ./ [1:k]';
## endfunction
##
## [x, flag, relres, iter, resvec] = ...
##                    pcr (A, b, [], [], "apply_m")
## semilogy ([1:iter+1], resvec);
## @end group
## @end example
##
## @sc{Example 4:} Finally, a preconditioner which depends on a
## parameter @var{k}.
##
## @example
## @group
## function y = apply_m (x, varargin)
##   k = varargin@{1@};
##   y = x;
##   y(1:k) = x(1:k) ./ [1:k]';
## endfunction
##
## [x, flag, relres, iter, resvec] = ...
##                    pcr (A, b, [], [], "apply_m"', [], 3)
## @end group
## @end example
##
## Reference:
##
## @nospell{W. Hackbusch}, @cite{Iterative Solution of Large Sparse
## Systems of Equations}, section 9.5.4; @nospell{Springer}, 1994
##
## @seealso{sparse, pcg}
## @end deftypefn

function [x, flag, relres, iter, resvec] = pcr (A, b, tol, maxit, m, x0, varargin)

  breakdown = false;

  if (nargin < 6 || isempty (x0))
    x = zeros (size (b));
  else
    x = x0;
  endif

  if (nargin < 5)
    m = [];
  endif

  if (nargin < 4 || isempty (maxit))
    maxit = 20;
  endif

  maxit += 2;

  if (nargin < 3 || isempty (tol))
    tol = 1e-6;
  endif

  if (nargin < 2)
    print_usage ();
  endif

  ##  init
  if (isnumeric (A))            # is A a matrix?
    r = b - A*x;
  else                          # then A should be a function!
    r = b - feval (A, x, varargin{:});
  endif

  if (isnumeric (m))            # is M a matrix?
    if (isempty (m))            # if M is empty, use no precond
      p = r;
    else                        # otherwise, apply the precond
      p = m \ r;
    endif
  else                          # then M should be a function!
    p = feval (m, r, varargin{:});
  endif

  iter = 2;

  b_bot_old = 1;
  q_old = p_old = s_old = zeros (size (x));

  if (isnumeric (A))            # is A a matrix?
    q = A * p;
  else                          # then A should be a function!
    q = feval (A, p, varargin{:});
  endif

  resvec(1) = abs (norm (r));

  ## iteration
  while (resvec(iter-1) > tol*resvec(1) && iter < maxit)

    if (isnumeric (m))          # is M a matrix?
      if (isempty (m))          # if M is empty, use no precond
        s = q;
      else                      # otherwise, apply the precond
        s = m \ q;
      endif
    else                        # then M should be a function!
      s = feval (m, q, varargin{:});
    endif
    b_top = r' * s;
    b_bot = q' * s;

    if (b_bot == 0.0)
      breakdown = true;
      break;
    endif
    lambda = b_top / b_bot;

    x += lambda*p;
    r -= lambda*q;

    if (isnumeric (A))          # is A a matrix?
      t = A*s;
    else                        # then A should be a function!
      t = feval (A, s, varargin{:});
    endif

    alpha0 = (t'*s) / b_bot;
    alpha1 = (t'*s_old) / b_bot_old;

    p_temp = p;
    q_temp = q;

    p = s - alpha0*p - alpha1*p_old;
    q = t - alpha0*q - alpha1*q_old;

    s_old = s;
    p_old = p_temp;
    q_old = q_temp;
    b_bot_old = b_bot;

    resvec(iter) = abs (norm (r));
    iter += 1;
  endwhile

  flag = 0;
  relres = resvec(iter-1) ./ resvec(1);
  iter -= 2;
  if (iter >= maxit-2)
    flag = 1;
    if (nargout < 2)
      warning ("pcr: maximum number of iterations (%d) reached\n", iter);
      warning ("pcr: the initial residual norm was reduced %g times\n",
               1.0/relres);
    endif
  elseif (nargout < 2 && ! breakdown)
    fprintf (stderr, "pcr: converged in %d iterations. \n", iter);
    fprintf (stderr, "pcr: the initial residual norm was reduced %g times\n",
             1.0 / relres);
  endif

  if (breakdown)
    flag = 3;
    if (nargout < 2)
      warning ("pcr: breakdown occurred:\n");
      warning ("system matrix singular or preconditioner indefinite?\n");
    endif
  endif

endfunction


%!demo
%! ## Simplest usage of PCR (see also 'help pcr')
%!
%! N = 20;
%! A = diag (linspace (-3.1,3,N)); b = rand (N,1);
%! y = A \ b;  # y is the true solution
%! x = pcr (A,b);
%! printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
%!
%! ## You shouldn't be afraid if PCR issues some warning messages in this
%! ## example: watch out in the second example, why it takes N iterations
%! ## of PCR to converge to (a very accurate, by the way) solution.

%!demo
%! ## Full output from PCR
%! ## We use this output to plot the convergence history
%!
%! N = 20;
%! A = diag (linspace (-3.1,30,N)); b = rand (N,1);
%! X = A \ b;  # X is the true solution
%! [x, flag, relres, iter, resvec] = pcr (A,b);
%! printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
%! clf;
%! title ("Convergence history");
%! xlabel ("Iteration"); ylabel ("log (||b-Ax||/||b||)");
%! semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");

%!demo
%! ## Full output from PCR
%! ## We use indefinite matrix based on the Hilbert matrix, with one
%! ## strongly negative eigenvalue
%! ## Hilbert matrix is extremely ill conditioned, so is ours,
%! ## and that's why PCR WILL have problems
%!
%! N = 10;
%! A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
%! X = A \ b;  # X is the true solution
%! printf ("Condition number of A is   %g\n", cond (A));
%! [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
%! if (flag == 3)
%!   printf ("PCR breakdown.  System matrix is [close to] singular\n");
%! endif
%! clf;
%! title ("Convergence history");
%! xlabel ("Iteration"); ylabel ("log (||b-Ax||)");
%! semilogy ([0:iter], resvec, "o-g;absolute residual;");

%!demo
%! ## Full output from PCR
%! ## We use an indefinite matrix based on the 1-D Laplacian matrix for A,
%! ## and here we have cond (A) = O(N^2)
%! ## That's the reason we need some preconditioner; here we take
%! ## a very simple and not powerful Jacobi preconditioner,
%! ## which is the diagonal of A.
%!
%! ## Note that we use here indefinite preconditioners!
%!
%! N = 100;
%! ## Form 1-D Laplacian matrix
%! A = 2 * eye (N,N);
%! A(2:(N+1):end) = -1;
%! A((N+1):(N+1):end) = -1;
%!
%! A = [A, zeros(size(A)); zeros(size(A)), -A];
%! b = rand (2*N,1);
%! X = A \ b;  # X is the true solution
%! maxit = 80;
%! printf ("System condition number is %g\n", cond (A));
%! ## No preconditioner: the convergence is very slow!
%!
%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
%! clf;
%! title ("Convergence history");
%! xlabel ("Iteration"); ylabel ("log (||b-Ax||)");
%! semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
%!
%! pause (1);
%! ## Test Jacobi preconditioner: it will not help much!!!
%!
%! M = diag (diag (A)); # Jacobi preconditioner
%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
%! hold on;
%! semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
%!
%! pause (1);
%! ## Test nonoverlapping block Jacobi preconditioner: this one should give
%! ## some convergence speedup!
%!
%! M = zeros (N,N); k = 4;
%! for i=1:k:N # get k x k diagonal blocks of A
%!   M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
%! endfor
%! M = [M, zeros(size (M)); zeros(size(M)), -M];
%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
%! semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
%! hold off;

%!test
%! ## solve small indefinite diagonal system
%!
%! N = 10;
%! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
%! X = A \ b;  # X is the true solution
%! [x, flag] = pcr (A,b,[],N+1);
%! assert (norm (x-X) / norm (X) < 1e-10);
%! assert (flag, 0);

%!test
%! ## solve tridiagonal system, do not converge in default 20 iterations
%! ## should perform max allowable default number of iterations
%!
%! N = 100;
%! ## Form 1-D Laplacian matrix
%! A = 2 * eye (N,N);
%! A(2:(N+1):end) = -1;
%! A((N+1):(N+1):end) = -1;
%! b = ones (N,1);
%! X = A \ b;  # X is the true solution
%! [x, flag, relres, iter, resvec] = pcr (A,b,1e-12);
%! assert (flag, 1);
%! assert (relres > 0.6);
%! assert (iter, 20);

%!test
%! ## solve tridiagonal system with "perfect" preconditioner
%! ## converges in one iteration
%!
%! N = 100;
%! ## Form 1-D Laplacian matrix
%! A = 2 * eye (N,N);
%! A(2:(N+1):end) = -1;
%! A((N+1):(N+1):end) = -1;
%! b = ones (N,1);
%! X = A \ b;  # X is the true solution
%! [x, flag, relres, iter] = pcr (A,b,[],[],A,b);
%! assert (norm (x-X) / norm (X) < 1e-6);
%! assert (relres < 1e-6);
%! assert (flag, 0);
%! assert (iter, 1); # should converge in one iteration
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {[@var{Afun}, @var{M1fun}, @var{M2fun}] =} __alltohandles__ (@var{A}, @var{b}, @var{M1}, @var{M2}, @var{solver_name})
##
## Check if the parameters @var{A} (matrix of our linear system), @var{b}
## (right hand side vector), @var{M1}, @var{M2} (preconditioner matrices) are
## really matrices or functions handle, summarizing if they are void or not.
##
## The input parameters are:
##
## @itemize
## @item @var{A} is the matrix of the linear system.
##
## @item @var{b} is the right hand side vector.
##
## @item @var{M1}, @var{M2} preconditioners.  They can be [].
##
## @item @var{solver_name} is the name of the solver as string.
##
## @end itemize
##
## The output parameters are:
##
## @itemize
##
## @item @var{Afun}, @var{M1fun}, @var{M2fun} are the corresponding
## function handles.
##
## @end itemize
## @end deftypefn

function [Afun, M1fun, M2fun] = __alltohandles__ (A, b, M1, M2, solver_name)

  A_is_numeric = false;
  M1_is_numeric = false;
  M2_is_numeric = false;

  ## Check A and set its type
  if (is_function_handle (A))
     Afun = A;
  elseif (ischar (A))
    Afun = str2func (A);
  elseif (! isnumeric (A) || ! issquare (A))
    error ([solver_name, ": A must be a square matrix or a function handle"]);
  else
    A_is_numeric = true;
    if (columns (A) != rows (b))
      error ("__alltohandles__: dimension of B is not consistent with A");
    endif
  endif

  ## Check M1 and sets its type
  if (isempty (M1)) # M1 empty, set to identity function
    switch (solver_name)
      case {"pcg", "gmres", "bicgstab", "cgs", "tfqmr"}
        ## methods which do not require the transpose
        M1fun = @(x) x;
      case {"bicg"}
        ## methods which do require the transpose
        M1fun = @(x, ~) x;
      otherwise
        error (["__alltohandles__: unknown method: ", solver_name]);
    endswitch
  else # M1 not empty
    if (is_function_handle (M1))
      M1fun = M1;
    elseif (ischar (M1))
      M1fun = str2func (M1);
    elseif (! isnumeric (M1) || ! issquare (M1))
      error ([solver_name, ": M1 must be a square matrix or a function handle"]);
    else
      M1_is_numeric = true;
    endif
  endif

  if (isempty (M2)) # M2 empty, then I set is to the identity function
    switch (solver_name)
      case {"pcg", "gmres", "bicgstab", "cgs", "tfqmr"}
        ## methods which do not require the transpose
        M2fun = @(x) x;
      case {"bicg"}
        ## methods which do require the transpose
        M2fun = @(x, ~) x;
      otherwise
        error (["__alltohandles__: unknown method: ", solver_name]);
    endswitch
  else # M2 not empty
    if (is_function_handle (M2))
      M2fun = M2;
    elseif (ischar (M2))
      M2fun = str2func (M2);
    elseif (! isnumeric (M2) || ! issquare (M2))
      error ([solver_name, ": M2 must be a square matrix or a function handle"]);
    else
      M2_is_numeric = true;
    endif
  endif

  switch (solver_name)
    case {"pcg", "gmres", "bicgstab", "cgs", "tfqmr"}
      ## methods which do not require the transpose
      if (A_is_numeric)
        Afun = @(x) A * x;
      endif
      if (M1_is_numeric)
        M1fun = @(x) M1 \ x;
      endif
      if (M2_is_numeric)
        M2fun = @(x) M2 \ x;
      endif
    case {"bicg"}
      ## methods which do require the transpose
      if (A_is_numeric)
        Afun = @(x, trans) A_sub (A, x, trans);
      endif
      if (M1_is_numeric)
        M1fun = @(x, trans) M_sub (M1, x, trans);
      endif
      if (M2_is_numeric)
        M2fun = @(x, trans) M_sub (M2, x, trans);
      endif
    otherwise
      error (["__alltohandles__: unknown method: ", solver_name]);
  endswitch

endfunction

function y = A_sub (A, x, trans)
  if (strcmp (trans, "transp"))
    y = A' * x;
  else
    y = A * x;
  endif
endfunction

function y = M_sub (M, x, trans)
  if (strcmp (trans, "transp"))
    y = M' \ x;
  else
    y = M \ x;
  endif
endfunction
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{varargout} =} __default__input__ (@var{def_val}, @var{varargin})
## Check if the input arguments of a function are empty or missing.
## If they are, use default values.
##
## The input arguments are:
##
## @itemize @minus
## @item @var{def_val} is a cell array that contains the values to use
## as default.
##
## @item @var{varargin} are the input arguments.
## @end itemize
##
## The output arguments are:
##
## @itemize @minus
## @item @var{varargout} are the input arguments where any empty or omitted
## parameters have been replaced with default values.
##
## @end itemize
##
## @end deftypefn

function varargout = __default__input__ (def_val, varargin)

  m = numel (def_val);
  n = numel (varargin);
  count = min (m, n);

  ## Check for missing values in input and replace with default value.
  for i = 1:count
    if (isempty (varargin{i}))
      varargout{i} = def_val{i};
    else
      varargout{i} = varargin{i};
    endif
  endfor

  ## Copy any remaining items to output
  if (n < m)
    varargout(n+1:m) = def_val(n+1:m);
  elseif (m < n)
    varargout(m+1:n) = varargin(m+1:n);
  endif

endfunction
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################
##
## Original version by Paul Kienzle distributed as free software in the
## public domain.

## -*- texinfo -*-
## @deftypefn  {} {} __sprand__ (@var{s}, @var{randfun})
## @deftypefnx {} {} __sprand__ (@var{m}, @var{n}, @var{d}, @var{fcnname}, @var{randfun})
## @deftypefnx {} {} __sprand__ (@var{m}, @var{n}, @var{d}, @var{rc}, @var{fcnname}, @var{randfun})
## Undocumented internal function.
## @end deftypefn

## Actual implementation of sprand and sprandn happens here.

function S = __sprand__ (varargin)

  if (nargin == 2)
    [m, randfun] = deal (varargin{1:2});
    [i, j] = find (m);
    [nr, nc] = size (m);
    S = sparse (i, j, randfun (size (i)), nr, nc);
  else
    if (nargin == 5)
      [m, n, d, fcnname, randfun] = deal (varargin{:});
    else
      [m, n, d, rc, fcnname, randfun] = deal (varargin{:});
    endif

    if (! (isscalar (m) && m == fix (m) && m >= 0))
      error ("%s: M must be a non-negative integer", fcnname);
    endif
    if (! (isscalar (n) && n == fix (n) && n >= 0))
      error ("%s: N must be a non-negative integer", fcnname);
    endif
    if (d < 0 || d > 1)
      error ("%s: density D must be between 0 and 1", fcnname);
    endif

    if (m == 0 || n == 0)
      S = sparse (m, n);
      return;
    endif

    if (nargin == 5)
      mn = m*n;
      k = round (d*mn);
      if (mn > sizemax ())
        ## randperm will overflow, so use alternative methods

        idx = unique (fix (rand (1.01*k, 1) * mn)) + 1;

        ## idx contains random numbers in [1,mn]
        ## Generate 1% more random values than necessary in order to reduce the
        ## probability that there are less than k distinct values; maybe a
        ## better strategy could be used but I don't think it's worth the price.

        ## actual number of entries in S
        k = min (length (idx), k);
        j = floor ((idx(1:k) - 1) / m);
        i = idx(1:k) - j * m;
        j += 1;
      else
        idx = randperm (mn, k);
        [i, j] = ind2sub ([m, n], idx);
      endif

      S = sparse (i, j, randfun (k, 1), m, n);

    elseif (nargin == 6)
      ## Create a matrix with specified reciprocal condition number.

      if (! isscalar (rc) && ! isvector (rc))
        error ("%s: RC must be a scalar or vector", fcnname);
      endif

      ## We want to reverse singular valued decomposition A=U*S*V'.
      ## First, first S is constructed and then U = U1*U2*..Un and
      ## V' = V1*V2*..Vn are seen as Jacobi rotation matrices with angles and
      ## planes of rotation randomized.  Repeatedly apply rotations until the
      ## required density for A is achieved.

      if (isscalar (rc))
        if (rc < 0 || rc > 1)
          error ("%s: reciprocal condition number RC must be between 0 and 1", fcnname);
        endif
        ## Reciprocal condition number is ratio of smallest SV to largest SV
        ## Generate singular values randomly and sort them to build S
        ## Random singular values in range [rc, 1].
        v = rand (1, min (m,n)) * (1 - rc) + rc;
        v(1) = 1;
        v(end) = rc;
        v = sort (v, "descend");
        S = sparse (diag (v, m, n));
      else
        ## Only the min (m, n) greater singular values from rc vector are used.
        if (length (rc) > min (m,n))
          rc = rc(1:min (m, n));
        endif
        S = sparse (diag (sort (rc, "descend"), m, n));
      endif

      Uinit = speye (m);
      Vinit = speye (n);
      k = round (d*m*n);
      while (nnz (S) < k)
        if (m > 1)
          ## Construct U randomized rotation matrix
          rot_angleu = 2 * pi * rand ();
          cu = cos (rot_angleu); su = sin (rot_angleu);
          rndtmp = randperm (m, 2);
          i = rndtmp(1); j = rndtmp(2);
          U = Uinit;
          U(i, i) = cu; U(i, j) = -su;
          U(j, i) = su; U(j, j) = cu;
          S = U * S;
        endif
        if (n > 1)
          ## Construct V' randomized rotation matrix
          rot_anglev = 2 * pi * rand ();
          cv = cos (rot_anglev); sv = sin (rot_anglev);
          rndtmp = randperm (n, 2);
          i = rndtmp(1); j = rndtmp(2);
          V = Vinit;
          V(i, i) = cv;  V(i, j) = sv;
          V(j, i) = -sv; V(j, j) = cv;
          S *= V;
        endif
      endwhile
    endif
  endif

endfunction
########################################################################
##
## Copyright (C) 2014-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} qmr (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
## @deftypefnx {} {@var{x} =} qmr (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} qmr (@var{A}, @var{b}, @dots{})
## Solve @code{A x = b} using the Quasi-Minimal Residual iterative method
## (without look-ahead).
##
## @itemize @minus
## @item @var{rtol} is the relative tolerance, if not given or set to [] the
## default value 1e-6 is used.
##
## @item @var{maxit} the maximum number of outer iterations, if not given or
## set to [] the default value @code{min (20, numel (b))} is used.
##
## @item @var{x0} the initial guess, if not given or set to [] the default
## value @code{zeros (size (b))} is used.
## @end itemize
##
## @var{A} can be passed as a matrix or as a function handle or inline
## function @code{f} such that @code{f(x, "notransp") = A*x} and
## @code{f(x, "transp") = A'*x}.
##
## The preconditioner @var{P} is given as @code{P = M1 * M2}.  Both @var{M1}
## and @var{M2} can be passed as a matrix or as a function handle or inline
## function @code{g} such that @code{g(x, "notransp") = M1 \ x} or
## @code{g(x, "notransp") = M2 \ x} and @code{g(x, "transp") = M1' \ x} or
## @code{g(x, "transp") = M2' \ x}.
##
## If called with more than one output parameter
##
## @itemize @minus
## @item @var{flag} indicates the exit status:
##
## @itemize @minus
## @item 0: iteration converged to the within the chosen tolerance
##
## @item 1: the maximum number of iterations was reached before convergence
##
## @item 3: the algorithm reached stagnation
## @end itemize
##
## (the value 2 is unused but skipped for compatibility).
##
## @item @var{relres} is the final value of the relative residual.
##
## @item @var{iter} is the number of iterations performed.
##
## @item @var{resvec} is a vector containing the residual norms at each
##       iteration.
## @end itemize
##
## References:
##
## @enumerate
## @item
## @nospell{R. Freund and N. Nachtigal}, @cite{QMR: a quasi-minimal residual
## method for non-Hermitian linear systems}, @nospell{Numerische Mathematik},
## 1991, 60, pp.@: 315--339.
##
## @item
## @nospell{ R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra},
## @nospell{ V. Eijkhour, R. Pozo, C. Romine, and H. van der Vorst},
## @cite{Templates for the solution of linear systems: Building blocks
## for iterative methods}, SIAM, 2nd ed., 1994.
## @end enumerate
##
## @seealso{bicg, bicgstab, cgs, gmres, pcg}
## @end deftypefn

function [x, flag, relres, iter, resvec] = qmr (A, b, rtol, maxit, M1, M2, x0)

  if (nargin >= 2 && isvector (full (b)))

    if (ischar (A))
      fun = str2func (A);
      Ax  = @(x) feval (fun, x, "notransp");
      Atx = @(x) feval (fun, x, "transp");
    elseif (is_function_handle (A))
      Ax  = @(x) feval (A, x, "notransp");
      Atx = @(x) feval (A, x, "transp");
    elseif (isnumeric (A) && issquare (A))
      Ax  = @(x) A  * x;
      Atx = @(x) A' * x;
    else
      error ("qmr: A must be a square matrix or function");
    endif

    if (nargin < 3 || isempty (rtol))
      rtol = 1e-6;
    endif

    if (nargin < 4 || isempty (maxit))
      maxit = min (rows (b), 20);
    else
      maxit = fix (maxit);
    endif

    if (nargin < 5 || isempty (M1))
      M1m1x = @(x, ignore) x;
      M1tm1x = M1m1x;
    elseif (ischar (M1))
      fun = str2func (M1);
      M1m1x  = @(x) feval (fun, x, "notransp");
      M1tm1x = @(x) feval (fun, x, "transp");
    elseif (is_function_handle (M1))
      M1m1x  = @(x) feval (M1, x, "notransp");
      M1tm1x = @(x) feval (M1, x, "transp");
    elseif (isnumeric (M1) && ismatrix (M1))
      M1m1x  = @(x) M1  \ x;
      M1tm1x = @(x) M1' \ x;
    else
      error ("qmr: preconditioner M1 must be a function or matrix");
    endif

    if (nargin < 6 || isempty (M2))
      M2m1x = @(x, ignore) x;
      M2tm1x = M2m1x;
    elseif (ischar (M2))
      fun = str2func (M2);
      M2m1x  = @(x) feval (fun, x, "notransp");
      M2tm1x = @(x) feval (fun, x, "transp");
    elseif (is_function_handle (M2))
      M2m1x  = @(x) feval (M2, x, "notransp");
      M2tm1x = @(x) feval (M2, x, "transp");
    elseif (isnumeric (M2) && ismatrix (M2))
      M2m1x  = @(x) M2  \ x;
      M2tm1x = @(x) M2' \ x;
    else
      error ("qmr: preconditioner M2 must be a function or matrix");
    endif

    if (nargin < 7 || isempty (x0))
      x = zeros (size (b));
    else
      x = x0;
    endif

    r = b - Ax (x);

    bnorm = norm (b);
    res0 = norm (r);
    if (nargout > 4)
      resvec(1) = res0;
    endif
    vt = r;

    y = M1m1x (vt);

    rho0 = norm (y);
    wt = r;

    z = M2tm1x (wt);

    xi1 = norm (z);
    gamma0 = 1;
    eta0 = -1;
    flag = 1;
    for iter=1:1:maxit
      ## If rho0 == 0 or xi1 == 0, method fails.
      v = vt / rho0;
      y /= rho0;
      w = wt / xi1;
      z /= xi1;

      delta1 = z' * y;   # If delta1 == 0, method fails.

      yt = M2m1x (y);
      zt = M1tm1x (z);

      if (iter == 1)
        p = yt;
        q = zt;
      else
        p = yt - (xi1*delta1/eps0) * p;
        q = zt - (rho0*delta1/eps0) * q;
      endif
      pt = Ax (p);

      eps0 = q' * pt;          # If eps0 == 0, method fails.
      beta1 = eps0 / delta1;   # If beta1 == 0, method fails.
      vt = pt - beta1 * v;

      y = M1m1x (vt);
      rho1 = norm (y);
      wt = Atx (q) - beta1 * w;
      z = M2tm1x (wt);

      xi1 = norm (z);
      theta1 = rho1 / (gamma0 * abs (beta1));
      gamma1 = 1 / sqrt (1 + theta1^2);   # If gamma1 == 0, method fails.
      eta1 = -eta0 * rho0 * gamma1^2 / (beta1 * gamma0^2);

      if (iter == 1)
        d = eta1 * p;
        s = eta1 * pt;
      else
        d = eta1 * p + (theta0*gamma1)^2 * d;
        s = eta1 * pt + (theta0 * gamma1)^2 * s;
      endif
      x += d;
      r -= s;

      res1 = norm (r) / bnorm;
      if (nargout > 4)
        resvec(iter + 1, 1) = norm (r);
      endif

      if (res1 < rtol)
        ## Convergence achieved.
        flag = 0;
        break;
      elseif (res0 <= res1)
        ## Stagnation encountered.
        flag = 3;
        break;
      endif
      theta0 = theta1;
      eta0 = eta1;
      gamma0 = gamma1;
      rho0 = rho1;
    endfor

    relres = res1;
    if (flag == 1)
      if (nargout < 2)
        printf ("qmr stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", rtol);
        printf ("because the maximum number of iterations was reached. ");
        printf ("The iterate returned (number %i) has ", maxit);
        printf ("relative residual %e\n", res1);
      endif
    elseif (flag == 3)
      if (nargout < 2)
        printf ("qmr stopped at iteration %i ", iter);
        printf (" without converging to the desired tolerance %e\n", rtol);
        printf ("because the method stagnated.\n");
        printf ("The iterate returned (number %i) ", iter);
        printf ("has relative residual %e\n", res1);
      endif
    elseif (nargout < 2)
      printf ("qmr converged at iteration %i ", iter);
      printf ("to a solution with relative residual %e\n", res1);
    endif
  else
    print_usage ();
  endif

endfunction


%!demo
%! % Solve system of A*x=b
%! A = [5 -1 3;-1 2 -2;3 -2 3];
%! b = [7;-1;4];
%! [x, flag, relres, iter, resvec] = qmr (A, b)

%!test
%! n = 100;
%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! rtol = 1e-8;
%! maxit = 15;
%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
%! [x, flag, relres, iter, resvec] = qmr (A, b, rtol, maxit, M1, M2);
%! assert (x, ones (size (b)), 1e-7);

%!function y = afun (x, t, a)
%!  switch (t)
%!    case "notransp"
%!      y = a * x;
%!    case "transp"
%!      y = a' * x;
%!  endswitch
%!endfunction
%!
%!test
%! n = 100;
%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! rtol = 1e-8;
%! maxit = 15;
%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
%!
%! [x, flag, relres, iter, resvec] = qmr (@(x, t) afun (x, t, A),
%!                                         b, rtol, maxit, M1, M2);
%! assert (x, ones (size (b)), 1e-7);

%!test
%! n = 100;
%! rtol = 1e-8;
%! a = sprand (n, n, .1);
%! A = a' * a + 100 * eye (n);
%! b = sum (A, 2);
%! [x, flag, relres, iter, resvec] = qmr (A, b, rtol, [], diag (diag (A)));
%! assert (x, ones (size (b)), 1e-7);

%!test
%! A = [1 + 1i, 1 + 1i; 2 - 1i, 2 + 1i];
%! b = A * [1; 1];
%! [x, flag, relres, iter, resvec] = qmr (A, b);
%! assert (x, [1; 1], 1e-6);
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{s} =} spaugment (@var{A}, @var{c})
## Create the augmented matrix of @var{A}.
##
## This is given by
##
## @example
## @group
## [@var{c} * eye(@var{m}, @var{m}), @var{A};
##             @var{A}', zeros(@var{n}, @var{n})]
## @end group
## @end example
##
## @noindent
## This is related to the least squares solution of
## @code{@var{A} \ @var{b}}, by
##
## @example
## @group
## @var{s} * [ @var{r} / @var{c}; x] = [ @var{b}, zeros(@var{n}, columns(@var{b})) ]
## @end group
## @end example
##
## @noindent
## where @var{r} is the residual error
##
## @example
## @var{r} = @var{b} - @var{A} * @var{x}
## @end example
##
## As the matrix @var{s} is symmetric indefinite it can be factorized with
## @code{lu}, and the minimum norm solution can therefore be found without the
## need for a @code{qr} factorization.  As the residual error will be
## @code{zeros (@var{m}, @var{m})} for underdetermined problems, and example
## can be
##
## @example
## @group
## m = 11; n = 10; mn = max (m, n);
## A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
##              [-1, 0, 1], m, n);
## x0 = A \ ones (m,1);
## s = spaugment (A);
## [L, U, P, Q] = lu (s);
## x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
## x1 = x1(end - n + 1 : end);
## @end group
## @end example
##
## To find the solution of an overdetermined problem needs an estimate of the
## residual error @var{r} and so it is more complex to formulate a minimum norm
## solution using the @code{spaugment} function.
##
## In general the left division operator is more stable and faster than using
## the @code{spaugment} function.
## @seealso{mldivide}
## @end deftypefn

function s = spaugment (A, c)

  if (nargin < 2)
    if (issparse (A))
      c = max (max (abs (A))) / 1000;
    else
      if (ndims (A) != 2)
        error ("spaugment: A must be a 2-D matrix");
      else
        c = max (abs (A(:))) / 1000;
      endif
    endif
  elseif (! isscalar (c))
    error ("spaugment: C must be a scalar");
  endif

  [m, n] = size (A);
  s = [ c * speye(m, m), A; A', sparse(n, n)];

endfunction


%!testif HAVE_UMFPACK, HAVE_CXSPARSE
%! m = 11; n = 10; mn = max (m ,n);
%! A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],[-1,0,1], m, n);
%! x0 = A \ ones (m,1);
%! s = spaugment (A);
%! [L, U, P, Q] = lu (s);
%! x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
%! x1 = x1(end - n + 1 : end);
%! assert (x1, x0, 1e-6);
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{x} =} spconvert (@var{m})
## Convert a simple sparse matrix format easily generated by other programs
## into Octave's internal sparse format.
##
## The input @var{m} is either a 3 or 4 column real matrix, containing the
## row, column, real, and imaginary parts of the elements of the sparse
## matrix.  An element with a zero real and imaginary part can be used to
## force a particular matrix size.
## @seealso{sparse}
## @end deftypefn

function s = spconvert (m)

  if (nargin < 1)
    print_usage ();
  endif

  if (issparse (m))
    s = m;
  else
    sz = size (m);
    if (! ismatrix (m) || ! isreal (m)
        || length (sz) != 2 || (sz(2) != 3 && sz(2) != 4))
      error (["spconvert: argument must be sparse or real matrix" ...
              "with 3 or 4 columns"]);
    elseif (sz(2) == 3)
      s = sparse (m(:,1), m(:,2), m(:,3));
    else
      s = sparse (m(:,1), m(:,2), m(:,3) + 1i*m(:,4));
    endif
  endif

endfunction


%!test
%! i = [1; 3; 5];
%! j = [2; 4; 6];
%! v = [7; 8; 9];
%! s = spconvert ([i, j, v]);
%! assert (issparse (s));
%! [fi, fj, fv] = find (s);
%! assert (isequal (i, fi) && isequal (j, fj) && isequal (v, fv));
%! s = spconvert ([i, j, v, j]);
%! [fi, fj, fv] = find (s);
%! assert (isequal (i, fi) && isequal (j, fj) && isequal (complex (v, j), fv));
%! assert (size (spconvert ([1, 1, 3; 5, 15, 0])), [5, 15]);

## Test input validation
%!error <Invalid call> spconvert ()
%!error spconvert ({[1 2 3]})
%!error spconvert ([1 2])
%!error spconvert ([1 2 3i])
%!error spconvert ([1 2 3 4 5])
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{B} =} spdiags (@var{A})
## @deftypefnx {} {[@var{B}, @var{d}] =} spdiags (@var{A})
## @deftypefnx {} {@var{B} =} spdiags (@var{A}, @var{d})
## @deftypefnx {} {@var{A} =} spdiags (@var{v}, @var{d}, @var{A})
## @deftypefnx {} {@var{A} =} spdiags (@var{v}, @var{d}, @var{m}, @var{n})
## A generalization of the function @code{diag}.
##
## Called with a single input argument, the nonzero diagonals @var{d} of
## @var{A} are extracted.
##
## With two arguments the diagonals to extract are given by the vector @var{d}.
##
## The other two forms of @code{spdiags} modify the input matrix by replacing
## the diagonals.  They use the columns of @var{v} to replace the diagonals
## represented by the vector @var{d}.  If the sparse matrix @var{A} is
## defined then the diagonals of this matrix are replaced.  Otherwise a
## matrix of @var{m} by @var{n} is created with the diagonals given by the
## columns of @var{v}.
##
## Negative values of @var{d} represent diagonals below the main diagonal, and
## positive values of @var{d} diagonals above the main diagonal.
##
## For example:
##
## @example
## @group
## spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
##    @result{} 5 10  0  0
##       1  6 11  0
##       0  2  7 12
##       0  0  3  8
##       0  0  0  4
## @end group
## @end example
##
## @seealso{diag}
## @end deftypefn

function [B, d] = spdiags (v, d, m, n)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1 || nargin == 2)
    ## extract nonzero diagonals of A into B,d
    [nr, nc] = size (v);
    [i, j] = find (v);

    if (nargin == 1)
      ## d contains the active diagonals
      d = unique (j-i);
    endif

    ## FIXME: Maybe this could be done faster using [i,j,v] = find (v)
    ##        and then massaging the indices i, j.  However, some
    ##        benchmarking has shown that diag() written in C++ makes
    ##        the following code faster even with the for loop.
    Brows = min (nr, nc);
    B = zeros (Brows, length (d));
    for k = 1:length (d)
      dn = d(k);
      if (dn <= -nr || dn > nc)
        continue;
      endif
      dv = diag (v, dn);
      len = rows (dv);
      ## Put sub/super-diagonals in the right place based on matrix size (MxN)
      if (nr >= nc)
        if (dn > 0)
          offset = Brows - len + 1;
          B(offset:Brows, k) = dv;
        else
          B(1:len, k) = dv;
        endif
      else
        if (dn < 0)
          offset = Brows - len + 1;
          B(offset:Brows, k) = dv;
        else
          B(1:len, k) = dv;
        endif
      endif
    endfor

  elseif (nargin == 3)
    ## Replace specific diagonals d of m with v,d
    [nr, nc] = size (m);
    A = spdiags (m, d);
    B = m - spdiags (A, d, nr, nc) + spdiags (v, d, nr, nc);

  else
    ## Create new matrix of size mxn using v,d
    [j, i, v] = find (v);
    if (m >= n)
      offset = max (min (d(:), n-m), 0);
    else
      offset = d(:);
    endif
    j = j(:) + offset(i(:));
    i = j - d(:)(i(:));
    idx = i > 0 & i <= m & j > 0 & j <= n;
    B = sparse (i(idx), j(idx), v(idx), m, n);

  endif

endfunction


%!test
%! [B,d] = spdiags (magic (3));
%! assert (d, [-2 -1 0 1 2]');
%! assert (B, [4 3 8 0 0
%!             0 9 5 1 0
%!             0 0 2 7 6]);
%! B = spdiags (magic (3), [-2 1]);
%! assert (B, [4 0; 0 1; 0 7]);

## Test zero filling for supra- and super-diagonals
%!test
%! ## Case 1: M = N
%! A = sparse (zeros (3,3));
%! A(1,3) = 13;
%! A(3,1) = 31;
%! [B, d] = spdiags (A);
%! assert (d, [-2 2]');
%! assert (B, [31 0; 0 0; 0 13]);
%! assert (spdiags (B, d, 3,3), A);

%!test
%! ## Case 1: M > N
%! A = sparse (zeros (4,3));
%! A(1,3) = 13;
%! A(3,1) = 31;
%! [B, d] = spdiags (A);
%! assert (d, [-2 2]');
%! assert (B, [31 0; 0 0; 0 13]);
%! assert (spdiags (B, d, 4,3), A);

%!test
%! ## Case 1: M < N
%! A = sparse (zeros (3,4));
%! A(1,3) = 13;
%! A(3,1) = 31;
%! [B, d] = spdiags (A);
%! assert (d, [-2 2]');
%! assert (B, [0 13; 0 0; 31 0]);
%! assert (spdiags (B, d, 3,4), A);

%!assert (spdiags (zeros (1,0),1,1,1), sparse (0))
%!assert (spdiags (zeros (0,1),1,1,1), sparse (0))
%!assert (spdiags ([0.5 -1 0.5], 0:2, 1, 1), sparse (0.5))

## Test input validation
%!error <Invalid call> spdiags ()
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{s} =} speye (@var{m}, @var{n})
## @deftypefnx {} {@var{s} =} speye (@var{m})
## @deftypefnx {} {@var{s} =} speye (@var{sz})
## Return a sparse identity matrix of size @var{m}x@var{n}.
##
## The implementation is significantly more efficient than
## @code{sparse (eye (@var{m}))} as the full matrix is not constructed.
##
## Called with a single argument a square matrix of size
## @var{m}-by-@var{m} is created.  If called with a single vector argument
## @var{sz}, this argument is taken to be the size of the matrix to create.
## @seealso{sparse, spdiags, eye}
## @end deftypefn

function s = speye (m, n)

  if (nargin == 1)
    if (isvector (m) && length (m) == 2)
      n = m(2);
      m = m(1);
    elseif (isscalar (m))
      n = m;
    else
      error ("speye: invalid matrix dimension");
    endif
  else
    if (! isscalar (m) || ! isscalar (n))
      error ("speye: invalid matrix dimension");
    endif
  endif

  lo = min ([m, n]);
  s = sparse (1:lo, 1:lo, 1, m, n);

endfunction


%!assert (issparse (speye (4)))
%!assert (speye (4), sparse (1:4,1:4,1))
%!assert (speye (2,4), sparse (1:2,1:2,1,2,4))
%!assert (speye (4,2), sparse (1:2,1:2,1,4,2))
%!assert (speye ([4,2]), sparse (1:2,1:2,1,4,2))
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{y} =} spfun (@var{f}, @var{S})
## Compute @code{f (@var{S})} for the nonzero elements of @var{S}.
##
## The input function @var{f} is applied only to the nonzero elements of
## the input matrix @var{S} which is typically sparse.  The function @var{f}
## can be passed as a string, function handle, or inline function.
##
## The output @var{y} is a sparse matrix with the same sparsity structure as
## the input @var{S}.  @code{spfun} preserves sparsity structure which is
## different than simply applying the function @var{f} to the sparse matrix
## @var{S} when @code{@var{f} (0) != 0}.
##
## Example
##
## Sparsity preserving @code{spfun} versus normal function application
##
## @example
## @group
## S = pi * speye (2,2)
## S =
##
## Compressed Column Sparse (rows = 2, cols = 2, nnz = 2 [50%])
##
##   (1, 1) -> 3.1416
##   (2, 2) -> 3.1416
##
## y = spfun (@@cos, S)
## y =
##
## Compressed Column Sparse (rows = 2, cols = 2, nnz = 2 [50%])
##
##   (1, 1) -> -1
##   (2, 2) -> -1
## @end group
##
## @group
## y = cos (S)
## y =
##
## Compressed Column Sparse (rows = 2, cols = 2, nnz = 4 [100%])
##
##   (1, 1) -> -1
##   (2, 1) -> 1
##   (1, 2) -> 1
##   (2, 2) -> -1
##
## @end group
## @end example
## @seealso{arrayfun, cellfun, structfun}
## @end deftypefn

function y = spfun (f, S)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isnumeric (S))
    error ("spfun: S must be numeric");
  endif

  [i, j, v] = find (S);
  [m, n] = size (S);

  y = sparse (i, j, feval (f, v), m, n);

endfunction


%!assert (spfun ("exp", [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
%!assert (spfun ("exp", sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))
%!assert (spfun (@exp, [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
%!assert (spfun (@exp, sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))

## Test input validation
%!error <Invalid call> spfun ()
%!error <Invalid call> spfun (@cos)
%!error <S must be numeric> spfun (@cos, {1})
%!error <S must be numeric> spfun (@cos, "FooBar")
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{r} =} spones (@var{S})
## Replace the nonzero entries of @var{S} with ones.
##
## This creates a sparse matrix with the same structure as @var{S}.
## @seealso{sparse, sprand, sprandn, sprandsym, spfun, spy}
## @end deftypefn

function r = spones (S)

  if (nargin < 1)
    print_usage ();
  endif

  [i, j, v] = find (S);
  [m, n] = size (S);

  r = sparse (i, j, 1, m, n);

endfunction


%!assert (issparse (spones ([1,2;3,0])))
%!assert (spones ([1,2;3,0]), sparse ([1,1;1,0]))
%!assert (spones (sparse ([1,2;3,0])), sparse ([1,1;1,0]))
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################
##
## Original version by Paul Kienzle distributed as free software in the
## public domain.

## -*- texinfo -*-
## @deftypefn  {} {} sprand (@var{m}, @var{n}, @var{d})
## @deftypefnx {} {} sprand (@var{m}, @var{n}, @var{d}, @var{rc})
## @deftypefnx {} {} sprand (@var{s})
## Generate a sparse matrix with uniformly distributed random values.
##
## The size of the matrix is @var{m}x@var{n} with a density of values @var{d}.
## @var{d} must be between 0 and 1.  Values will be uniformly distributed on
## the interval (0, 1).
##
## If called with a single matrix argument, a sparse matrix is generated with
## random values wherever the matrix @var{s} is nonzero.
##
## If called with a scalar fourth argument @var{rc}, a random sparse matrix
## with reciprocal condition number @var{rc} is generated.  If @var{rc} is
## a vector, then it specifies the first singular values of the generated
## matrix (@code{length (@var{rc}) <= min (@var{m}, @var{n})}).
##
## @seealso{sprandn, sprandsym, rand}
## @end deftypefn

function s = sprand (m, n, d, rc)

  if (nargin == 1)
    s = __sprand__ (m, @rand);
  elseif (nargin == 3)
    s = __sprand__ (m, n, d, "sprand", @rand);
  elseif (nargin == 4)
    s = __sprand__ (m, n, d, rc, "sprand", @rand);
  else
    print_usage ();
  endif

endfunction


## Test 3-input calling form
%!test
%! s = sprand (4, 10, 0.1);
%! assert (size (s), [4, 10]);
%! assert (nnz (s) / numel (s), 0.1);

## Test 4-input calling form
%!test
%! d = rand ();
%! s1 = sprand (100, 100, d, 0.4);
%! rc = [5, 4, 3, 2, 1, 0.1];
%! s2 = sprand (100, 100, d, rc);
%! s3 = sprand (6, 4, d, rc);
%! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps));
%! assert (1/cond (s1), 0.4, sqrt (eps));
%! assert (nnz (s1) / (100*100), d, 0.02);
%! assert (nnz (s2) / (100*100), d, 0.02);
%! assert (svd (s3)', [5 4 3 2], sqrt (eps));

## Test 1-input calling form
%!test
%! s = sprand (sparse ([1 2 3], [3 2 3], [2 2 2]));
%! [i, j, v] = find (s);
%! assert (sort (i), [1 2 3]');
%! assert (sort (j), [2 3 3]');
%! assert (all (v > 0 & v < 1));

## Test very large, very low density matrix doesn't fail
%!test
%! s = sprand (1e6, 1e6, 1e-7);

## Test empty array creation
%!assert (size (sprand (0, 0, 0.5)), [0, 0])
%!assert (size (sprand (0, 3, 0.5)), [0, 3])
%!assert (size (sprand (3, 0, 0.5)), [3, 0])

## Test input validation
%!error <Invalid call> sprand ()
%!error <Invalid call> sprand (1, 2)
%!error <M must be a non-negative integer> sprand (-1, -1, 0.5)
%!error <M must be a non-negative integer> sprand (ones (3), 3, 0.5)
%!error <M must be a non-negative integer> sprand (3.5, 3, 0.5)
%!error <M must be a non-negative integer> sprand (-1, 3, 0.5)
%!error <N must be a non-negative integer> sprand (3, ones (3), 0.5)
%!error <N must be a non-negative integer> sprand (3, 3.5, 0.5)
%!error <N must be a non-negative integer> sprand (3, -1, 0.5)
%!error <D must be between 0 and 1> sprand (3, 3, -1)
%!error <D must be between 0 and 1> sprand (3, 3, 2)
%!error <RC must be a scalar or vector> sprand (2, 2, 0.2, ones (3,3))
%!error <RC must be between 0 and 1> sprand (2, 2, 0.2, -1)
%!error <RC must be between 0 and 1> sprand (2, 2, 0.2, 2)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################
##
## Original version by Paul Kienzle distributed as free software in the
## public domain.

## -*- texinfo -*-
## @deftypefn  {} {} sprandn (@var{m}, @var{n}, @var{d})
## @deftypefnx {} {} sprandn (@var{m}, @var{n}, @var{d}, @var{rc})
## @deftypefnx {} {} sprandn (@var{s})
## Generate a sparse matrix with normally distributed random values.
##
## The size of the matrix is @var{m}x@var{n} with a density of values @var{d}.
## @var{d} must be between 0 and 1.  Values will be normally distributed with a
## mean of 0 and a variance of 1.
##
## If called with a single matrix argument, a sparse matrix is generated with
## random values wherever the matrix @var{s} is nonzero.
##
## If called with a scalar fourth argument @var{rc}, a random sparse matrix
## with reciprocal condition number @var{rc} is generated.  If @var{rc} is
## a vector, then it specifies the first singular values of the generated
## matrix (@code{length (@var{rc}) <= min (@var{m}, @var{n})}).
##
## @seealso{sprand, sprandsym, randn}
## @end deftypefn

function s = sprandn (m, n, d, rc)

  if (nargin == 1)
    s = __sprand__ (m, @randn);
  elseif (nargin == 3)
    s = __sprand__ (m, n, d, "sprandn", @randn);
  elseif (nargin == 4)
    s = __sprand__ (m, n, d, rc, "sprandn", @randn);
  else
    print_usage ();
  endif

endfunction


## Test 3-input calling form
%!test
%! s = sprandn (4, 10, 0.1);
%! assert (size (s), [4, 10]);
%! assert (nnz (s) / numel (s), 0.1);

## Test 4-input calling form
%!test
%! d = rand ();
%! s1 = sprandn (100, 100, d, 0.4);
%! rc = [5, 4, 3, 2, 1, 0.1];
%! s2 = sprandn (100, 100, d, rc);
%! s3 = sprandn (6, 4, d, rc);
%! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps));
%! assert (1/cond (s1), 0.4, sqrt (eps));
%! assert (nnz (s1) / (100*100), d, 0.02);
%! assert (nnz (s2) / (100*100), d, 0.02);
%! assert (svd (s3)', [5 4 3 2], sqrt (eps));

## Test 1-input calling form
%!test
%! s = sprandn (sparse ([1 2 3], [3 2 3], [2 2 2]));
%! [i, j] = find (s);
%! assert (sort (i), [1 2 3]');
%! assert (sort (j), [2 3 3]');

## Test very large, very low density matrix doesn't fail
%!test
%! s = sprandn (1e6,1e6,1e-7);

## Test empty array creation
%!assert (size (sprandn (0, 0, 0.5)), [0, 0])
%!assert (size (sprandn (0, 3, 0.5)), [0, 3])
%!assert (size (sprandn (3, 0, 0.5)), [3, 0])

## Test input validation
%!error <Invalid call> sprandn ()
%!error <Invalid call> sprandn (1, 2)
%!error <M must be a non-negative integer> sprand (-1, -1, 0.5)
%!error <M must be a non-negative integer> sprandn (ones (3), 3, 0.5)
%!error <M must be a non-negative integer> sprandn (3.5, 3, 0.5)
%!error <M must be a non-negative integer> sprandn (-1, 3, 0.5)
%!error <N must be a non-negative integer> sprandn (3, ones (3), 0.5)
%!error <N must be a non-negative integer> sprandn (3, 3.5, 0.5)
%!error <N must be a non-negative integer> sprandn (3, -1, 0.5)
%!error <D must be between 0 and 1> sprandn (3, 3, -1)
%!error <D must be between 0 and 1> sprandn (3, 3, 2)
%!error <RC must be a scalar or vector> sprandn (2, 2, 0.2, ones (3,3))
%!error <RC must be between 0 and 1> sprandn (2, 2, 0.2, -1)
%!error <RC must be between 0 and 1> sprandn (2, 2, 0.2, 2)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} sprandsym (@var{n}, @var{d})
## @deftypefnx {} {} sprandsym (@var{s})
## Generate a symmetric random sparse matrix.
##
## The size of the matrix will be @var{n}x@var{n}, with a density of values
## given by @var{d}.  @var{d} must be between 0 and 1 inclusive.  Values will
## be normally distributed with a mean of zero and a variance of 1.
##
## If called with a single matrix argument, a random sparse matrix is generated
## wherever the matrix @var{s} is nonzero in its lower triangular part.
## @seealso{sprand, sprandn, spones, sparse}
## @end deftypefn

function S = sprandsym (n, d)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    [i, j] = find (tril (n));
    [nr, nc] = size (n);
    S = sparse (i, j, randn (size (i)), nr, nc);
    S += tril (S, -1)';
    return;
  endif

  if (!(isscalar (n) && n == fix (n) && n >= 0))
    error ("sprandsym: N must be a non-negative integer 0");
  endif

  if (n == 0)
    S = sparse (n, n);
    return;
  endif

  if (d < 0 || d > 1)
    error ("sprandsym: density D must be between 0 and 1");
  endif

  ## Actual number of nonzero entries
  k = round (n^2*d);

  ## Diagonal nonzero entries, same parity as k
  r = pick_rand_diag (n, k);

  ## Off diagonal nonzero entries
  m = (k - r)/2;

  ondiag = randperm (n, r);
  offdiag = randperm (n*(n - 1)/2, m);

  ## Row index
  i = lookup (cumsum (0:n), offdiag - 1) + 1;

  ## Column index
  j = offdiag - (i - 1).*(i - 2)/2;

  diagvals = randn (1, r);
  offdiagvals = randn (1, m);

  S = sparse ([ondiag, i, j], [ondiag, j, i],
              [diagvals, offdiagvals, offdiagvals], n, n);

endfunction

function r = pick_rand_diag (n, k)

  ## Pick a random number R of entries for the diagonal of a sparse NxN
  ## symmetric square matrix with exactly K nonzero entries, ensuring
  ## that this R is chosen uniformly over all such matrices.
  ##
  ## Let D be the number of diagonal entries and M the number of
  ## off-diagonal entries.  Then K = D + 2*M.  Let A = N*(N-1)/2 be the
  ## number of available entries in the upper triangle of the matrix.
  ## Then, by a simple counting argument, there is a total of
  ##
  ##     T = nchoosek (N, D) * nchoosek (A, M)
  ##
  ## symmetric NxN matrices with a total of K nonzero entries and D on
  ## the diagonal.  Letting D range from mod (K,2) through min (N,K), and
  ## dividing by this sum, we obtain the probability P for D to be each
  ## of those values.
  ##
  ## However, we cannot use this form for computation, as the binomial
  ## coefficients become unmanageably large.  Instead, we use the
  ## successive quotients Q(i) = T(i+1)/T(i), which we easily compute to
  ## be
  ##
  ##               (N - D)*(N - D - 1)*M
  ##     Q =  -------------------------------
  ##            (D + 2)*(D + 1)*(A - M + 1)
  ##
  ## Then, after prepending 1, the cumprod of these quotients is
  ##
  ##      C = [ T(1)/T(1), T(2)/T(1), T(3)/T(1), ..., T(N)/T(1) ]
  ##
  ## Their sum is thus S = sum (T)/T(1), and then C(i)/S is the desired
  ## probability P(i) for i=1:N.  The cumsum will finally give the
  ## distribution function for computing the random number of entries on
  ## the diagonal R.
  ##
  ## Thanks to Zsbn Ambrus <ambrus@math.bme.hu> for most of the ideas
  ## of the implementation here, especially how to do the computation
  ## numerically to avoid overflow.

  ## Degenerate case
  if (k == 1)
    r = 1;
    return;
  endif

  ## Compute the stuff described above
  a = n*(n - 1)/2;
  d = [mod(k,2):2:min(n,k)-2];
  m = (k - d)/2;
  q = (n - d).*(n - d - 1).*m ./ (d + 2)./(d + 1)./(a - m + 1);

  ## Slight modification from discussion above: pivot around the max in
  ## order to avoid overflow (underflow is fine, just means effectively
  ## zero probabilities).
  [~, midx] = max (cumsum (log (q)));
  midx += 1;
  lc = fliplr (cumprod (1./q(midx-1:-1:1)));
  rc = cumprod (q(midx:end));

  ## Now c = t(i)/t(midx), so c > 1 == [].
  c = [lc, 1, rc];
  s = sum (c);
  p = c/s;

  ## Add final d
  d(end+1) = d(end) + 2;

  ## Pick a random r using this distribution
  r = d(sum (cumsum (p) < rand) + 1);

endfunction


%!test
%! s = sprandsym (10, 0.1);
%! assert (issparse (s));
%! assert (issymmetric (s));
%! assert (size (s), [10, 10]);
%! assert (nnz (s) / numel (s), 0.1, .01);

## Test 1-input calling form
%!test
%! s = sprandsym (sparse ([1 2 3], [3 2 3], [2 2 2]));
%! [i, j] = find (s);
%! assert (sort (i), [2 3]');
%! assert (sort (j), [2 3]');

## Test empty array creation
%!assert (size (sprandsym (0, 0.5)), [0, 0])

## Test input validation
%!error <Invalid call> sprandsym ()
%!error sprandsym (ones (3), 0.5)
%!error sprandsym (3.5, 0.5)
%!error sprandsym (-1, 0.5)
%!error sprandsym (3, -1)
%!error sprandsym (3, 2)
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S})
## @deftypefnx {} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S}, @var{j})
## Return the stats for the nonzero elements of the sparse matrix @var{S}.
##
## @var{count} is the number of nonzeros in each column, @var{mean} is the mean
## of the nonzeros in each column, and @var{var} is the variance of the
## nonzeros in each column.
##
## Called with two input arguments, if @var{S} is the data and @var{j} is the
## bin number for the data, compute the stats for each bin.  In this case,
## bins can contain data values of zero, whereas with
## @code{spstats (@var{S})} the zeros may disappear.
## @end deftypefn

function [count, mean, var] = spstats (S, j)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    [i, j, v] = find (S);
  else
    v = S;
    i = 1:length (v);
    S = sparse (i, j, v);
  endif
  [n, m] = size (S);

  count = sum (sparse (i, j, 1, n, m));
  if (nargout > 1)
    mean = sum (S) ./ count;
  endif
  if (nargout > 2)
    ## FIXME: Variance with count = 0 or 1?
    diff = S - sparse (i, j, mean (j), n, m);
    var = sum (diff .* diff) ./ (count - 1);
  endif

endfunction


%!test
%! [n,m,v] = spstats ([1 2 1 2 3 4],[2 2 1 1 1 1]);
%! assert (n, sparse ([4,2]));
%! assert (m, sparse ([10/4,3/2]), 10*eps);
%! assert (v, sparse ([5/3,1/2]), 10*eps);
########################################################################
##
## Copyright (C) 1998-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} spy (@var{x})
## @deftypefnx {} {} spy (@dots{}, @var{markersize})
## @deftypefnx {} {} spy (@dots{}, @var{line_spec})
## Plot the sparsity pattern of the sparse matrix @var{x}.
##
## If the optional numeric argument @var{markersize} is given, it determines
## the size of the markers used in the plot.
##
## If the optional string @var{line_spec} is given it is passed to @code{plot}
## and determines the appearance of the plot.
## @seealso{plot, gplot}
## @end deftypefn

function spy (x, varargin)

  if (nargin < 1 || nargin > 3)
    print_usage ();
  endif

  markersize = NaN;
  if (nnz (x) < 1000)
    line_spec = "*";
  else
    line_spec = ".";
  endif
  for arg = varargin
    arg = arg{1};
    if (ischar (arg))
      if (numel (arg) == 1)
        line_spec = [line_spec, arg];
      else
        line_spec = arg;
      endif
    elseif (isreal (arg) && isscalar (arg))
      markersize = arg;
    else
      error ("spy: expected markersize or linespec");
    endif
  endfor

  [i, j] = find (x);
  [m, n] = size (x);

  if (isnan (markersize))
    plot (j, i, line_spec);
  else
    plot (j, i, line_spec, "markersize", markersize);
  endif

  axis ([0, n+1, 0, m+1], "ij");
  xlabel (sprintf ("nnz = %d", nnz (x)));

endfunction


%!demo
%! clf;
%! spy (sprand (10,10, 0.2));

## Test input validation
%!error <Invalid call> spy ()
%!error <Invalid call> spy (1,2,3,4)
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{s} =} svds (@var{A})
## @deftypefnx {} {@var{s} =} svds (@var{A}, @var{k})
## @deftypefnx {} {@var{s} =} svds (@var{A}, @var{k}, @var{sigma})
## @deftypefnx {} {@var{s} =} svds (@var{A}, @var{k}, @var{sigma}, @var{opts})
## @deftypefnx {} {[@var{u}, @var{s}, @var{v}] =} svds (@dots{})
## @deftypefnx {} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
##
## Find a few singular values of the matrix @var{A}.
##
## The singular values are calculated using
##
## @example
## @group
## [@var{m}, @var{n}] = size (@var{A});
## @var{s} = eigs ([sparse(@var{m}, @var{m}), @var{A};
##                      @var{A}', sparse(@var{n}, @var{n})])
## @end group
## @end example
##
## The eigenvalues returned by @code{eigs} correspond to the singular values
## of @var{A}.  The number of singular values to calculate is given by @var{k}
## and defaults to 6.
##
## The argument @var{sigma} specifies which singular values to find.  When
## @var{sigma} is the string @qcode{'L'}, the default, the largest singular
## values of @var{A} are found.  Otherwise, @var{sigma} must be a real scalar
## and the singular values closest to @var{sigma} are found.  As a corollary,
## @code{@var{sigma} = 0} finds the smallest singular values.  Note that for
## relatively small values of @var{sigma}, there is a chance that the
## requested number of singular values will not be found.  In that case
## @var{sigma} should be increased.
##
## @var{opts} is a structure defining options that @code{svds} will pass
## to @code{eigs}.  The possible fields of this structure are documented in
## @code{eigs}.  By default, @code{svds} sets the following three fields:
##
## @table @code
## @item tol
## The required convergence tolerance for the singular values.  The default
## value is 1e-10.  @code{eigs} is passed @code{@var{tol} / sqrt (2)}.
##
## @item maxit
## The maximum number of iterations.  The default is 300.
##
## @item disp
## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then
## diagnostics are disabled.  The default value is 0.
## @end table
##
## If more than one output is requested then @code{svds} will return an
## approximation of the singular value decomposition of @var{A}
##
## @example
## @var{A}_approx = @var{u}*@var{s}*@var{v}'
## @end example
##
## @noindent
## where @var{A}_approx is a matrix of size @var{A} but only rank @var{k}.
##
## @var{flag} returns 0 if the algorithm has successfully converged, and 1
## otherwise.  The test for convergence is
##
## @example
## @group
## norm (@var{A}*@var{v} - @var{u}*@var{s}, 1) <= @var{tol} * norm (@var{A}, 1)
## @end group
## @end example
##
## @code{svds} is best for finding only a few singular values from a large
## sparse matrix.  Otherwise, @code{svd (full (@var{A}))} will likely be more
## efficient.
## @seealso{svd, eigs}
## @end deftypefn

function [u, s, v, flag] = svds (A, k, sigma, opts)

  persistent root2 = sqrt (2);

  if (nargin < 1)
    print_usage ();
  endif

  if (ndims (A) > 2)
    error ("svds: A must be a 2-D matrix");
  endif

  if (nargin < 4)
    opts.tol = 0;    # use ARPACK default
    opts.disp = 0;
    opts.maxit = 300;
  else
    if (! isstruct (opts))
      error ("svds: OPTS must be a structure");
    endif
    if (! isfield (opts, "tol"))
      opts.tol = 0;  # use ARPACK default
    else
      opts.tol = opts.tol / root2;
    endif
    if (isfield (opts, "v0"))
      if (! isvector (opts.v0) || (length (opts.v0) != sum (size (A))))
        error ("svds: OPTS.v0 must be a vector with rows (A) + columns (A) entries");
      endif
    endif
  endif

  if (nargin < 3 || strcmp (sigma, "L"))
    if (isreal (A))
      sigma = "LA";
    else
      sigma = "LR";
    endif
  elseif (isscalar (sigma) && isnumeric (sigma) && isreal (sigma))
    if (sigma < 0)
      error ("svds: SIGMA must be a positive real value");
    endif
  else
    error ("svds: SIGMA must be a positive real value or the string 'L'");
  endif

  [m, n] = size (A);
  max_a = max (abs (nonzeros (A)));
  if (isempty (max_a))
    max_a = 0;
  endif
  ## Must initialize variable value, otherwise it may appear to interpreter
  ## that code is trying to call flag() colormap function.
  flag = 0;

  if (max_a == 0)
    s = zeros (k, 1);  # special case of zero matrix
  else
    if (nargin < 2)
      k = min ([6, m, n]);
    else
      k = min ([k, m, n]);
    endif

    ## Scale everything by the 1-norm to make things more stable.
    b = A / max_a;
    b_opts = opts;
    ## Call to eigs is always a symmetric matrix by construction
    b_opts.issym = true;
    b_sigma = sigma;
    if (! ischar (b_sigma))
      b_sigma /= max_a;
    endif

    if (b_sigma == 0)
      ## Find the smallest eigenvalues
      ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0.
      ## As we are only interested in the positive eigenvalues, we have to
      ## double k and then throw out the k negative eigenvalues.
      ## Separately, if sigma is nonzero, but smaller than the smallest
      ## singular value, ARPACK may not return k eigenvalues.  However, as
      ## computation scales with k we'd like to avoid doubling k for all
      ## scalar values of sigma.
      b_k = 2 * k;
    else
      b_k = k;  # Normal case, find just the k largest eigenvalues
    endif

    if (nargout > 1)
      [V, s, flag] = eigs ([sparse(m,m), b; b', sparse(n,n)],
                           b_k, b_sigma, b_opts);
      s = diag (s);
    else
      s = eigs ([sparse(m,m), b; b', sparse(n,n)], b_k, b_sigma, b_opts);
    endif

    if (ischar (sigma))
      norma = max (s);
    else
      norma = normest (A);
    endif
    ## We wish to exclude all eigenvalues that are less than zero as these
    ## are artifacts of the way the matrix passed to eigs is formed.  There
    ## is also the possibility that the value of sigma chosen is exactly
    ## a singular value, and in that case we're dead!! So have to rely on
    ## the warning from eigs.  We exclude the singular values which are
    ## less than or equal to zero to within some tolerance scaled by the
    ## norm since if we don't we might end up with too many singular
    ## values.
    if (b_sigma == 0)
      if (sum (s>0) < k)
        ## It may happen that the number of positive s is less than k.
        ## In this case, take -s (if s in an eigenvalue, so is -s),
        ## flipped upside-down.
        s = flipud (-s);
      endif
    endif
    tol = norma * opts.tol;
    ind = find (s > tol);
    if (length (ind) < k)
      ## Too few eigenvalues returned.  Add in any zero eigenvalues of B,
      ## including the nominally negative ones.
      zind = find (abs (s) <= tol);
      p = min (length (zind), k - length (ind));
      ind = [ind; zind(1:p)];
    elseif (length (ind) > k)
      ## Too many eigenvalues returned.  Select according to criterion.
      if (b_sigma == 0)
        ind = ind(end+1-k:end); # smallest eigenvalues
      else
        ind = ind(1:k);         # largest eigenvalues
      endif
    endif
    s = s(ind);

    if (length (s) < k)
      warning ("svds: returning fewer singular values than requested");
      if (! ischar (sigma))
        warning ("svds: try increasing the value of sigma");
      endif
    endif

    s *= max_a;
  endif

  if (nargout < 2)
    u = s;
  else
    if (max_a == 0)
      u = eye (m, k);
      s = diag (s);
      v = eye (n, k);
    else
      u = root2 * V(1:m,ind);
      s = diag (s);
      v = root2 * V(m+1:end,ind);
    endif

    if (nargout > 3)
      flag = (flag != 0);
    endif
  endif

endfunction


%!shared n, k, A, u, s, v, opts, rand_state, randn_state, tol
%! n = 100;
%! k = 7;
%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
%! [u,s,v] = svd (full (A));
%! s = diag (s);
%! [~, idx] = sort (abs (s));
%! s = s(idx);
%! u = u(:, idx);
%! v = v(:, idx);
%! rand_state = rand ("state");
%! rand ("state", 42);
%! opts.v0 = rand (2*n,1);  # Initialize eigs ARPACK starting vector
%!                          # to guarantee reproducible results

%!testif HAVE_ARPACK
%! [u2,s2,v2,flag] = svds (A,k);
%! s2 = diag (s2);
%! assert (flag, ! 1);
%! tol = 15 * eps * norm (s2, 1);
%! assert (s2, s(end:-1:end-k+1), tol);

%!testif HAVE_ARPACK, HAVE_UMFPACK
%! [u2,s2,v2,flag] = svds (A,k,0,opts);
%! s2 = diag (s2);
%! assert (flag, ! 1);
%! tol = 15 * eps * norm (s2, 1);
%! assert (s2, s(k:-1:1), tol);

%!testif HAVE_ARPACK, HAVE_UMFPACK
%! idx = floor (n/2);
%! % Don't put sigma right on a singular value or there are convergence issues
%! sigma = 0.99*s(idx) + 0.01*s(idx+1);
%! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
%! s2 = diag (s2);
%! assert (flag, ! 1);
%! tol = 15 * eps * norm (s2, 1);
%! assert (s2, s((idx+floor (k/2)):-1:(idx-floor (k/2))), tol);

%!testif HAVE_ARPACK
%! [u2,s2,v2,flag] = svds (zeros (10), k);
%! assert (u2, eye (10, k));
%! assert (s2, zeros (k));
%! assert (v2, eye (10, 7));
%!
%!testif HAVE_ARPACK
%! s = svds (speye (10));
%! assert (s, ones (6, 1), 8*eps);

%!testif HAVE_ARPACK <57185>
%! z = complex (ones (10), ones (10));
%! s = svds (z);
%! assert (isreal (s));

%!test
%! ## Restore random number generator seed at end of tests
%! rand ("state", rand_state);
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} tfqmr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
## @deftypefnx {} {@var{x} =} tfqmr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} tfqmr (@var{A}, @var{b}, @dots{})
## Solve @code{A x = b} using the Transpose-Tree qmr method, based on the cgs.
##
## The input parameters are:
##
## @itemize @minus
##
## @item @var{A} is the matrix of the linear system and it must be square.
## @var{A} can be passed as a matrix, function handle, or inline
## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
## parameters to @code{Afun} are passed after @var{x0}.
##
## @item @var{b} is the right hand side vector.  It must be a column vector
## with the same number of rows as @var{A}.
##
## @item @var{tol} is the relative tolerance, if not given or set to [] the
## default value 1e-6 is used.
##
## @item @var{maxit} the maximum number of outer iterations, if not given or
## set to [] the default value @code{min (20, numel (b))} is used.  To be
## compatible, since the method as different behaviors in the iteration
## number is odd or even, is considered as iteration in @code{tfqmr} the
## entire odd-even cycle.  That is, to make an entire iteration, the algorithm
## performs two sub-iterations: the odd one and the even one.
##
## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
## @var{M} is given as @code{M = M1 * M2}.
## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
## @code{g(x) = M2 \ x}.
## The technique used is the right-preconditioning, i.e., it is solved
## @code{A*inv(M)*y = b} and then @code{x = inv(M)*y}, instead of
## @code{A x = b}.
##
## @item @var{x0} the initial guess, if not given or set to [] the default
## value @code{zeros (size (b))} is used.
##
## @end itemize
##
## The arguments which follow @var{x0} are treated as parameters, and passed in
## a proper way to any of the functions (@var{A} or @var{M}) which are passed
## to @code{tfqmr}.
##
## The output parameters are:
##
## @itemize @minus
##
## @item @var{x} is the approximation computed.  If the method doesn't
## converge then it is the iterated with the minimum residual.
##
## @item @var{flag} indicates the exit status:
##
## @itemize @minus
## @item 0: iteration converged to the within the chosen tolerance
##
## @item 1: the maximum number of iterations was reached before convergence
##
## @item 2: the preconditioner matrix is singular
##
## @item 3: the algorithm reached stagnation
##
## @item 4: the algorithm can't continue due to a division by zero
## @end itemize
##
## @item @var{relres} is the relative residual obtained as
## @code{(@var{A}*@var{x}-@var{b}) / @code{norm (@var{b})}}.
##
## @item @var{iter} is the iteration which @var{x} is
## computed.
##
## @item @var{resvec} is a vector containing the residual at each iteration
## (including @code{norm (b - A x0)}).
## Doing @code{length (@var{resvec}) - 1} is possible to see the
## total number of iterations performed.
##
## @end itemize
##
## Let us consider a trivial problem with a tridiagonal matrix
##
## @example
## @group
## n = 20;
## A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
##     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
##     sparse (1, 2, 1, 1, n) * n / 2);
## b = A * ones (n, 1);
## restart = 5;
## [M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
## M = M1 * M2;
## Afun = @@(x) A * x;
## Mfun = @@(x) M \ x;
## M1fun = @@(x) M1 \ x;
## M2fun = @@(x) M2 \ x;
## @end group
## @end example
##
## @sc{Example 1:} simplest usage of @code{tfqmr}
##
## @example
## x = tfqmr (A, b, [], n)
## @end example
##
## @sc{Example 2:} @code{tfqmr} with a function which computes
## @code{@var{A} * @var{x}}
##
## @example
## x = tfqmr (Afun, b, [], n)
## @end example
##
## @sc{Example 3:} @code{tfqmr} with a preconditioner matrix @var{M}
##
## @example
## x = tfqmr (A, b, [], 1e-06, n, M)
## @end example
##
## @sc{Example 4:} @code{tfqmr} with a function as preconditioner
##
## @example
## x = tfqmr (Afun, b, 1e-6, n, Mfun)
## @end example
##
## @sc{Example 5:} @code{tfqmr} with preconditioner matrices @var{M1}
## and @var{M2}
##
## @example
## x = tfqmr (A, b, [], 1e-6, n, M1, M2)
## @end example
##
## @sc{Example 6:} @code{tfmqr} with functions as preconditioners
##
## @example
## x = tfqmr (Afun, b, 1e-6, n, M1fun, M2fun)
## @end example
##
## @sc{Example 7:} @code{tfqmr} with as input a function requiring an argument
##
## @example
## @group
## function y = Ap (A, x, z) # compute A^z * x
##    y = x;
##    for i = 1:z
##      y = A * y;
##    endfor
##  endfunction
## Apfun = @@(x, string, p) Ap (A, x, string, p);
## x = tfqmr (Apfun, b, [], [], [], [], [], 2);
## @end group
## @end example
##
## @sc{Example 8:} explicit example to show that @code{tfqmr} uses a
## right preconditioner
##
## @example
## @group
## [M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
## M = M1 * M2;
##
## ## reference solution computed by tfqmr after one iteration
## [x_ref, fl] = tfqmr (A, b, [], 1, M)
##
## ## right preconditioning
## [y, fl] = tfqmr (A / M, b, [], 1)
## x = M \ y # compare x and x_ref
##
## @end group
## @end example
##
## Reference:
##
## @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
## Second edition, 2003, SIAM
##
## @seealso{bicg, bicgstab, cgs, gmres, pcg, qmr, pcr}
##
## @end deftypefn

function [x_min, flag, relres, iter_min, resvec] = ...
         tfqmr (A, b, tol = [], maxit = [], M1 = [], M2 = [], ...
                x0 = [], varargin)

  [Afun, M1fun, M2fun] = __alltohandles__ (A, b, M1, M2, "tfqmr");

  [tol, maxit, x0] = __default__input__ ({1e-06, 2 * min(20, rows (b)), ...
                                          zeros(rows (b), 1)}, tol, ...
                                         maxit, x0);

  maxit = 2 * maxit; # To be compatible, since iteration = odd+even ones

  norm_b = norm (b, 2);
  if (norm_b == 0)
    if (nargout < 2)
      printf ("The right hand side vector is all zero so tfqmr \n")
      printf ("returned an all zero solution without iterating.\n")
    endif
    x_min = zeros (numel (b), 1);
    iter_min = 0;
    flag = 0;
    resvec = 0;
    relres = 0;
    return;
  endif

  x = x_pr = x_min = x0;
  iter = iter_min = m = 0;
  resvec = zeros (maxit, 1);
  flag = 1;

  w = u = r = r_star = b - feval (Afun, x0, varargin{:});
  rho_1 = (r_star' * r);
  d = 0;
  tau = norm (r, 2);
  theta = eta = 0;
  resvec (1, 1) = norm (r, 2);
  it = 1;

  try
    warning ("error", "Octave:singular-matrix", "local");
    u_hat = feval (M1fun, u, varargin{:});
    u_hat = feval (M2fun, u_hat, varargin{:});
    v = feval (Afun, u_hat, varargin{:});
  catch
    flag = 2;
  end_try_catch
  while ((flag != 2) && (iter < maxit) && ...
         (resvec (iter + 1, 1) >= norm_b * tol))
    if (it > 0) # iter is even
      v_r = r_star' * v; # inner prod between r_star and v
      if (v_r == 0)
        ## Essentially the next iteration doesn't change x,
        ## and the iter after this will have a division by zero
        flag = 4;
        break;
      endif
      alpha = rho_1 / v_r;
      u_1 = u - alpha * v;  # u at the after iteration
    endif
    u_hat = feval (M1fun, u, varargin{:});
    u_hat = feval (M2fun, u_hat, varargin{:});
    w -= alpha * feval (Afun, u_hat, varargin{:});
    d = u_hat + ((theta * theta) / alpha) * eta * d;
    theta = norm (w, 2) / tau;
    c = 1 / sqrt (1 + theta * theta);
    tau *= theta * c;
    eta = (c * c) * alpha;
    x += eta * d;
    r -= eta * feval (Afun, d, varargin{:});
    if (it < 0) # iter is odd
      rho_2 = rho_1;
      rho_1 = (r_star' * w);
      if (rho_1 == 0)
        ## Essentially the next iteration doesn't change x,
        ## and the iter after this will have a division by zero
        flag = 4;
        break;
      endif
      beta = rho_1 / rho_2;
      u_1 = w + beta * u; # u at the after iteration
      u1_hat = feval (M1fun, u_1, varargin{:});
      u1_hat = feval (M2fun, u1_hat, varargin{:});
      v = feval (Afun, u1_hat, varargin{:}) + ...
          beta * (feval (Afun, u_hat, varargin{:}) + beta * v);
    endif
    u = u_1;
    iter += 1;
    resvec (iter + 1, 1) = norm (r, 2);
    if (resvec (iter + 1, 1) <= resvec (iter_min + 1, 1))
      ## iter with min residual
      x_min = x;
      iter_min = iter;
    endif
    if (norm (x_pr - x) <= norm (x) * eps)
      flag = 3; # Stagnation
      break;
    endif
    x_pr = x;
    it = -it;
  endwhile
  resvec = resvec (1: (iter + 1));

  relres = resvec (iter_min + 1) / norm (b);
  iter_min = floor (iter_min / 2); # compatibility, since it
                                   # makes two times the effective iterations

  if (relres <= tol)
    flag = 0;
  endif

  if (nargout < 2) # Output strings
    switch (flag)
      case {0}
        printf ("tfqmr converged at iteration %i ", iter_min);
        printf ("to a solution with relative residual %e\n", relres);
      case {1}
        printf ("tfqmr stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the maximum number of iterations was reached.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {2}
        printf ("tfqmr stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the preconditioner matrix is singular.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {3}
        printf ("tfqmr stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method stagnated.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
      case {4}
        printf ("tfqmr stopped at iteration %i ", iter);
        printf ("without converging to the desired tolerance %e\n", tol);
        printf ("because the method can't continue.\n");
        printf ("The iterate returned (number %i) ", iter_min);
        printf ("has relative residual %e\n", relres);
    endswitch
  endif

endfunction


%!test
%! ## Check that all type of inputs work
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M1 = diag (sqrt (diag (A)));
%! M2 = M1;
%! maxit = 10;
%! Afun = @(z) A * z;
%! M1_fun = @(z) M1 \ z;
%! M2_fun = @(z) M2 \ z;
%! [x, flag] = tfqmr (A,b);
%! assert (flag, 0);
%! [x, flag] = tfqmr (A, b, [], maxit, M1, M2);
%! assert (flag, 0);
%! [x, flag] = tfqmr (A, b, [], maxit, M1_fun, M2_fun);
%! assert (flag, 0);
%! [x, flag] = tfqmr (A, b, [], maxit, M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = tfqmr (A, b, [], maxit, M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = tfqmr (Afun, b);
%! assert (flag, 0);
%! [x, flag] = tfqmr (Afun, b, [], maxit, M1, M2);
%! assert (flag, 0);
%! [x, flag] = tfqmr (Afun, b, [], maxit, M1_fun, M2);
%! assert (flag, 0);
%! [x, flag] = tfqmr (Afun, b, [], maxit, M1, M2_fun);
%! assert (flag, 0);
%! [x, flag] = tfqmr (Afun, b, [], maxit, M1_fun, M2_fun);
%! assert (flag, 0);

%!shared A, b, n, M1, M2
%!
%!test
%! n = 100;
%! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
%! b = sum (A, 2);
%! tol = 1e-8;
%! maxit = 15;
%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
%! [x, flag, relres, iter, resvec] = tfqmr (A, b, tol, maxit, M1, M2);
%! assert (x, ones (size (b)), 1e-7);
%!
%!test
%!function y = afun (x, a)
%!  y = a * x;
%!endfunction
%!
%! tol = 1e-8;
%! maxit = 15;
%!
%! [x, flag, relres, iter, resvec] = tfqmr (@(x) afun (x, A), b,
%!                                             tol, maxit, M1, M2);
%! assert (x, ones (size (b)), 1e-7);

%!test
%! ## Jacobi preconditioner works
%! n = 10;
%! tol = 1e-8;
%! A = hilb (n) + 1i * hilb (n);
%! A(1,1) = 100;
%! A(n, n) = 100;
%! b = sum (A, 2);
%! [x, flag, relres, iter, resvec] = tfqmr (A, b, tol);
%! assert (x, ones (size (b)), 0.005);
%! assert (iter, 8);
%! [x, flag, relres, iter, resvec] = tfqmr (A, b, tol, [], diag (diag (A)));
%! assert (x, ones (size (b)), 0.002);
%! assert (iter, 6);

%!test
%! ## Solve complex linear system
%! A = [1 + 1i, 1 + 1i; 2 - 1i, 2 + 1i];
%! b = A * [1; 1];
%! [x, flag, relres, iter, resvec] = tfqmr (A, b, [], 3);
%! assert (x, [1; 1], 1e-6);

%!test
%! A = diag (1:50);
%! A (1,50) = 10000;
%! b = ones (50,1);
%! [x, flag, relres, iter, resvec] = tfqmr (A, b, [], 100);
%! assert (flag, 0);
%! assert (x, A \ b, 1e-05);
%! ## Detects a singular preconditioner
%! M = ones (50);
%! M(1, 1) = 0;
%! [x, flag] = tfqmr (A, b, [], 100, M);
%! assert (flag, 2);

%!test
%! A = single (1);
%! b = 1;
%! [x, flag] = tfqmr (A, b);
%! assert (class (x), "single");

%!test
%! A = 1;
%! b = single (1);
%! [x, flag] = tfqmr (A, b);
%! assert (class (x), "single");

%!test
%! A = single (1);
%! b = single (1);
%! [x, flag] = tfqmr (A, b);
%! assert (class (x), "single");

%!test
%!function y = Afun (x)
%!  A = toeplitz ([2, 1, 0, 0], [2, -1, 0, 0]);
%!  y = A * x;
%!endfunction
%! [x, flag] = tfqmr ("Afun", [1; 2; 2; 3]);
%! assert (x, ones (4, 1), 1e-6);

%!test # unpreconditioned residual
%! A = toeplitz (sparse ([2, 1, 0, 0, 0]), sparse ([2, -1, 0, 0, 0]));
%! b = sum (A, 2);
%! M = magic (5);
%! [x, flag, relres] = tfqmr (A, b, [], 3, M);
%! assert (relres, norm (b - A * x) / norm (b), 8 * eps);

%!demo # simplest use
%! n = 20;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!     sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.1 * eye (n));
%! M = M1 * M2;
%! x = tfqmr (A, b, [], n);
%! Afun = @(x) A * x;
%! x = tfqmr (Afun, b, [], n);
%! x = tfqmr (A, b, 1e-6, n, M);
%! x = tfqmr (A, b, 1e-6, n, M1, M2);
%! Mfun = @(z) M \ z;
%! x = tfqmr (Afun, b, 1e-6, n, Mfun);
%! M1fun = @(z) M1 \ z;
%! M2fun = @(z) M2 \ z;
%! x = tfqmr (Afun, b, 1e-6, n, M1fun, M2fun);
%! function y = Ap (A, x, z) # compute A^z * x or (A^z)' * x
%!    y = x;
%!    for i = 1:z
%!      y = A * y;
%!    endfor
%!  endfunction
%! Afun = @(x, p) Ap (A, x, p);
%! x = tfqmr (Afun, b, [], 2*n, [], [], [], 2); # solution of A^2 * x = b

%!demo
%! n = 10;
%! A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
%!     toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
%!     sparse (1, 2, 1, 1, n) * n / 2);
%! b = A * ones (n, 1);
%! [M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
%! M = M1 * M2;
%!
%! ## reference solution computed by tfqmr after one iteration
%! [x_ref, fl] = tfqmr (A, b, [], 1, M);
%! x_ref
%!
%! ## right preconditioning
%! [y, fl] = tfqmr (A / M, b, [], 1);
%! x = M \ y # compare x and x_ref
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} treelayout (@var{tree})
## @deftypefnx {} {} treelayout (@var{tree}, @var{permutation})
## treelayout lays out a tree or a forest.
##
## The first argument @var{tree} is a vector of predecessors.
##
## The parameter @var{permutation} is an optional postorder permutation.
##
## The complexity of the algorithm is O(n) in terms of time and memory
## requirements.
## @seealso{etreeplot, gplot, treeplot}
## @end deftypefn

function [x_coordinate, y_coordinate, height, s] = ...
                                                 treelayout (tree, permutation)

  if (nargin < 1)
    print_usage ();
  elseif (! isvector (tree) || rows (tree) != 1 || ! isnumeric (tree)
          || any (tree > length (tree)) || any (tree < 0))
    error ("treelayout: the first input argument must be a vector of predecessors");
  endif

  ## Make it a row vector.
  tree = tree(:)';

  ## The count of nodes of the graph.
  num_nodes = length (tree);
  ## The number of children.
  num_children = zeros (1, num_nodes + 1);

  ## Checking vector of predecessors.
  for i = 1 : num_nodes
    if (tree(i) < i)
      ## This part of graph was checked before.
      continue;
    endif

    ## Try to find cicle in this part of graph using modified Floyd's
    ## cycle-finding algorithm.
    tortoise = tree(i);
    hare = tree(tortoise);

    while (tortoise != hare)
      ## End after finding a cicle or reaching a checked part of graph.

      if (hare < i)
        ## This part of graph was checked before.
        break;
      endif

      tortoise = tree(tortoise);
      ## Hare will move faster than tortoise so in cicle hare must
      ## reach tortoise.
      hare = tree(tree(hare));

    endwhile

    if (tortoise == hare)
      ## If hare reach tortoise we found circle.
      error ("treelayout: vector of predecessors has bad format");
    endif

  endfor
  ## Vector of predecessors has right format.

  for i = 1:num_nodes
    ## vec_of_child is helping vector which is used to speed up the
    ## choice of descendant nodes.

    num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
  endfor

  pos = 1;
  start = zeros (1, num_nodes+1);
  xhelp = zeros (1, num_nodes+1);
  stop = zeros (1, num_nodes+1);
  for i = 1 : num_nodes + 1
    start(i) = pos;
    xhelp(i) = pos;
    pos += num_children(i);
    stop(i) = pos;
  endfor

  if (nargin == 1)
    for i = 1:num_nodes
      vec_of_child(xhelp(tree(i)+1)) = i;
      xhelp(tree(i)+1) = xhelp(tree(i)+1) + 1;
    endfor
  else
    vec_of_child = permutation;
  endif

  ## The number of "parent" (actual) node (its descendants will be
  ## browse in the next iteration).
  par_number = 0;

  ## The x-coordinate of the left most descendant of "parent node"
  ## this value is increased in each leaf.
  left_most = 0;

  ## The level of "parent" node (root level is num_nodes).
  level = num_nodes;

  ## num_nodes - max_ht is the height of this graph.
  max_ht = num_nodes;

  ## Main stack - each item consists of two numbers - the number of
  ## node and the number it's of parent node on the top of stack
  ## there is "parent node".
  stk = [-1, 0];

  ## Number of vertices s in the top-level separator.
  s = 0;
  ## Flag which says if we are in top level separator.
  top_level = 1;
  ## The top of the stack.
  while (par_number != -1)
    if (start(par_number+1) < stop(par_number+1))
      idx = vec_of_child(start(par_number+1) : stop(par_number+1) - 1);
    else
      idx = zeros (1, 0);
    endif

    ## Add to idx the vector of parent descendants.
    stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];

    ## We are in top level separator when we have one child and the
    ## flag is 1
    if (columns (idx) == 1 && top_level == 1)
      s += 1;
    else
      ## We aren't in top level separator now.
      top_level = 0;
    endif
    ## If there is not any descendant of "parent node":
    if (stk(end,2) != par_number)
     left_most += 1;
     x_coordinate_r(par_number) = left_most;
     max_ht = min (max_ht, level);
     if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
         && stk(end,2) != stk(end-1,2))
        ## Return to the nearest branching the position to return
        ## position is the position on the stack, where should be
        ## started further search (there are two nodes which has the
        ## same parent node).

        position = (find ((shift (stk(:,2), 1) - stk(:,2)) == 0))(end) + 1;
        par_number_vec = stk(position:end,2);

        ## The vector of removed nodes (the content of stack form
        ## position to end).

        level += length (par_number_vec);

        ## The level have to be decreased.

        x_coordinate_r(par_number_vec) = left_most;
        stk(position:end,:) = [];
      endif

      ## Remove the next node from "searched branch".

      stk(end,:) = [];
      ## Choose new "parent node".
      par_number = stk(end,1);
      ## If there is another branch start to search it.
      if (par_number != -1)
        y_coordinate(par_number) = level;
        x_coordinate_l(par_number) = left_most + 1;
      endif
    else

      ## There were descendants of "parent nod" choose the last of
      ## them and go on through it.
      level -= 1;
      par_number = stk(end,1);
      y_coordinate(par_number) = level;
      x_coordinate_l(par_number) = left_most + 1;
    endif
  endwhile

  ## Calculate the x coordinates (the known values are the position
  ## of most left and most right descendants).
  x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;

  height = num_nodes - max_ht - 1;

endfunction


%!test
%! % Compute a simple tree layout
%! [x, y, h, s] = treelayout ([0, 1, 2, 2]);
%! assert (x, [1.5, 1.5, 2, 1]);
%! assert (y, [3, 2, 1, 1]);
%! assert (h, 2);
%! assert (s, 2);

%!test
%! % Compute a simple tree layout with defined postorder permutation
%! [x, y, h, s] = treelayout ([0, 1, 2, 2], [1, 2, 4, 3]);
%! assert (x, [1.5, 1.5, 1, 2]);
%! assert (y, [3, 2, 1, 1]);
%! assert (h, 2);
%! assert (s, 2);

%!test
%! % Compute a simple tree layout with defined postorder permutation
%! [x, y, h, s] = treelayout ([0, 1, 2, 2], [4, 2, 3, 1]);
%! assert (x, [0, 0, 0, 1]);
%! assert (y, [0, 0, 0, 3]);
%! assert (h, 0);
%! assert (s, 1);
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} treeplot (@var{tree})
## @deftypefnx {} {} treeplot (@var{tree}, @var{node_style}, @var{edge_style})
## Produce a graph of tree or forest.
##
## The first argument is vector of predecessors.
##
## The optional parameters @var{node_style} and @var{edge_style} define the
## output plot style.
##
## The complexity of the algorithm is O(n) in terms of is time and memory
## requirements.
## @seealso{etreeplot, gplot}
## @end deftypefn

function treeplot (tree, node_style = "ko", edge_style = "r")

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (tree) || ! isrow (tree) || any (tree > length (tree)))
    error ("treeplot: TREE must be a vector of predecessors");
  endif

  ##  Verify node_style
  if (nargin > 1)
    if (isempty (regexp (node_style, '[ox+*]', 'once')))
      node_style = [node_style, "o"];
    endif
  endif

  ## Make it a row vector.
  tree = tree(:)';

  ## The count of nodes of the graph.
  num_nodes = length (tree);

  ## The number of children.
  num_children = zeros (1, num_nodes+1);

  for i = 1:num_nodes
    ## VEC_OF_CHILD is helping vector which is used to speed up the
    ## choose of descendant nodes.

    num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
  endfor
  pos = 1;
  start = zeros (1, num_nodes+1);
  xhelp = zeros (1, num_nodes+1);
  stop = zeros (1, num_nodes+1);
  for i = 1:num_nodes+1
    start(i) = pos;
    xhelp(i) = pos;
    pos += num_children(i);
    stop(i) = pos;
  endfor
  for i = 1:num_nodes
    vec_of_child(xhelp(tree(i)+1)) = i;
    xhelp(tree(i)+1) = xhelp(tree(i)+1)+1;
  endfor

  ## The number of "parent" (actual) node (its descendants will be
  ## browse in the next iteration).
  par_number = 0;

  ## The x-coordinate of the left most descendant of "parent node"
  ## this value is increased in each leaf.
  left_most = 0;

  ## The level of "parent" node (root level is num_nodes).
  level = num_nodes;

  ## Num_nodes - max_ht is the height of this graph.
  max_ht = num_nodes;

  ## Main stack - each item consists of two numbers - the number of
  ## node and the number it's of parent node on the top of stack
  ## there is "parent node".
  stk = [-1, 0];

  ## Stack which is used to draw the graph edge (it has to be an
  ## uninterrupted line).
  skelet = 0;

  ## The top of the stack.
  while (par_number != -1)
    if (start(par_number+1) < stop(par_number+1))
      idx = vec_of_child(start(par_number+1):stop(par_number+1)-1);
    else
      idx = zeros (1, 0);
    endif
    ## Add to idx the vector of parent descendants.
    stk = [stk; [idx', ones(fliplr(size(idx)))*par_number]];
    ## Add to stack the records relevant to parent descendant s.
    if (par_number != 0)
      skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
    endif

    ## If there is not any descendant of "parent node":
    if (stk(end,2) != par_number)
      left_most += 1;
      x_coordinate_r(par_number) = left_most;
      max_ht = min (max_ht, level);
      if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
          && stk(end,2) != stk(end-1,2))
        ## Return to the nearest branching the position to return
        ## position is the position on the stack, where should be
        ## started further search (there are two nodes which has the
        ## same parent node).
        position = (find ((shift (stk(:,2),1) - stk(:,2)) == 0))(end) + 1;
        par_number_vec = stk(position:end,2);
        ## The vector of removed nodes (the content of stack form
        ## position to end).
        skelet = [skelet; flipud(par_number_vec)];
        level += length (par_number_vec);
        ## The level have to be decreased.
        x_coordinate_r(par_number_vec) = left_most;
        stk(position:end,:) = [];
      endif
      ## Remove the next node from "searched branch".
      stk(end,:) = [];
      ## Choose new "parent node".
      par_number = stk(end,1);
      ## If there is another branch start to search it.
      if (par_number != -1)
        skelet = [skelet; stk(end,2); par_number];
        y_coordinate(par_number) = level;
        x_coordinate_l(par_number) = left_most + 1;
      endif
    else
      ## There were descendants of "parent nod" choose the last of
      ## them and go on through it.
      level -= 1;
      par_number = stk(end,1);
      y_coordinate(par_number) = level;
      x_coordinate_l(par_number) = left_most + 1;
    endif
  endwhile

  ## Calculate the x coordinates (the known values are the position
  ## of most left and most right descendants).
  x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;

  ## FIXME: We should probably stuff all the arguments into a cell
  ##        array and make a single call to plot here so we can avoid
  ##        setting the hold state...

  hold_is_on = ishold ();
  unwind_protect
    ## Plot graph nodes.
    plot (x_coordinate, y_coordinate, node_style);

    ## Helping command - usable for plotting edges
    skelet = [skelet; 0];

    ## Draw graph edges.
    idx = find (skelet == 0);

    hold ("on");
    ## Plot each tree component in one loop.
    for i = 2:length (idx)
      ## Tree component start.
      istart = idx(i-1) + 1;
      ## Tree component end.
      istop = idx(i) - 1;
      if (istop - istart < 1)
        continue;
      endif
      plot (x_coordinate(skelet(istart:istop)),
            y_coordinate(skelet(istart:istop)), edge_style);
    endfor

    ## Set axis and graph size.
    axis ([0.5, left_most+0.5, max_ht-0.5, num_nodes-0.5], "nolabel");

  unwind_protect_cleanup
    if (! hold_is_on)
      hold ("off");
    endif
  end_unwind_protect

endfunction


%!demo
%! clf;
%! treeplot ([2 4 2 0 6 4 6]);
%! % Plot a simple tree plot

%!demo
%! clf;
%! treeplot ([2 4 2 0 6 4 6], "b+", "g");
%! % Plot a simple tree plot defining the edge and node styles
encoding=utf-8
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} beta (@var{a}, @var{b})
## Compute the Beta function for real inputs @var{a} and @var{b}.
##
## The Beta function definition is
## @tex
## $$
##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
## $$
## @end tex
## @ifnottex
##
## @example
## beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
## @end example
##
## @end ifnottex
##
## The Beta function can grow quite large and it is often more useful to work
## with the logarithm of the output rather than the function directly.
## @xref{XREFbetaln,,@code{betaln}}, for computing the logarithm of the Beta
## function in an efficient manner.
## @seealso{betaln, betainc, betaincinv}
## @end deftypefn

function retval = beta (a, b)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isreal (a) || ! isreal (b))
    error ("beta: A and B must be real");
  elseif (! size_equal (a, b) && numel (a) != 1 && numel (b) != 1)
    error ("beta: A and B must have consistent sizes");
  endif

  retval = real (exp (gammaln (a) + gammaln (b) - gammaln (a+b)));

endfunction


%!test
%! a = [1, 1.5, 2, 3];
%! b = [4, 3, 2, 1];
%! v1 = beta (a, b);
%! v2 = beta (b, a);
%! v3 = gamma (a).*gamma (b) ./ gamma (a+b);
%! assert (v1, v2, sqrt (eps));
%! assert (v2, v3, sqrt (eps));

%!assert (beta (1, 1), 1)

%!test
%! a = 2:10;
%! tol = 10 * max (a) * eps;
%! assert (-a, beta (-1./a, 1), tol);
%! assert (-a, beta (1, -1./a), tol);

%!test
%! a = 0.25 + (0:5) * 0.5;
%! tol = 10 * max (a) * eps;
%! assert (zeros (size (a)), beta (a, -a), tol);
%! assert (zeros (size (a)), beta (-a, a), tol);

%!error <Invalid call> beta ()
%!error <Invalid call> beta (1)
%!error <A and B must be real> beta (1i, 2)
%!error <A and B must be real> beta (2, 1i)
%!error <A and B must have consistent sizes> beta ([1 2], [1 2 3])
%!error <A and B must have consistent sizes> beta ([1 2 3], [1 2])
%!error <A and B must have consistent sizes> beta ([1 2 3], [1 2 3]')
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} betainc (@var{x}, @var{a}, @var{b})
## @deftypefnx {} {} betainc (@var{x}, @var{a}, @var{b}, @var{tail})
## Compute the incomplete beta function.
##
## This is defined as
## @tex
## $$
## I_x (a, b) = {1 \over {B(a,b)}} \displaystyle{\int_0^x t^{a-1} (1-t)^{b-1} dt}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                           x
##                          /
##                  1       |
## I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
##              beta (a,b)  |
##                          /
##                         0
## @end group
## @end example
##
## @end ifnottex
##
## with real @var{x} in the range [0,1].  The inputs @var{a} and @var{b} must
## be real and strictly positive (> 0).  If one of the inputs is not a scalar
## then the other inputs must be scalar or of compatible dimensions.
##
## By default, @var{tail} is @qcode{"lower"} and the incomplete beta function
## integrated from 0 to @var{x} is computed.  If @var{tail} is @qcode{"upper"}
## then the complementary function integrated from @var{x} to 1 is calculated.
## The two choices are related by
##
## betainc (@var{x}, @var{a}, @var{b}, @qcode{"upper"}) =
## 1 - betainc (@var{x}, @var{a}, @var{b}, @qcode{"lower"}).
##
## @code{betainc} uses a more sophisticated algorithm than subtraction to
## get numerically accurate results when the @qcode{"lower"} value is small.
##
## Reference: @nospell{A. Cuyt, V. Brevik Petersen, B. Verdonk, H. Waadeland,
## W.B. Jones}, @cite{Handbook of Continued Fractions for Special Functions},
## ch.@: 18.
##
## @seealso{beta, betaincinv, betaln}
## @end deftypefn

function y = betainc (x, a, b, tail = "lower")

  if (nargin < 3)
    print_usage ();
  endif

  [err, x, a, b] = common_size (x, a, b);
  if (err > 0)
    error ("betainc: X, A, and B must be of common size or scalars");
  endif

  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
    error ("betainc: all inputs must be real");
  endif

  ## Remember original shape of data, but convert to column vector for calcs.
  orig_sz = size (x);
  x = x(:);
  a = a(:);
  b = b(:);

  if (any ((x < 0) | (x > 1)))
    error ("betainc: X must be in the range [0, 1]");
  endif

  if (any (a <= 0))
    error ("betainc: A must be strictly positive");
  endif

  if (any (b <= 0))
    error ("betainc: B must be strictly positive");
  endif

  ## If any of the arguments is single then the output should be as well.
  if (strcmp (class (x), "single") || strcmp (class (a), "single")
      || strcmp (class (b), "single"))
    a = single (a);
    b = single (b);
    x = single (x);
  endif

  ## Convert to floating point if necessary
  if (isinteger (x))
    y = double (x);
  endif
  if (isinteger (a))
    a = double (a);
  endif
  if (isinteger (b))
    b = double (b);
  endif

  ## Initialize output array
  y = zeros (size (x), class (x));

  ## Trivial cases (long code here trades memory for speed)
  a_one = (a == 1);
  b_one = (b == 1);
  a_b_one = a_one & b_one;
  a_not_one = ! a_one;
  b_not_one = ! b_one;
  non_trivial = a_not_one & b_not_one;
  a_one &= b_not_one;
  b_one &= a_not_one;

  if (strcmpi (tail, "lower"))
    y(a_b_one) = x(a_b_one);
    ## See bug #62329.
    ## equivalent to "1 - (1 - x(a_one)) .^ b(a_one)", but less roundoff error
    y(a_one) = - expm1 (log1p (- x(a_one)) .* b(a_one));
    y(b_one) = x(b_one) .^ a(b_one);
  elseif (strcmpi (tail, "upper"))
    y(a_b_one) = 1 - x(a_b_one);
    ## equivalent to "(1 - x(a_one)) .^ b(a_one)", but less roundoff error
    y(a_one) = exp (log1p (- x(a_one)) .* b(a_one));
    ## equivalent to "1 - x(b_one) .^ a(b_one)", but less roundoff error
    y(b_one) = - expm1 (log (x(b_one)) .* a(b_one));
  endif

  ## Non-Trivial cases
  ## In the following, we use the fact that the continued fraction Octave uses
  ## is more efficient when x <= a / (a + b).  Moreover, to compute the upper
  ## version, which is defined as I_x(a,b,"upper") = 1 - I_x(a,b) we use the
  ## property I_x(a,b) + I_(1-x) (b,a) = 1.

  x = x(non_trivial);
  a = a(non_trivial);
  b = b(non_trivial);

  if (strcmpi (tail, "lower"))
    fflag = (x > a./(a + b));
    x(fflag) = 1 - x(fflag);
    [a(fflag), b(fflag)] = deal (b(fflag), a(fflag));
  elseif (strcmpi (tail, "upper"))
    fflag = (x < (a ./ (a + b)));
    x(! fflag) = 1 - x(! fflag);
    [a(! fflag), b(! fflag)] = deal (b(! fflag), a(! fflag));
  else
    error ("betainc: invalid value for TAIL");
  endif

  f = zeros (size (x), class (x));

  ## Continued fractions: CPVWJ, formula 18.5.20, modified Lentz algorithm
  ## implemented in a separate .cc file.  This particular continued fraction
  ## gives (B(a,b) * I_x(a,b)) / (x^a * (1-x)^b).

  f = __betainc__ (x, a, b);

  ## Divide continued fraction by B(a,b) / (x^a * (1-x)^b) to obtain I_x(a,b).
  y_nt = a .* log (x) + b .* log1p (-x) ...
         + (gammaln (a + b) - gammaln (a) - gammaln (b)) + log (f);
  y_nt = real (exp (y_nt));
  y_nt(fflag) = 1 - y_nt(fflag);

  y(non_trivial) = y_nt;

  ## Restore original shape
  y = reshape (y, orig_sz);

endfunction


## Double precision
%!test
%! a = [1, 1.5, 2, 3];
%! b = [4, 3, 2, 1];
%! v1 = betainc (1, a, b);
%! v2 = [1,1,1,1];
%! x = [.2, .4, .6, .8];
%! v3 = betainc (x, a, b);
%! v4 = 1 - betainc (1-x, b, a);
%! assert (v1, v2, sqrt (eps));
%! assert (v3, v4, sqrt (eps));

## Single precision
%!test
%! a = single ([1, 1.5, 2, 3]);
%! b = single ([4, 3, 2, 1]);
%! v1 = betainc (1, a, b);
%! v2 = single ([1,1,1,1]);
%! x = single ([.2, .4, .6, .8]);
%! v3 = betainc (x, a, b);
%! v4 = 1 - betainc (1-x, b, a);
%! assert (v1, v2, sqrt (eps ("single")));
%! assert (v3, v4, sqrt (eps ("single")));

## Mixed double/single precision
%!test
%! a = single ([1, 1.5, 2, 3]);
%! b = [4, 3, 2, 1];
%! v1 = betainc (1,a,b);
%! v2 = single ([1,1,1,1]);
%! x = [.2, .4, .6, .8];
%! v3 = betainc (x, a, b);
%! v4 = 1 - betainc (1. - x, b, a);
%! assert (v1, v2, sqrt (eps ("single")));
%! assert (v3, v4, sqrt (eps ("single")));

%!test <*51157>
%! y = betainc ([0.00780;0.00782;0.00784],250.005,49750.995);
%! y_ex = [0.999999999999989; 0.999999999999992; 0.999999999999995];
%! assert (y, y_ex, -1e-14);

%!assert (betainc (0.001, 20, 30), 2.750687665855991e-47, -3e-14)
%!assert (betainc (0.0001, 20, 30), 2.819953178893307e-67, -7e-14)
%!assert <*54383> (betainc (0.99, 20, 30, "upper"),
%!                 1.5671643161872703e-47, -7e-14)
%!assert (betainc (0.999, 20, 30, "upper"), 1.850806276141535e-77, -7e-14)
%!assert (betainc (0.5, 200, 300), 0.9999964565197356, -1e-15)
%!assert (betainc (0.5, 200, 300, "upper"), 3.54348026439253e-06, -3e-13)

## Test trivial values
%!test
%! [a,b] = ndgrid (linspace (1e-4, 100, 20), linspace (1e-4, 100, 20));
%! assert (betainc (0, a, b), zeros (20));
%! assert (betainc (1, a, b), ones (20));
%! assert (betainc (0, a, b, "upper"), ones (20));
%! assert (betainc (1, a, b, "upper"), zeros (20));

%!test <*34405>
%! assert (betainc (NaN, 1, 2), NaN);
%! assert (betainc (0.5, 1, Inf), 1);

%!test <*62329>
%! assert (betainc (2e-20, 1, 0.5), 1e-20, -1e-15)
%! assert (betainc (2e-5, 1, 0.5), 2e-5 / (1 + sqrt (1 - 2e-5)), -1e-15)
%! assert (betainc (0.99, 1, 0.5, "upper"), 0.1, -1e-15)
%! assert (betainc (0.99, 0.5, 1, "upper"), - expm1 (log (0.99)/2), -1e-15)

## Test input validation
%!error <Invalid call> betainc ()
%!error <Invalid call> betainc (1)
%!error <Invalid call> betainc (1,2)
%!error <must be of common size or scalars> betainc (ones (2,2), ones (1,2), 1)
%!error <all inputs must be real> betainc (0.5i, 1, 2)
%!error <all inputs must be real> betainc (0, 1i, 1)
%!error <all inputs must be real> betainc (0, 1, 1i)
%!error <X must be in the range \[0, 1\]> betainc (-0.1,1,1)
%!error <X must be in the range \[0, 1\]> betainc (1.1,1,1)
%!error <X must be in the range \[0, 1\]>
%! x = ones (1, 1, 2);
%! x(1,1,2) = -1;
%! betainc (x,1,1);
%!error <A must be strictly positive> betainc (0.5,0,1)
%!error <A must be strictly positive>
%! a = ones (1, 1, 2);
%! a(1,1,2) = 0;
%! betainc (1,a,1);
%!error <B must be strictly positive> betainc (0.5,1,0)
%!error <B must be strictly positive>
%! b = ones (1, 1, 2);
%! b(1,1,2) = 0;
%! betainc (1,1,b);
%!error <invalid value for TAIL> betainc (1,2,3, "foobar")
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} betaincinv (@var{y}, @var{a}, @var{b})
## @deftypefnx {} {} betaincinv (@var{y}, @var{a}, @var{b}, "lower")
## @deftypefnx {} {} betaincinv (@var{y}, @var{a}, @var{b}, "upper")
## Compute the inverse of the normalized incomplete beta function.
##
## The normalized incomplete beta function is defined as
## @tex
## $$
##  I_x (a, b) = {1 \over {B(a,b)}} \displaystyle{\int_0^x t^{a-1} (1-t)^{b-1} dt}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                           x
##                          /
##                  1       |
## I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
##              beta (a,b)  |
##                          /
##                         0
## @end group
## @end example
##
## @end ifnottex
##
## If two inputs are scalar, then @code{betaincinv (@var{y}, @var{a}, @var{b})}
## is returned for each of the other inputs.
##
## If two or more inputs are not scalar, the sizes of them must agree, and
## @code{betaincinv} is applied element-by-element.
##
## The variable @var{y} must be in the interval [0,1], while @var{a} and
## @var{b} must be real and strictly positive.
##
## By default, @var{tail} is @qcode{"lower"} and the inverse of the incomplete
## beta function integrated from 0 to @var{x} is computed.  If @var{tail} is
## @qcode{"upper"} then the complementary function integrated from @var{x} to 1
## is inverted.
##
## The function is computed by standard Newton's method, by solving
## @tex
## $$
##  y - I_x (a, b) = 0
## $$
## @end tex
## @ifnottex
##
## @example
## @var{y} - betainc (@var{x}, @var{a}, @var{b}) = 0
## @end example
##
## @end ifnottex
##
## @seealso{betainc, beta, betaln}
## @end deftypefn

function x = betaincinv (y, a, b, tail = "lower")

  if (nargin < 3)
    print_usage ();
  endif

  [err, y, a, b] = common_size (y, a, b);
  if (err > 0)
    error ("betaincinv: Y, A, and B must be of common size or scalars");
  endif

  if (! (isfloat (y) && isfloat (a) && isfloat (b)
         && isreal (y) && isreal (a) && isreal (b)))
    error ("betaincinv: Y, A, and B must be real, floating point values");
  endif

  ## Remember original shape of data, but convert to column vector for calcs.
  orig_sz = size (y);
  y = y(:);
  a = a(:);
  b = b(:);

  if (any ((y < 0) | (y > 1)))
    error ("betaincinv: Y must be in the range [0, 1]");
  endif

  if (any (a <= 0))
    error ("betaincinv: A must be strictly positive");
  endif

  if (any (b <= 0))
    error ("betaincinv: B must be strictly positive");
  endif

  ## If any of the arguments is single then the output should be as well.
  if (isa (y, "single") || isa (a, "single") || isa (b, "single"))
    y = single (y);
    a = single (a);
    b = single (b);
  endif

  if (strcmpi (tail, "lower"))
    ys = y;
  elseif (strcmpi (tail, "upper"))
    ys = 1 - y;  # only for computation of initial points, no loss of accuracy
  else
    error ("betaincinv: invalid value for TAIL");
  endif

  ## Choose starting point for Newton's Method to guarantee convergence.
  ## If (a-1)*(b-1) > 0, F has a point of inflection at x = (a-1)/(a+b-2).
  ## In this case, it is convex on (0,x) and concave on (x,1) if a>1; otherwise
  ## it is the other way round.  If (a-1)*(b-1) <= 0, there is no point of
  ## inflection, and it is everywhere convex for a>1 and concave otherwise.
  ## We thus choose our starting x for the Newton iterations so that we stay
  ## within a region of constant sign of curvature and on the correct side of
  ## the eventual solution, guaranteeing convergence.  Curvatures above are to
  ## be understood under the condition tail=="lower".

  ## Initialize output array
  x = x_i = y_i = zeros (size (y), class (y));

  ## Have point of inflection
  idx = find ((a - 1) .* (b - 1) > 0);
  if (! isempty (idx))
    x_i(idx) = (a(idx) - 1) ./ (a(idx) + b(idx) - 2);
    y_i(idx) = betainc (x_i(idx), a(idx), b(idx));
  endif

  ## Converge outwards
  tmpidx = find (a(idx) > 1);
  if (! isempty (tmpidx))
    x(idx(tmpidx)) = x_i(idx(tmpidx));
  endif
  ## Converge inwards
  ## To the left of inflection point
  tmpidx = idx(find ((a(idx) <= 1) & (y_i(idx) >= ys(idx))));
  if (! isempty (tmpidx))
    x(tmpidx) = (ys(tmpidx) ./ y_i(tmpidx)).^(1 ./ a(tmpidx)) .* x_i(tmpidx);
  endif
  ## To the right of inflection point
  tmpidx = idx(find ((a(idx) <= 1) & (y_i(idx) < ys(idx))));
  if (! isempty (tmpidx))
    x(tmpidx) = 1 - ...
                ((1 - ys(tmpidx)) ./ (1 - y_i(tmpidx))).^(1 ./ b(tmpidx)) ...
                .* (1 - x_i(tmpidx));
  endif

  ## Have no point of inflection
  idx = find ((a - 1) .* (b - 1) <= 0);

  ## Negative curvature
  tmpidx = idx(find (a(idx) < 1));
  if (! isempty (tmpidx))
    x(tmpidx) = (ys(tmpidx) .* beta (a(tmpidx), b(tmpidx)) .* a(tmpidx)) ...
                .^ (1 ./ a(tmpidx));
  endif
  ## Positive curvature
  tmpidx = idx(find (a(idx) >= 1));
  if (! isempty (tmpidx))
    x(tmpidx) = 1 - ...
                ((1 - ys(tmpidx)) .* beta (a(tmpidx), b(tmpidx)) .* b(tmpidx)) ...
                .^ (1 ./ b(tmpidx));
  endif

  ## Cleanup memory before continuing
  clear ys x_i y_i idx tmpidx

  if (strcmpi (tail, "lower"))
    x(y == 0) = 0;
    x(y == 1) = 1;
    F = @(x, a, b, y) y - betainc (x, a, b);
    JF = @(x, a, b, Bln) -exp ((a-1) .* log (x) + (b-1) .* log1p (-x) - Bln);
  else
    x(y == 0) = 1;
    x(y == 1) = 0;
    F = @(x, a, b, y) y - betainc (x, a, b, "upper");
    JF = @(x, a, b, Bln) exp ((a-1) .* log (x) + (b-1) .* log1p (-x) - Bln);
  endif

  x = newton_method (F, JF, x, a, b, y);

  ## Restore original shape
  x = reshape (x, orig_sz);

endfunction

function x = newton_method (F, JF, x, a, b, y);

  Bln = betaln (a, b);
  ## Exclude special values that have been already computed.
  todo = find ((y != 0) & (y != 1));
  step = -F (x(todo), a(todo), b(todo), y(todo)) ./ ...
         JF (x(todo), a(todo), b(todo), Bln(todo));
  x_old = x(todo);
  x(todo) += step;
  dx = x(todo) - x_old;
  idx = (dx != 0);
  todo = todo(idx);
  dx_old = dx(idx);
  while (! isempty (todo))
    step = -F (x(todo), a(todo), b(todo), y(todo)) ./ ...
           JF (x(todo), a(todo), b(todo), Bln(todo));
    x_old = x(todo);
    x(todo) += step;
    dx = x(todo) - x_old;
    idx = (abs (dx) < abs (dx_old));  # Converging if dx is getting smaller
    todo = todo(idx);
    dx_old = dx(idx);
  endwhile

endfunction


%!test
%! x = linspace (0.1, 0.9, 11);
%! a = [2, 3, 4];
%! [x,a,b] = ndgrid (x,a,a);
%! xx = betaincinv (betainc (x, a, b), a, b);
%! assert (xx, x, 3e-15);

%!test
%! x = linspace (0.1, 0.9, 11);
%! a = [2, 3, 4];
%! [x,a,b] = ndgrid (x,a,a);
%! xx = betaincinv (betainc (x, a, b, "upper"), a, b, "upper");
%! assert (xx, x, 3e-15);

%!test
%! x = linspace (0.1, 0.9, 11);
%! a = [0.1:0.1:1];
%! [x,a,b] = ndgrid (x,a,a);
%! xx = betaincinv (betainc (x, a, b), a, b);
%! assert (xx, x, 5e-15);

%!test
%! x = linspace (0.1, 0.9, 11);
%! a = [0.1:0.1:1];
%! [x,a,b] = ndgrid (x,a,a);
%! xx = betaincinv (betainc (x, a, b, "upper"), a, b, "upper");
%! assert (xx, x, 5e-15);

## Test the conservation of the input class
%!assert (class (betaincinv (0.5, 1, 1)), "double")
%!assert (class (betaincinv (single (0.5), 1, 1)), "single")
%!assert (class (betaincinv (0.5, single (1), 1)), "single")
%!assert (class (betaincinv (0.5, 1, single (1))), "single")

## Extreme values for y, a, b that really test the algorithm
%!assert (betaincinv ([0, 1], 1, 3), [0, 1])
%!assert <*60528> (betaincinv (1e-6, 1, 3), 3.3333344444450617e-7, 2*eps)
%!assert <*60528> (betaincinv (1-1e-6, 3, 1), 0.9999996666665555, 2*eps)
%!assert (betainc (betaincinv (0.9, 1e-3, 1), 1e-3, 1), 0.9, 2*eps)
%!assert (betainc (betaincinv (.01, 1, 1e-3), 1, 1e-3), .01, 6*eps)
%!assert (betainc (betaincinv (0.5, 100, 1), 100, 1), 0.5, 8*eps)
%!assert (betainc (betaincinv (0.5, 1, 100), 1, 100), 0.5, 22*eps)
%!assert (betaincinv ([0, 1], 1, 3, "upper"), [1, 0])
%!assert <*60528> (betaincinv (1e-6, 1, 3, "upper"), 0.99, 2*eps)
%!assert <*60528> (betaincinv (1-1e-6, 3, 1,"upper"), .01, 250*eps)
%!assert (betainc (betaincinv (0.1, 1e-3, 1, "upper"), 1e-3, 1, "upper"),
%!        0.1, 2*eps)
%!assert (betainc (betaincinv (.99, 1, 1e-3, "upper"), 1, 1e-3, "upper"),
%!        .99, 6*eps)
%!assert (betainc (betaincinv (0.5, 100, 1, "upper"), 100, 1, "upper"),
%!        0.5, 8*eps)
%!assert (betainc (betaincinv (0.5, 1, 100, "upper"), 1, 100, "upper"),
%!        0.5, 22*eps)

## Test input validation
%!error <Invalid call> betaincinv ()
%!error <Invalid call> betaincinv (1)
%!error <Invalid call> betaincinv (1,2)
%!error <must be of common size or scalars>
%! betaincinv (ones (2,2), ones (1,2), 1);
%!error <must be .* floating point> betaincinv ('a', 1, 2)
%!error <must be .* floating point> betaincinv (0, int8 (1), 1)
%!error <must be .* floating point> betaincinv (0, 1, true)
%!error <must be real> betaincinv (0.5i, 1, 2)
%!error <must be real> betaincinv (0, 1i, 1)
%!error <must be real> betaincinv (0, 1, 1i)
%!error <Y must be in the range \[0, 1\]> betaincinv (-0.1,1,1)
%!error <Y must be in the range \[0, 1\]> betaincinv (1.1,1,1)
%!error <Y must be in the range \[0, 1\]>
%! y = ones (1, 1, 2);
%! y(1,1,2) = -1;
%! betaincinv (y,1,1);
%!error <A must be strictly positive> betaincinv (0.5,0,1)
%!error <A must be strictly positive>
%! a = ones (1, 1, 2);
%! a(1,1,2) = 0;
%! betaincinv (1,a,1);
%!error <B must be strictly positive> betaincinv (0.5,1,0)
%!error <B must be strictly positive>
%! b = ones (1, 1, 2);
%! b(1,1,2) = 0;
%! betaincinv (1,1,b);
%!error <invalid value for TAIL> betaincinv (1,2,3, "foobar")
########################################################################
##
## Copyright (C) 1998-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} betaln (@var{a}, @var{b})
## Compute the natural logarithm of the Beta function for real inputs @var{a}
## and @var{b}.
##
## @code{betaln} is defined as
## @tex
## $$
##  {\rm betaln} (a, b) = \ln (B (a,b)) \equiv \ln ({\Gamma (a) \Gamma (b) \over \Gamma (a + b)}).
## $$
## @end tex
## @ifnottex
##
## @example
## betaln (a, b) = log (beta (a, b))
## @end example
##
## @end ifnottex
## and is calculated in a way to reduce the occurrence of underflow.
##
## The Beta function can grow quite large and it is often more useful to work
## with the logarithm of the output rather than the function directly.
## @seealso{beta, betainc, betaincinv, gammaln}
## @end deftypefn

function retval = betaln (a, b)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isreal (a) || ! isreal (b))
    error ("betaln: A and B must be real");
  elseif (! size_equal (a, b) && numel (a) != 1 && numel (b) != 1)
    error ("betaln: A and B must have consistent sizes");
  endif

  retval = gammaln (a) + gammaln (b) - gammaln (a + b);

endfunction


%!assert (betaln (3,4), log (beta (3,4)), eps)

## Test input validation
%!error <Invalid call> betaln ()
%!error <Invalid call> betaln (1)
%!error <A and B must be real> betaln (1i, 2)
%!error <A and B must be real> betaln (2, 1i)
%!error <A and B must have consistent sizes> betaln ([1 2], [1 2 3])
%!error <A and B must have consistent sizes> betaln ([1 2 3], [1 2])
%!error <A and B must have consistent sizes> betaln ([1 2 3], [1 2 3]')
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} cosint (@var{x})
## Compute the cosine integral function:
## @tex
## $$
## {\rm Ci} (x) = - \int_x^\infty {{\cos (t)} \over t} dt
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##             +oo
##            /
## Ci (x) = - | (cos (t)) / t dt
##            /
##           x
## @end group
## @end example
##
## @end ifnottex
## An equivalent definition is
## @tex
## $$
## {\rm Ci} (x) = \gamma + \log (x) + \int_0^x {{\cos (t) - 1} \over t} dt
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                              x
##                             /
##                             |  cos (t) - 1
## Ci (x) = gamma + log (x) +  | -------------  dt
##                             |        t
##                             /
##                            0
## @end group
## @end example
##
## @end ifnottex
## Reference:
##
## @nospell{M. Abramowitz and I.A. Stegun},
## @cite{Handbook of Mathematical Functions}, 1964.
##
## @seealso{sinint, expint, cos}
##
## @end deftypefn

function y = cosint (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    error ("cosint: X must be numeric");
  endif

  ## Convert to floating point if necessary
  if (isinteger (x))
    x = double (x);
  endif

  ## Convert to column vector
  orig_sz = size (x);
  if (iscomplex (x))
    ## Work around reshape which narrows to real (bug #52953)
    x = complex (real (x)(:), imag (x)(:));
  else
    x = x(:);
  endif

  ## Initialize the result
  y = zeros (size (x), class (x));
  tol = eps (class (x));

  todo = true (size (x));

  ## Special values
  y(x == Inf) = 0;
  y((x == -Inf) & ! signbit (imag (x))) = 1i * pi;
  y((x == -Inf) &  signbit (imag (x))) = -1i * pi;

  todo(isinf (x)) = false;

  ## For values large in modulus, but not in the range (-oo,0), we use the
  ## relation with expint.

  flag_large = (abs (x) > 2);
  xx = x(flag_large);

  ## Abramowitz, relation 5.2.20
  ii_sw = (real (xx) <= 0 & imag (xx) < 0);
  xx(ii_sw) = conj (xx(ii_sw));
  ii_nw = (real (xx) < 0);
  xx(ii_nw) *= -1;
  yy = -0.5 * (expint (1i * xx) + expint (-1i * xx));
  yy(ii_nw) += 1i * pi;
  yy(ii_sw) = conj (yy(ii_sw));
  y(todo & flag_large) = yy;

  todo(flag_large) = false;

  ## For values small in modulus, use the series expansion (also near (-oo, 0])
  if (iscomplex (x))
    ## indexing can lose imag part: if it was -0, we could end up on the
    ## wrong right side of the branch cut along the negative real axis.
    xx = complex (real (x)(todo), imag (x)(todo));
  else
    xx = x(todo);
  endif
  ssum = - xx .^ 2 / 4; # First term of the series expansion
  ## FIXME: This is way more precision than a double value can hold.
  gma = 0.57721566490153286060651209008; # Euler gamma constant
  yy = gma + log (complex (xx)) + ssum;  # log (complex (Z)) handles signed zero
  flag_sum = true (nnz (todo), 1);
  it = 0;
  maxit = 300;
  while (any (flag_sum) && (++it < maxit))
    ssum .*= - xx .^ 2 * (2 * it) / ((2 * it + 2) ^ 2 * (2 * it + 1));
    yy(flag_sum) += ssum (flag_sum);
    flag_sum = (abs (ssum) >= tol);
  endwhile
  y(todo) = yy;

  ## Clean up values which are purely real
  flag_neg_zero_imag = (real (x) < 0) & (imag (x) == 0) & signbit (imag (x));
  y(flag_neg_zero_imag) = complex (real (y(flag_neg_zero_imag)), -pi);

  ## Restore original shape
  y = reshape (y, orig_sz);

endfunction


%!assert (cosint (1.1), 0.38487337742465081550, 2 * eps)

%!test
%! x = [2, 3, pi; exp(1), 5, 6];
%! A = cosint (x);
%! B = [0.422980828774864996, 0.119629786008000328, 0.0736679120464254860; ...
%!      0.213958001340379779, -0.190029749656643879, -0.0680572438932471262];
%! assert (A, B, -5e-15);

%!assert (cosint (0), - Inf)
%!assert (cosint (-0), -inf + 1i*pi)
%!assert (cosint (complex (-0, 0)), -inf + 1i*pi)
%!assert (cosint (complex (-0, -0)), -inf - 1i*pi)
%!assert (cosint (inf), 0)
%!assert (cosint (-inf), 1i * pi)
%!assert (cosint (complex (-inf, -0)), -1i * pi)
%!assert (isnan (cosint (nan)))

%!assert (class (cosint (single (1))), "single")

## tests against maple
%!assert (cosint (1), 0.337403922900968135, -2*eps)
%!assert (cosint (-1), 0.337403922900968135 + 3.14159265358979324*I, -2*eps)
%!assert (cosint (pi), 0.0736679120464254860, -4e-15)
%!assert (cosint (-pi), 0.0736679120464254860 + 3.14159265358979324*I, -2*eps)
%!assert (cosint (300), -0.00333219991859211178, -2*eps)
%!assert (cosint (1e4), -0.0000305519167244852127, -2*eps)
%!assert (cosint (20i), 1.28078263320282944e7 + 1.57079632679489662*I, -2*eps)

%!test
%! x = (0:4).';
%! y_ex = [-Inf
%!         0.337403922900968135
%!         0.422980828774864996
%!         0.119629786008000328
%!         -0.140981697886930412];
%! assert (cosint (x), y_ex, -3e-15);

%!test
%! x = -(1:4).';
%! y_ex = [0.337403922900968135 + pi*1i
%!         0.422980828774864996 + pi*1i
%!         0.119629786008000328 + pi*1i
%!         -0.140981697886930412 + pi*1i];
%! assert (cosint (x), y_ex, -4*eps);

%!test
%! x = complex (-(1:4).', 0);
%! y_ex = [0.337403922900968135 + pi*1i
%!         0.422980828774864996 + pi*1i
%!         0.119629786008000328 + pi*1i
%!         -0.140981697886930412 + pi*1i];
%! assert (cosint (x), y_ex, -4*eps);

%!test
%! x = complex (-(1:4).', -0);
%! y_ex = [0.337403922900968135 - pi*1i
%!         0.422980828774864996 - pi*1i
%!         0.119629786008000328 - pi*1i
%!         -0.140981697886930412 - pi*1i];
%! assert (cosint (x), y_ex, -4*eps);

%!test
%! x = 1i * (0:4).';
%! y_ex = [-Inf
%!         0.837866940980208241 + 1.57079632679489662*I
%!         2.45266692264691452 + 1.57079632679489662*I
%!         4.96039209476560976 + 1.57079632679489662*I
%!         9.81354755882318556 + 1.57079632679489662*I];
%! assert (cosint (x), y_ex, -4*eps);

%!test
%! x = -1i * (1:4).';
%! y_ex = [0.837866940980208241 - 1.57079632679489662*I
%!         2.45266692264691452 - 1.57079632679489662*I
%!         4.96039209476560976 - 1.57079632679489662*I
%!         9.81354755882318556 - 1.57079632679489662*I];
%! assert (cosint (x), y_ex, -4*eps);

%!test
%! x = [1+2i; -2+5i; 2-5i; 100; 10i; -1e-4 + 1e-6*1i; -20-1i];
%! A = [ 2.03029639329172164 - 0.151907155175856884*I
%!      1.61538963829107749 + 19.7257540553382650*I
%!      1.61538963829107749 + 16.5841614017484717*I
%!      -0.00514882514261049214
%!      1246.11448604245441 + 1.57079632679489662*I
%!      -8.63307471207423322 + 3.13159298695312800*I
%!      0.0698222284673061493 - 3.11847446254772946*I ];
%! B = cosint (x);
%! assert (A, B, -3*eps);
%! B = cosint (single (x));
%! assert (A, B, -3*eps ("single"));

## Fails along negative real axis
%!test
%! x = [-25; -100; -1000];
%! yex = [-0.0068485971797025909189 + pi*1i
%!        -0.0051488251426104921444 + pi*1i
%!        0.000826315511090682282 + pi*1i];
%! y = cosint (x);
%! assert (y, yex, -5*eps);

## FIXME: Need a test for bug #52953
%#!test <*52953>

## Test input validation
%!error <Invalid call> cosint ()
%!error <X must be numeric> cosint ("1")
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{k} =} ellipke (@var{m})
## @deftypefnx {} {@var{k} =} ellipke (@var{m}, @var{tol})
## @deftypefnx {} {[@var{k}, @var{e}] =} ellipke (@dots{})
## Compute complete elliptic integrals of the first K(@var{m}) and second
## E(@var{m}) kind.
##
## @var{m} must be a scalar or real array with -Inf @leq{} @var{m} @leq{} 1.
##
## The optional input @var{tol} controls the stopping tolerance of the
## algorithm and defaults to @code{eps (class (@var{m}))}.  The tolerance can
## be increased to compute a faster, less accurate approximation.
##
## When called with one output only elliptic integrals of the first kind are
## returned.
##
## Mathematical Note:
##
## Elliptic integrals of the first kind are defined as
##
## @tex
## $$
## {\rm K} (m) = \int_0^1 {dt \over \sqrt{(1 - t^2) (1 - m t^2)}}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##          1
##         /               dt
## K (m) = | ------------------------------
##         / sqrt ((1 - t^2)*(1 - m*t^2))
##        0
## @end group
## @end example
##
## @end ifnottex
##
## Elliptic integrals of the second kind are defined as
##
## @tex
## $$
## {\rm E} (m) = \int_0^1 {\sqrt{1 - m t^2} \over \sqrt{1 - t^2}} dt
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##          1
##         /  sqrt (1 - m*t^2)
## E (m) = |  ------------------ dt
##         /  sqrt (1 - t^2)
##        0
## @end group
## @end example
##
## @end ifnottex
##
## Reference: Milton @nospell{Abramowitz} and Irene A. @nospell{Stegun},
## @cite{Handbook of Mathematical Functions}, Chapter 17, Dover, 1965.
## @seealso{ellipj}
## @end deftypefn

function [k, e] = ellipke (m, tol = [])

  if (nargin < 1)
    print_usage ();
  endif

  sz = size (m);
  if (! isreal (m))
    error ("ellipke: M must be real");
  elseif (any (m > 1))
    error ("ellipke: M must be <= 1");
  endif

  if (isempty (tol))
    tol = eps (class (m));
  elseif (! (isreal (tol) && isscalar (tol) && tol > 0))
    error ("ellipke: TOL must be a real scalar > 0");
  endif

  k = e = zeros (sz);

  ## Handle extreme values
  idx_1 = (m == 1);
  k(idx_1) = Inf;
  e(idx_1) = 1;

  idx_neginf = (m == -Inf);
  k(idx_neginf) = 0;
  e(idx_neginf) = Inf;

  ## Arithmetic-Geometric Mean (AGM) algorithm
  ## ( Abramowitz and Stegun, Section 17.6 )
  Nmax = 16;
  idx = ! idx_1 & ! idx_neginf;
  if (any (idx))
    idx_neg = find (m < 0 & ! idx_neginf);
    mult_k = 1./sqrt (1 - m(idx_neg));
    mult_e = sqrt (1 - m(idx_neg));
    m(idx_neg) = -m(idx_neg) ./ (1 - m(idx_neg));
    b = sqrt (1 - m(idx));
    a = ones (size (b));
    c = sqrt (m(idx));
    f = 0.5;
    sum = f*c.^2;
    n = 2;
    do
      t = (a + b)/2;
      c = (a - b)/2;
      b = sqrt (a .* b);
      a = t;
      f *= 2;
      sum += f*c.^2;
    until (all (c./a < tol) || (++n > Nmax))
    if (n >= Nmax)
      error ("ellipke: algorithm did not converge in %d iterations", Nmax);
    endif
    k(idx) = 0.5*pi ./ a;
    e(idx) = 0.5*pi*(1 - sum) ./ a;
    k(idx_neg) = mult_k .* k(idx_neg);
    e(idx_neg) = mult_e .* e(idx_neg);
  endif

endfunction


## Test complete elliptic functions of first and second kind
## against "exact" solution from Mathematica 3.0
%!test
%! m = [0.0, 0.01; 0.1, 0.5; 0.9, 0.99; 1.0, 0.0];
%! [k,e] = ellipke (m);
%!
%! k_exp = [1.5707963267948966192, 1.5747455615173559527
%!          1.6124413487202193982, 1.8540746773013719184
%!          2.5780921133481731882, 3.6956373629898746778
%!          Inf                  , 1.5707963267948966192 ];
%! e_exp = [1.5707963267948966192, 1.5668619420216682912
%!          1.5307576368977632025, 1.3506438810476755025
%!          1.1047747327040733261, 1.0159935450252239356
%!          1.0                  , 1.5707963267948966192 ];
%! assert (k, k_exp, 8*eps);
%! assert (e, e_exp, 8*eps);

## Test against A&S Table 17.1
%!test
%! m = [0:5:50]'/100;
%! k_exp = [1.570796326794897;
%!          1.591003453790792;
%!          1.612441348720219;
%!          1.635256732264580;
%!          1.659623598610528;
%!          1.685750354812596;
%!          1.713889448178791;
%!          1.744350597225613;
%!          1.777519371491253;
%!          1.813883936816983;
%!          1.854074677301372 ];
%! e_exp = [1.570796327;
%!          1.550973352;
%!          1.530757637;
%!          1.510121831;
%!          1.489035058;
%!          1.467462209;
%!          1.445363064;
%!          1.422691133;
%!          1.399392139;
%!          1.375401972;
%!          1.350643881 ];
%! [k,e] = ellipke (m);
%! assert (k, k_exp, 1e-15);
%! assert (e, e_exp, 1e-8);

## Test negative values against "exact" solution from Mathematica.
%! m = [-0.01; -1; -5; -100; -1000; -Inf];
%! [k,e] = ellipke (m);
%!
%! k_exp = [1.5668912730681963584;
%!          1.3110287771460599052;
%!          0.9555039270640439337;
%!          0.3682192486091410329;
%!          0.1530293349884987857;
%!          0];
%! e_exp = [1.5747159850169884130;
%!          1.9100988945138560089;
%!          2.8301982463458773125;
%!          10.209260919814572009;
%!          31.707204053711259719;
%!          Inf ];
%! assert (k, k_exp, 8*eps);
%! assert (e, e_exp, 8*eps (e_exp));

## Test input validation
%!error <Invalid call> ellipke ()
%!error <M must be real> ellipke (1i)
%!error <M must be .= 1> ellipke (2)
%!error <TOL must be a real scalar . 0> ellipke (1, i)
%!error <TOL must be a real scalar . 0> ellipke (1, [1 1])
%!error <TOL must be a real scalar . 0> ellipke (1, -1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} expint (@var{x})
## Compute the exponential integral.
##
## The exponential integral is defined as:
##
## @tex
## $$
## {\rm E_1} (x) = \int_x^\infty {e^{-t} \over t} dt
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##            +oo
##           /
##           | exp (-t)
## E_1 (x) = | -------- dt
##           |    t
##           /
##          x
## @end group
## @end example
##
## @end ifnottex
##
## Note: For compatibility, this function uses the @sc{matlab} definition
## of the exponential integral.  Most other sources refer to this particular
## value as @math{E_1 (x)}, and the exponential integral as
## @tex
## $$
## {\rm Ei} (x) = - \int_{-x}^\infty {e^{-t} \over t} dt.
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##             +oo
##            /
##            | exp (-t)
## Ei (x) = - | -------- dt
##            |    t
##            /
##          -x
## @end group
## @end example
##
## @end ifnottex
## The two definitions are related, for positive real values of @var{x}, by
## @tex
## $
## E_1 (-x) = -{\rm Ei} (x) - i\pi.
## $
## @end tex
## @ifnottex
## @w{@code{E_1 (-x) = -Ei (x) - i*pi}}.
## @end ifnottex
##
## References:
##
## @nospell{M. Abramowitz and I.A. Stegun},
## @cite{Handbook of Mathematical Functions}, 1964.
##
## @nospell{N. Bleistein and R.A. Handelsman},
## @cite{Asymptotic expansions of integrals}, 1986.
##
## @seealso{cosint, sinint, exp}
## @end deftypefn

function E1 = expint (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    error ("expint: X must be numeric");
  endif

  ## Convert to floating point if necessary
  if (isinteger (x))
    x = double (x);
  endif

  orig_sparse = issparse (x);
  orig_sz = size (x);
  x = x(:);  # convert to column vector

  ## Initialize the result
  if (isreal (x) && x >= 0)
    E1 = zeros (size (x), class (x));
  else
    E1 = complex (zeros (size (x), class (x)));
  endif
  tol = eps (class (x));

  ## Divide the input into 3 regions and apply a different algorithm for each.
  ## s = series expansion, cf = continued fraction, a = asymptotic series
  s_idx = (((real (x) + 19.5).^ 2 ./ (20.5^2) + ...
            imag (x).^2 ./ (10^2)) <= 1) ...
          | (real (x) < 0 & abs (imag (x)) <= 1e-8);
  cf_idx = ((((real (x) + 1).^2 ./ (38^2) + ...
              imag (x).^2 ./ (40^2)) <= 1) ...
            & (! s_idx)) & (real (x) <= 35);
  a_idx = (! s_idx) & (! cf_idx);
  x_s  = x(s_idx);
  x_cf = x(cf_idx);
  x_a  = x(a_idx);

  ## Series expansion
  ## Abramowitz, Stegun, "Handbook of Mathematical Functions",
  ## formula 5.1.11, p 229.
  ## FIXME: Why so long?  IEEE double doesn't have this much precision.
  gm = 0.577215664901532860606512090082402431042159335;
  e1_s = -gm - log (x_s);
  res = -x_s;
  ssum = res;
  k = 1;
  todo = true (size (res));
  while (k < 1e3 && any (todo))
    res(todo) .*= (k * (- x_s(todo)) / ((k + 1) ^ 2));
    ssum(todo) += res(todo);
    k += 1;
    todo = (abs (res) > (tol * abs (ssum)));
  endwhile
  e1_s -= ssum;

  ## Continued fraction expansion,
  ## Abramowitz, Stegun, "Handbook of Mathematical Functions",
  ## formula 5.1.22, p 229.
  ## Modified Lentz's algorithm, from "Numerical recipes in Fortran 77" p.165.

  e1_cf = exp (-x_cf) .* __expint__ (x_cf);

  ## Remove spurious imaginary part if needed (__expint__ works automatically
  ## with complex values)

  if (isreal (x_cf) && x_cf >= 0)
    e1_cf = real (e1_cf);
  endif

  ## Asymptotic series, from N. Bleistein and R.A. Handelsman
  ## "Asymptotic expansion of integrals", pages 1-4.
  e1_a = exp (-x_a) ./ x_a;
  ssum = res = ones (size (x_a), class (x_a));
  k = 0;
  todo = true (size (x_a));
  while (k < 1e3 && any (todo))
    res(todo) ./= (- x_a(todo) / (k + 1));
    ssum(todo) += res(todo);
    k += 1;
    todo = abs (x_a) > k;
  endwhile
  e1_a .*= ssum;

  ## Combine results from each region into final output
  E1(s_idx)  = e1_s;
  E1(cf_idx) = e1_cf;
  E1(a_idx)  = e1_a;

  ## Restore shape and sparsity of input
  E1 = reshape (E1, orig_sz);
  if (orig_sparse)
    E1 = sparse (E1);
  endif

endfunction


## The following values were computed with the Octave symbolic package
%!test
%! X = [-50 - 50i  -30 - 50i  -10 - 50i    5 - 50i   15 - 50i   25 - 50i
%!      -50 - 30i  -30 - 30i  -10 - 30i    5 - 30i   15 - 30i   25 - 30i
%!      -50 - 10i  -30 - 10i  -10 - 10i    5 - 10i   15 - 10i   25 - 10i
%!      -50 +  5i  -30 +  5i  -10 +  5i    5 +  5i   15 +  5i   25 +  5i
%!      -50 + 15i  -30 + 15i  -10 + 15i    5 + 15i   15 + 15i   25 + 15i
%!      -50 + 25i  -30 + 25i  -10 + 25i    5 + 25i   15 + 25i   25 + 25i];
%! y_exp = [ -3.61285286166493e+19 + 6.46488018613387e+19i, ...
%!           -4.74939752018180e+10 + 1.78647798300364e+11i, ...
%!            3.78788822381261e+01 + 4.31742823558278e+02i, ...
%!            5.02062497548626e-05 + 1.23967883532795e-04i, ...
%!            3.16785290137650e-09 + 4.88866651583182e-09i, ...
%!            1.66999261039533e-13 + 1.81161508735941e-13i;
%!            3.47121527628275e+19 + 8.33104448629260e+19i, ...
%!            1.54596484273693e+11 + 2.04179357837414e+11i, ...
%!            6.33946547999647e+02 + 3.02965459323125e+02i, ...
%!            2.19834747595065e-04 - 9.25266900230165e-06i, ...
%!            8.49515487435091e-09 - 2.95133588338825e-09i, ...
%!            2.96635342439717e-13 - 1.85401806861382e-13i;
%!            9.65535916388246e+19 + 3.78654062133933e+19i, ...
%!            3.38477774418380e+11 + 8.37063899960569e+10i, ...
%!            1.57615042657685e+03 - 4.33777639047543e+02i, ...
%!            2.36176542789578e-05 - 5.75861972980636e-04i, ...
%!           -6.83624588479039e-09 - 1.47230889442175e-08i, ...
%!           -2.93020801760942e-13 - 4.03912221595793e-13i;
%!           -1.94572937469407e+19 - 1.03494929263031e+20i, ...
%!           -4.22385087573180e+10 - 3.61103191095041e+11i, ...
%!            4.89771220858552e+02 - 2.09175729060712e+03i, ...
%!            7.26650666035639e-04 + 4.71027801635222e-04i, ...
%!            1.02146578536128e-08 + 1.51813977370467e-08i, ...
%!            2.41628751621686e-13 + 4.66309048729523e-13i;
%!            5.42351559144068e+19 + 8.54503231614651e+19i, ...
%!            1.22886461074544e+11 + 3.03555953589323e+11i, ...
%!           -2.13050339387819e+02 + 1.23853666784218e+03i, ...
%!           -3.68087391884738e-04 + 1.94003994408861e-04i, ...
%!           -1.39355838231763e-08 + 6.57189276453356e-10i, ...
%!           -4.55133112151501e-13 - 8.46035902535333e-14i;
%!           -7.75482228205081e+19 - 5.36017490438329e+19i, ...
%!           -1.85284579257329e+11 - 2.08761110392897e+11i, ...
%!           -1.74210199269860e+02 - 8.09467914953486e+02i, ...
%!            9.40470496160143e-05 - 2.44265223110736e-04i, ...
%!            6.64487526601190e-09 - 7.87242868014498e-09i, ...
%!            3.10273337426175e-13 - 2.28030229776792e-13i];
%! assert (expint (X), y_exp, -1e-14);

## Exceptional values (-Inf, Inf, NaN, 0, 0.37250741078)
%!test
%! x = [-Inf; Inf; NaN; 0; -0.3725074107813668];
%! y_exp = [-Inf - i*pi; 0; NaN; Inf; 0 - i*pi];
%! y = expint (x);
%! assert (y, y_exp, 5*eps);

%!test <*53351>
%! assert (expint (32.5 + 1i),
%!         1.181108930758065e-16 - 1.966348533426658e-16i, -4*eps);
%! assert (expint (44 + 1i),
%!         9.018757389858152e-22 - 1.475771020004195e-21i, -4*eps);

%!test <*47738>
%! assert (expint (10i), 0.0454564330044554 + 0.0875512674239774i, -5*eps);

## Test preservation or conversion of the class
%!assert (class (expint (single (1))), "single")
%!assert (class (expint (int8 (1))), "double")
%!assert (class (expint (int16 (1))), "double")
%!assert (class (expint (int32 (1))), "double")
%!assert (class (expint (int64 (1))), "double")
%!assert (class (expint (uint8 (1))), "double")
%!assert (class (expint (uint16 (1))), "double")
%!assert (class (expint (uint32 (1))), "double")
%!assert (class (expint (uint64 (1))), "double")
%!assert (issparse (expint (sparse (1))))

## Test on the correct Image set
%!assert (isreal (expint (linspace (0, 100))))
%!assert (! isreal (expint (-1)))

## Test input validation
%!error <Invalid call> expint ()
%!error <X must be numeric> expint ("1")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{pf} =} factor (@var{q})
## @deftypefnx {} {[@var{pf}, @var{n}] =} factor (@var{q})
## Return the prime factorization of @var{q}.
##
## The prime factorization is defined as @code{prod (@var{pf}) == @var{q}}
## where every element of @var{pf} is a prime number.  If @code{@var{q} == 1},
## return 1.  The output @var{pf} is of the same numeric class as the input.
##
## With two output arguments, return the unique prime factors @var{pf} and
## their multiplicities.  That is,
## @code{prod (@var{pf} .^ @var{n}) == @var{q}}.
##
## Implementation Note: The input @var{q} must be less than @code{flintmax}
## when the input is a floating-point class (double or single).
## @seealso{gcd, lcm, isprime, primes}
## @end deftypefn

function [pf, n] = factor (q)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isscalar (q) || ! isreal (q) || q < 0 || q != fix (q))
    error ("factor: Q must be a real non-negative integer");
  endif

  ## Special case if q is prime, because isprime() is now much faster than
  ## factor().  This also absorbs the case of q < 4, where there are no primes
  ## less than sqrt(q).
  if (q < 4 || isprime (q))
    pf = q;
    n = 1;
    return;
  endif

  ## If we are here, then q is composite.

  cls = class (q);  # store class
  if (isfloat (q) && q > flintmax (q))
    error ("factor: Q too large to factor (> flintmax)");
  endif

  ## The basic idea is to divide by the prime numbers from 1 to sqrt(q).
  ## But primes(sqrt(q)) can be very time-consuming to compute for q > 1e16,
  ## so we divide by smaller primes first.
  ##
  ## This won't make a difference for prime q, but it makes a big (100x)
  ## difference for large composite q.  Since there are many more composites
  ## than primes, this leads overall to a speedup.
  ##
  ## There is at most one prime greater than sqrt(q), and if it exists,
  ## it has multiplicity 1, so no need to consider any factors greater
  ## than sqrt(q) directly.  If there were two factors p1, p2 > sqrt(q), then
  ##
  ##   q >= p1*p2 > sqrt(q)*sqrt(q) == q,
  ##
  ## which is a contradiction.
  ##
  ## The following calculation of transition and number of divisors to use
  ## was determined empirically.  As of now (October 2021) it gives the best
  ## overall performance over the range of 1 <= q <= intmax ("uint64").
  ##
  ## For future programmers: check periodically for performance improvements
  ## and tune this transition as required.  Trials that didn't yield success
  ## in (October 2021):
  ##
  ## 1.) persistent smallprimes = primes (FOO)
  ##
  ##     For various fixed FOO in the range 10 <= FOO <= 10e6.
  ##     (FOO is independent of q.)  The thought had been that making it
  ##     persistent would cache it so it didn't need to be recomputed for
  ##     subsequent calls, but it slowed it down overall.  It seems calling
  ##     primes twice with smaller q is still faster than one persistent
  ##     call for a large q.
  ##
  ## 2.) smallprimes = primes (q ^ FOO)
  ##
  ##     For various values of FOO.  For FOO >= 0.25 or FOO <= 0.16, the
  ##     performance is very poor.  FOO needs to be in the 0.17 to 0.24 range,
  ##     somewhat.  Benchmark experiments indicate it should increase gently
  ##     from 0.18 to 0.21 as q goes from 10^11 to 10^18.
  ##
  ##     But putting in such an expression would require calculating the log
  ##     of q, which defeats any performance improvement.  Or a step-wise
  ##     approximation like:
  ##
  ##     foo = 0.18 + 0.01 * (q > 1e12) + 0.01 * (q > 1e14) ...
  ##                                    + 0.01 * (q > 1e16);
  ##     smallprimes = primes (feval (cls, q^foo));
  ##
  ##     where the RHS of foo would go from 0.18 to 0.21 over several orders
  ##     of magnitude without calling the log.  Obviously that is overly
  ##     empirical, so putting in q^0.2 seems to be the most robust overall
  ##     for 64-bit q.

  ## Lookup table for sufficiently small values for q.
  if (q < 10e9)
    ## Lookup, rather calling up to primes(100) is about 3% faster, than the
    ## previous value of primes(30).  Same for very small q < 1e6.
    ##
    ## For 1e9 < q < 10e9 the lookup approach is about 7% faster.

    smallprimes = feval (cls, ...
      [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]);

    ## Only for really small values of q, statements like
    ##
    ##   smallprimes(smallprimes > q) = [];
    ##
    ## are relevant and slow down significantly for large values of q.
  else
    ## For sufficiently large q, go up to the 5th root of q for now.
    smallprimes = primes (feval (cls, q^0.2));
  endif

  ## pf is the list of prime factors returned with type of input class.
  pf = feval (cls, []);
  [pf, q] = reducefactors (q, pf, smallprimes);

  ## pf now contains all prime factors of q within smallprimes, including
  ## repetitions, in ascending order.
  ##
  ## q itself will be divided by those prime factors to become smaller,
  ## unless q was prime to begin with.

  if (isprime (q))
    ## This is an optimization for numbers like 18446744073709551566
    ## == 2 * 9223372036854775783, where the small factors can be pulled
    ## out easily and the remaining is prime.  This optimization reduces
    ## 14.3 s to 1.8 ms (8000X faster) for such cases.
    pf(end+1) = q;
  else
    ## Now go all the way to sqrt(q), where q is smaller than the original q in
    ## most cases.
    ##
    ## Note: Do not try to weed out the smallprimes inside largeprimes, whether
    ## using length(smallprimes) or max(smallprimes) -- it slows it down!
    largeprimes = primes (sqrt (q));
    [pf, q] = reducefactors (q, pf, largeprimes);

    ## At this point, all prime factors <= the sqrt of the original q have been
    ## pulled out in ascending order.
    ##
    ## If q = 1, then no further primes are left.
    ## If q > 1, then q itself must be prime, and it must be the single prime
    ## factor that was larger than the sqrt of the original q.
    if (q > 1)
      pf(end+1) = q;
    endif
  end

  ## At this point, all prime factors have been pulled out of q in ascending
  ## order.  There is no need to sort(pf).

  ## Determine multiplicity.
  if (nargout > 1)
    idx = find ([0, pf] != [pf, 0]);
    pf = pf(idx(1:length (idx)-1));
    n = diff (idx);
  endif

endfunction

function [pf, q] = reducefactors (qin, pfin, divisors)

  pf = pfin;
  q = qin;
  ## The following line is a few milliseconds faster than
  ## divisors (mod (q, divisors) ~= 0) = [];
  divisors = divisors (mod (q, divisors) == 0);

  for pp = divisors  # for each factor in turn
    ## Keep extracting all occurrences of that factor before going to larger
    ## factors.
    ##
    ## Note: mod() was marginally faster than rem(), when assessed over 10e6
    ##       trials of the whole factor() function.
    while (mod (q, pp) == 0)
      pf(end+1) = pp;
      q /= pp;
    endwhile
  endfor

endfunction


## Test special case input
%!assert (factor (1), 1)
%!assert (factor (2), 2)
%!assert (factor (3), 3)

%!test
%! for i = 2:20
%!   pf = factor (i);
%!   assert (prod (pf), i);
%!   assert (all (isprime (pf)));
%!   [pf, n] = factor (i);
%!   assert (prod (pf.^n), i);
%!   assert (all ([0,pf] != [pf,0]));
%! endfor

%!assert (factor (uint8 (8)), uint8 ([2 2 2]))
%!assert (factor (single (8)), single ([2 2 2]))
%!test
%! [pf, n] = factor (int16 (8));
%! assert (pf, int16 (2));
%! assert (n, double (3));

## Test input validation
%!error <Invalid call> factor ()
%!error <Q must be a real non-negative integer> factor ([1,2])
%!error <Q must be a real non-negative integer> factor (6i)
%!error <Q must be a real non-negative integer> factor (-20)
%!error <Q must be a real non-negative integer> factor (1.5)
%!error <Q too large to factor> factor (flintmax ("single") + 2)
%!error <Q too large to factor> factor (flintmax ("double") + 2)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} factorial (@var{n})
## Return the factorial of @var{n} where @var{n} is a real non-negative
## integer.
##
## If @var{n} is a scalar, this is equivalent to @code{prod (1:@var{n})}.  For
## vector or matrix arguments, return the factorial of each element in the
## array.
##
## For non-integers see the generalized factorial function @code{gamma}.
## Note that the factorial function grows large quite quickly, and even
## with double precision values overflow will occur if @var{n} > 171.  For
## such cases consider @code{gammaln}.
## @seealso{prod, gamma, gammaln}
## @end deftypefn

function x = factorial (n)

  if (nargin < 1)
    print_usage ();
  elseif (! isreal (n) || any (n(:) < 0 | n(:) != fix (n(:))))
    error ("factorial: all N must be real non-negative integers");
  endif

  x = round (gamma (n+1));

  ## FIXME: Matlab returns an output of the same type as the input.
  ## This doesn't seem particularly worth copying--for example uint8 would
  ## saturate for n > 5.  If desired, however, the following code could be
  ## uncommented.
  ## if (! isfloat (x))
  ##   x = cast (x, class (n));
  ## endif

endfunction


%!assert (factorial (5), prod (1:5))
%!assert (factorial ([1,2;3,4]), [1,2;6,24])
%!assert (factorial (70), exp (sum (log (1:70))), -128*eps)
%!assert (factorial (0), 1)

%!error <Invalid call> factorial ()
%!error <must be real non-negative integers> factorial (2i)
%!error <must be real non-negative integers> factorial (-3)
%!error <must be real non-negative integers> factorial (5.5)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} gammainc (@var{x}, @var{a})
## @deftypefnx {} {} gammainc (@var{x}, @var{a}, @var{tail})
## Compute the normalized incomplete gamma function.
##
## This is defined as
## @tex
## $$
##  \gamma (x, a) = {1 \over {\Gamma (a)}}\displaystyle{\int_0^x t^{a-1} e^{-t} dt}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                                 x
##                        1       /
## gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
##                   gamma (a)    /
##                             t=0
## @end group
## @end example
##
## @end ifnottex
## with the limiting value of 1 as @var{x} approaches infinity.
## The standard notation is @math{P(a,x)}, e.g., @nospell{Abramowitz} and
## @nospell{Stegun} (6.5.1).
##
## If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned
## for each element of @var{x} and vice versa.
##
## If neither @var{x} nor @var{a} is scalar then the sizes of @var{x} and
## @var{a} must agree, and @code{gammainc} is applied element-by-element.
## The elements of @var{a} must be non-negative.
##
## By default, @var{tail} is @qcode{"lower"} and the incomplete gamma function
## integrated from 0 to @var{x} is computed.  If @var{tail} is @qcode{"upper"}
## then the complementary function integrated from @var{x} to infinity is
## calculated.
##
## If @var{tail} is @qcode{"scaledlower"}, then the lower incomplete gamma
## function is multiplied by
## @tex
## $\Gamma(a+1)\exp(x)x^{-a}$.
## @end tex
## @ifnottex
## @math{gamma(a+1)*exp(x)/(x^a)}.
## @end ifnottex
## If @var{tail} is @qcode{"scaledupper"}, then the upper incomplete gamma
## function is multiplied by the same quantity.
##
## References:
##
## @nospell{M. Abramowitz and I.A. Stegun},
## @cite{Handbook of mathematical functions},
## @nospell{Dover publications, Inc.}, 1972.
##
## @nospell{W. Gautschi},
## @cite{A computational procedure for incomplete gamma functions},
## @nospell{ACM Trans.@: Math Software}, pp.@: 466--481, Vol 5, No.@: 4, 2012.
##
## @nospell{W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery},
## @cite{Numerical Recipes in Fortran 77}, ch.@: 6.2, Vol 1, 1992.
##
## @seealso{gamma, gammaincinv, gammaln}
## @end deftypefn

## P(a,x) = gamma(a,x)/Gamma(a), upper
## 1-P(a,x)=Q(a,x)=Gamma(a,x)/Gamma(a), lower

function y = gammainc (x, a, tail = "lower")

  if (nargin < 2)
    print_usage ();
  endif

  [err, x, a] = common_size (x, a);
  if (err > 0)
    error ("gammainc: X and A must be of common size or scalars");
  endif

  if (iscomplex (x) || iscomplex (a))
    error ("gammainc: all inputs must be real");
  endif

  ## Remember original shape of data, but convert to column vector for calcs.
  x_sz = size (x);
  x = x(:);
  a = a(:);

  if (any (a < 0))
    error ("gammainc: A must be non-negative");
  endif

  if (nargin == 3
      && ! any (strcmpi (tail, {"lower","upper","scaledlower","scaledupper"})))
    error ("gammainc: invalid value for TAIL");
  endif
  tail = tolower (tail);

  ## If any of the arguments is single then the output should be as well.
  if (strcmp (class (x), "single") || strcmp (class (a), "single"))
    x = single (x);
    a = single (a);
  endif

  ## Convert to floating point if necessary
  if (isinteger (x))
    x = double (x);
  endif
  if (isinteger (a))
    a = double (a);
  endif

  ## Initialize output array
  y = zeros (x_sz, class (x));

  ## Different x, a combinations are handled by different subfunctions.
  todo = true (size (x));  # Track which elements need to be calculated.

  ## Case 0: x == Inf, a == Inf
  idx = (x == Inf) & (a == Inf);
  if (any (idx))
    y(idx) = NaN;
    todo(idx) = false;
  endif

  ## Case 1: x == 0, a == 0.
  idx = (x == 0) & (a == 0);
  if (any (idx))
    y(idx) = gammainc_00 (tail);
    todo(idx) = false;
  endif

  ## Case 2: x == 0.
  idx = todo & (x == 0);
  if (any (idx))
    y(idx) = gammainc_x0 (tail);
    todo(idx) = false;
  endif

  ## Case 3: x = Inf
  idx = todo & (x == Inf);
  if (any (idx))
    y(idx) = gammainc_x_inf (tail);
    todo(idx) = false;
  endif

  ## Case 4: a = Inf
  idx = todo & (a == Inf);
  if (any (idx))
    y(idx) = gammainc_a_inf (tail);
    todo(idx) = false;
  endif

  ## Case 5: a == 0.
  idx = todo & (a == 0);
  if (any (idx))
    y(idx) = gammainc_a0 (x(idx), tail);
    todo(idx) = false;
  endif

  ## Case 6: a == 1.
  idx = todo & (a == 1);
  if (any (idx))
    y(idx) = gammainc_a1 (x(idx), tail);
    todo(idx) = false;
  endif

  ## Case 7: positive integer a; exp (x) and a! both under 1/eps.
  idx = (todo
         & (a == fix (a)) & (a > 1) & (a <= 18) & (x <= 36) & (abs (x) >= .1));
  if (any (idx))
    y(idx) = gammainc_an (x(idx), a(idx), tail);
    todo(idx) = false;
  endif

  ## For a < 2, x < 0, we increment a by 2 and use a recurrence formula after
  ## the computations.

  flag_a_small = todo & (abs (a) > 0) & (abs (a) < 2) & (x < 0);
  a(flag_a_small) += 2;

  flag_s = (((x + 0.25 < a) | (x < 0)) & (x > -20)) | (abs (x) < 1);

  ## Case 8: x, a relatively small.
  idx = todo & flag_s;
  if (any (idx))
    y(idx) = gammainc_s (x(idx), a(idx), tail);
    todo(idx) = false;
  endif

  ## Case 9: x positive and large relative to a.
  idx = todo;
  if (any (idx))
    y(idx) = gammainc_l (x(idx), a(idx), tail);
    todo(idx) = false;
  endif

  if (any (flag_a_small))
    if (strcmp (tail, "lower"))
      y(flag_a_small) += D (x(flag_a_small), a(flag_a_small) - 1) + ...
        D (x(flag_a_small), a(flag_a_small) - 2);
    elseif (strcmp (tail, "upper"))
      y(flag_a_small) -= D (x(flag_a_small), a(flag_a_small) - 1) + ...
           D (x(flag_a_small), a(flag_a_small) - 2);
    elseif (strcmp (tail, "scaledlower"))
      y(flag_a_small) = y(flag_a_small) .* (x(flag_a_small) .^ 2) ./ ...
        (a(flag_a_small) .* (a(flag_a_small) - 1)) + (x(flag_a_small) ./ ...
          (a(flag_a_small) - 1)) + 1;
    elseif (strcmp (tail, "scaledupper"))
      y(flag_a_small) = y(flag_a_small) .* (x(flag_a_small) .^ 2) ./ ...
        (a(flag_a_small) .* (a(flag_a_small) - 1)) - (x(flag_a_small) ./ ...
          (a(flag_a_small) - 1)) - 1;
     endif
  endif

endfunction

## Subfunctions to handle each case:

## x == 0, a == 0.
function y = gammainc_00 (tail)
  if (strcmp (tail, "upper") || strcmp (tail, "scaledupper"))
    y = 0;
  else
    y = 1;
  endif
endfunction

## x == 0.
function y = gammainc_x0 (tail)
  if (strcmp (tail, "lower"))
    y = 0;
  elseif (strcmp (tail, "upper") || strcmp (tail, "scaledlower"))
    y = 1;
  else
    y = Inf;
  endif
endfunction

## x == Inf.
function y = gammainc_x_inf (tail)
  if (strcmp (tail, "lower"))
    y = 1;
  elseif (strcmp (tail, "upper") || strcmp (tail, "scaledupper"))
    y = 0;
  else
    y = Inf;
  endif
endfunction

## a == Inf.
function y = gammainc_a_inf (tail)
  if (strcmp (tail, "lower"))
    y = 0;
  elseif (strcmp (tail, "upper") || strcmp (tail, "scaledlower"))
    y = 1;
  else
    y = Inf;
  endif
endfunction

## a == 0.
function y = gammainc_a0 (x, tail)
  if (strcmp (tail, "lower"))
    y = 1;
  elseif (strcmp (tail, "scaledlower"))
    y = exp (x);
  else
    y = 0;
  endif
endfunction

## a == 1.
function y = gammainc_a1 (x, tail)

  if (strcmp (tail, "lower"))
    if (abs (x) < 1/2)
      y = - expm1 (-x);
    else
      y = 1 - exp (-x);
    endif
  elseif (strcmp (tail, "upper"))
    y = exp (-x);
  elseif (strcmp (tail, "scaledlower"))
    if (abs (x) < 1/2)
      y = expm1 (x) ./ x;
    else
      y = (exp (x) - 1) ./ x;
    endif
  else
    y = 1 ./ x;
  endif

endfunction

## positive integer a; exp (x) and a! both under 1/eps
## uses closed-form expressions for nonnegative integer a
## -- http://mathworld.wolfram.com/IncompleteGammaFunction.html.
function y = gammainc_an (x, a, tail)

  y = t = ones (size (x), class (x));
  i = 1;
  while (any (a(:) > i))
    jj = (a > i);
    t(jj) .*= (x(jj) / i);
    y(jj) += t(jj);
    i++;
  endwhile
  if (strcmp (tail, "lower"))
    y = 1 - exp (-x) .* y;
  elseif (strcmp (tail, "upper"))
    y .*= exp (-x);
  elseif (strcmp (tail, "scaledlower"))
    y = (1 - exp (-x) .* y) ./ D(x, a);
  elseif (strcmp (tail, "scaledupper"))
    y .*= exp (-x) ./ D(x, a);
  endif

endfunction

## x + 0.25 < a | x < 0 | abs(x) < 1.
## Numerical Recipes in Fortran 77 (6.2.5)
## series
function y = gammainc_s (x, a, tail)

  if (strcmp (tail, "scaledlower") || strcmp (tail, "scaledupper"))
    y = ones (size (x), class (x));
    term = x ./ (a + 1);
  else
    ## Of course it is possible to scale at the end, but some tests fail.
    ## And try gammainc (1,1000), it take 0 iterations if you scale now.
    y = D (x,a);
    term = y .* x ./ (a + 1);
  endif
  n = 1;
  while (any (abs (term(:)) > (abs (y(:)) * eps)))
    ## y can be zero from the beginning (gammainc (1,1000))
    jj = abs (term) > abs (y) * eps;
    n += 1;
    y(jj) += term(jj);
    term(jj) .*= x(jj) ./ (a(jj) + n);
  endwhile
  if (strcmp (tail, "upper"))
    y = 1 - y;
  elseif (strcmp (tail, "scaledupper"))
    y = 1 ./ D (x,a) - y;
  endif

endfunction

## x positive and large relative to a
## NRF77 (6.2.7)
## Gamma (a,x)/Gamma (a)
## Lentz's algorithm
## __gammainc__ in libinterp/corefcn/__gammainc__.cc
function y = gammainc_l (x, a, tail)

  y = __gammainc__ (x, a);
  if (strcmp (tail,  "lower"))
    y = 1 - y .* D (x, a);
  elseif (strcmp (tail, "upper"))
    y .*= D (x, a);
  elseif (strcmp (tail, "scaledlower"))
    y = 1 ./ D (x, a) - y;
  endif

endfunction

## Compute exp(-x)*x^a/Gamma(a+1) in a stable way for x and a large.
##
## L. Knusel, Computation of the Chi-square and Poisson distribution,
## SIAM J. Sci. Stat. Comput., 7(3), 1986
## which quotes Section 5, Abramowitz&Stegun 6.1.40, 6.1.41.
function y = D (x, a)

  athresh = 10;  # FIXME: can this be better tuned?
  y = zeros (size (x), class (x));

  todo = true (size (x));
  todo(x == 0) = false;

  ii = todo & (x > 0) & (a > athresh) & (a >= x);
  if (any (ii))
    lnGa = log (2 * pi * a(ii)) / 2 + 1 ./ (12 * a(ii)) - ...
           1 ./ (360 * a(ii) .^ 3) + 1 ./ (1260 * a(ii) .^ 5) - ...
           1 ./ (1680 * a(ii) .^ 7) + 1 ./ (1188 * a(ii) .^ 9)- ...
           691 ./ (87360 * a(ii) .^ 11) + 1 ./ (156 * a(ii) .^ 13) - ...
           3617 ./ (122400 * a(ii) .^ 15) + ...
           43867 ./ (244188 * a(ii) .^ 17) - 174611 ./ (125400 * a(ii) .^ 19);
    lns = log1p ((a(ii) - x(ii)) ./ x(ii));
    y(ii) = exp ((a(ii) - x(ii)) - a(ii) .* lns - lnGa);
    todo(ii) = false;
  endif

  ii = todo & (x > 0) & (a > athresh) & (a < x);
  if (any (ii))
    lnGa = log (2 * pi * a(ii)) / 2 + 1 ./ (12 * a(ii)) - ...
           1 ./ (360 * a(ii) .^ 3) + 1 ./ (1260 * a(ii) .^ 5) - ...
           1 ./ (1680 * a(ii) .^ 7) + 1 ./ (1188 * a(ii) .^ 9)- ...
           691 ./ (87360 * a(ii) .^ 11) + 1 ./ (156 * a(ii) .^ 13) - ...
           3617 ./ (122400 * a(ii) .^ 15) + ...
           43867 ./ (244188 * a(ii) .^ 17) - 174611 ./ (125400 * a(ii) .^ 19);
    lns = -log1p ((x(ii) - a(ii)) ./ a(ii));
    y(ii) = exp ((a(ii) - x(ii)) - a(ii) .* lns - lnGa);
    todo(ii) = false;
  endif

  ii = todo & ((x <= 0) | (a <= athresh));
  if (any (ii))  # standard formula for a not so large.
    y(ii) = exp (a(ii) .* log (x(ii)) - x(ii) - gammaln (a(ii) + 1));
    todo(ii) = false;
  endif

  ii = (x < 0) & (a == fix (a));
  if (any (ii))  # remove spurious imaginary part.
    y(ii) = real (y(ii));
  endif

endfunction


## Test: case 1,2,5
%!assert (gammainc ([0, 0, 1], [0, 1, 0]), [1, 0, 1])
%!assert (gammainc ([0, 0, 1], [0, 1, 0], "upper"), [0, 1, 0])
%!assert (gammainc ([0, 0, 1], [0, 1, 0], "scaledlower"), [1, 1, exp(1)])
%!assert (gammainc ([0, 0, 1], [0, 1, 0], "scaledupper"), [0, Inf, 0])

## Test: case 3,4
%!assert (gammainc ([2, Inf], [Inf, 2]), [0, 1])
%!assert (gammainc ([2, Inf], [Inf, 2], "upper"), [1, 0])
%!assert (gammainc ([2, Inf], [Inf, 2], "scaledlower"), [1, Inf])
%!assert (gammainc ([2, Inf], [Inf, 2], "scaledupper"), [Inf, 0])

## Test: case 5
## Matlab fails for this test
%!assert (gammainc (-100,1,"upper"), exp (100), -eps)

## Test: case 6
%!assert (gammainc ([1, 2, 3], 1), 1 - exp (-[1, 2, 3]))
%!assert (gammainc ([1, 2, 3], 1, "upper"), exp (- [1, 2, 3]))
%!assert (gammainc ([1, 2, 3], 1, "scaledlower"), ...
%!        (exp ([1, 2, 3]) - 1) ./ [1, 2, 3])
%!assert (gammainc ([1, 2, 3], 1, "scaledupper"), 1 ./ [1, 2, 3])

## Test: case 7
%!assert (gammainc (2, 2, "lower"), 0.593994150290162, -2e-15)
%!assert (gammainc (2, 2, "upper"), 0.406005849709838, -2e-15)
%!assert (gammainc (2, 2, "scaledlower"), 2.194528049465325, -2e-15)
%!assert (gammainc (2, 2, "scaledupper"), 1.500000000000000, -2e-15)
%!assert (gammainc ([3 2 36],[2 3 18], "upper"), ...
%!        [4/exp(3) 5*exp(-2) (4369755579265807723 / 2977975)/exp(36)], -eps)
%!assert (gammainc (10, 10), 1 - (5719087 / 567) * exp (-10), -eps)
%!assert (gammainc (10, 10, "upper"), (5719087 / 567) * exp (-10), -eps)

## Test: case 8
%!assert (gammainc (-10, 10), 3.112658265341493126871617e7, -2*eps)
## Matlab fails this next one%!      %!
%!assert (isreal (gammainc (-10, 10)), true)
%!assert (gammainc (-10, 10.1, "upper"), ...
%!        -2.9582761911890713293e7-1i * 9.612022339061679758e6, -30*eps)
%!assert (gammainc (-10, 10, "upper"), -3.112658165341493126871616e7, ...
%!        -2*eps)
%!assert (gammainc (-10, 10, "scaledlower"), 0.5128019364747265, -1e-14)
%!assert (gammainc (-10, 10, "scaledupper"), -0.5128019200000000, -1e-14)
%!assert (gammainc (200, 201, "upper"), 0.518794309678684497, -2 * eps)
%!assert (gammainc (200, 201, "scaledupper"),
%!        18.4904360746560462660798514, -eps)
## Here we are very good (no D (x,a)) involved
%!assert (gammainc (1000, 1000.5, "scaledlower"), 39.48467539583672271, -2*eps)
%!assert (gammainc (709, 1000, "upper"), 0.99999999999999999999999954358, -eps)

## Test: case 9
%!test <*47800>
%! assert (gammainc (60, 6, "upper"), 6.18022358081160257327264261e-20,
%!         -10*eps);
## Matlab is better here than Octave
%!assert (gammainc (751, 750, "upper"), 0.4805914320558831327179457887, -12*eps)
%!assert (gammainc (200, 200, "upper"), 0.49059658199276367497217454, -6*eps)
%!assert (gammainc (200, 200), 0.509403418007236325027825459574527043, -5*eps)
%!assert (gammainc (200, 200, "scaledupper"), 17.3984438553791505135122900,
%!       -3*eps)
%!assert (gammainc (200, 200, "scaledlower"), 18.065406676779221643065, -8*eps)
%!assert (gammainc (201, 200, "upper"), 0.46249244908276709524913736667,
%!        -7*eps)
%!assert <*54550> (gammainc (77, 2), 1)

%!assert (gammainc (77, 2, "upper"), 0, -eps)
%!assert (gammainc (1000, 3.1), 1)
%!assert (gammainc (1000, 3.1, "upper"), 0)

## Test small argument
%!assert (gammainc ([1e-05, 1e-07,1e-10,1e-14], 0.1), ...
%!        [0.33239840504050, 0.20972940370977, 0.10511370061022, ...
%!        0.041846517936723], 1e-13);

%!assert (gammainc ([1e-05, 1e-07,1e-10,1e-14], 0.2), ...
%!        [0.10891226058559, 0.043358823442178, 0.010891244210402, ...
%!        0.0017261458806785], 1e-13);

%!test
%!assert (gammainc ([1e-02, 1e-03, 1e-5, 1e-9, 1e-14], 0.9), ...
%!        [0.016401189184068, 0.0020735998660840, 0.000032879756964708, ...
%!        8.2590606569241e-9, 2.6117443021738e-13], -1e-12);

%!test
%!assert (gammainc ([1e-02, 1e-03, 1e-5, 1e-9, 1e-14], 2), ...
%!        [0.0000496679133402659, 4.99666791633340e-7, 4.99996666679167e-11, ...
%!        4.99999999666667e-19, 4.99999999999997e-29], -1e-12);

%!test <*53543>
%! y_exp = 9.995001666250085e-04;
%! assert (gammainc (1/1000, 1), y_exp, -eps);

%!test <53612>
%! assert (gammainc (-20, 1.1, "upper"), ...
%!         6.50986687074979e8 + 2.11518396291149e8*i, -1e-13);

## Test conservation of the class (five tests for each subroutine).
%!assert (class (gammainc (0, 1)) == "double")
%!assert (class (gammainc (single (0), 1)) == "single")
%!assert (class (gammainc (int8 (0), 1)) == "double")
%!assert (class (gammainc (0, single (1))) == "single")
%!assert (class (gammainc (0, int8 (1))) == "double")
%!assert (class (gammainc (1, 0)) == "double")
%!assert (class (gammainc (single (1), 0)) == "single")
%!assert (class (gammainc (int8 (1), 0)) == "double")
%!assert (class (gammainc (1, single (0))) == "single")
%!assert (class (gammainc (1, int8 (0))) == "double")
%!assert (class (gammainc (1, 1)) == "double")
%!assert (class (gammainc (single (1), 1)) == "single")
%!assert (class (gammainc (int8 (1), 1)) == "double")
%!assert (class (gammainc (1, single (1))) == "single")
%!assert (class (gammainc (1, int8 (1))) == "double")
%!assert (class (gammainc (1, 2)) == "double")
%!assert (class (gammainc (single (1), 2)) == "single")
%!assert (class (gammainc (int8 (1), 2)) == "double")
%!assert (class (gammainc (1, single (2))) == "single")
%!assert (class (gammainc (1, int8 (2))) == "double")
%!assert (class (gammainc (-1, 0.5)) == "double")
%!assert (class (gammainc (single (-1), 0.5)) == "single")
%!assert (class (gammainc (int8 (-1), 0.5)) == "double")
%!assert (class (gammainc (-1, single (0.5))) == "single")
%!assert (class (gammainc (-1, int8 (0.5))) == "double")
%!assert (class (gammainc (1, 0.5)) == "double")
%!assert (class (gammainc (single (1), 0.5)) == "single")
%!assert (class (gammainc (int8 (1), 0.5)) == "double")
%!assert (class (gammainc (1, single (0.5))) == "single")
%!assert (class (gammainc (1, int8 (0.5))) == "double")

## Test input validation
%!error <Invalid call> gammainc ()
%!error <Invalid call> gammainc (1)
%!error <must be of common size or scalars> gammainc ([0, 0],[0; 0])
%!error <must be of common size or scalars> gammainc ([1 2 3], [1 2])
%!error <all inputs must be real> gammainc (2+i, 1)
%!error <all inputs must be real> gammainc (1, 2+i)
%!error <A must be non-negative> gammainc (1, [0, -1, 1])
%!error <A must be non-negative>
%! a = ones (2,2,2);
%! a(1,1,2) = -1;
%! gammainc (1, a);
%!error <invalid value for TAIL> gammainc (1,2, "foobar")
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} gammaincinv (@var{y}, @var{a})
## @deftypefnx {} {} gammaincinv (@var{y}, @var{a}, @var{tail})
## Compute the inverse of the normalized incomplete gamma function.
##
## The normalized incomplete gamma function is defined as
## @tex
## $$
##  \gamma (x, a) = {1 \over {\Gamma (a)}}\displaystyle{\int_0^x t^{a-1} e^{-t} dt}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                                 x
##                        1       /
## gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
##                   gamma (a)    /
##                             t=0
## @end group
## @end example
##
## @end ifnottex
##
## and @code{gammaincinv (gammainc (@var{x}, @var{a}), @var{a}) = @var{x}}
## for each non-negative value of @var{x}.  If @var{a} is scalar then
## @code{gammaincinv (@var{y}, @var{a})} is returned for each element of
## @var{y} and vice versa.
##
## If neither @var{y} nor @var{a} is scalar then the sizes of @var{y} and
## @var{a} must agree, and @code{gammaincinv} is applied element-by-element.
## The variable @var{y} must be in the interval @math{[0,1]} while @var{a} must
## be real and positive.
##
## By default, @var{tail} is @qcode{"lower"} and the inverse of the incomplete
## gamma function integrated from 0 to @var{x} is computed.  If @var{tail} is
## @qcode{"upper"}, then the complementary function integrated from @var{x} to
## infinity is inverted.
##
## The function is computed with Newton's method by solving
## @tex
## $$
##  y - \gamma (x, a) = 0
## $$
## @end tex
## @ifnottex
##
## @example
## @var{y} - gammainc (@var{x}, @var{a}) = 0
## @end example
##
## @end ifnottex
##
## Reference: @nospell{A. Gil, J. Segura, and N. M. Temme}, @cite{Efficient and
## accurate algorithms for the computation and inversion of the incomplete
## gamma function ratios}, @nospell{SIAM J. Sci.@: Computing}, pp.@:
## A2965--A2981, Vol 34, 2012.
##
## @seealso{gammainc, gamma, gammaln}
## @end deftypefn

function x = gammaincinv (y, a, tail = "lower")

  if (nargin < 2)
    print_usage ();
  endif

  [err, y, a] = common_size (y, a);
  if (err > 0)
    error ("gammaincinv: Y and A must be of common size or scalars");
  endif

  if (iscomplex (y) || iscomplex (a))
    error ("gammaincinv: all inputs must be real");
  endif

  ## Remember original shape of data, but convert to column vector for calcs.
  orig_sz = size (y);
  y = y(:);
  a = a(:);

  if (any ((y < 0) | (y > 1)))
    error ("gammaincinv: Y must be in the range [0, 1]");
  endif

  if (any (a <= 0))
    error ("gammaincinv: A must be strictly positive");
  endif

  ## If any of the arguments is single then the output should be as well.
  if (strcmp (class (y), "single") || strcmp (class (a), "single"))
    y = single (y);
    a = single (a);
  endif

  ## Convert to floating point if necessary
  if (isinteger (y))
    y = double (y);
  endif
  if (isinteger (a))
    a = double (a);
  endif

  ## Initialize output array
  x = zeros (size (y), class (y));

  maxit = 20;
  tol = eps (class (y));

  ## Special cases, a = 1 or y = 0, 1.

  if (strcmpi (tail, "lower"))
    x(a == 1) = - log1p (- y(a == 1));
    x(y == 0) = 0;
    x(y == 1) = Inf;
    p = y;
    q = 1 - p;
  elseif (strcmpi (tail, "upper"))
    x(a == 1) = - log (y(a == 1));
    x(y == 0) = Inf;
    x(y == 1) = 0;
    q = y;
    p = 1 - q;
  else
    error ("gammaincinv: invalid value for TAIL");
  endif

  todo = (a != 1) & (y != 0) & (y != 1);

  ## Case 1: p small.

  i_flag_1 = todo & (p < ((0.2 * (1 + a)) .^ a) ./ gamma (1 + a));

  if (any (i_flag_1))
    aa = a(i_flag_1);
    pp = p(i_flag_1);

    ## Initial guess.

    r = (pp .* gamma (1 + aa)) .^ (1 ./ aa);

    c2 = 1 ./ (aa + 1);
    c3 = (3  * aa + 5) ./ (2 * (aa + 1) .^2 .* (aa + 2));
    c4 = (8 * aa .^ 2 + 33 * aa + 31) ./ (3 * (aa + 1) .^ 3 .* (aa + 2) .* ...
         (aa + 3));
    c5 = (125 * aa .^ 4 + 1179 * aa .^ 3 + 3971 * aa.^2 + 5661 * aa + 2888) ...
         ./ (24 * (1 + aa) .^4 .* (aa + 2) .^ 2 .* (aa + 3) .* (aa + 4));

    ## FIXME: Would polyval() be better here for more accuracy?
    x0 = r + c2 .* r .^ 2 + c3 .* r .^ 3 + c4 .* r .^4 + c5 .* r .^ 5;

    ## For this case we invert the lower version.

    F = @(p, a, x) p - gammainc (x, a, "lower");
    JF = @(a, x) - exp (- gammaln (a) - x + (a - 1) .* log (x));
    x(i_flag_1) = newton_method (F, JF, pp, aa, x0, tol, maxit);
  endif

  todo(i_flag_1) = false;

  ## Case 2: q small.

  i_flag_2 = (q < exp (- 0.5 * a) ./ gamma (1 + a)) & (a > 0) & (a < 10);
  i_flag_2 &= todo;

  if (any (i_flag_2))
    aa = a(i_flag_2);
    qq = q(i_flag_2);

    ## Initial guess.

    x0 = (-log (qq) - gammaln (aa));

    ## For this case, we invert the upper version.

    F = @(q, a, x) q - gammainc (x, a, "upper");
    JF = @(a, x) exp (- gammaln (a) - x) .* x .^ (a - 1);
    x(i_flag_2) = newton_method (F, JF, qq, aa, x0, tol, maxit);
  endif

  todo(i_flag_2) = false;

  ## Case 3: a small.

  i_flag_3 = todo & ((a > 0) & (a < 1));

  if (any (i_flag_3))
    aa = a(i_flag_3);
    pp = p(i_flag_3);

    ## Initial guess

    xl = (pp .* gamma (aa + 1)) .^ (1 ./ aa);
    x0 = xl;

    ## For this case, we invert the lower version.

    F = @(p, a, x) p - gammainc (x, a, "lower");
    JF = @(a, x) - exp (-gammaln (a) - x) .* x .^ (a - 1);
    x(i_flag_3) = newton_method (F, JF, pp, aa, x0, tol, maxit);
  endif

  todo(i_flag_3) = false;

  ## Case 4: a large.

  i_flag_4 = todo;

  if (any (i_flag_4))
    aa = a(i_flag_4);
    qq = q(i_flag_4);

    ## Initial guess

    d = 1 ./ (9 * aa);
    t = 1 - d + sqrt (2) * erfcinv (2 * qq) .* sqrt (d);
    x0 = aa .* (t .^ 3);

    ## For this case, we invert the upper version.

    F = @(q, a, x) q - gammainc (x, a, "upper");
    JF = @(a, x) exp (- gammaln (a) - x + (a - 1) .* log (x));
    x(i_flag_4) = newton_method (F, JF, qq, aa, x0, tol, maxit);
  endif

  ## Restore original shape
  x = reshape (x, orig_sz);

endfunction

## subfunction: Newton's Method
function x = newton_method (F, JF, y, a, x0, tol, maxit);

  l = numel (y);
  res = -F (y, a, x0) ./ JF (a, x0);
  todo = (abs (res) >= tol * abs (x0));
  x = x0;
  it = 0;
  while (any (todo) && (it++ < maxit))
    x(todo) += res(todo);
    res(todo) = -F (y(todo), a(todo), x(todo)) ./ JF (a(todo), x(todo));
    todo = (abs (res) >= tol * abs (x));
  endwhile
  x += res;

endfunction


%!test
%! x = [1e-10, 1e-09, 1e-08, 1e-07];
%! a = [2, 3, 4];
%! [x, a] = ndgrid (x, a);
%! xx = gammainc (gammaincinv (x, a), a);
%! assert (xx, x, -3e-14);

%!test
%! x = [1e-10, 1e-09, 1e-08, 1e-07];
%! a = [2, 3, 4];
%! [x, a] = ndgrid (x, a);
%! xx = gammainc (gammaincinv (x, a, "upper"), a, "upper");
%! assert (xx, x, -3e-14);

%!test
%! x = linspace (0, 1)';
%! a = [linspace(0.1, 1, 10), 2:5];
%! [x, a] = ndgrid (x, a);
%! xx = gammainc (gammaincinv (x, a), a);
%! assert (xx, x, -1e-13);

%!test
%! x = linspace (0, 1)';
%! a = [linspace(0.1, 1, 10), 2:5];
%! [x, a] = ndgrid (x, a);
%! xx = gammainc (gammaincinv (x, a, "upper"), a, "upper");
%! assert (xx, x, -1e-13);

%!test <*56453>
%! assert (gammaincinv (1e-15, 1) * 2, 2e-15, -1e-15);
%! assert (gammaincinv (1e-16, 1) * 2, 2e-16, -1e-15);

## Test the conservation of the input class
%!assert (class (gammaincinv (0.5, 1)), "double")
%!assert (class (gammaincinv (single (0.5), 1)), "single")
%!assert (class (gammaincinv (0.5, single (1))), "single")
%!assert (class (gammaincinv (int8 (0), 1)), "double")
%!assert (class (gammaincinv (0.5, int8 (1))), "double")
%!assert (class (gammaincinv (int8 (0), single (1))), "single")
%!assert (class (gammaincinv (single (0.5), int8 (1))), "single")

## Test input validation
%!error <Invalid call> gammaincinv ()
%!error <Invalid call> gammaincinv (1)
%!error <must be of common size or scalars>
%! gammaincinv (ones (2,2), ones (1,2), 1);
%!error <all inputs must be real> gammaincinv (0.5i, 1)
%!error <all inputs must be real> gammaincinv (0, 1i)
%!error <Y must be in the range \[0, 1\]> gammaincinv (-0.1,1)
%!error <Y must be in the range \[0, 1\]> gammaincinv (1.1,1)
%!error <Y must be in the range \[0, 1\]>
%! y = ones (1, 1, 2);
%! y(1,1,2) = -1;
%! gammaincinv (y,1);
%!error <A must be strictly positive> gammaincinv (0.5, 0)
%!error <A must be strictly positive>
%! a = ones (1, 1, 2);
%! a(1,1,2) = 0;
%! gammaincinv (1,a,1);
%!error <invalid value for TAIL> gammaincinv (1,2, "foobar")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isprime (@var{x})
## Return a logical array which is true where the elements of @var{x} are prime
## numbers and false where they are not.
##
## A prime number is conventionally defined as a positive integer greater than
## 1 (e.g., 2, 3, @dots{}) which is divisible only by itself and 1.  Octave
## extends this definition to include both negative integers and complex
## values.  A negative integer is prime if its positive counterpart is prime.
## This is equivalent to @code{isprime (abs (x))}.
##
## If @code{class (@var{x})} is complex, then primality is tested in the domain
## of Gaussian integers (@url{https://en.wikipedia.org/wiki/Gaussian_integer}).
## Some non-complex integers are prime in the ordinary sense, but not in the
## domain of Gaussian integers.  For example, @math{5 = (1+2i)*(1-2i)} shows
## that 5 is not prime because it has a factor other than itself and 1.
## Exercise caution when testing complex and real values together in the same
## matrix.
##
## Examples:
##
## @example
## @group
## isprime (1:6)
##   @result{}  0  1  1  0  1  0
## @end group
## @end example
##
## @example
## @group
## isprime ([i, 2, 3, 5])
##   @result{}  0  0  1  0
## @end group
## @end example
##
## Programming Note: @code{isprime} is suitable for all @var{x}
## in the range abs(@var{x})
## @tex
## $ < 2^{64}$.
## @end tex
## @ifnottex
##  < 2^64.
## @end ifnottex
##
## Compatibility Note: @sc{matlab} does not extend the definition of prime
## numbers and will produce an error if given negative or complex inputs.
## @seealso{primes, factor, gcd, lcm}
## @end deftypefn

function t = isprime (x)

  if (nargin < 1)
    print_usage ();
  elseif (any (fix (x) != x))
    error ("isprime: X contains non-integer entries");
  endif

  if (isempty (x))
    t = x;
    return;
  endif

  if (iscomplex (x))
    t = isgaussianprime (x);
    return;
  endif

  ## Code strategy is to quickly compare entries in x with small primes
  ## using lookup(), then do direct division on larger numbers up to
  ## a threshold, then call Miller-Rabin for numbers over the threshold.

  x = abs (x);  # handle negative entries

  ## Generate prime table of suitable length up to maxp.
  ## The value of maxp needs to be at least 37,
  ## because of the method used by __isprimelarge__ below.
  maxp = 37;
  pr = [2 3 5 7 11 13 17 19 23 29 31 37];
  t = lookup (pr, x, "b");  # quick search for table matches.

  THRESHOLD = 195e8;
  ## FIXME: THRESHOLD is the input value at which Miller-Rabin
  ## becomes more efficient than direct division. For smaller numbers,
  ## use direct division. For larger numbers, use Miller-Rabin.
  ##
  ## From numerical experiments in Jun 2022, this was observed:
  ##    THRESHOLD       Division       Miller-Rabin
  ##         29e9       29.8196s       26.2484s       (previous value)
  ##         20e9       26.7445s       26.0161s
  ##         10e9       20.9330s       25.3247s
  ##         19e9       26.5397s       26.8987s
  ##        195e8       26.5735s       26.4749s
  ## which is close enough, so new threshold = 195e8.
  ##
  ## The test code was this:
  ##   n = THRESHOLD - (1:1e7); tic; isprime(n); toc
  ##   n = THRESHOLD + (1:1e7); tic; isprime(n); toc
  ##
  ## Two notes for future programmers:
  ##
  ## 1. Test and tune THRESHOLD periodically. Miller-Rabin is only CPU-limited,
  ##    while factorization by division is very memory-intensive. This is
  ##    plainly noticeable from the loudness of the computer fans when running
  ##    the division technique! CPU speed and RAM speed scale differently over
  ##    time, so test and tune THRESHOLD periodically.
  ##
  ## 2. If you make improvements elsewhere in the code that favor one over
  ##    the other (not symmetric), you should also retune THRESHOLD afterwards.
  ##    If the Miller-Rabin part is sped up, the optimum THRESHOLD will
  ##    decrease, and if factorization is sped up, it will increase.
  ##

  ## Process large entries that are still suitable for direct division
  m = x (x > maxp & x <= THRESHOLD);
  if ( ! isempty (m))
    ## Start by dividing through by the small primes until the remaining list
    ## of entries is small (and most likely prime themselves).
    pr2 = primes (sqrt (max (m)));
    t |= lookup (pr2, x, "b");
    for p = pr2
      m = m(rem (m, p) != 0);
      if (numel (m) < numel (pr) / 10)
        break;
      endif
    endfor

    ## Check the remaining list of possible primes against the remaining
    ## prime factors which were not tested in the for loop.
    ## This is just an optimization to use arrayfun over for loop.
    pr2 = pr2 (pr2 > p);
    mm = arrayfun (@(x) all (rem (x, pr2)), m);
    m = m(mm);

    ## Add any remaining entries, which are truly prime, to the results.
    if ( ! isempty (m))
      t |= lookup (sort (m), x, "b");
    endif
  endif

  ## Process remaining entries (everything above THRESHOLD) with Miller-Rabin
  ii = (x(:)' > THRESHOLD);
  t(ii) = __isprimelarge__ (x(ii));

endfunction

function t = isgaussianprime (z)

  ## Assume prime unless proven otherwise
  t = true (size (z));

  x = real (z);
  y = imag (z);

  ## If purely real or purely imaginary, ordinary prime test for
  ## that complex part if that part is 3 mod 4.
  xidx = y==0 & mod (x, 4) == 3;
  yidx = x==0 & mod (y, 4) == 3;

  t(xidx) &= isprime (x(xidx));
  t(yidx) &= isprime (y(yidx));

  ## Otherwise, prime if x^2 + y^2 is prime
  zidx = ! (xidx | yidx);          # Skip entries that were already evaluated
  zabs = x(zidx).^2 + y(zidx).^2;
  t(zidx) &= isprime (zabs);

endfunction


%!assert (isprime (3), true)
%!assert (isprime (4), false)
%!assert (isprime (uint64 (18446744073709551557)), true)
%!assert (isprime (5i), false)
%!assert (isprime (7i), true)
%!assert (isprime ([1+2i, (2+3i)*(-1+2i)]), [true, false])
%!assert (isprime (-2), true)
%!assert (isprime (complex (-2)), false)
%!assert (isprime (2i), false)
%!assert (isprime ([i, 2, 3, 5]), [false, false, true, false])
%!assert (isprime (0), false)
%!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]))

## Test input validation
%!error <Invalid call> isprime ()
%!error <X contains non-integer entries> isprime (0.5i)
%!error <X contains non-integer entries> isprime (0.5)
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} lcm (@var{x}, @var{y})
## @deftypefnx {} {} lcm (@var{x}, @var{y}, @dots{})
## Compute the least common multiple of @var{x} and @var{y}, or of the list of
## all arguments.
##
## All elements must be numeric and of the same size or scalar.
## @seealso{factor, gcd, isprime}
## @end deftypefn

function l = lcm (varargin)

  if (nargin < 2)
    print_usage ();
  endif

  if (common_size (varargin{:}) != 0)
    error ("lcm: all args must be the same size or scalar");
  elseif (! all (cellfun ("isnumeric", varargin)))
    error ("lcm: all arguments must be numeric");
  endif

  l = varargin{1};
  for i = 2:nargin
    x = varargin{i};
    msk = (l == 0 & x == 0);
    l .*= x ./ gcd (l, x);
    l(msk) = 0;
  endfor

endfunction


%!assert (lcm (3, 5, 7, 15), 105)

## Test input validation
%!error <Invalid call> lcm ()
%!error <Invalid call> lcm (1)
%!error <same size or scalar> lcm ([1 2], [1 2 3])
%!error <arguments must be numeric> lcm ([1 2], {1 2})
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{l} =} legendre (@var{n}, @var{x})
## @deftypefnx {} {@var{l} =} legendre (@var{n}, @var{x}, @var{normalization})
## Compute the associated Legendre function of degree @var{n} and order
## @var{m} = 0 @dots{} @var{n}.
##
## The value @var{n} must be a real non-negative integer.
##
## @var{x} is a vector with real-valued elements in the range [-1, 1].
##
## The optional argument @var{normalization} may be one of @qcode{"unnorm"},
## @qcode{"sch"}, or @qcode{"norm"}.  The default if no normalization is given
## is @qcode{"unnorm"}.
##
## When the optional argument @var{normalization} is @qcode{"unnorm"}, compute
## the associated Legendre function of degree @var{n} and order @var{m} and
## return all values for @var{m} = 0 @dots{} @var{n}.  The return value has one
## dimension more than @var{x}.
##
## The associated Legendre function of degree @var{n} and order @var{m}:
##
## @tex
## $$
## P^m_n(x) = (-1)^m (1-x^2)^{m/2}{d^m\over {dx^m}}P_n (x)
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##  m         m      2  m/2   d^m
## P(x) = (-1) * (1-x  )    * ----  P(x)
##  n                         dx^m   n
## @end group
## @end example
##
## @end ifnottex
##
## @noindent
## with Legendre polynomial of degree @var{n}:
##
## @tex
## $$
## P(x) = {1\over{2^n n!}}\biggl({d^n\over{dx^n}}(x^2 - 1)^n\biggr)
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##           1    d^n   2    n
## P(x) = ------ [----(x - 1) ]
##  n     2^n n!  dx^n
## @end group
## @end example
##
## @end ifnottex
##
## @noindent
## @code{legendre (3, [-1.0, -0.9, -0.8])} returns the matrix:
##
## @example
## @group
##  x  |   -1.0   |   -0.9   |   -0.8
## ------------------------------------
## m=0 | -1.00000 | -0.47250 | -0.08000
## m=1 |  0.00000 | -1.99420 | -1.98000
## m=2 |  0.00000 | -2.56500 | -4.32000
## m=3 |  0.00000 | -1.24229 | -3.24000
## @end group
## @end example
##
## When the optional argument @var{normalization} is @qcode{"sch"}, compute
## the Schmidt semi-normalized associated Legendre function.  The Schmidt
## semi-normalized associated Legendre function is related to the unnormalized
## Legendre functions by the following:
##
## For Legendre functions of degree @var{n} and order 0:
##
## @tex
## $$
## SP^0_n (x) = P^0_n (x)
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##   0      0
## SP(x) = P(x)
##   n      n
## @end group
## @end example
##
## @end ifnottex
##
## For Legendre functions of degree n and order m:
##
## @tex
## $$
## SP^m_n (x) = P^m_n (x)(-1)^m\biggl({2(n-m)!\over{(n+m)!}}\biggl)^{0.5}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##   m      m         m    2(n-m)! 0.5
## SP(x) = P(x) * (-1)  * [-------]
##   n      n              (n+m)!
## @end group
## @end example
##
## @end ifnottex
##
## When the optional argument @var{normalization} is @qcode{"norm"}, compute
## the fully normalized associated Legendre function.  The fully normalized
## associated Legendre function is related to the unnormalized associated
## Legendre functions by the following:
##
## For Legendre functions of degree @var{n} and order @var{m}
##
## @tex
## $$
## NP^m_n (x) = P^m_n (x)(-1)^m\biggl({(n+0.5)(n-m)!\over{(n+m)!}}\biggl)^{0.5}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##   m      m         m    (n+0.5)(n-m)! 0.5
## NP(x) = P(x) * (-1)  * [-------------]
##   n      n                  (n+m)!
## @end group
## @end example
##
## @end ifnottex
## @end deftypefn

function retval = legendre (n, x, normalization)

  persistent warned_overflow = false;

  if (nargin < 2)
    print_usage ();
  endif

  if (! isreal (n) || ! isscalar (n) || n < 0 || n != fix (n))
    error ("legendre: N must be a real non-negative integer");
  elseif (! isreal (x) || any (x(:) < -1 | x(:) > 1))
    error ("legendre: X must be real-valued vector in the range -1 <= X <= 1");
  endif

  if (nargin == 3)
    normalization = lower (normalization);
  else
    normalization = "unnorm";
  endif

  unnorm = false;
  switch (normalization)
    case "unnorm"
      scale = 1;
      unnorm = true;
    case "norm"
      scale = sqrt (n+0.5);
    case "sch"
      scale = sqrt (2);
    otherwise
      error ('legendre: NORMALIZATION option must be "unnorm", "norm", or "sch"');
  endswitch

  scale *= ones (size (x));

  ## Based on the recurrence relation below
  ##            m                 m              m
  ## (n-m+1) * P (x) = (2*n+1)*x*P (x)  - (n+m)*P (x)
  ##            n+1               n              n-1
  ## https://en.wikipedia.org/wiki/Associated_Legendre_polynomials

  overflow = false;
  retval = zeros ([n+1, size(x)]);
  for m = 1:n
    lpm1 = scale;
    lpm2 = (2*m-1) .* x .* scale;
    lpm3 = lpm2;
    for k = m+1:n
      lpm3a = (2*k-1) .* x .* lpm2;
      lpm3b = (k+m-2) .* lpm1;
      lpm3 = (lpm3a - lpm3b) / (k-m+1);
      lpm1 = lpm2;
      lpm2 = lpm3;
      if (! warned_overflow)
        if (   any (abs (lpm3a) > realmax)
            || any (abs (lpm3b) > realmax)
            || any (abs (lpm3)  > realmax))
          overflow = true;
        endif
      endif
    endfor
    retval(m,:) = lpm3(:);
    if (unnorm)
      scale *= -(2*m-1);
    else  # normalization = "sch" or "norm"
      scale *= (2*m-1) / sqrt ((n-m+1)*(n+m));
    endif
    scale .*= sqrt (1-x.^2);
  endfor

  retval(n+1,:) = scale(:);

  if (isvector (x))
    ## vector case is special
    retval = reshape (retval, n + 1, length (x));
  endif

  if (strcmp (normalization, "sch"))
    retval(1,:) ./= sqrt (2);
  endif

  if (overflow && ! warned_overflow)
    warning ("legendre: overflow - results may be unstable for high orders");
    warned_overflow = true;
  endif

endfunction


%!test
%! result = legendre (3, [-1.0 -0.9 -0.8]);
%! expected = [
%!    -1.00000  -0.47250  -0.08000
%!     0.00000  -1.99420  -1.98000
%!     0.00000  -2.56500  -4.32000
%!     0.00000  -1.24229  -3.24000
%! ];
%! assert (result, expected, 1e-5);

%!test
%! result = legendre (3, [-1.0 -0.9 -0.8], "sch");
%! expected = [
%!    -1.00000  -0.47250  -0.08000
%!     0.00000   0.81413   0.80833
%!    -0.00000  -0.33114  -0.55771
%!     0.00000   0.06547   0.17076
%! ];
%! assert (result, expected, 1e-5);

%!test
%! result = legendre (3, [-1.0 -0.9 -0.8], "norm");
%! expected = [
%!    -1.87083  -0.88397  -0.14967
%!     0.00000   1.07699   1.06932
%!    -0.00000  -0.43806  -0.73778
%!     0.00000   0.08661   0.22590
%! ];
%! assert (result, expected, 1e-5);

%!test
%! result = legendre (151, 0);
%! ## Don't compare to "-Inf" since it would fail on 64 bit systems.
%! assert (result(end) < -1.7976e308 && all (isfinite (result(1:end-1))));

%!test
%! result = legendre (150, 0);
%! ## This agrees with Matlab's result.
%! assert (result(end), 3.7532741115719e+306, 0.0000000000001e+306);

%!test
%! result = legendre (0, 0:0.1:1);
%! assert (result, full (ones (1,11)));

%!test
%! ## Test matrix input
%! result = legendre (3, [-1,0,1;1,0,-1]);
%! expected(:,:,1) = [-1,1;0,0;0,0;0,0];
%! expected(:,:,2) = [0,0;1.5,1.5;0,0;-15,-15];
%! expected(:,:,3) = [1,-1;0,0;0,0;0,0];
%! assert (result, expected);

%!test
%! result = legendre (3, [-1,0,1;1,0,-1]');
%! expected(:,:,1) = [-1,0,1;0,1.5,0;0,0,0;0,-15,0];
%! expected(:,:,2) = [1,0,-1;0,1.5,0;0,0,0;0,-15,0];
%! assert (result, expected);

## Test input validation
%!error <Invalid call> legendre ()
%!error <Invalid call> legendre (1)
%!error <must be a real non-negative integer> legendre (i, [-1, 0, 1])
%!error <must be a real non-negative integer> legendre ([1, 2], [-1, 0, 1])
%!error <must be a real non-negative integer> legendre (-1, [-1, 0, 1])
%!error <must be a real non-negative integer> legendre (1.1, [-1, 0, 1])
%!error <must be real-valued vector> legendre (1, [-1+i, 0, 1])
%!error <in the range -1 .= X .= 1> legendre (1, [-2, 0, 1])
%!error <in the range -1 .= X .= 1> legendre (1, [-1, 0, 2])
%!error <NORMALIZATION option must be> legendre (1, [-1, 0, 1], "badnorm")
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} nchoosek (@var{n}, @var{k})
## @deftypefnx {} {@var{c} =} nchoosek (@var{set}, @var{k})
##
## Compute the binomial coefficient of @var{n} or list all possible
## combinations of a @var{set} of items.
##
## If @var{n} is a scalar then calculate the binomial coefficient
## of @var{n} and @var{k} which is defined as
## @tex
## $$
##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
##                = {n! \over k! (n-k)!}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##  /   \
##  | n |    n (n-1) (n-2) @dots{} (n-k+1)       n!
##  |   |  = ------------------------- =  ---------
##  | k |               k!                k! (n-k)!
##  \   /
## @end group
## @end example
##
## @end ifnottex
## @noindent
## This is the number of combinations of @var{n} items taken in groups of
## size @var{k}.
##
## If the first argument is a vector, @var{set}, then generate all
## combinations of the elements of @var{set}, taken @var{k} at a time, with
## one row per combination.  The result @var{c} has @var{k} columns and
## @w{@code{nchoosek (length (@var{set}), @var{k})}} rows.
##
## For example:
##
## How many ways can three items be grouped into pairs?
##
## @example
## @group
## nchoosek (3, 2)
##    @result{} 3
## @end group
## @end example
##
## What are the possible pairs?
##
## @example
## @group
## nchoosek (1:3, 2)
##    @result{}  1   2
##        1   3
##        2   3
## @end group
## @end example
##
## Programming Note: When calculating the binomial coefficient @code{nchoosek}
## works only for non-negative, integer arguments.  Use @code{bincoeff} for
## non-integer and negative scalar arguments, or for computing many binomial
## coefficients at once with vector inputs for @var{n} or @var{k}.
##
## @seealso{bincoeff, perms}
## @end deftypefn

function C = nchoosek (v, k)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isvector (v))
    error ("nchoosek: first argument must be a scalar or a vector");
  endif
  if (! (isreal (k) && isscalar (k) && k >= 0 && k == fix (k)))
    error ("nchoosek: K must be an integer >= 0");
  endif
  if (isscalar (v))
    if (isnumeric (v) && (iscomplex (v) || v < k || v < 0 || v != fix (v)))
      error ("nchoosek: N must be a non-negative integer >= K");
    endif
  endif

  n = numel (v);

  if (n == 1 && isnumeric (v))
    ## Improve precision over direct call to prod().
    ## Steps: 1) Make a list of integers for numerator and denominator,
    ## 2) filter out common factors, 3) multiply what remains.
    k = min (k, v-k);

    if (isinteger (v) || isinteger (k))
      numer = (v-k+1):v;
      denom = (1:k);
    else
      ## For a ~25% performance boost, multiply values pairwise so there
      ## are fewer elements in do/until loop which is the slow part.
      ## Since Odd*Even is guaranteed to be Even, also take out a factor
      ## of 2 from numerator and denominator.
      if (rem (k, 2))  # k is odd
        numer = [((v-k+1:v-(k+1)/2) .* (v-1:-1:v-(k-1)/2)) / 2, v];
        denom = [((1:(k-1)/2) .* (k-1:-1:(k+1)/2)) / 2, k];
      else             # k is even
        numer = ((v-k+1:v-k/2) .* (v:-1:v-k/2+1)) / 2;
        denom = ((1:k/2) .* (k:-1:k/2+1)) / 2;
      endif
    endif

    ## Remove common factors from numerator and denominator
    do
      for i = numel (denom):-1:1
        factors = gcd (denom(i), numer);
        [f, j] = max (factors);
        denom(i) /= f;
        numer(j) /= f;
      endfor
      denom = denom(denom > 1);
      numer = numer(numer > 1);
    until (isempty (denom))

    C = prod (numer, "native");
    if (isfloat (C) && C > flintmax (C))
      warning ("Octave:nchoosek:large-output-float", ...
               "nchoosek: possible loss of precision");
    elseif (isinteger (C) && C == intmax (C))
      warning ("Octave:nchoosek:large-output-integer", ...
               "nchoosek: result may have saturated at intmax");
    endif
  elseif (k == 0)
    C = v(zeros (1, 0));  # Return 1x0 object for Matlab compatibility
  elseif (k == 1)
    C = v(:);
  elseif (k == n)
    C = v(:).';
  elseif (k > n)
    C = v(zeros (0, k));  # return 0xk object for Matlab compatibility
  elseif (k == 2)
    ## Can do it without transpose.
    x = repelem (v(1:n-1), [n-1:-1:1]).';
    y = cat (1, cellslices (v(:), 2:n, n*ones (1, n-1)){:});
    C = [x, y];
  elseif (k < n)
    v = v(:).';
    C = v(k:n);
    l = 1:n-k+1;
    for j = 2:k
      c = columns (C);
      cA = cellslices (C, l, c*ones (1, n-k+1), 2);
      l = c-l+1;
      b = repelem (v(k-j+1:n-j+1), l);
      C = [b; cA{:}];
      l = cumsum (l);
      l = [1, 1 + l(1:n-k)];
    endfor
    C = C.';
  endif

endfunction


%!assert (nchoosek (80, 10), bincoeff (80, 10))
%!assert (nchoosek (1:5, 3),
%!        [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])

## Test basic behavior for various input types
%!assert (nchoosek ('a':'b', 2), 'ab')
%!assert (nchoosek ("a":"b", 2), "ab")
%!assert (nchoosek ({1,2}, 2), {1,2})
%!test
%! s(1).a = 1;
%! s(2).a = 2;
%! assert (nchoosek (s, 1), s(:));
%! assert (nchoosek (s, 2), s);

## Verify Matlab compatibility of return sizes & types
%!test
%! x = nchoosek (1:2, 0);
%! assert (size (x), [1, 0]);
%! assert (isa (x, "double"));
%! x = nchoosek (1:2, 3);
%! assert (size (x), [0, 3]);
%! assert (isa (x, "double"));

%!test
%! x = nchoosek (single (1:2), 0);
%! assert (size (x), [1, 0]);
%! assert (isa (x, "single"));
%! x = nchoosek (single (1:2), 3);
%! assert (size (x), [0, 3]);
%! assert (isa (x, "single"));

%!test
%! x = nchoosek ('a':'b', 0);
%! assert (size (x), [1, 0]);
%! assert (is_sq_string (x));
%! x = nchoosek ('a':'b', 3);
%! assert (size (x), [0, 3]);
%! assert (is_sq_string (x));

%!test
%! x = nchoosek ("a":"b", 0);
%! assert (size (x), [1, 0]);
%! assert (is_dq_string (x));
%! x = nchoosek ("a":"b", 3);
%! assert (size (x), [0, 3]);
%! assert (is_dq_string (x));

%!test
%! x = nchoosek (uint8(1):uint8(2), 0);
%! assert (size (x), [1, 0]);
%! assert (isa (x, "uint8"));
%! x = nchoosek (uint8(1):uint8(2), 3);
%! assert (size (x), [0, 3]);
%! assert (isa (x, "uint8"));

%!test
%! x = nchoosek ({1, 2}, 0);
%! assert (size (x), [1, 0]);
%! assert (iscell (x));
%! x = nchoosek ({1, 2}, 3);
%! assert (size (x), [0, 3]);
%! assert (iscell (x));

%!test
%! s.a = [1 2 3];
%! s.b = [4 5 6];
%! x = nchoosek (s, 0);
%! assert (size (x), [1, 0]);
%! assert (isstruct (x));
%! assert (fieldnames (x), {"a"; "b"});
%! x = nchoosek (s, 3);
%! assert (size (x), [0, 3]);
%! assert (isstruct (x));
%! assert (fieldnames (x), {"a"; "b"});

%!test
%! s.a = [1 2 3];
%! s.b = [4 5 6];
%! s(2).a = 1;  # make s a struct array rather than scalar struct
%! s(3).b = 2;  # make s at least three elements for k == 2 test below
%! x = nchoosek (s, 0);
%! assert (size (x), [1, 0]);
%! assert (isstruct (x));
%! assert (fieldnames (x), {"a"; "b"});
%! x = nchoosek (s, 2);
%! assert (size (x), [3, 2]);
%! assert (isstruct (x));
%! assert (fieldnames (x), {"a"; "b"});
%! x = nchoosek (s, 4);
%! assert (size (x), [0, 4]);
%! assert (isstruct (x));
%! assert (fieldnames (x), {"a"; "b"});

%!test <61565>
%! x = nchoosek (uint8 (10), uint8 (5));
%! assert (x, uint8 (252));
%! assert (class (x), "uint8");

## Test input validation
%!error <Invalid call> nchoosek ()
%!error <Invalid call> nchoosek (1)
%!error <first argument must be a scalar or a vector> nchoosek (ones (3, 3), 1)
%!error <K must be an integer .= 0> nchoosek (100, 2i)
%!error <K must be an integer .= 0> nchoosek (100, [2 3])
%!error <K must be an integer .= 0> nchoosek (100, -45)
%!error <K must be an integer .= 0> nchoosek (100, 45.5)
%!error <N must be a non-negative integer .= K> nchoosek (100i, 2)
%!error <N must be a non-negative integer .= K> nchoosek (100, 145)
%!error <N must be a non-negative integer .= K> nchoosek (-100, 45)
%!error <N must be a non-negative integer .= K> nchoosek (100.5, 45)
%!warning <possible loss of precision> nchoosek (100, 45);
%!warning <result .* saturated> nchoosek (uint64 (80), uint64 (40));
%!warning <result .* saturated> nchoosek (uint32 (80), uint32 (40));
%!warning <result .* saturated> nchoosek (uint16 (80), uint16 (40));
%!warning <result .* saturated> nchoosek ( uint8 (80),  uint8 (40));
%!warning <result .* saturated> nchoosek ( int64 (80),  int64 (40));
%!warning <result .* saturated> nchoosek ( int32 (80),  int32 (40));
%!warning <result .* saturated> nchoosek ( int16 (80),  int16 (40));
%!warning <result .* saturated> nchoosek (  int8 (80),   int8 (40));
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################
##
## Original version by Paul Kienzle distributed as free software in the
## public domain.

## -*- texinfo -*-
## @deftypefn {} {} nthroot (@var{x}, @var{n})
##
## Compute the real (non-complex) @var{n}-th root of @var{x}.
##
## @var{x} must have all real entries and @var{n} must be a scalar.
## If @var{n} is an even integer and @var{x} has negative entries then
## @code{nthroot} aborts and issues an error.
##
## Example:
##
## @example
## @group
## nthroot (-1, 3)
## @result{} -1
## (-1) ^ (1 / 3)
## @result{} 0.50000 - 0.86603i
## @end group
## @end example
## @seealso{realsqrt, sqrt, cbrt}
## @end deftypefn

function y = nthroot (x, n)

  if (nargin != 2)
    print_usage ();
  endif

  if (iscomplex (x))
    error ("nthroot: X must not contain complex values");
  endif

  if (! isreal (n) || ! isscalar (n) || n == 0)
    error ("nthroot: N must be a real nonzero scalar");
  endif

  if (n == 3)
    y = cbrt (x);
  elseif (n == -3)
    y = 1 ./ cbrt (x);
  elseif (n < 0)
    y = 1 ./ nthroot (x, -n);
  else
    ## Compute using power.
    integer_n = n == fix (n);
    if (integer_n && mod (n, 2) == 1)
      y = abs (x) .^ (1/n) .* sign (x);
    elseif (any (x(:) < 0))
      error ("nthroot: N must be an odd integer if X contains negative values");
    else
      y = x .^ (1/n);
    endif

    if (integer_n && n > 0 && isfinite (n))
      if (isscalar (y) && y == 0)
        ## Don't apply correction which leads to division by zero (bug #43492)
      else
        ## FIXME: What is this correction for?
        y = ((n-1)*y + x ./ (y.^(n-1))) / n;
        y = merge (isfinite (y), y, x);
      endif
    endif
  endif

endfunction


%!assert (nthroot (-32, 5), -2)
%!assert (nthroot (81, 4), 3)
%!assert (nthroot (Inf, 4), Inf)
%!assert (nthroot (-Inf, 7), -Inf)
%!assert (nthroot (-Inf, -7), 0)

## This should not generate a division by zero warning
%!test <*43492>
%! warnmsg = lastwarn ();
%! assert (nthroot (0, 2), 0);
%! assert (lastwarn (), warnmsg);

## Test input validation
%!error <Invalid call> nthroot ()
%!error <Invalid call> nthroot (1)
%!error <X must not contain complex values> nthroot (1+j, 2)
%!error <N must be a real nonzero scalar> nthroot (1, i)
%!error <N must be a real nonzero scalar> nthroot (1, [1 2])
%!error <N must be a real nonzero scalar> nthroot (1, 0)
%!error <N must be an odd integer> nthroot (-1, 2)
########################################################################
##
## Copyright (C) 2001-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} perms (@var{v})
## Generate all permutations of vector @var{v} with one row per permutation.
##
## Results are returned in inverse lexicographic order.  The result has size
## @code{factorial (@var{n}) * @var{n}}, where @var{n} is the length of
## @var{v}.  Any repetitions are included in the output.  To generate just the
## unique permutations use @code{unique (perms (@var{v}), "rows")(end:-1:1,:)}.
##
## Example
##
## @example
## @group
## perms ([1, 2, 3])
## @result{}
##   3   2   1
##   3   1   2
##   2   3   1
##   2   1   3
##   1   3   2
##   1   2   3
## @end group
## @end example
##
## Programming Note: The maximum length of @var{v} should be less than or
## equal to 10 to limit memory consumption.
## @seealso{permute, randperm, nchoosek}
## @end deftypefn

## FIXME: In principle it should be more efficient to do indexing using uint8
## type.  However, benchmarking shows doubles are faster.  If this changes in
## a later version of Octave the index variables here can be made uint8.

function A = perms (v)

  if (nargin < 1)
    print_usage ();
  endif

  v = v(:).';
  if (isnumeric (v) || ischar (v))
    ## Order of output is only dependent on the actual values for
    ## character and numeric arrays.
    v = sort (v, "ascend");
  endif
  n = numel (v);

  if (n < 4)    # special cases for small n
    switch (n)
      case 0
        A = reshape (v, 1, 0);
      case 1
        A = v;
      case 2
        A = [v([2 1]);v];
      case 3
        A = v([3 2 1; 3 1 2; 2 3 1; 2 1 3; 1 3 2; 1 2 3]);
    endswitch
  else
    v = v(end:-1:1);
    n-= 1;

    idx = zeros (factorial (n), n);
    idx(1:6, n-2:n) = [1, 2, 3;1, 3, 2;2, 1, 3;2, 3, 1;3, 1, 2;3, 2, 1]+(n-3);
    f = 2;    # jump-start for efficiency with medium n
    for j = 3:n-1
      b = 1:n;
      f *= j;
      perm = idx(1:f, n-(j-1):n);
      idx(1:(j+1)*f, n-j) = (n-j:n)(ones (f, 1),:)(:);
      for i=0:j
        b(i+n-j) -= 1;
        idx((1:f)+i*f, n-(j-1):n) = b(perm);
      endfor
    endfor

    n += 1;
    f *= n-1;
    A = v(1)(ones (factorial (n), n));
    A(:,1) = v(ones (f, 1),:)(:);

    for i = 1:n
      b = v([1:i-1 i+1:n]);
      A((1:f)+(i-1)*f, 2:end) = b(idx);
    endfor
  endif

endfunction


%!assert (rows (perms (1:6)), factorial (6))
%!assert (perms (pi), pi)
%!assert (perms ([pi, e]), [pi, e; e, pi])
%!assert (perms ([1,2,3]), [3,2,1;3,1,2;2,3,1;2,1,3;1,3,2;1,2,3])
%!assert (perms (1:5), perms ([2 5 4 1 3]'))
%!assert (perms ("abc"), char ("cba", "cab", "bca", "bac", "acb", "abc"))
%!assert (perms ("fobar"), sortrows (unique (perms ("fobar"), "rows"), -(1:5)))
%!assert (unique (perms (1:5)(:))', 1:5)
%!assert (perms (int8 (1:4)), int8 (perms (1:4)))

%!error <Invalid call> perms ()

## Should work for any array type, such as cells and structs, and not
## only for numeric data.

%!assert <*52431> (perms ({1}), {1})
%!assert <*52431> (perms ({0.1, "foo"}), {"foo", 0.1; 0.1, "foo"})
%!assert <*52431> (perms ({"foo", 0.1}), {0.1, "foo"; "foo", 0.1})
%!assert <*52431> (perms ({"foo"; 0.1}), {0.1, "foo"; "foo", 0.1})
%!assert <*52431> (perms ({0.1; "foo"}), {"foo", 0.1; 0.1, "foo"})
%!assert <*52431> (perms ({"foo", "bar"}), {"bar", "foo"; "foo", "bar"})
%!assert <*52431> (perms ({"bar", "foo"}), {"foo", "bar"; "bar", "foo"})
%!
%!assert <*52431> (perms (struct ()), struct ())
%!assert <*52431> (perms (struct ("foo", {1, 2})),
%!                struct ("foo", {2, 1; 1, 2}))
%!assert <*52431> (perms (struct ("foo", {1, 2}, "bar", {3, 4})),
%!                struct ("foo", {2, 1; 1, 2}, "bar", {4, 3; 3, 4}))

## Also sort logical input with order dependent on the input order and
## not their values.

%!assert <*52431> (perms (logical ([1 0])), logical ([0 1;, 1 0]))
%!assert <*52431> (perms (logical ([0 1])), logical ([1 0; 0 1]))
%!assert <*52431> (perms (logical ([0 1 0])),
%!                logical ([0 1 0; 0 0 1; 1 0 0; 1 0 0; 0 0 1; 0 1 0]))
%!assert <*52431> (perms (logical ([0 1 1])),
%!                logical ([1 1 0; 1 0 1; 1 1 0; 1 0 1; 0 1 1; 0 1 1]))

%!assert <*52432> (perms ([]), reshape ([], 1, 0))
%!assert <*52432> (perms (single ([])), reshape (single ([]), 1, 0))
%!assert <*52432> (perms (int8 ([])), reshape (int8 ([]), 1, 0))
%!assert <*52432> (perms ({}), cell (1, 0))

%!test <*52432>
%! s = struct ();
%! s(1) = [];
%! assert (perms (reshape (s, 0, 0)), reshape (s, 1, 0));
%! assert (perms (reshape (s, 0, 1)), reshape (s, 1, 0));
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} pow2 (@var{x})
## @deftypefnx {} {} pow2 (@var{f}, @var{e})
## With one input argument, compute
## @tex
## $2^x$
## @end tex
## @ifnottex
## 2 .^ x
## @end ifnottex
## for each element of @var{x}.
##
## With two input arguments, return
## @tex
## $f \cdot 2^e$.
## @end tex
## @ifnottex
## f .* (2 .^ e).
## @end ifnottex
## @seealso{log2, nextpow2, power}
## @end deftypefn

function y = pow2 (f, e)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    y = 2 .^ f;
  else
    y = f .* (2 .^ e);
  endif

endfunction


%!test
%! x = [3, 0, -3];
%! v = [8, 1, .125];
%! assert (pow2 (x), v, sqrt (eps));

%!test
%! x = [3, 0, -3, 4, 0, -4, 5, 0, -5];
%! y = [-2, -2, -2, 1, 1, 1, 3, 3, 3];
%! z = x .* (2 .^ y);
%! assert (pow2 (x,y), z, sqrt (eps));

%!error <Invalid call> pow2 ()
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{p} =} primes (@var{n})
## Return all primes up to @var{n}.
##
## The output data class (double, single, uint32, etc.@:) is the same as the
## input class of @var{n}.  The algorithm used is the Sieve of Eratosthenes.
##
## Note: For a specific number @var{n} of primes, call
## @code{list_primes (@var{n})}.  Alternatively, call
## @code{primes (@var{n}*log (@var{k}*@var{n}))(1:@var{n})} where @var{k} is
## about 5 or 6.  This works because the distance from one prime to the next is
## proportional to the logarithm of the prime, on average.  On integrating,
## there are about @var{n} primes less than @code{@var{n} * log (5*@var{n})}.
##
## @seealso{list_primes, isprime}
## @end deftypefn

function p = primes (n)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isscalar (n) && isreal (n)))
    error ("primes: N must be a real scalar");
  endif
  if (ischar (n))
    n = double (n);
  endif
  if (! isfinite (n) && n != -Inf)
    error ("primes: N must be finite (not +Inf or NaN)");
  endif

  cls = class (n);     # if n is not double, store its class
  n = double (n);      # and use only double for internal use.
  # This conversion is needed for both calculation speed (twice as fast as
  # integer) and also for the accuracy of the sieve calculation when given
  # integer input, to avoid unwanted rounding in the sieve lengths.

  if (n > flintmax ())
    warning ("primes: input exceeds flintmax.  Results may be inaccurate.");
  endif

  if (n < 353)
    ## Lookup table of first 70 primes
    a = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...
         53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, ...
         109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, ...
         173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
         233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
         293, 307, 311, 313, 317, 331, 337, 347, 349];
    p = a(a <= n);
  elseif (n < 100e3)
    ## Classical Sieve algorithm
    ## Fast, but memory scales as n/2.
    len = floor ((n-1)/2);        # length of the sieve
    sieve = true (1, len);        # assume every odd number is prime
    for i = 1:(sqrt (n)-1)/2      # check up to sqrt (n)
      if (sieve(i))               # if i is prime, eliminate multiples of i
        sieve(3*i+1:2*i+1:len) = false; # do it
      endif
    endfor
    p = [2, 1+2*find(sieve)];     # primes remaining after sieve
  else
    ## Sieve algorithm optimized for large n
    ## Memory scales as n/3 or 1/6th less than classical Sieve
    lenm = floor ((n+1)/6);       # length of the 6n-1 sieve
    lenp = floor ((n-1)/6);       # length of the 6n+1 sieve
    sievem = true (1, lenm);      # assume every number of form 6n-1 is prime
    sievep = true (1, lenp);      # assume every number of form 6n+1 is prime

    for i = 1:(sqrt (n)+1)/6      # check up to sqrt (n)
      if (sievem(i))              # if i is prime, eliminate multiples of i
        sievem(7*i-1:6*i-1:lenm) = false;
        sievep(5*i-1:6*i-1:lenp) = false;
      endif                       # if i is prime, eliminate multiples of i
      if (sievep(i))
        sievep(7*i+1:6*i+1:lenp) = false;
        sievem(5*i+1:6*i+1:lenm) = false;
      endif
    endfor
    p = sort ([2, 3, 6*find(sievem)-1, 6*find(sievep)+1]);
  endif

  # cast back to the type of the input
  p = cast (p, cls);

endfunction


%!assert (size (primes (350)), [1, 70])
%!assert (primes (357)(end), 353)
%!assert (primes (uint64 (358))(end), uint64 (353))
%!assert (primes (int32 (1e6))(end), int32 (999983))
%!assert (class (primes (single (10))), "single")
%!assert (class (primes (uint8 (10))), "uint8")
%!assert (primes (-Inf), zeros (1,0))

%!error <Invalid call> primes ()
%!error <N must be a real scalar> primes (ones (2,2))
%!error <N must be a real scalar> primes (5i)
%!error <N must be finite> primes (Inf)
%!error <N must be finite> primes (NaN)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} reallog (@var{x})
## Return the real-valued natural logarithm of each element of @var{x}.
##
## If any element results in a complex return value @code{reallog} aborts and
## issues an error.
## @seealso{log, realpow, realsqrt}
## @end deftypefn

function y = reallog (x)

  if (nargin < 1)
    print_usage ();
  elseif (iscomplex (x) || any (x(:) < 0))
    error ("reallog: produced complex result");
  else
    y = log (x);
  endif

endfunction


%!assert (reallog (1:5), log (1:5))
%!test
%! x = rand (10, 10);
%! assert (reallog (x), log (x));

%!error <Invalid call> reallog ()
%!error <produced complex result> reallog (2i)
%!error <produced complex result> reallog (-1)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} realpow (@var{x}, @var{y})
## Compute the real-valued, element-by-element power operator.
##
## This is equivalent to @w{@code{@var{x} .^ @var{y}}}, except that
## @code{realpow} reports an error if any return value is complex.
## @seealso{power, reallog, realsqrt}
## @end deftypefn

function z = realpow (x, y)

  if (nargin != 2)
    print_usage ();
  endif

  z = x .^ y;
  if (iscomplex (z))
    error ("realpow: produced complex result");
  endif

endfunction


%!assert (realpow (1:10, 0.5:0.5:5), power (1:10, 0.5:0.5:5))
%!assert (realpow (1:10, 0.5:0.5:5), [1:10] .^ [0.5:0.5:5])
%!test
%! x = rand (10, 10);
%! y = randn (10, 10);
%! assert (x.^y, realpow (x,y));
%!assert <47775> (realpow (1i,2), -1)

%!error <Invalid call> realpow ()
%!error <Invalid call> realpow (1)
%!error <produced complex result> realpow (-1, 1/2)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} realsqrt (@var{x})
## Return the real-valued square root of each element of @var{x}.
##
## If any element results in a complex return value @code{realsqrt} aborts and
## issues an error.
## @seealso{sqrt, realpow, reallog}
## @end deftypefn

function y = realsqrt (x)

  if (nargin < 1)
    print_usage ();
  elseif (iscomplex (x) || any (x(:) < 0))
    error ("realsqrt: produced complex result");
  else
    y = sqrt (x);
  endif

endfunction


%!assert (realsqrt (1:5), sqrt (1:5))
%!test
%! x = rand (10, 10);
%! assert (realsqrt (x), sqrt (x));

%!error <Invalid call> realsqrt ()
%!error <produced complex result> realsqrt (-1)
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} sinint (@var{x})
## Compute the sine integral function:
## @tex
## $$
## {\rm Si} (x) = \int_0^x {\sin (t) \over t} dt
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##            x
##           /
## Si (x) =  | sin (t) / t dt
##           /
##          0
## @end group
## @end example
##
## @end ifnottex
##
## Reference:
## @nospell{M. Abramowitz and I.A. Stegun},
## @cite{Handbook of Mathematical Functions}, 1964.
##
## @seealso{cosint, expint, sin}
## @end deftypefn

function y = sinint (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isnumeric (x))
    error ("sinint: X must be numeric");
  endif

  ## Convert to floating point if necessary
  if (isinteger (x))
    x = double (x);
  endif

  ## Convert to column vector
  orig_sz = size (x);
  x = x(:);
  if (iscomplex (x))
    ## Work around reshape which narrows to real (bug #52953)
    x = complex (real (x)(:), imag (x)(:));
  else
    x = x(:);
  endif

  ## Initialize the result
  y = zeros (size (x), class (x));
  tol = eps (class (x));

  todo = true (size (x));

  ## Special values
  y(x == 0) = x(x == 0);    # correctly signed zero
  y(x == Inf) = pi / 2;
  y(x == - Inf) = - pi / 2;

  todo = ((todo) & (x != 0) & (x != Inf) & (x != - Inf));

  ## For values large in modulus we use the relation with expint

  flag_large = abs (x) > 2;
  xx = x(flag_large & todo);
  ii_neg = (real (xx) < 0);
  xx(ii_neg) *= -1;
  ii_conj = (real (xx) == 0) & (imag (xx) < 0);
  xx(ii_conj) = conj (xx(ii_conj));
  yy = -0.5i * (expint (1i * xx) - expint (-1i * xx)) + pi / 2;
  yy(ii_neg) *= -1;
  yy(ii_conj) = conj (yy(ii_conj));
  y(todo & flag_large) = yy;

  ## For values small in modulus we use the series expansion

  todo = (todo) & (! flag_large);
  xx = x(todo);
  ssum = xx;  # First term of the series expansion
  yy = ssum;
  flag_sum = true (nnz (todo), 1);
  it = 0;
  maxit = 300;
  while (any (flag_sum) && (it < maxit))
    ssum .*= - xx .^ 2 * (2 * it + 1) / ((2 * it + 3) ^ 2 * (2 * it + 2));
    yy(flag_sum) += ssum (flag_sum);
    flag_sum = (abs (ssum) >= tol);
    it++;
  endwhile

  y(todo) = yy;

  y = reshape (y, orig_sz);

endfunction


%!assert (sinint (1.1), 1.02868521867373, -5e-15)

%!test
%! x = [2, 3, pi; exp(1), 5, 6];
%! A = sinint (x);
%! B = [1.60541297680269, 1.84865252799947, 1.85193705198247e+00; ...
%!      1.82104026914757, 1.54993124494467, 1.42468755128051e+00];
%! assert (A, B, -5e-15);

## Test exceptional values
%!assert (sinint (0), 0)
%!assert (signbit (sinint (-0)))
%!assert (sinint (Inf), pi/2)
%!assert (sinint (-Inf), -pi/2)
%!assert (isnan (sinint (NaN)))

## Check single data type is preserved
%!assert (class (sinint (single (1))), "single")

## Tests against Maple
%!assert (sinint (1)  ,  0.9460830703671830149414, -2*eps)
%!assert (sinint (-1) , -0.9460830703671830149414, -2*eps)
%!assert (sinint (pi) ,  1.851937051982466170361, -3*eps)
%!assert (sinint (-pi), -1.851937051982466170361, -3*eps)
%!assert (sinint (300),  1.5708810882137495193, -2*eps)
%!assert (sinint (1e4),  1.5708915453859619157, -2*eps)
%!assert (sinint (20i),  1.2807826332028294459e7*1i, -2*eps)

%!test
%! x = (0:4)';
%! y_ex = [0
%!         0.946083070367183015
%!         1.60541297680269485
%!         1.84865252799946826
%!         1.75820313894905306];
%! assert (sinint (x), y_ex, -4*eps);

%!test
%! x = -(0:4)';
%! y_ex = - [0
%!           0.946083070367183015
%!           1.60541297680269485
%!           1.84865252799946826
%!           1.75820313894905306];
%! assert (sinint (x), y_ex, -4*eps);

%!test
%! x = 1i * (0:4).';
%! y_ex = [0
%!         1.05725087537572851*I
%!         2.50156743335497564*I
%!         4.97344047585980680*I
%!         9.81732691123303446*I];
%! assert (sinint (x), y_ex, -4*eps);

%!test
%! x = - 1i * (0:4).';
%! y_ex = - [0
%!           1.05725087537572851*I
%!           2.50156743335497564*I
%!           4.97344047585980680*I
%!           9.81732691123303446*I];
%! assert (sinint (x), y_ex, -4*eps);

%!test
%! % maple:
%! % > A := [1+2*I, -2 + 5*I, 100, 10*I, -1e-4 + 1e-6*I, -20 + I];
%! % > for a in A do evalf(Si(a)) end do;
%! x = [1+2i; -2+5i; 100; 10i; -1e-4 + 1e-6*1i; -20-1i];
%! A = [ 1.6782404878293681180 + 2.0396845546022061045*1i
%!      -18.154174221650281533 + 1.6146414539230479060*1i
%!       1.5622254668890562934
%!       1246.1144901994233444*1i
%!      -0.000099999999944461111128 + 0.99999999833338888972e-6*1i
%!      -1.5386156269726011209 - 0.053969388020443786229*1i ];
%! B = sinint (x);
%! assert (A, B, -3*eps);
%! B = sinint (single (x));
%! assert (A, B, -3*eps ("single"));

## FIXME: Need a test for bug #52953
%#!test <*52953>

## Test input validation
%!error <Invalid call> sinint ()
%!error <X must be numeric> sinint ("1")
encoding=utf-8
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{s}, @var{l}] =} bounds (@var{x})
## @deftypefnx {} {[@var{s}, @var{l}] =} bounds (@var{x}, @var{dim})
## @deftypefnx {} {[@var{s}, @var{l}] =} bounds (@dots{}, "nanflag")
## Return the smallest and largest values of the input data @var{x}.
##
## If @var{x} is a vector, the bounds are calculated over the elements of
## @var{x}.  If @var{x} is a matrix, the bounds are calculated for each column.
## For a multi-dimensional array, the bounds are calculated over the first
## non-singleton dimension.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional argument @qcode{"nanflag"} defaults to @qcode{"omitnan"} which
## does not include NaN values in the result.  If the argument
## @qcode{"includenan"} is given, and there is a NaN present, then the result
## for both smallest (@var{s}) and largest (@var{l}) elements will be NaN.
##
## The bounds are a quickly computed measure of the dispersion of a data set,
## but are less accurate than @code{iqr} if there are outlying data points.
## @seealso{range, iqr, mad, std}
## @end deftypefn

function [s, l] = bounds (x, dim, nanflag = false)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("bounds: X must be a numeric vector or matrix");
  endif

  need_dim = true;
  if (nargin == 2)
    if (ischar (dim))
      nanflag = dim;
    else
      need_dim = false;
    endif
  elseif (nargin == 3)
    need_dim = ifelse (isempty (dim), true, false);
  endif

  sz = size (x);
  if (need_dim)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("bounds: DIM must be an integer and a valid dimension");
    endif
  endif

  if (nanflag)
    nanflag = strcmp (nanflag, "includenan");
  endif

  s = min (x, [], dim);
  l = max (x, [], dim);
  if (nanflag)
    nanidx = any (isnan (x), dim);
    s(nanidx) = NaN;
    l(nanidx) = NaN;
  endif

endfunction


%!test
%! [s,l] = bounds (1:10);
%! assert ([s,l], [1, 10]);
%!test
%! [s,l] = bounds ([10:-1:1]');
%! assert ([s,l], [1, 10]);
%!test
%! [s,l] = bounds (single (1:10));
%! assert ([s,l], single ([1, 10]));
%!assert (bounds (magic (3)), [3, 1, 2])
%!assert (bounds (magic (3), 2), [1; 3; 2])
%!test
%! x = magic (3);
%! x(2,3) = NaN;
%! assert (bounds (x), [3, 1, 2]);
%! assert (bounds (x, "omitnan"), [3, 1, 2]);
%! assert (bounds (x, "includenan"), [3, 1, NaN]);
%! assert (bounds (x, 2), [1; 3; 2]);
%! assert (bounds (x, 2, "omitnan"), [1; 3; 2]);
%! assert (bounds (x, 2, "includenan"), [1; NaN; 2]);
%!test
%! x = reshape (1:27, [3, 3, 3]);
%! [s,l] = bounds (x, 3);
%! assert (s, x(:,:,1));
%! assert (l, x(:,:,3));

## Test input validation
%!error <Invalid call> bounds ()
%!error <X must be a numeric> bounds (['A'; 'B'])
%!error <DIM must be an integer> bounds (1, ones (2,2))
%!error <DIM must be an integer> bounds (1, 1.5)
%!error <DIM must be .* a valid dimension> bounds (1, 0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} center (@var{x})
## @deftypefnx {} {} center (@var{x}, @var{dim})
## Center data by subtracting its mean.
##
## If @var{x} is a vector, subtract its mean.
##
## If @var{x} is a matrix, do the above for each column.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## Programming Note: @code{center} has obvious application for normalizing
## statistical data.  It is also useful for improving the precision of general
## numerical calculations.  Whenever there is a large value that is common
## to a batch of data, the mean can be subtracted off, the calculation
## performed, and then the mean added back to obtain the final answer.
## @seealso{zscore}
## @end deftypefn

function retval = center (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("center: X must be a numeric vector or matrix");
  endif

  if (isinteger (x))
    x = double (x);
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin != 2)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("center: DIM must be an integer and a valid dimension");
    endif
  endif

  n = size (x, dim);

  if (n == 0)
    retval = x;
  else
    ## FIXME: Use bsxfun, rather than broadcasting, until broadcasting
    ##        supports diagonal and sparse matrices (Bugs #41441, #35787).
    retval = bsxfun (@minus, x, mean (x, dim));
    ## retval = x - mean (x, dim);   # automatic broadcasting
  endif

endfunction


%!assert (center ([1,2,3]), [-1,0,1])
%!assert (center (single ([1,2,3])), single ([-1,0,1]))
%!assert (center (int8 ([1,2,3])), [-1,0,1])
%!assert (center (logical ([1, 0, 0, 1])), [0.5, -0.5, -0.5, 0.5])
%!assert (center (ones (3,2,0,2)), zeros (3,2,0,2))
%!assert (center (ones (3,2,0,2, "single")), zeros (3,2,0,2, "single"))
%!assert (center (magic (3)), [3,-4,1;-2,0,2;-1,4,-3])
%!assert (center ([1 2 3; 6 5 4], 2), [-1 0 1; 1 0 -1])
%!assert (center (1, 3), 0)

## Test input validation
%!error <Invalid call> center ()
%!error <DIM must be an integer> center (1, ones (2,2))
%!error <DIM must be an integer> center (1, 1.5)
%!error <DIM must be .* a valid dimension> center (1, 0)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} corr (@var{x})
## @deftypefnx {} {} corr (@var{x}, @var{y})
## Compute matrix of correlation coefficients.
##
## If each row of @var{x} and @var{y} is an observation and each column is
## a variable, then the @w{(@var{i}, @var{j})-th} entry of
## @code{corr (@var{x}, @var{y})} is the correlation between the
## @var{i}-th variable in @var{x} and the @var{j}-th variable in @var{y}.
## @tex
## $$
## {\rm corr}(x,y) = {{\rm cov}(x,y) \over {\rm std}(x) \, {\rm std}(y)}
## $$
## @end tex
## @ifnottex
##
## @example
## corr (@var{x},@var{y}) = cov (@var{x},@var{y}) / (std (@var{x}) * std (@var{y}))
## @end example
##
## @end ifnottex
## If called with one argument, compute @code{corr (@var{x}, @var{x})},
## the correlation between the columns of @var{x}.
## @seealso{cov}
## @end deftypefn

function retval = corr (x, y = [])

  if (nargin < 1)
    print_usage ();
  endif

  ## Input validation is done by cov.m.  Don't repeat tests here

  ## Special case, scalar is always 100% correlated with itself
  if (isscalar (x))
    if (isa (x, "single"))
      retval = single (1);
    else
      retval = 1;
    endif
    return;
  endif

  ## No check for division by zero error, which happens only when
  ## there is a constant vector and should be rare.
  if (nargin == 2)
    c = cov (x, y);
    s = std (x)' * std (y);
    retval = c ./ s;
  else
    c = cov (x);
    s = sqrt (diag (c));
    retval = c ./ (s * s');
  endif

endfunction


%!test
%! x = rand (10);
%! cc1 = corr (x);
%! cc2 = corr (x, x);
%! assert (size (cc1) == [10, 10] && size (cc2) == [10, 10]);
%! assert (cc1, cc2, sqrt (eps));

%!test
%! x = [1:3]';
%! y = [3:-1:1]';
%! assert (corr (x, y), -1, 5*eps);
%! assert (corr (x, flipud (y)), 1, 5*eps);
%! assert (corr ([x, y]), [1 -1; -1 1], 5*eps);

%!test
%! x = single ([1:3]');
%! y = single ([3:-1:1]');
%! assert (corr (x, y), single (-1), 5*eps);
%! assert (corr (x, flipud (y)), single (1), 5*eps);
%! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps);

%!assert (corr (5), 1)
%!assert (corr (single (5)), single (1))

## Test input validation
%!error <Invalid call> corr ()
%!error corr ([1; 2], ["A", "B"])
%!error corr (ones (2,2,2))
%!error corr (ones (2,2), ones (2,2,2))
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{r} =} corrcoef (@var{x})
## @deftypefnx {} {@var{r} =} corrcoef (@var{x}, @var{y})
## @deftypefnx {} {@var{r} =} corrcoef (@dots{}, @var{param}, @var{value}, @dots{})
## @deftypefnx {} {[@var{r}, @var{p}] =} corrcoef (@dots{})
## @deftypefnx {} {[@var{r}, @var{p}, @var{lci}, @var{hci}] =} corrcoef (@dots{})
## Compute a matrix of correlation coefficients.
##
## @var{x} is an array where each column contains a variable and each row is
## an observation.
##
## If a second input @var{y} (of the same size as @var{x}) is given then
## calculate the correlation coefficients between @var{x} and @var{y}.
##
## @var{param}, @var{value} are optional pairs of parameters and values which
## modify the calculation.  Valid options are:
##
## @table @asis
## @item @qcode{"alpha"}
## Confidence level used for the bounds of the confidence interval, @var{lci}
## and @var{hci}.  Default is 0.05, i.e., 95% confidence interval.
##
## @item @qcode{"rows"}
## Determine processing of NaN values.  Acceptable values are @qcode{"all"},
## @qcode{"complete"}, and @qcode{"pairwise"}.  Default is @qcode{"all"}.
## With @qcode{"complete"}, only the rows without NaN values are considered.
## With @qcode{"pairwise"}, the selection of NaN-free rows is made for each
## pair of variables.
## @end table
##
## Output @var{r} is a matrix of Pearson's product moment correlation
## coefficients for each pair of variables.
##
## Output @var{p} is a matrix of pair-wise p-values testing for the null
## hypothesis of a correlation coefficient of zero.
##
## Outputs @var{lci} and @var{hci} are matrices containing, respectively, the
## lower and higher bounds of the 95% confidence interval of each correlation
## coefficient.
## @seealso{corr, cov}
## @end deftypefn

## FIXME: It would be good to add a definition of the calculation method
## for a Pearson product moment correlation to the documentation.

function [r, p, lci, hci] = corrcoef (x, varargin)

  if (nargin == 0)
    print_usage ();
  endif

  alpha = 0.05;
  rows = "all";

  if (nargin > 1)

    ## Check for matrix argument y
    if (isnumeric (varargin{1}))
      y = varargin{1};
      nx = numel (x);
      ny = numel (y);
      if (nx > 0 && ny > 0 && nx != ny)
        error ("corrcoef: X and Y must be the same size");
      endif
      x = [x(:), y(:)];
      varargin(1) = [];
    endif

    ## Check for Parameter/Value arguments
    for i = 1:2:numel (varargin)

      if (! ischar (varargin{i}))
        error ("corrcoef: parameter %d must be a string", i);
      endif
      parameter = varargin{i};
      if (i+1 > numel (varargin))
        error ('corrcoef: parameter "%s" missing value', parameter);
      endif
      value = varargin{i+1};

      switch (tolower (parameter))
        case "alpha"
          if (isnumeric (value) && isscalar (value)
              && value >= 0 && value <= 1)
            alpha = value;
          else
            error ('corrcoef: "alpha" must be a scalar between 0 and 1');
          endif

        case "rows"
          if (! ischar (value))
            error ('corrcoef: "rows" value must be a string');
          endif
          value = tolower (value);
          switch (value)
            case {"all", "complete", "pairwise"}
              rows = value;
            otherwise
              error ('corrcoef: "rows" must be "all", "complete", or "pairwise"');
          endswitch

        otherwise
          error ('corrcoef: Unknown option "%s"', parameter);

      endswitch
    endfor
  endif

  if (strcmp (rows, "complete"))
    x(any (isnan (x), 2), :) = [];
  endif

  if (isempty (x) || isscalar (x))
    r = p = lci = hci = NaN;
    return;
  endif

  ## Flags for calculation
  pairwise = strcmp (rows, "pairwise");
  calc_pval = nargout > 1;

  if (isrow (x))
    x = x(:);
  endif
  [m, n] = size (x);
  r = eye (n);
  if (calc_pval)
    p = eye (n);
  endif
  if (strcmp (rows, "pairwise"))
    mpw = m * ones (n);
  endif
  for i = 1:n
    if (! pairwise && any (isnan (x(:,i))))
      r(i,i) = NaN;
      if (nargout > 1)
        p(i,i) = NaN;
      endif
    endif
    for j = i+1:n
      xi = x(:,i);
      xj = x(:,j);
      if (pairwise)
        idx = any (isnan ([xi xj]), 2);
        xi(idx) = xj(idx) = [];
        mpw(i,j) = mpw(j,i) = m - nnz (idx);
      endif
      r(i,j) = r(j,i) = corr (xi, xj);
      if (calc_pval)
        df = m - 2;
        stat = sqrt (df) * r(i,j) / sqrt (1 - r(i,j)^2);
        cdf = tcdf (stat, df);
        p(i,j) = p(j,i) = 2 * min (cdf, 1 - cdf);
      endif
    endfor
  endfor

  if (nargout > 2)
    if (pairwise)
      m = mpw;
    endif
    CI = sqrt (2) * erfinv (1-alpha) ./ sqrt (m-3);
    lci = tanh (atanh (r) - CI);
    hci = tanh (atanh (r) + CI);
  endif

endfunction


## Compute cumulative distribution function for T distribution.
function cdf = tcdf (x, n)

  if (iscomplex (x))
    error ("tcdf: X must not be complex");
  endif

  if (isa (x, "single"))
    cdf = zeros (size (x), "single");
  else
    cdf = zeros (size (x));
  endif

  k = ! isinf (x) & (n > 0);

  xx = x .^ 2;
  x_big_abs = (xx > n);

  ## deal with the case "abs(x) big"
  kk = k & x_big_abs;
  cdf(kk) = betainc (n ./ (n + xx(kk)), n/2, 1/2) / 2;

  ## deal with the case "abs(x) small"
  kk = k & ! x_big_abs;
  cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n + xx(kk)), 1/2, n/2));

  k &= (x > 0);
  if (any (k(:)))
    cdf(k) = 1 - cdf(k);
  endif

  k = isnan (x) | !(n > 0);
  cdf(k) = NaN;

  k = (x == Inf) & (n > 0);
  cdf(k) = 1;

endfunction


%!test
%! x = rand (5);
%! r = corrcoef (x);
%! assert (size (r) == [5, 5]);

%!test
%! x = [1, 2, 3];
%! r = corrcoef (x);
%! assert (size (r) == [1, 1]);

%!assert (isnan (corrcoef ([])))
%!assert (isnan (corrcoef (NaN)))
%!assert (isnan (corrcoef (1)))

%!test
%! x = [NaN, NaN];
%! r = corrcoef (x);
%! assert (size(r) == [1, 1] && isnan (r));

%!test
%! x = rand (5);
%! [r, p] = corrcoef (x);
%! assert (size (r) == [5, 5] && size (p) == [5 5]);
%! assert (diag (r), ones (5,1), eps);

%!test
%! x = rand (5,1);
%! y = rand (5,1);
%! R1 = corrcoef (x, y);
%! R2 = corrcoef ([x, y]);
%! assert (R1, R2);
%! R3 = corrcoef (x.', y.');
%! assert (R1, R3);

%!test
%! x = [1;2;3];
%! y = [1;2;3];
%! r = corrcoef (x, y);
%! assert (r, ones (2,2));

%!test
%! x = [1;2;3];
%! y = [3;2;1];
%! r = corrcoef (x, y);
%! assert (r, [1, -1; -1, 1]);

%!test
%! x = [1;2;3];
%! y = [1;1;1];
%! r = corrcoef (x, y);
%! assert (r, [1, NaN; NaN, 1]);

%!error <Invalid call> corrcoef ()
%!error <parameter 1 must be a string> corrcoef (1, 2, 3)
%!error <parameter "alpha" missing value> corrcoef (1, 2, "alpha")
%!error <"alpha" must be a scalar> corrcoef (1,2, "alpha", "1")
%!error <"alpha" must be a scalar> corrcoef (1,2, "alpha", ones (2,2))
%!error <"alpha" must be a scalar between 0 and 1> corrcoef (1,2, "alpha", -1)
%!error <"alpha" must be a scalar between 0 and 1> corrcoef (1,2, "alpha", 2)
%!error <"rows" must be "all"...> corrcoef (1,2, "rows", "foobar")
%!error <Unknown option "foobar"> corrcoef (1,2, "foobar", 1)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} cov (@var{x})
## @deftypefnx {} {} cov (@var{x}, @var{opt})
## @deftypefnx {} {} cov (@var{x}, @var{y})
## @deftypefnx {} {} cov (@var{x}, @var{y}, @var{opt})
## Compute the covariance matrix.
##
## If each row of @var{x} and @var{y} is an observation, and each column is
## a variable, then the @w{(@var{i}, @var{j})-th} entry of
## @code{cov (@var{x}, @var{y})} is the covariance between the @var{i}-th
## variable in @var{x} and the @var{j}-th variable in @var{y}.
## @tex
## $$
## \sigma_{ij} = {1 \over N-1} \sum_{i=1}^N (x_i - \bar{x})(y_i - \bar{y})
## $$
## where $\bar{x}$ and $\bar{y}$ are the mean values of @var{x} and @var{y}.
## @end tex
## @ifnottex
##
## @example
## cov (@var{x}) = 1/(N-1) * SUM_i (@var{x}(i) - mean(@var{x})) * (@var{y}(i) - mean(@var{y}))
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} and @var{y} vectors.
##
## @end ifnottex
##
## If called with one argument, compute @code{cov (@var{x}, @var{x})}, the
## covariance between the columns of @var{x}.
##
## The argument @var{opt} determines the type of normalization to use.
## Valid values are
##
## @table @asis
## @item 0:
##   normalize with @math{N-1}, provides the best unbiased estimator of the
## covariance [default]
##
## @item 1:
##   normalize with @math{N}, this provides the second moment around the mean
## @end table
##
## Compatibility Note:: Octave always treats rows of @var{x} and @var{y}
## as multivariate random variables.
## For two inputs, however, @sc{matlab} treats @var{x} and @var{y} as two
## univariate distributions regardless of their shapes, and will calculate
## @code{cov ([@var{x}(:), @var{y}(:)])} whenever the number of elements in
## @var{x} and @var{y} are equal.  This will result in a 2x2 matrix.
## Code relying on @sc{matlab}'s definition will need to be changed when
## running in Octave.
## @seealso{corr}
## @end deftypefn

function c = cov (x, y = [], opt = 0)

  if (nargin < 1)
    print_usage ();
  endif

  if (   ! (isnumeric (x) || islogical (x))
      || ! (isnumeric (y) || islogical (y)))
    error ("cov: X and Y must be numeric matrices or vectors");
  endif

  if (ndims (x) != 2 || ndims (y) != 2)
    error ("cov: X and Y must be 2-D matrices or vectors");
  endif

  if (nargin == 2 && isscalar (y))
    opt = y;
  endif

  if (opt != 0 && opt != 1)
    error ("cov: normalization OPT must be 0 or 1");
  endif

  ## Special case, scalar has zero covariance
  if (isscalar (x))
    if (isa (x, "single"))
      c = single (0);
    else
      c = 0;
    endif
    return;
  endif

  if (isrow (x))
    x = x.';
  endif
  n = rows (x);

  if (nargin == 1 || isscalar (y))
    x = center (x, 1);
    c = x' * x / (n - 1 + opt);
  else
    if (isrow (y))
      y = y.';
    endif
    if (rows (y) != n)
      error ("cov: X and Y must have the same number of observations");
    endif
    x = center (x, 1);
    y = center (y, 1);
    c = x' * y / (n - 1 + opt);
  endif

endfunction


%!test
%! x = rand (10);
%! cx1 = cov (x);
%! cx2 = cov (x, x);
%! assert (size (cx1) == [10, 10] && size (cx2) == [10, 10]);
%! assert (cx1, cx2, 1e1*eps);

%!test
%! x = [1:3]';
%! y = [3:-1:1]';
%! assert (cov (x, y), -1, 5*eps);
%! assert (cov (x, flipud (y)), 1, 5*eps);
%! assert (cov ([x, y]), [1 -1; -1 1], 5*eps);

%!test
%! x = single ([1:3]');
%! y = single ([3:-1:1]');
%! assert (cov (x, y), single (-1), 5*eps);
%! assert (cov (x, flipud (y)), single (1), 5*eps);
%! assert (cov ([x, y]), single ([1 -1; -1 1]), 5*eps);

%!test
%! x = [1:5];
%! c = cov (x);
%! assert (isscalar (c));
%! assert (c, 2.5);

%!assert (cov (5), 0)
%!assert (cov (single (5)), single (0))

%!test
%! x = [1:5];
%! c = cov (x, 0);
%! assert (c, 2.5);
%! c = cov (x, 1);
%! assert (c, 2);

## Test input validation
%!error <Invalid call> cov ()
%!error cov ([1; 2], ["A", "B"])
%!error cov (ones (2,2,2))
%!error cov (ones (2,2), ones (2,2,2))
%!error <normalization OPT must be 0 or 1> cov (1, 3)
%!error cov (ones (2,2), ones (3,2))
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} discrete_cdf (@var{x}, @var{v}, @var{p})
## For each element of @var{x}, compute the cumulative distribution function
## (CDF) at @var{x} of a univariate discrete distribution which assumes the
## values in @var{v} with probabilities @var{p}.
## @end deftypefn

function cdf = discrete_cdf (x, v, p)

  if (nargin != 3)
    print_usage ();
  endif

  if (! isvector (v))
    error ("discrete_cdf: V must be a vector");
  elseif (any (isnan (v)))
    error ("discrete_cdf: V must not have any NaN elements");
  elseif (! isvector (p) || (length (p) != length (v)))
    error ("discrete_cdf: P must be a vector with length (V) elements");
  elseif (! (all (p >= 0) && any (p)))
    error ("discrete_cdf: P must be a nonzero, non-negative vector");
  endif

  p = p(:) / sum (p);   # Reshape and normalize probability vector

  if (isa (x, "single") || isa (v, "single") || isa (p, "single"))
    cdf = NaN (size (x), "single");
  else
    cdf = NaN (size (x));
  endif

  k = ! isnan (x);
  [vs, vi] = sort (v);
  cdf(k) = [0 ; cumsum(p(vi))](lookup (vs, x(k)) + 1);

endfunction


%!shared x,v,p,y
%! x = [-1 0.1 1.1 1.9 3];
%! v = 0.1:0.2:1.9;
%! p = 1/length (v) * ones (1, length (v));
%! y = [0 0.1 0.6 1 1];
%!assert (discrete_cdf ([x, NaN], v, p), [y, NaN], eps)

## Test class of input preserved
%!assert (discrete_cdf (single ([x, NaN]), v, p),
%!        single ([y, NaN]), 2*eps ("single"))
%!assert (discrete_cdf ([x, NaN], single (v), p),
%!        single ([y, NaN]), 2*eps ("single"))
%!assert (discrete_cdf ([x, NaN], v, single (p)),
%!        single ([y, NaN]), 2*eps ("single"))

## Test input validation
%!error <Invalid call> discrete_cdf ()
%!error <Invalid call> discrete_cdf (1)
%!error <Invalid call> discrete_cdf (1,2)
%!error discrete_cdf (1, ones (2), ones (2,1))
%!error discrete_cdf (1, [1 ; NaN], ones (2,1))
%!error discrete_cdf (1, ones (2,1), ones (1,1))
%!error discrete_cdf (1, ones (2,1), [1 -1])
%!error discrete_cdf (1, ones (2,1), [1 NaN])
%!error discrete_cdf (1, ones (2,1), [0 0])
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} discrete_inv (@var{x}, @var{v}, @var{p})
## For each element of @var{x}, compute the quantile (the inverse of the CDF)
## at @var{x} of the univariate distribution which assumes the values in
## @var{v} with probabilities @var{p}.
## @end deftypefn

function inv = discrete_inv (x, v, p)

  if (nargin != 3)
    print_usage ();
  endif

  if (! isvector (v))
    error ("discrete_inv: V must be a vector");
  elseif (! isvector (p) || (length (p) != length (v)))
    error ("discrete_inv: P must be a vector with length (V) elements");
  elseif (any (isnan (p)))
    error ("discrete_rnd: P must not have any NaN elements");
  elseif (! (all (p >= 0) && any (p)))
    error ("discrete_inv: P must be a nonzero, non-negative vector");
  endif

  if (isa (x, "single") || isa (v, "single") || isa (p, "single"))
    inv = NaN (size (x), "single");
  else
    inv = NaN (size (x));
  endif

  ## FIXME: This isn't elegant.  But cumsum and lookup together produce
  ## different results when called with a single or a double.
  if (isa (p, "single"))
    p = double (p);
  endif

  [v, idx] = sort (v);
  p = cumsum (p(idx)(:)) / sum (p);  # Reshape and normalize probability vector

  k = (x == 0);
  inv(k) = v(1);

  k = (x == 1);
  inv(k) = v(end);

  k = (x > 0) & (x < 1);
  inv(k) = v(length (p) - lookup (sort (p, "descend"), x(k)) + 1);

endfunction


%!shared x,v,p,y
%! x = [-1 0 0.1 0.5 1 2];
%! v = 0.1:0.2:1.9;
%! p = 1/length (v) * ones (1, length (v));
%! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
%!assert (discrete_inv ([x, NaN], v, p), [y, NaN], eps)

## Test class of input preserved
%!assert (discrete_inv (single ([x, NaN]), v, p),
%!        single ([y, NaN]), eps ("single"))
%!assert (discrete_inv ([x, NaN], single (v), p),
%!        single ([y, NaN]), eps ("single"))
%!assert (discrete_inv ([x, NaN], v, single (p)),
%!        single ([y, NaN]), eps ("single"))

## Test input validation
%!error <Invalid call> discrete_inv ()
%!error <Invalid call> discrete_inv (1)
%!error <Invalid call> discrete_inv (1,2)
%!error discrete_inv (1, ones (2), ones (2,1))
%!error discrete_inv (1, ones (2,1), ones (1,1))
%!error discrete_inv (1, ones (2,1), [1 NaN])
%!error discrete_inv (1, ones (2,1), [1 -1])
%!error discrete_inv (1, ones (2,1), [0  0])
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} discrete_pdf (@var{x}, @var{v}, @var{p})
## For each element of @var{x}, compute the probability density function (PDF)
## at @var{x} of a univariate discrete distribution which assumes the values
## in @var{v} with probabilities @var{p}.
## @end deftypefn

function pdf = discrete_pdf (x, v, p)

  if (nargin != 3)
    print_usage ();
  endif

  if (! isvector (v))
    error ("discrete_pdf: V must be a vector");
  elseif (any (isnan (v)))
    error ("discrete_pdf: V must not have any NaN elements");
  elseif (! isvector (p) || (length (p) != length (v)))
    error ("discrete_pdf: P must be a vector with length (V) elements");
  elseif (! (all (p >= 0) && any (p)))
    error ("discrete_pdf: P must be a nonzero, non-negative vector");
  endif

  ## Reshape and normalize probability vector.  Values not in table get 0 prob.
  p = [0 ; p(:)/sum(p)];

  if (isa (x, "single") || isa (v, "single") || isa (p, "single"))
    pdf = NaN (size (x), "single");
  else
    pdf = NaN (size (x));
  endif

  k = ! isnan (x);
  [vs, vi] = sort (v(:));
  pdf(k) = p([0 ; vi](lookup (vs, x(k), 'm') + 1) + 1);

endfunction


%!shared x,v,p,y
%! x = [-1 0.1 1.1 1.9 3];
%! v = 0.1:0.2:1.9;
%! p = 1/length (v) * ones (1, length (v));
%! y = [0 0.1 0.1 0.1 0];
%!assert (discrete_pdf ([x, NaN], v, p), [y, NaN], 5*eps)

## Test class of input preserved
%!assert (discrete_pdf (single ([x, NaN]), v, p),
%!        single ([y, NaN]), 5*eps ("single"))
%!assert (discrete_pdf ([x, NaN], single (v), p),
%!        single ([y, NaN]), 5*eps ("single"))
%!assert (discrete_pdf ([x, NaN], v, single (p)),
%!        single ([y, NaN]), 5*eps ("single"))

## Test input validation
%!error <Invalid call> discrete_pdf ()
%!error <Invalid call> discrete_pdf (1)
%!error <Invalid call> discrete_pdf (1,2)
%!error discrete_pdf (1, ones (2), ones (2,1))
%!error discrete_pdf (1, [1 ; NaN], ones (2,1))
%!error discrete_pdf (1, ones (2,1), ones (1,1))
%!error discrete_pdf (1, ones (2,1), [1 -1])
%!error discrete_pdf (1, ones (2,1), [1 NaN])
%!error discrete_pdf (1, ones (2,1), [0  0])
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} discrete_rnd (@var{v}, @var{p})
## @deftypefnx {} {} discrete_rnd (@var{v}, @var{p}, @var{r})
## @deftypefnx {} {} discrete_rnd (@var{v}, @var{p}, @var{r}, @var{c}, @dots{})
## @deftypefnx {} {} discrete_rnd (@var{v}, @var{p}, [@var{sz}])
## Return a matrix of random samples from the univariate distribution which
## assumes the values in @var{v} with probabilities @var{p}.
##
## When called with a single size argument, return a square matrix with
## the dimension specified.  When called with more than one scalar argument the
## first two arguments are taken as the number of rows and columns and any
## further arguments specify additional matrix dimensions.  The size may also
## be specified with a vector of dimensions @var{sz}.
##
## If no size arguments are given then the result matrix is the common size of
## @var{v} and @var{p}.
## @end deftypefn

function rnd = discrete_rnd (v, p, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  if (! isvector (v))
    error ("discrete_rnd: V must be a vector");
  elseif (! isvector (p) || (length (p) != length (v)))
    error ("discrete_rnd: P must be a vector with length (V) elements");
  elseif (any (isnan (p)))
    error ("discrete_rnd: P must not have any NaN elements");
  elseif (! (all (p >= 0) && any (p)))
    error ("discrete_rnd: P must be a nonzero, non-negative vector");
  endif

  if (nargin == 2)
    sz = size (v);
  elseif (nargin == 3)
    if (isscalar (varargin{1}) && varargin{1} >= 0)
      sz = [varargin{1}, varargin{1}];
    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
      sz = varargin{1};
    else
      error ("discrete_rnd: dimension vector must be row vector of non-negative integers");
    endif
  elseif (nargin > 3)
    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
      error ("discrete_rnd: dimensions must be non-negative integers");
    endif
    sz = [varargin{:}];
  endif

  rnd = v(lookup (cumsum (p(1:end-1)) / sum (p), rand (sz)) + 1);
  rnd = reshape (rnd, sz);

endfunction


%!assert (size (discrete_rnd (1:2, 1:2, 3)), [3, 3])
%!assert (size (discrete_rnd (1:2, 1:2, [4 1])), [4, 1])
%!assert (size (discrete_rnd (1:2, 1:2, 4, 1)), [4, 1])

## Test class of input preserved
%!assert (class (discrete_rnd (1:2, 1:2)), "double")
%!assert (class (discrete_rnd (single (1:2), 1:2)), "single")
## FIXME: Maybe this should work, maybe it shouldn't.
#%!assert (class (discrete_rnd (1:2, single(1:2))), "single")

## Test input validation
%!error <Invalid call> discrete_rnd ()
%!error <Invalid call> discrete_rnd (1)
%!error discrete_rnd (1:2,1:2, -1)
%!error discrete_rnd (1:2,1:2, ones (2))
%!error discrete_rnd (1:2,1:2, [2 -1 2])
%!error discrete_rnd (1:2,1:2, 1, ones (2))
%!error discrete_rnd (1:2,1:2, 1, -1)
## test v,p verification
%!error discrete_rnd (1, ones (2), ones (2,1))
%!error discrete_rnd (1, ones (2,1), ones (1,1))
%!error discrete_rnd (1, ones (2,1), [1 -1])
%!error discrete_rnd (1, ones (2,1), [1 NaN])
%!error discrete_rnd (1, ones (2,1), [0  0])
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} empirical_cdf (@var{x}, @var{data})
## For each element of @var{x}, compute the cumulative distribution function
## (CDF) at @var{x} of the empirical distribution obtained from
## the univariate sample @var{data}.
## @end deftypefn

function cdf = empirical_cdf (x, data)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isvector (data))
    error ("empirical_cdf: DATA must be a vector");
  endif

  cdf = discrete_cdf (x, data, ones (size (data)));

endfunction


%!shared x,v,y
%! x = [-1 0.1 1.1 1.9 3];
%! v = 0.1:0.2:1.9;
%! y = [0 0.1 0.6 1 1];
%!assert (empirical_cdf (x, v), y, eps)
%!assert (empirical_cdf ([x(1) NaN x(3:5)], v), [0 NaN 0.6 1 1], eps)

## Test class of input preserved
%!assert (empirical_cdf ([x, NaN], v), [y, NaN], eps)
%!assert (empirical_cdf (single ([x, NaN]), v), single ([y, NaN]), eps)
%!assert (empirical_cdf ([x, NaN], single (v)), single ([y, NaN]), eps)

## Test input validation
%!error <Invalid call> empirical_cdf ()
%!error <Invalid call> empirical_cdf (1)
%!error empirical_cdf (1, ones (2))
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} empirical_inv (@var{x}, @var{data})
## For each element of @var{x}, compute the quantile (the inverse of the CDF)
## at @var{x} of the empirical distribution obtained from the
## univariate sample @var{data}.
## @end deftypefn

function inv = empirical_inv (x, data)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isvector (data))
    error ("empirical_inv: DATA must be a vector");
  endif

  inv = discrete_inv (x, data, ones (size (data)));

endfunction


%!shared x,v,y
%! x = [-1 0 0.1 0.5 1 2];
%! v = 0.1:0.2:1.9;
%! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
%!assert (empirical_inv (x, v), y, eps)

## Test class of input preserved
%!assert (empirical_inv ([x, NaN], v), [y, NaN], eps)
%!assert (empirical_inv (single ([x, NaN]), v), single ([y, NaN]), eps)
%!assert (empirical_inv ([x, NaN], single (v)), single ([y, NaN]), eps)

## Test input validation
%!error <Invalid call> empirical_inv ()
%!error <Invalid call> empirical_inv (1)
%!error empirical_inv (1, ones (2))
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} empirical_pdf (@var{x}, @var{data})
## For each element of @var{x}, compute the probability density function (PDF)
## at @var{x} of the empirical distribution obtained from the
## univariate sample @var{data}.
## @end deftypefn

function pdf = empirical_pdf (x, data)

  if (nargin != 2)
    print_usage ();
  endif

  if (! isvector (data))
    error ("empirical_pdf: DATA must be a vector");
  endif

  uniq_vals = unique (data);
  if (numel (data) != numel (uniq_vals))
    ## Handle ties, multiple elements with same value
    p = histc (data, uniq_vals);
    data = uniq_vals;
  else
    p = ones (size (data));
  endif

  pdf = discrete_pdf (x, data, p);

endfunction


%!shared x,v,y
%! x = [-1 0.1 1.1 1.9 3];
%! v = 0.1:0.2:1.9;
%! y = [0 0.1 0.1 0.1 0];
%!assert (empirical_pdf (x, v), y)

## Test class of input preserved
%!assert (empirical_pdf (single (x), v), single (y))
%!assert (empirical_pdf (x, single (v)), single (y))

## Test distribution with ties
%!assert (empirical_pdf (2, [1 2 3 2]), 0.5)

## Test input validation
%!error <Invalid call> empirical_pdf ()
%!error <Invalid call> empirical_pdf (1)
%!error empirical_inv (1, ones (2))
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} empirical_rnd (@var{data})
## @deftypefnx {} {} empirical_rnd (@var{data}, @var{r})
## @deftypefnx {} {} empirical_rnd (@var{data}, @var{r}, @var{c}, @dots{})
## @deftypefnx {} {} empirical_rnd (@var{data}, [@var{sz}])
## Return a matrix of random samples from the empirical distribution obtained
## from the univariate sample @var{data}.
##
## When called with a single size argument, return a square matrix with
## the dimension specified.  When called with more than one scalar argument the
## first two arguments are taken as the number of rows and columns and any
## further arguments specify additional matrix dimensions.  The size may also
## be specified with a vector of dimensions @var{sz}.
##
## If no size arguments are given then the result matrix is a random ordering
## of the sample @var{data}.
## @end deftypefn

function rnd = empirical_rnd (data, varargin)

  if (nargin < 1)
    print_usage ();
  endif

  if (! isvector (data))
    error ("empirical_rnd: DATA must be a vector");
  endif

  rnd = discrete_rnd (data, ones (size (data)), varargin{:});

endfunction


%!assert (size (empirical_rnd (ones (3, 1))), [3, 1])
%!assert (size (empirical_rnd (1:2, [4 1])), [4, 1])
%!assert (size (empirical_rnd (1:2, 4, 1)), [4, 1])

## Test class of input preserved
%!assert (class (empirical_rnd (1:2, 1)), "double")
%!assert (class (empirical_rnd (single (1:2), 1)), "single")

## Test input validation
%!error <Invalid call> empirical_rnd ()
%!error empirical_rnd (ones (2), 1)
%!error empirical_rnd (ones (2), 1, 1)
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{n} =} histc (@var{x}, @var{edges})
## @deftypefnx {} {@var{n} =} histc (@var{x}, @var{edges}, @var{dim})
## @deftypefnx {} {[@var{n}, @var{idx}] =} histc (@dots{})
## Compute histogram counts.
##
## When @var{x} is a vector, the function counts the number of elements of
## @var{x} that fall in the histogram bins defined by @var{edges}.  This
## must be a vector of monotonically increasing values that define the edges
## of the histogram bins.
## @tex
## $n(k)$
## @end tex
## @ifnottex
## @code{@var{n}(k)}
## @end ifnottex
## contains the number of elements in @var{x} for which
## @tex
## $@var{edges}(k) <= @var{x} < @var{edges}(k+1)$.
## @end tex
## @ifnottex
## @code{@var{edges}(k) <= @var{x} < @var{edges}(k+1)}.
## @end ifnottex
## The final element of @var{n} contains the number of elements of @var{x}
## exactly equal to the last element of @var{edges}.
##
## When @var{x} is an @math{N}-dimensional array, the computation is carried
## out along dimension @var{dim}.  If not specified @var{dim} defaults to the
## first non-singleton dimension.
##
## When a second output argument is requested an index matrix is also returned.
## The @var{idx} matrix has the same size as @var{x}.  Each element of
## @var{idx} contains the index of the histogram bin in which the
## corresponding element of @var{x} was counted.
## @seealso{hist}
## @end deftypefn

function [n, idx] = histc (x, edges, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (! isreal (x))
    error ("histc: X argument must be real-valued, not complex");
  endif

  num_edges = numel (edges);
  if (num_edges == 0)
    warning ("histc: empty EDGES specified\n");
    n = idx = [];
    return;
  endif

  if (! isreal (edges))
    error ("histc: EDGES must be real-valued, not complex");
  else
    ## Make sure 'edges' is sorted
    edges = edges(:);
    if (! issorted (edges) || edges(1) > edges(end))
      warning ("histc: edge values not sorted on input");
      edges = sort (edges);
    endif
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("histc: DIM must be an integer and a valid dimension");
    endif
  endif

  nsz = sz;
  nsz(dim) = num_edges;

  ## the splitting point is 3 bins

  if (num_edges <= 3)

    ## This is the O(M*N) algorithm.

    ## Allocate the histogram
    n = zeros (nsz);

    ## Allocate 'idx'
    if (nargout > 1)
      idx = zeros (sz);
    endif

    ## Prepare indices
    idx1 = cell (1, dim-1);
    for k = 1:length (idx1)
      idx1{k} = 1:sz(k);
    endfor
    idx2 = cell (length (sz) - dim);
    for k = 1:length (idx2)
      idx2{k} = 1:sz(k+dim);
    endfor

    ## Compute the histograms
    for k = 1:num_edges-1
      b = (edges(k) <= x & x < edges(k+1));
      n(idx1{:}, k, idx2{:}) = sum (b, dim);
      if (nargout > 1)
        idx(b) = k;
      endif
    endfor
    b = (x == edges(end));
    n(idx1{:}, num_edges, idx2{:}) = sum (b, dim);
    if (nargout > 1)
      idx(b) = num_edges;
    endif

  else

    ## This is the O(M*log(N) + N) algorithm.

    ## Look-up indices.
    idx = lookup (edges, x);
    ## Zero invalid ones (including NaNs).  x < edges(1) are already zero.
    idx(! (x <= edges(end))) = 0;

    iidx = idx;

    ## In case of matrix input, we adjust the indices.
    if (! isvector (x))
      nl = prod (sz(1:dim-1));
      nn = sz(dim);
      nu = prod (sz(dim+1:end));
      if (nl != 1)
        iidx = (iidx-1) * nl;
        iidx += reshape (kron (ones (1, nn*nu), 1:nl), sz);
      endif
      if (nu != 1)
        ne =length (edges);
        iidx += reshape (kron (nl*ne*(0:nu-1), ones (1, nl*nn)), sz);
      endif
    endif

    ## Select valid elements.
    iidx = iidx(idx != 0);

    ## Call accumarray to sum the indexed elements.
    n = accumarray (iidx(:), 1, nsz);

  endif

endfunction


%!test
%! x = linspace (0, 10, 1001);
%! n = histc (x, 0:10);
%! assert (n, [repmat(100, 1, 10), 1]);

%!test
%! x = repmat (linspace (0, 10, 1001), [2, 1, 3]);
%! n = histc (x, 0:10, 2);
%! assert (n, repmat ([repmat(100, 1, 10), 1], [2, 1, 3]));

## Test input validation
%!error <Invalid call> histc ()
%!error <Invalid call> histc (1)
%!error histc ([1:10 1+i], 2)
%!warning <empty EDGES specified> histc (1:10, []);
%!error histc (1, 1, 3)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{Z} =} iqr (@var{x})
## @deftypefnx {} {@var{Z} =} iqr (@var{x}, @var{dim})
## @deftypefnx {} {@var{Z} =} iqr (@var{x}, @qcode{"ALL"})
## Return the interquartile range of @var{x}, defined as the distance between
## the 25th and 75th percentile values of @var{x} calculated using:
##    quantile (x, [0.25 0.75])
##
## If @var{x} is a vector, @code{iqr (@var{x})} will operate on the data in
## @var{x}.
##
## If @var{x} is a matrix, @code{iqr (@var{x})} will operate independently on
## each column in @var{x} returning a row vector @var{Z}.
##
## If @var{x} is a n-dimensional array, @code{iqr (@var{x})} will operate
## independently on the first non-singleton dimension in @var{x}, returning an
## array @var{Z} the same shape as @var{x} with the non-singleton dimenion
## reduced to 1.
##
## The optional variable @var{dim} can be used to force @code{iqr} to operate
## over the specified dimension.  @var{dim} can either be a scalar dimension or
## a vector of non-repeating dimensions over which to operate.  In either case
## @var{dim} must be positive integers.  A vector @var{dim} concatenates all
## specified dimensions for independent operation by @code{iqr}.
##
## Specifying dimension @qcode{"ALL"} will force @code{iqr} to operate
## on all elements of @var{x}, and is equivalent to @code{iqr (@var{x}(:))}.
## Similarly, specifying a vector dimension including all non-singleton
## dimensions of @var{x} is equivalent to @code{iqr (@var{x}, @qcode{"ALL"})}.
##
## If @var{x} is a scalar, or only singleton dimensions are specified for
## @var{dim}, the output will be @code{zeros (size (@var{x}))}.
##
## As a measure of dispersion, the interquartile range is less affected by
## outliers than either @code{range} or @code{std}.
##
## @seealso{bounds, mad, range, std, prctile, quantile}
## @end deftypefn

## TODO:  When Probability Distribution Objects are implemented, enable
##        handling for those object types.

function z = iqr (x, dim)

  ## input checks
  if (nargin < 1)
    print_usage ();
  elseif (nargin < 2)
    dim = [];
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("iqr: X must be a numeric vector or matrix");
  endif

  vecdim_flag = false;
  nd = ndims (x);
  sz = size (x);

  if (isempty (dim))
    ## Find first non-singleton dimension.
    if (max (sz) == 1)
      dim = 2;
    else
      dim = find ((sz > 1), 1);
    endif
  else

    if (isvector (dim) && isnumeric (dim)
        && all (dim > 0) && all (rem (dim, 1) == 0))

      if (((num_vecdims = numel (dim)) > 1) && all (diff (sort (dim))))
        ## DIM must be 1D and non repeating.

        ## Detect trivial case of DIM being all dimensions (same as "all").
        highest_dim = (max (nd, max (dim)));
        if ((num_vecdims == nd) && (highest_dim == nd))
          x = x(:);
          sz = size (x);
          dim = 1;
        else
          ## Move dimensions for operation to the front, keeping the order of
          ## the remaining dimensions.
          ## Reshape those into a single dimension.
          ## Process as normal for a dim1 iqr on X, reshape when done.

          vecdim_flag = true;  ## flag for final reshape

          if (iscolumn (dim))
            dim = dim.';
          endif

          ## Permutation vector with DIM at front
          perm = [1:highest_dim];
          perm(dim) = [];
          perm = [dim, perm];

          ## Reshape X to put dims to process at front.
          x = permute (x, perm);
          sz_x_new = size (x);

          ## Preserve trailing singletons when dim > ndims (x).
          sz_x_new = [sz_x_new, ones(1, highest_dim - numel (sz_x_new))];

          newshape = [prod(sz_x_new(1:num_vecdims)), ...
                      ones(1, (num_vecdims-1)), ...
                      sz_x_new((num_vecdims+1):end)];

          if (numel (newshape) == 1)
            newshape = [newshape, 1];
          endif

          ## Collapse dimensions to be processses into single column.
          x = reshape (x, newshape);

          ## Operate column-wise.
          dim = 1;
        endif

      elseif (! isscalar (dim))
        error ("iqr: vector DIM must contain non-repeating positive integers");
      endif

    elseif (strcmp (tolower (dim), "all"))
      ## "ALL" simplifies to collapsing all elements to single vector
      x = x(:);
      dim = 1;
      sz = size (x);

    else
      error ("iqr: DIM must be a positive integer scalar, vector, or 'all'");
    endif

  endif

  if (((dim > nd) || (sz(dim) == 1)) && all (isfinite (x)))
    ## shortcut easy zeros
    z = zeros (sz);
  elseif (iscolumn (x) && (dim == 1))
    ## detect col vector with quantile/diff dim requirement mismatch
    z = abs (diff (quantile (x, [0.25, 0.75], 1), [], 2));
  else
    z = abs (diff (quantile (x, [0.25, 0.75], dim), [], dim));
  endif

  if (vecdim_flag)
    z = ipermute (z, perm);
  endif

endfunction


%!assert (iqr (17), 0)
%!assert (iqr (17, 1), 0)
%!assert (iqr (17, 4), 0)
%!assert (iqr (1:3), 1.5)
%!assert (iqr (1:4), 2)
%!assert (iqr (1:5), 2.5)
%!assert (iqr (1:10), 5)
%!assert (iqr ((1:10).'), 5)
%!assert (iqr (1:10, 2), 5)
%!assert (iqr (1:10, 1), zeros (1, 10))
%!assert (iqr (1:10, 3), zeros (1, 10))
%!assert (iqr ([1:5; 2:6], "all"), 3)

%!test
%! x = reshape (1:6, [1 2 3]);
%! assert (iqr (x), ones (1, 1, 3));
%! assert (iqr (x, 1), zeros (1, 2, 3));
%! assert (iqr (x, 2), ones (1, 1, 3));
%! assert (iqr (x, 3), [3 3]);

## n-D arrays
%!test
%! x = magic (4); x = cat (3,x, 2*x, 3*x); x = cat (4, x, 2*x);
%! y = cat (3, 8*[1 1 1 1], 16*[1 1 1 1], 24*[1 1 1 1]);
%! assert (iqr (x), cat (4, y, 2*y));
%! assert (iqr (x, 1), cat (4, y, 2*y));
%! y = cat (3, 4*[3 1 1 3].', 8*[3 1 1 3].', 12*[3 1 1 3].');
%! assert (iqr (x, 2), cat (4, y, 2*y));
%! y = [24 3 4.5 19.5; 7.5 16.5 15 12; 13.5 10.5 9, 18; 6 21 22.5 1.5];
%! assert (iqr (x, 3), cat (4, y, 2*y));
%! y = [16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1];
%! assert (iqr (x, 4), cat (3, y, 2*y, 3*y));
%! assert (iqr (x, 5), zeros (size (x)));

## vector dimensions
%!assert (iqr (17, [1 8]), 0)
%!assert (iqr ([[1 2 5]; [2 5 6]], [1 2]), 3)
%!assert (iqr (cat (3, [1 2 5; 2 5 6], [1 2 5; 2 5 6]), [1 2]), cat(3, 3, 3))
%!assert (iqr (cat (3, [1 2 5; 2 5 6], [1 2 5; 2 5 6]), [1 2]'), cat(3, 3, 3))
%!test
%! x = magic (4); x = cat (3, x, 2*x, 3*x); x = cat (4, x, 2*x);
%! y = cat (3, 8, 16, 24);
%! assert (iqr (x, [1 2]), cat (4, y, 2*y));
%! y = [14, 18.5, 17.5 19.5];
%! assert (iqr (x, [1 3]), cat (4, y, 2*y));
%! y = [10.5 12.5 11.5 15.0000];
%! assert (iqr (x, [1 4]), cat (3, y, 2*y, 3*y));
%! assert (iqr (x, [1 5]), iqr (x, 1));
%! y = [24 13 12 25.5]';
%! assert (iqr (x, [2 3]), cat (4, y, 2*y));
%! y = [17.5, 9, 8, 18.5]';
%! assert (iqr (x, [2 4]), cat (3, y, 2*y, 3*y));
%! assert (iqr (x, [3 4]), [32 4 6 26; 10 22 20 16; 18 14 12 24; 8 28 30 2]);
%! assert (iqr (x, [3 4]), iqr (x, [4 3]));
%! assert (iqr (x, [1 2 3]), cat (4, 17.5, 35));
%! assert (iqr (x, [2 3 4]), [29.5 19.5 23 31]');
%! assert (iqr (x, [1 3 4]), [22 28 22 30.5]);
%! assert (iqr (x, [1 2 4]), cat (3, 11, 22, 33));
%! assert (iqr (x, [1 2 5]), iqr (x, [1 2]));
%! assert (iqr (x, [5 6]), zeros (size (x)));

## Inf, NaN
%!assert (iqr (Inf), NaN)
%!assert (iqr (-Inf), NaN)
%!assert (iqr (NaN), NaN)
%!assert (iqr (NaN), NaN)
%!assert (iqr ([1 2 Inf], 1), [0 0 NaN])
%!assert (iqr ([1 2 Inf], 2), Inf)
%!assert (iqr ([1 2 -Inf], 1), [0 0 NaN])
%!assert (iqr ([1 2 -Inf], 2), Inf)
%!assert (iqr ([1 2 3 NaN], 1), [0 0 0 NaN])
%!assert (iqr ([1 2 3 NaN], 2), 1.5)
%!assert (iqr ([1 NaN 2 3], 2), 1.5)
%!assert (iqr (NaN (2), 1), [NaN, NaN])
%!assert (iqr (NaN (2), 2), [NaN; NaN])
%!assert (iqr (NaN (2), 3), NaN (2))
%!assert (iqr ([[1 2 5], [2 NaN 6]], "all"), 3.5)

## input validation
%!error iqr ()
%!error iqr (1, 2, 3)
%!error <X .* numeric> iqr (['A'; 'B'])
%!error <DIM .* positive integer> iqr (1, 'A')
%!error <DIM .* positive integer> iqr (1, 0)
%!error <DIM .* positive integer> iqr (1, -2)
%!error <DIM .* positive integer> iqr (1, 1.4)
%!error <DIM .* positive integer> iqr (1, [1 -2])
%!error <DIM .* positive integer> iqr (1, [1 1.4])
%!error <DIM .* positive integer> iqr ([1 2 3], NaN)
%!error <DIM .* positive integer> iqr ([1 2 3], [2 NaN])
%!error <DIM .* positive integer> iqr ([1 2 3], Inf)
%!error <DIM .* positive integer> iqr ([1 2 3], [2 Inf])
%!error <vector DIM .* non-repeating> iqr ([1 2 3], [1 2 1])
%!error <DIM .* vector> iqr (1, [1 2; 3 4])
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} kendall (@var{x})
## @deftypefnx {} {} kendall (@var{x}, @var{y})
## @cindex Kendall's Tau
## Compute Kendall's
## @tex
## $\tau$.
## @end tex
## @ifnottex
## @var{tau}.
## @end ifnottex
##
## For two data vectors @var{x}, @var{y} of common length @math{N}, Kendall's
## @tex
## $\tau$
## @end tex
## @ifnottex
## @var{tau}
## @end ifnottex
## is the correlation of the signs of all rank differences of
## @var{x} and @var{y}; i.e., if both @var{x} and @var{y} have distinct
## entries, then
##
## @tex
## $$ \tau = {1 \over N(N-1)} \sum_{i,j} {\rm sign}(q_i-q_j) \, {\rm sign}(r_i-r_j) $$
## @end tex
## @ifnottex
##
## @example
## @group
##          1
## @var{tau} = -------   SUM sign (@var{q}(i) - @var{q}(j)) * sign (@var{r}(i) - @var{r}(j))
##       N (N-1)   i,j
## @end group
## @end example
##
## @end ifnottex
## @noindent
## in which the
## @tex
## $q_i$ and $r_i$
## @end tex
## @ifnottex
## @var{q}(i) and @var{r}(i)
## @end ifnottex
## are the ranks of @var{x} and @var{y}, respectively.
##
## If @var{x} and @var{y} are drawn from independent distributions,
## Kendall's
## @tex
## $\tau$
## @end tex
## @ifnottex
## @var{tau}
## @end ifnottex
## is asymptotically normal with mean 0 and variance
## @tex
## ${2 (2N+5) \over 9N(N-1)}$.
## @end tex
## @ifnottex
## @code{(2 * (2N+5)) / (9 * N * (N-1))}.
## @end ifnottex
##
## @code{kendall (@var{x})} is equivalent to @code{kendall (@var{x},
## @var{x})}.
## @seealso{ranks, spearman}
## @end deftypefn

function tau = kendall (x, y = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (   ! (isnumeric (x) || islogical (x))
      || ! (isnumeric (y) || islogical (y)))
    error ("kendall: X and Y must be numeric matrices or vectors");
  endif

  if (ndims (x) != 2 || ndims (y) != 2)
    error ("kendall: X and Y must be 2-D matrices or vectors");
  endif

  if (isrow (x))
    x = x.';
  endif
  [n, c] = size (x);

  if (nargin == 2)
    if (isrow (y))
      y = y.';
    endif
    if (rows (y) != n)
      error ("kendall: X and Y must have the same number of observations");
    else
      x = [x, y];
    endif
  endif

  if (isa (x, "single") || isa (y, "single"))
    cls = "single";
  else
    cls = "double";
  endif
  r   = ranks (x);
  m   = sign (kron (r, ones (n, 1, cls)) - kron (ones (n, 1, cls), r));
  tau = corr (m);

  if (nargin == 2)
    tau = tau(1 : c, (c + 1) : columns (x));
  endif

endfunction


%!test
%! x = [1:2:10];
%! y = [100:10:149];
%! assert (kendall (x,y), 1, 5*eps);
%! assert (kendall (x,fliplr (y)), -1, 5*eps);

%!assert (kendall (logical (1)), 1)
%!assert (kendall (single (1)), single (1))

## Test input validation
%!error <Invalid call> kendall ()
%!error kendall (['A'; 'B'])
%!error kendall (ones (2,1), ['A'; 'B'])
%!error kendall (ones (2,2,2))
%!error kendall (ones (2,2), ones (2,2,2))
%!error kendall (ones (2,2), ones (3,2))
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} kurtosis (@var{x})
## @deftypefnx {} {} kurtosis (@var{x}, @var{flag})
## @deftypefnx {} {} kurtosis (@var{x}, @var{flag}, @var{dim})
## Compute the sample kurtosis of the elements of @var{x}.
##
## The sample kurtosis is defined as
## @tex
## $$
## \kappa_1 = {{{1\over N}\,
##          \sum_{i=1}^N (x_i - \bar{x})^4} \over \sigma^4},
## $$
## where $N$ is the length of @var{x}, $\bar{x}$ its mean, and $\sigma$
## its (uncorrected) standard deviation.
## @end tex
## @ifnottex
##
## @example
## @group
##      mean ((@var{x} - mean (@var{x})).^4)
## k1 = ------------------------
##             std (@var{x}).^4
## @end group
## @end example
##
## @end ifnottex
##
## @noindent
## The optional argument @var{flag} controls which normalization is used.
## If @var{flag} is equal to 1 (default value, used when @var{flag} is omitted
## or empty), return the sample kurtosis as defined above.  If @var{flag} is
## equal to 0, return the @w{"bias-corrected"} kurtosis coefficient instead:
## @tex
## $$
## \kappa_0 = 3 + {\scriptstyle N - 1 \over \scriptstyle (N - 2)(N - 3)} \,
##     \left( (N + 1)\, \kappa_1 - 3 (N - 1) \right)
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##               N - 1
## k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
##          (N - 2)(N - 3)
## @end group
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} vector.
##
## @end ifnottex
## The bias-corrected kurtosis coefficient is obtained by replacing the sample
## second and fourth central moments by their unbiased versions.  It is an
## unbiased estimate of the population kurtosis for normal populations.
##
## If @var{x} is a matrix, or more generally a multi-dimensional array, return
## the kurtosis along the first non-singleton dimension.  If the optional
## @var{dim} argument is given, operate along this dimension.
##
## @seealso{var, skewness, moment}
## @end deftypefn

function y = kurtosis (x, flag, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("kurtosis: X must be a numeric vector or matrix");
  endif

  if (nargin < 2 || isempty (flag))
    flag = 1;  # default: do not use the "bias corrected" version
  else
    if (! isscalar (flag) || (flag != 0 && flag != 1))
      error ("kurtosis: FLAG must be 0 or 1");
    endif
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("kurtosis: DIM must be an integer and a valid dimension");
    endif
  endif

  n = size (x, dim);
  sz(dim) = 1;

  x = center (x, dim);   # center also promotes integer, logical to double
  v = var (x, 1, dim);   # normalize with 1/N
  y = sum (x .^ 4, dim);
  idx = (v != 0);
  y(idx) = y(idx) ./ (n * v(idx) .^ 2);
  y(! idx) = NaN;

  ## Apply bias correction to the second and fourth central sample moment
  if (flag == 0)
    if (n > 3)
      C = (n - 1) / ((n - 2) * (n - 3));
      y = 3 + C * ((n + 1) * y - 3 * (n - 1));
    else
      y(:) = NaN;
    endif
  endif

endfunction


%!test
%! x = [-1; 0; 0; 0; 1];
%! y = [x, 2*x];
%! assert (kurtosis (y), [2.5, 2.5], sqrt (eps));

%!assert (kurtosis ([-3, 0, 1]) == kurtosis ([-1, 0, 3]))
%!assert (kurtosis (ones (3, 5)), NaN (1, 5))
%!assert (kurtosis (1, [], 3), NaN)

%!assert (kurtosis ([1:5 10; 1:5 10],  0, 2),
%!        5.4377317925288901 * [1; 1], 8 * eps)
%!assert (kurtosis ([1:5 10; 1:5 10],  1, 2),
%!        2.9786509002956195 * [1; 1], 8 * eps)
%!assert (kurtosis ([1:5 10; 1:5 10], [], 2),
%!        2.9786509002956195 * [1; 1], 8 * eps)

## Test behavior on single input
%!assert (kurtosis (single ([1:5 10])), single (2.9786513), eps ("single"))
%!assert (kurtosis (single ([1 2]), 0), single (NaN))

## Verify no warnings
%!test
%! lastwarn ("");  # clear last warning
%! kurtosis (1);
%! assert (lastwarn (), "");

## Test input validation
%!error <Invalid call> kurtosis ()
%!error <X must be a numeric vector or matrix> kurtosis (['A'; 'B'])
%!error <FLAG must be 0 or 1> kurtosis (1, 2)
%!error <FLAG must be 0 or 1> kurtosis (1, [1 0])
%!error <DIM must be an integer> kurtosis (1, [], ones (2,2))
%!error <DIM must be an integer> kurtosis (1, [], 1.5)
%!error <DIM must be .* a valid dimension> kurtosis (1, [], 0)
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} mad (@var{x})
## @deftypefnx {} {} mad (@var{x}, @var{opt})
## @deftypefnx {} {} mad (@var{x}, @var{opt}, @var{dim})
## Compute the mean or median absolute deviation of the elements of @var{x}.
##
## The mean absolute deviation is defined as
##
## @example
## @var{mad} = mean (abs (@var{x} - mean (@var{x})))
## @end example
##
## The median absolute deviation is defined as
##
## @example
## @var{mad} = median (abs (@var{x} - median (@var{x})))
## @end example
##
## If @var{x} is a matrix, compute @code{mad} for each column and return
## results in a row vector.  For a multi-dimensional array, the calculation is
## done over the first non-singleton dimension.
##
## The optional argument @var{opt} determines whether mean or median absolute
## deviation is calculated.  The default is 0 which corresponds to mean
## absolute deviation; A value of 1 corresponds to median absolute deviation.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## As a measure of dispersion, @code{mad} is less affected by outliers than
## @code{std}.
## @seealso{bounds, range, iqr, std, mean, median}
## @end deftypefn

function retval = mad (x, opt = 0, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("mad: X must be a numeric vector or matrix");
  endif

  if (isempty (opt))
    opt = 0;
  elseif (! isscalar (opt) || (opt != 0 && opt != 1))
    error ("mad: OPT must be 0 or 1");
  endif

  sz = size (x);
  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("mad: DIM must be an integer and a valid dimension");
    endif
  endif

  if (opt == 0)
    fcn = @mean;
  else
    fcn = @median;
  endif

  retval = fcn (abs (x - fcn (x, dim)), dim);

endfunction


%!assert (mad ([0 0 1 2 100]), 31.76)
%!assert (mad (single ([0 0 1 2 100])), single (31.76))
%!assert (mad ([0 0 1 2 100]'), 31.76)
%!assert (mad ([0 0 1 2 100], 1), 1)
%!assert (mad (single ([0 0 1 2 100]), 1), single (1))
%!assert (mad ([0 0 1 2 100]', 1), 1)
%!assert (mad (magic (4)), [4, 4, 4, 4])
%!assert (mad (magic (4), [], 2), [6; 2; 2; 6])
%!assert (mad (magic (4), 1), [2.5, 3.5, 3.5, 2.5])
%!assert (mad (magic (4), 1, 2), [5.5; 1.5; 1.5; 5.5])

## Test input validation
%!error <Invalid call> mad ()
%!error <X must be a numeric> mad (['A'; 'B'])
%!error <OPT must be 0 or 1> mad (1, 2)
%!error <DIM must be an integer> mad (1, [], ones (2,2))
%!error <DIM must be an integer> mad (1, [], 1.5)
%!error <DIM must be .* a valid dimension> mad (1, [], 0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} mean (@var{x})
## @deftypefnx {} {} mean (@var{x}, @var{dim})
## @deftypefnx {} {} mean (@var{x}, @var{opt})
## @deftypefnx {} {} mean (@var{x}, @var{dim}, @var{opt})
## @deftypefnx {} {} mean (@dots{}, @var{outtype})
## Compute the mean of the elements of the vector @var{x}.
##
## The mean is defined as
##
## @tex
## $$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
## where $N$ is the number of elements of @var{x}.
##
## @end tex
## @ifnottex
##
## @example
## mean (@var{x}) = SUM_i @var{x}(i) / N
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} vector.
##
## @end ifnottex
## If @var{x} is a matrix, compute the mean for each column and return them
## in a row vector.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional argument @var{opt} selects the type of mean to compute.
## The following options are recognized:
##
## @table @asis
## @item @qcode{"a"}
## Compute the (ordinary) arithmetic mean.  [default]
##
## @item @qcode{"g"}
## Compute the geometric mean.
##
## @item @qcode{"h"}
## Compute the harmonic mean.
## @end table
##
## The optional argument @var{outtype} selects the data type of the
## output value.  The following options are recognized:
##
## @table @asis
## @item @qcode{"default"}
## Output will be of class double unless @var{x} is of class single,
## in which case the output will also be single.
##
## @item @qcode{"double"}
## Output will be of class double.
##
## @item @qcode{"native"}
## Output will be the same class as @var{x} unless @var{x} is of class
## logical in which case it returns of class double.
##
## @end table
##
## Both @var{dim} and @var{opt} are optional.  If both are supplied, either
## may appear first.
## @seealso{median, mode}
## @end deftypefn

function y = mean (x, varargin)

  if (nargin < 1 || nargin > 4)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("mean: X must be a numeric vector or matrix");
  endif
  nd = ndims (x);
  sz = size (x);

  ## We support too many options...

  ## If OUTTYPE is set, it must be the last option.  If DIM and
  ## MEAN_TYPE exist, they must be the first two options

  out_type = "default";
  if (numel (varargin))
    maybe_out_type = tolower (varargin{end});
    if (any (strcmpi (maybe_out_type, {"default", "double", "native"})))
      out_type = maybe_out_type;
      varargin(end) = [];
    endif
  endif

  scalars = cellfun (@isscalar, varargin);
  chars = cellfun (@ischar, varargin);
  numerics = cellfun (@isnumeric, varargin);

  dim_mask = numerics & scalars;
  mean_type_mask = chars & scalars;
  if (! all (dim_mask | mean_type_mask))
    print_usage ();
  endif

  switch (nnz (dim_mask))
    case 0 # Find the first non-singleton dimension
      (dim = find (sz > 1, 1)) || (dim = 1);
    case 1
      dim = varargin{dim_mask};
      if (dim != fix (dim) || dim < 1)
        error ("mean: DIM must be an integer and a valid dimension");
      endif
    otherwise
      print_usage ();
  endswitch

  switch (nnz (mean_type_mask))
    case 0
      mean_type = "a";
    case 1
      mean_type = varargin{mean_type_mask};
    otherwise
      print_usage ();
  endswitch

  ## The actual mean computation
  n = size (x, dim);
  switch (mean_type)
    case "a"
      y = sum (x, dim) / n;
    case "g"
      if (! any (x(:) < 0))
        y = exp (sum (log (x), dim) ./ n);
      else
        error ("mean: X must not contain any negative values");
      endif
    case "h"
      y = n ./ sum (1 ./ x, dim);
    otherwise
      error ("mean: mean type '%s' not recognized", mean_type);
  endswitch

  ## Convert output as requested
  switch (out_type)
    case "default"
      ## do nothing, the operators already do the right thing
    case "double"
      y = double (y);
    case "native"
      if (islogical (x))
        ## ignore it, return double anyway
      else
        y = cast (y, class (x));
      endif
    otherwise
      ## this should have been filtered out during input check, but...
      error ("mean: OUTTYPE '%s' not recognized", out_type);
  endswitch

endfunction


%!test
%! x = -10:10;
%! y = x';
%! z = [y, y+10];
%! assert (mean (x), 0);
%! assert (mean (y), 0);
%! assert (mean (z), [0, 10]);

## Test small numbers
%!assert (mean (repmat (0.1,1,1000), "g"), 0.1, 20*eps)

%!assert (mean (magic (3), 1), [5, 5, 5])
%!assert (mean (magic (3), 2), [5; 5; 5])
%!assert (mean ([2 8], "g"), 4)
%!assert (mean ([4 4 2], "h"), 3)
%!assert (mean (logical ([1 0 1 1])), 0.75)
%!assert (mean (single ([1 0 1 1])), single (0.75))
%!assert (mean ([1 2], 3), [1 2])

## Test input validation
%!error <Invalid call to mean.  Correct usage is> mean ()
%!error <Invalid call to mean.  Correct usage is> mean (1, 2, 3, 4)
%!error <X must be a numeric> mean ({1:5})
%!error <Invalid call to mean.  Correct usage is> mean (1, 2, 3)
%!error <Invalid call to mean.  Correct usage is> mean (1, ones (2,2))
%!error <DIM must be an integer> mean (1, 1.5)
%!error <DIM must be .* a valid dimension> mean (1, 0)
%!error <X must not contain any negative values> mean ([1 -1], "g")
%!error <mean type 'b' not recognized> mean (1, "b")
%!error <Invalid call to mean.  Correct usage is> mean (1, 1, "foo")

## Test outtype option
%!test
%! in = [1 2 3];
%! out = 2;
%! assert (mean (in, "default"), mean (in));
%! assert (mean (in, "default"), out);
%!
%! in = single ([1 2 3]);
%! out = 2;
%! assert (mean (in, "default"), mean (in));
%! assert (mean (in, "default"), single (out));
%! assert (mean (in, "double"), out);
%! assert (mean (in, "native"), single (out));
%!
%! in = uint8 ([1 2 3]);
%! out = 2;
%! assert (mean (in, "default"), mean (in));
%! assert (mean (in, "default"), out);
%! assert (mean (in, "double"), out);
%! assert (mean (in, "native"), uint8 (out));
%!
%! in = logical ([1 0 1]);
%! out = 2/3;
%! assert (mean (in, "default"), mean (in));
%! assert (mean (in, "default"), out);
%! assert (mean (in, "native"), out);  # logical ignores native option
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} meansq (@var{x})
## @deftypefnx {} {} meansq (@var{x}, @var{dim})
## Compute the mean square of the elements of the vector @var{x}.
##
## The mean square is defined as
## @tex
## $$
## {\rm meansq} (x) = {\sum_{i=1}^N {x_i}^2 \over N}
## $$
## where $N$ is the number of elements of @var{x}.
##
## @end tex
## @ifnottex
##
## @example
## @group
## meansq (@var{x}) = 1/N SUM_i @var{x}(i)^2
## @end group
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} vector.
##
## @end ifnottex
## If @var{x} is a matrix, return a row vector containing the mean square
## of each column.
##
## If the optional argument @var{dim} is given, operate along this dimension.
## @seealso{var, std, moment}
## @end deftypefn

function y = meansq (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("mean: X must be a numeric vector or matrix");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 2)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("mean: DIM must be an integer and a valid dimension");
    endif
  endif

  y = sumsq (x, dim) / size (x, dim);

endfunction


%!assert (meansq (1:5), 11)
%!assert (meansq (single (1:5)), single (11))
%!assert (meansq (magic (4)), [94.5, 92.5, 92.5, 94.5])
%!assert (meansq (magic (4), 2), [109.5; 77.5; 77.5; 109.5])
%!assert (meansq ([1 2], 3), [1 4])

## Test input validation
%!error <Invalid call> meansq ()
%!error <X must be a numeric> meansq (['A'; 'B'])
%!error <DIM must be an integer> meansq (1, ones (2,2))
%!error <DIM must be an integer> meansq (1, 1.5)
%!error <DIM must be .* a valid dimension> meansq (1, 0)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} median (@var{x})
## @deftypefnx {} {} median (@var{x}, @var{dim})
## Compute the median value of the elements of the vector @var{x}.
##
## When the elements of @var{x} are sorted, say
## @code{@var{s} = sort (@var{x})}, the median is defined as
## @tex
## $$
## {\rm median} (x) =
##   \cases{s(\lceil N/2\rceil), & $N$ odd;\cr
##           (s(N/2)+s(N/2+1))/2, & $N$ even.}
## $$
## where $N$ is the number of elements of @var{x}.
##
## @end tex
## @ifnottex
##
## @example
## @group
##              |  @var{s}(ceil(N/2))           N odd
## median (@var{x}) = |
##              | (@var{s}(N/2) + @var{s}(N/2+1))/2   N even
## @end group
## @end example
##
## @end ifnottex
## If @var{x} is of a discrete type such as integer or logical, then
## the case of even @math{N} rounds up (or toward @code{true}).
##
## If @var{x} is a matrix, compute the median value for each column and
## return them in a row vector.
##
## If the optional @var{dim} argument is given, operate along this dimension.
## @seealso{mean, mode}
## @end deftypefn

function retval = median (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("median: X must be a numeric vector or matrix");
  endif

  if (isempty (x))
    error ("median: X cannot be an empty matrix");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 2)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("median: DIM must be an integer and a valid dimension");
    endif
  endif

  n = size (x, dim);
  k = floor ((n+1) / 2);
  if (mod (n, 2) == 1)
    retval = nth_element (x, k, dim);
  else
    retval = sum (nth_element (x, k:k+1, dim), dim, "native") / 2;
    if (islogical (x))
      retval = logical (retval);
    endif
  endif
  ## Inject NaNs where needed, to be consistent with Matlab.
  if (isfloat (x))
    retval(any (isnan (x), dim)) = NaN;
  endif

endfunction


%!test
%! x = [1, 2, 3, 4, 5, 6];
%! x2 = x';
%! y = [1, 2, 3, 4, 5, 6, 7];
%! y2 = y';
%!
%! assert (median (x) == median (x2) && median (x) == 3.5);
%! assert (median (y) == median (y2) && median (y) == 4);
%! assert (median ([x2, 2*x2]), [3.5, 7]);
%! assert (median ([y2, 3*y2]), [4, 12]);

%!assert (median (single ([1,2,3])), single (2))
%!assert (median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN])
%!assert (median ([1,2], 3), [1,2])

## Test multidimensional arrays
%!shared a, b, x, y
%! old_state = rand ("state");
%! restore_state = onCleanup (@() rand ("state", old_state));
%! rand ("state", 2);
%! a = rand (2,3,4,5);
%! b = rand (3,4,6,5);
%! x = sort (a, 4);
%! y = sort (b, 3);
%!assert <*35679> (median (a, 4), x(:, :, :, 3))
%!assert <*35679> (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)

## Test non-floating point types
%!assert (median ([true, false]), true)
%!assert (median (uint8 ([1, 3])), uint8 (2))
%!assert (median (int8 ([1, 3, 4])), int8 (3))
%!assert (median (single ([1, 3, 4])), single (3))
%!assert (median (single ([1, 3, NaN])), single (NaN))

## Test input validation
%!error <Invalid call> median ()
%!error <X must be a numeric> median ({1:5})
%!error <X cannot be an empty matrix> median ([])
%!error <DIM must be an integer> median (1, ones (2,2))
%!error <DIM must be an integer> median (1, 1.5)
%!error <DIM must be .* a valid dimension> median (1, 0)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} mode (@var{x})
## @deftypefnx {} {} mode (@var{x}, @var{dim})
## @deftypefnx {} {[@var{m}, @var{f}, @var{c}] =} mode (@dots{})
## Compute the most frequently occurring value in a dataset (mode).
##
## @code{mode} determines the frequency of values along the first non-singleton
## dimension and returns the value with the highest frequency.  If two, or
## more, values have the same frequency @code{mode} returns the smallest.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The return variable @var{f} is the number of occurrences of the mode in
## the dataset.
##
## The cell array @var{c} contains all of the elements with the maximum
## frequency.
## @seealso{mean, median}
## @end deftypefn

function [m, f, c] = mode (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("mode: X must be a numeric vector or matrix");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 2)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("mode: DIM must be an integer and a valid dimension");
    endif
  endif

  if (dim > nd)
    ## Special case of mode over non-existent dimension.
    m = x;
    f = ones (size (x));
    c = num2cell (x);
    return;
  endif

  sz2 = sz;
  sz2(dim) = 1;
  sz3 = ones (1, nd);
  sz3(dim) = sz(dim);

  if (issparse (x))
    t2 = sparse (sz(1), sz(2));
  else
    t2 = zeros (sz);
  endif

  if (dim != 1)
    perm = [dim, 1:dim-1, dim+1:nd];
    t2 = permute (t2, perm);
  endif

  xs = sort (x, dim);
  t = cat (dim, true (sz2), diff (xs, 1, dim) != 0);

  if (dim != 1)
    t2(permute (t != 0, perm)) = diff ([find(permute (t, perm))(:); prod(sz)+1]);
    f = max (ipermute (t2, perm), [], dim);
    xs = permute (xs, perm);
  else
    t2(t) = diff ([find(t)(:); prod(sz)+1]);
    f = max (t2, [], dim);
  endif

  c = cell (sz2);
  if (issparse (x))
    m = sparse (sz2(1), sz2(2));
  else
    m = zeros (sz2, class (x));
  endif
  for i = 1 : prod (sz2)
    c{i} = xs(t2(:, i) == f(i), i);
    m(i) = c{i}(1);
  endfor

endfunction


%!test
%! [m, f, c] = mode (toeplitz (1:5));
%! assert (m, [1,2,2,2,1]);
%! assert (f, [1,2,2,2,1]);
%! assert (c, {[1;2;3;4;5],[2],[2;3],[2],[1;2;3;4;5]});
%!test
%! [m, f, c] = mode (toeplitz (1:5), 2);
%! assert (m, [1;2;2;2;1]);
%! assert (f, [1;2;2;2;1]);
%! assert (c, {[1;2;3;4;5];[2];[2;3];[2];[1;2;3;4;5]});
%!test
%! a = sprandn (32, 32, 0.05);
%! sp0 = sparse (0);
%! [m, f, c] = mode (a);
%! [m2, f2, c2] = mode (full (a));
%! assert (m, sparse (m2));
%! assert (f, sparse (f2));
%! c_exp(1:length (a)) = { sp0 };
%! assert (c ,c_exp);
%! assert (c2,c_exp);

%!assert (mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4])
%!assert (mode ([2,3,1,2,3,4],2),2)
%!assert (mode ([2,3,1,2,3,4]),2)
%!assert (mode (single ([2,3,1,2,3,4])), single (2))
%!assert (mode (int8 ([2,3,1,2,3,4])), int8 (2))

%!assert (mode ([2;3;1;2;3;4],1),2)
%!assert (mode ([2;3;1;2;3;4],2),[2;3;1;2;3;4])
%!assert (mode ([2;3;1;2;3;4]),2)

%!test
%! x = magic (3);
%! [m, f, c] = mode (x, 3);
%! assert (m, x);
%! assert (f, ones (3,3));
%! assert (c, num2cell (x));

%!shared x
%! x(:,:,1) = toeplitz (1:3);
%! x(:,:,2) = circshift (toeplitz (1:3), 1);
%! x(:,:,3) = circshift (toeplitz (1:3), 2);
%!test
%! [m, f, c] = mode (x, 1);
%! assert (reshape (m, [3, 3]), [1 1 1; 2 2 2; 1 1 1]);
%! assert (reshape (f, [3, 3]), [1 1 1; 2 2 2; 1 1 1]);
%! c = reshape (c, [3, 3]);
%! assert (c{1}, [1; 2; 3]);
%! assert (c{2}, 2);
%! assert (c{3}, [1; 2; 3]);
%!test
%! [m, f, c] = mode (x, 2);
%! assert (reshape (m, [3, 3]), [1 1 2; 2 1 1; 1 2 1]);
%! assert (reshape (f, [3, 3]), [1 1 2; 2 1 1; 1 2 1]);
%! c = reshape (c, [3, 3]);
%! assert (c{1}, [1; 2; 3]);
%! assert (c{2}, 2);
%! assert (c{3}, [1; 2; 3]);
%!test
%! [m, f, c] = mode (x, 3);
%! assert (reshape (m, [3, 3]), [1 2 1; 1 2 1; 1 2 1]);
%! assert (reshape (f, [3, 3]), [1 2 1; 1 2 1; 1 2 1]);
%! c = reshape (c, [3, 3]);
%! assert (c{1}, [1; 2; 3]);
%! assert (c{2}, [1; 2; 3]);
%! assert (c{3}, [1; 2; 3]);

## Test input validation
%!error <Invalid call> mode ()
%!error <X must be a numeric> mode ({1 2 3})
%!error <DIM must be an integer> mode (1, ones (2,2))
%!error <DIM must be an integer> mode (1, 1.5)
%!error <DIM must be .* a valid dimension> mode (1, 0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} moment (@var{x}, @var{p})
## @deftypefnx {} {} moment (@var{x}, @var{p}, @var{type})
## @deftypefnx {} {} moment (@var{x}, @var{p}, @var{dim})
## @deftypefnx {} {} moment (@var{x}, @var{p}, @var{type}, @var{dim})
## @deftypefnx {} {} moment (@var{x}, @var{p}, @var{dim}, @var{type})
## Compute the @var{p}-th central moment of the vector @var{x}.
##
## The @var{p}-th central moment of @var{x} is defined as:
##
## @tex
## $$
## {\sum_{i=1}^N (x_i - \bar{x})^p \over N}
## $$
## where $\bar{x}$ is the mean value of @var{x} and $N$ is the number of elements of @var{x}.
##
##
## @end tex
## @ifnottex
##
## @example
## @group
## 1/N SUM_i (@var{x}(i) - mean(@var{x}))^@var{p}
## @end group
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} vector.
##
## @end ifnottex
##
## If @var{x} is a matrix, return the row vector containing the @var{p}-th
## central moment of each column.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string @var{type} specifies the type of moment to be computed.
## Valid options are:
##
## @table @asis
## @item @qcode{"c"}
##   Central Moment (default).
##
## @item  @qcode{"a"}
## @itemx @qcode{"ac"}
##   Absolute Central Moment.  The moment about the mean ignoring sign
## defined as
## @tex
## $$
## {\sum_{i=1}^N {\left| x_i - \bar{x} \right|}^p \over N}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
## 1/N SUM_i (abs (@var{x}(i) - mean(@var{x})))^@var{p}
## @end group
## @end example
##
## @end ifnottex
##
## @item @qcode{"r"}
##   Raw Moment.  The moment about zero defined as
##
## @tex
## $$
## {\rm moment} (x) = { \sum_{i=1}^N {x_i}^p \over N }
## $$
## @end tex
## @ifnottex
##
## @example
## @group
## moment (@var{x}) = 1/N SUM_i @var{x}(i)^@var{p}
## @end group
## @end example
##
## @end ifnottex
##
## @item @nospell{@qcode{"ar"}}
##   Absolute Raw Moment.  The moment about zero ignoring sign defined as
## @tex
## $$
## {\sum_{i=1}^N {\left| x_i \right|}^p \over N}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
## 1/N SUM_i ( abs (@var{x}(i)) )^@var{p}
## @end group
## @end example
##
## @end ifnottex
## @end table
##
## If both @var{type} and @var{dim} are given they may appear in any order.
## @seealso{var, skewness, kurtosis}
## @end deftypefn

## Can easily be made to work for continuous distributions (using quad)
## as well, but how does the general case work?

function m = moment (x, p, opt1, opt2)

  if (nargin < 2)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)) || isempty (x))
    error ("moment: X must be a non-empty numeric matrix or vector");
  endif

  if (! (isnumeric (p) && isscalar (p)))
    error ("moment: P must be a numeric scalar");
  endif

  need_dim = false;

  if (nargin == 2)
    type = "";
    need_dim = true;
  elseif (nargin == 3)
    if (ischar (opt1))
      type = opt1;
      need_dim = true;
    else
      dim = opt1;
      type = "";
    endif
  elseif (nargin == 4)
    if (ischar (opt1))
      type = opt1;
      dim = opt2;
    elseif (ischar (opt2))
      type = opt2;
      dim = opt1;
    else
      error ("moment: TYPE must be a string");
    endif
  endif

  nd = ndims (x);
  sz = size (x);
  if (need_dim)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("moment: DIM must be an integer and a valid dimension");
    endif
  endif

  n = size (x, dim);

  if (! any (type == "r"))
    x = center (x, dim);
  endif
  if (any (type == "a"))
    x = abs (x);
  endif

  m = sum (x .^ p, dim) / n;

endfunction


%!shared x
%! x = rand (10);
%!assert (moment (x,1), mean (center (x)), eps)
%!assert (moment (x,2), meansq (center (x)), eps)
%!assert (moment (x,1,2), mean (center (x, 2), 2), eps)
%!assert (moment (x,1,"a"), mean (abs (center (x))), eps)
%!assert (moment (x,1,"r"), mean (x), eps)
%!assert (moment (x,1,"ar"), mean (abs (x)), eps)

%!assert (moment (single ([1 2 3]), 1, "r"), single (2))

%!assert (moment (1, 2, 4), 0)

## Test input validation
%!error <Invalid call> moment ()
%!error <Invalid call> moment (1)
%!error <X must be a non-empty numeric matrix> moment (['A'; 'B'], 2)
%!error <X must be a non-empty numeric matrix> moment (ones (2,0,3), 2)
%!error <P must be a numeric scalar> moment (1, true)
%!error <P must be a numeric scalar> moment (1, ones (2,2))
%!error <TYPE must be a string> moment (1, 2, 3, 4)
%!error <DIM must be an integer and a valid dimension> moment (1, 2, ones (2,2))
%!error <DIM must be an integer and a valid dimension> moment (1, 2, 1.5)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movmad (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movmad (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movmad (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movmad (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movmad (@dots{}, @var{property}, @var{value})
## Calculate the moving mean absolute deviation over a sliding window of length
## @var{wlen} on data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{mad} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movmad} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movmad} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{mad}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = mad (@var{x}(1:2))}, and
## @code{@var{y}(end) = mad (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = mad ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = mad ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{mad} handles @code{NaN},
## and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = mad ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = mad ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = mad ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = mad ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = mad ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = mad ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmax, movmean, movmedian, movmin, movprod,
## movstd, movsum, movvar}
## @end deftypefn

function y = movmad (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@mad, x, wlen, __parse_movargs__ ("movmad", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([0.5; repmat(2/3,8,1); 0.5], movmad ((1:10).', 3))

## Test input validation
%!error <Invalid call> movmad ()
%!error <Invalid call> movmad (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movmax (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movmax (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movmax (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movmax (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movmax (@dots{}, @var{property}, @var{value})
## Calculate the moving maximum over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{max} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movmax} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movmax} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{max}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = max (@var{x}(1:2))}, and
## @code{@var{y}(end) = max (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = max ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = max ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{max} handles @code{NaN},
## and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = max ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = max ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = max ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = max ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = max ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = max ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmean, movmedian, movmin, movprod,
## movstd, movsum, movvar}
## @end deftypefn

function y = movmax (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@max, x, wlen, "Endpoints", -Inf,
              __parse_movargs__ ("movmax", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([(2:10).'; 10], movmax ((1:10).', 3))

## Test input validation
%!error <Invalid call> movmax ()
%!error <Invalid call> movmax (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movmean (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movmean (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movmean (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movmean (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movmean (@dots{}, @var{property}, @var{value})
## Calculate the moving average over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{mean} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movmean} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movmean} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{mean}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = mean (@var{x}(1:2))}, and
## @code{@var{y}(end) = mean (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = mean ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = mean ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{mean} handles @code{NaN},
## and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = mean ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = mean ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = mean ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = mean ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = mean ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = mean ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmedian, movmin, movprod,
## movstd, movsum, movvar}
## @end deftypefn

function y = movmean (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@mean, x, wlen, __parse_movargs__ ("movmean", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([1.5; (2:9).'; 9.5], movmean ((1:10).', 3))

## Test input validation
%!error <Invalid call> movmean ()
%!error <Invalid call> movmean (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movmedian (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movmedian (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movmedian (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movmedian (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movmedian (@dots{}, @var{property}, @var{value})
## Calculate the moving median over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{movmedian} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movmedian} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movmedian} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to
## @code{movmedian}.  The default is @qcode{"includenan"}.  Caution: the
## @qcode{"omitnan"} option is not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = movmedian (@var{x}(1:2))}, and
## @code{@var{y}(end) = movmedian (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = movmedian ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movmedian ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{movmedian} handles
## @code{NaN}, and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = movmedian ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movmedian ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = movmedian ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movmedian ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = movmedian ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movmedian ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmean, movmin, movprod, movstd,
## movsum, movvar}
## @end deftypefn

function y = movmedian (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@median, x, wlen, __parse_movargs__ ("movmedian", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([1.5; (2:9).'; 9.5], movmedian ((1:10).', 3))

## Test input validation
%!error <Invalid call> movmedian ()
%!error <Invalid call> movmedian (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movmin (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movmin (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movmin (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movmin (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movmin (@dots{}, @var{property}, @var{value})
## Calculate the moving minimum over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{min} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movmin} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movmin} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{min}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = min (@var{x}(1:2))}, and
## @code{@var{y}(end) = min (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = min ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = min ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{min} handles @code{NaN},
## and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = min ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = min ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = min ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = min ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = min ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = min ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmean, movmedian, movprod,
## movstd, movsum, movvar}
## @end deftypefn

function y = movmin (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@min, x, wlen, "Endpoints", Inf,
              __parse_movargs__ ("movmin", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([1; (1:9).'], movmin ((1:10).', 3))

## Test input validation
%!error <Invalid call> movmin ()
%!error <Invalid call> movmin (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movprod (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movprod (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movprod (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movprod (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movprod (@dots{}, @var{property}, @var{value})
## Calculate the moving product over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{movprod} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movprod} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movprod} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{movprod}.
## The default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"}
## option is not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = movprod (@var{x}(1:2))}, and
## @code{@var{y}(end) = movprod (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = movprod ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movprod ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{movprod} handles
## @code{NaN}, and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = movprod ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movprod ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = movprod ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movprod ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = movprod ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movprod ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmean, movmedian, movmin,
## movstd, movsum, movvar}
## @end deftypefn

function y = movprod (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@prod, x, wlen, "Endpoints", 1,
              __parse_movargs__ ("movprod", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([2; 6; 24; 60; 120; 210; 336; 504; 720; 90], movprod ((1:10).', 3))

## Test input validation
%!error <Invalid call> movprod ()
%!error <Invalid call> movprod (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movstd (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movstd (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movstd (@dots{}, @var{opt})
## @deftypefnx {} {@var{y} =} movstd (@dots{}, @var{opt}, @var{dim})
## @deftypefnx {} {@var{y} =} movstd (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movstd (@dots{}, @var{property}, @var{value})
## Calculate the moving standard deviation over a sliding window of length
## @var{wlen} on data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{movstd} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movstd} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movstd} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## The optional argument @var{opt} determines the type of normalization to use.
## Valid values are
##
## @table @asis
## @item 0:
##   normalize with @math{N-1}, provides the square root of the best unbiased
## estimator of the variance [default]
##
## @item 1:
##   normalize with @math{N}, this provides the square root of the second
## moment around the mean
## @end table
##
## If the optional argument @var{dim} is given, operate along this dimension.
## The normalization argument @var{opt} must be given before the dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{movstd}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = movstd (@var{x}(1:2))}, and
## @code{@var{y}(end) = movstd (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = movstd ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movstd ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{movstd} handles
## @code{NaN}, and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = movstd ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movstd ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = movstd ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movstd ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = movstd ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movstd ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmean, movmedian, movmin,
## movprod, movsum, movvar}
## @end deftypefn

function y = movstd (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  ## Process "opt" normalization argument
  if (nargin > 2 && isnumeric (varargin{1}))
    if (! varargin{1})
      fcn = @std;
    else
      fcn = @(x) std (x, 1);
    endif
    varargin(1) = [];
  else
    fcn = @std;
  endif

  y = movfun (fcn, x, wlen, __parse_movargs__ ("movstd", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([1/sqrt(2); ones(8,1); 1/sqrt(2)], movstd ((1:10).', 3), 1e-8)

%!test <*56765>
%! x = 1:10;
%! y = movstd (x, 4);
%! y0 = movstd (x, 4, 0);
%! assert (y, y0);
%! y1 = movstd (x, 4, 1);
%! assert (y1(1:3), sqrt ([1/4, 2/3, 5/4]));

## Test input validation
%!error <Invalid call> movstd ()
%!error <Invalid call> movstd (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movsum (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movsum (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movsum (@dots{}, @var{dim})
## @deftypefnx {} {@var{y} =} movsum (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movsum (@dots{}, @var{property}, @var{value})
## Calculate the moving sum over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{movsum} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movsum} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movsum} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{movsum}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = movsum (@var{x}(1:2))}, and
## @code{@var{y}(end) = movsum (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = movsum ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movsum ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{movsum} handles
## @code{NaN}, and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = movsum ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = movsum ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = movsum ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movsum ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = movsum ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = movsum ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmean, movmedian, movmin,
## movprod, movstd, movvar}
## @end deftypefn

function y = movsum (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  y = movfun (@sum, x, wlen, "Endpoints", 0,
              __parse_movargs__ ("movsum", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([(3:3:27).'; 19], movsum ((1:10).', 3))

## Test input validation
%!error <Invalid call> movsum ()
%!error <Invalid call> movsum (1)
########################################################################
##
## Copyright (C) 2018-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{y} =} movvar (@var{x}, @var{wlen})
## @deftypefnx {} {@var{y} =} movvar (@var{x}, [@var{nb}, @var{na}])
## @deftypefnx {} {@var{y} =} movvar (@dots{}, @var{opt})
## @deftypefnx {} {@var{y} =} movvar (@dots{}, @var{opt}, @var{dim})
## @deftypefnx {} {@var{y} =} movvar (@dots{}, "@var{nancond}")
## @deftypefnx {} {@var{y} =} movvar (@dots{}, @var{property}, @var{value})
## Calculate the moving variance over a sliding window of length @var{wlen} on
## data @var{x}.
##
## If @var{wlen} is a scalar, the function @code{var} is applied to a
## moving window of length @var{wlen}.  When @var{wlen} is an odd number the
## window is symmetric and includes @w{@code{(@var{wlen} - 1) / 2}} elements on
## either side of the central element.  For example, when calculating the
## output at index 5 with a window length of 3, @code{movvar} uses data
## elements @w{@code{[4, 5, 6]}}.  If @var{wlen} is an even number, the window
## is asymmetric and has @w{@code{@var{wlen}/2}} elements to the left of the
## central element and @w{@code{@var{wlen}/2 - 1}} elements to the right of the
## central element.  For example, when calculating the output at index 5 with a
## window length of 4, @code{movvar} uses data elements
## @w{@code{[3, 4, 5, 6]}}.
##
## If @var{wlen} is an array with two elements @w{@code{[@var{nb}, @var{na}]}},
## the function is applied to a moving window @code{-@var{nb}:@var{na}}.  This
## window includes @var{nb} number of elements @emph{before} the current
## element and @var{na} number of elements @emph{after} the current element.
## The current element is always included.  For example, given
## @w{@code{@var{wlen} = [3, 0]}}, the data used to calculate index 5 is
## @w{@code{[2, 3, 4, 5]}}.
##
## The optional argument @var{opt} determines the type of normalization to use.
## Valid values are
##
## @table @asis
## @item 0:
##   normalize with @math{N-1}, provides the best unbiased estimator of the
## variance [default]
##
## @item 1:
##   normalizes with @math{N}, this provides the second moment around the mean
## @end table
##
## If the optional argument @var{dim} is given, operate along this dimension.
## The normalization argument @var{opt} must be given before the dimension.
##
## The optional string argument @qcode{"@var{nancond}"} controls whether
## @code{NaN} and @code{NA} values should be included (@qcode{"includenan"}),
## or excluded (@qcode{"omitnan"}), from the data passed to @code{var}.  The
## default is @qcode{"includenan"}.  Caution: the @qcode{"omitnan"} option is
## not yet implemented.
##
## The calculation can be controlled by specifying @var{property}/@var{value}
## pairs.  Valid properties are
##
## @table @asis
##
## @item @qcode{"Endpoints"}
##
## This property controls how results are calculated at the boundaries
## (@w{endpoints}) of the window.  Possible values are:
##
## @table @asis
## @item @qcode{"shrink"}  (default)
## The window is truncated at the beginning and end of the array to exclude
## elements for which there is no source data.  For example, with a window of
## length 3, @code{@var{y}(1) = var (@var{x}(1:2))}, and
## @code{@var{y}(end) = var (@var{x}(end-1:end))}.
##
## @item @qcode{"discard"}
## Any @var{y} values that use a window extending beyond the original
## data array are deleted.  For example, with a 10-element data vector and a
## window of length 3, the output will contain only 8 elements.  The first
## element would require calculating the function over indices
## @w{@code{[0, 1, 2]}} and is therefore discarded.  The last element would
## require calculating the function over indices @w{@code{[9, 10, 11]}} and is
## therefore discarded.
##
## @item @qcode{"fill"}
## Any window elements outside the data array are replaced by @code{NaN}.  For
## example, with a window of length 3,
## @code{@var{y}(1) = var ([NaN, @var{x}(1:2)])}, and
## @code{@var{y}(end) = var ([@var{x}(end-1:end), NaN])}.
## This option usually results in @var{y} having @code{NaN} values at the
## boundaries, although it is influenced by how @code{var} handles @code{NaN},
## and also by the property @qcode{"nancond"}.
##
## @item @var{user_value}
## Any window elements outside the data array are replaced by the specified
## value @var{user_value} which must be a numeric scalar.  For example, with a
## window of length 3,
## @code{@var{y}(1) = var ([@var{user_value}, @var{x}(1:2)])}, and
## @code{@var{y}(end) = var ([@var{x}(end-1:end), @var{user_value}])}.
## A common choice for @var{user_value} is 0.
##
## @item @qcode{"same"}
## Any window elements outside the data array are replaced by the value of
## @var{x} at the boundary.  For example, with a window of length 3,
## @code{@var{y}(1) = var ([@var{x}(1), @var{x}(1:2)])}, and
## @code{@var{y}(end) = var ([@var{x}(end-1:end), @var{x}(end)])}.
##
## @item @qcode{"periodic"}
## The window is wrapped so that any missing data elements are taken from
## the other side of the data.  For example, with a window of length 3,
## @code{@var{y}(1) = var ([@var{x}(end), @var{x}(1:2)])}, and
## @code{@var{y}(end) = var ([@var{x}(end-1:end), @var{x}(1)])}.
##
## @end table
##
## @item @qcode{"SamplePoints"}
## Caution: This option is not yet implemented.
##
## @end table
##
## Programming Note: This function is a wrapper which calls @code{movfun}.
## For additional options and documentation, @pxref{XREFmovfun,,@code{movfun}}.
##
## @seealso{movfun, movslice, movmad, movmax, movmean, movmedian, movmin,
## movprod, movstd, movsum}
## @end deftypefn

function y = movvar (x, wlen, varargin)

  if (nargin < 2)
    print_usage ();
  endif

  ## Process "opt" normalization argument
  if (nargin > 2 && isnumeric (varargin{1}))
    if (! varargin{1})
      fcn = @var;
    else
      fcn = @(x) var (x, 1);
    endif
    varargin(1) = [];
  else
    fcn = @var;
  endif

  y = movfun (fcn, x, wlen, __parse_movargs__ ("movvar", varargin{:}){:});

endfunction


## FIXME: Need functional BIST tests
## test for bug #55241
%!assert ([0.5; ones(8,1); 0.5], movvar ((1:10).', 3))

%!test <*56765>
%! x = 1:10;
%! y = movvar (x, 4);
%! y0 = movvar (x, 4, 0);
%! assert (y, y0);
%! y1 = movvar (x, 4, 1);
%! assert (y1(1:3), [1/4, 2/3, 5/4]);

## Test input validation
%!error <Invalid call> movvar ()
%!error <Invalid call> movvar (1)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} prctile (@var{x})
## @deftypefnx {} {@var{q} =} prctile (@var{x}, @var{p})
## @deftypefnx {} {@var{q} =} prctile (@var{x}, @var{p}, @var{dim})
## For a sample @var{x}, compute the quantiles, @var{q}, corresponding
## to the cumulative probability values, @var{p}, in percent.
##
## If @var{x} is a matrix, compute the percentiles for each column and return
## them in a matrix, such that the i-th row of @var{q} contains the
## @var{p}(i)th percentiles of each column of @var{x}.
##
## If @var{p} is unspecified, return the quantiles for @code{[0 25 50 75 100]}.
##
## The optional argument @var{dim} determines the dimension along which the
## percentiles are calculated.  If @var{dim} is omitted it defaults to the
## first non-singleton dimension.
##
## Programming Note: All non-numeric values (NaNs) of @var{x} are ignored.
## @seealso{quantile}
## @end deftypefn

function q = prctile (x, p = [], dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("prctile: X must be a numeric vector or matrix");
  endif

  if (isempty (p))
    p = [0, 25, 50, 75, 100];
  endif

  if (! (isnumeric (p) && isvector (p)))
    error ("prctile: P must be a numeric vector");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("quantile: DIM must be a positive integer");
    endif
  endif

  ## Convert from percent to decimal.
  p /= 100;

  q = quantile (x, p, dim);

endfunction


%!test
%! pct = 50;
%! q = prctile (1:4, pct);
%! qa = 2.5;
%! assert (q, qa);
%! q = prctile (1:4, pct, 1);
%! qa = [1, 2, 3, 4];
%! assert (q, qa);
%! q = prctile (1:4, pct, 2);
%! qa = 2.5;
%! assert (q, qa);

%!test
%! pct = [50 75];
%! q = prctile (1:4, pct);
%! qa = [2.5 3.5];
%! assert (q, qa);
%! q = prctile (1:4, pct, 1);
%! qa = [1, 2, 3, 4; 1, 2, 3, 4];
%! assert (q, qa);
%! q = prctile (1:4, pct, 2);
%! qa = [2.5 3.5];
%! assert (q, qa);

%!test
%! pct = 50;
%! x = [0.1126, 0.1148, 0.0521, 0.2364, 0.1393
%!      0.1718, 0.7273, 0.2041, 0.4531, 0.1585
%!      0.2795, 0.7978, 0.3296, 0.5567, 0.7307
%!      0.4288, 0.8753, 0.6477, 0.6287, 0.8165
%!      0.9331, 0.9312, 0.9635, 0.7796, 0.8461];
%! tol = 0.0001;
%! q = prctile (x, pct, 1);
%! qa = [0.2795, 0.7978, 0.3296, 0.5567, 0.7307];
%! assert (q, qa, tol);
%! q = prctile (x, pct, 2);
%! qa = [0.1148; 0.2041; 0.5567; 0.6477; 0.9312];
%! assert (q, qa, tol);

%!test
%! pct = 50;
%! tol = 0.0001;
%! x = [0.1126, 0.1148, 0.0521, 0.2364, 0.1393
%!      0.1718, 0.7273, 0.2041, 0.4531, 0.1585
%!      0.2795, 0.7978, 0.3296, 0.5567, 0.7307
%!      0.4288, 0.8753, 0.6477, 0.6287, 0.8165
%!      0.9331, 0.9312, 0.9635, 0.7796, 0.8461];
%! x(5,5) = Inf;
%! q = prctile (x, pct, 1);
%! qa = [0.2795, 0.7978, 0.3296, 0.5567, 0.7307];
%! assert (q, qa, tol);
%! x(5,5) = -Inf;
%! q = prctile (x, pct, 1);
%! qa = [0.2795, 0.7978, 0.3296, 0.5567, 0.1585];
%! assert (q, qa, tol);
%! x(1,1) = Inf;
%! q = prctile (x, pct, 1);
%! qa = [0.4288, 0.7978, 0.3296, 0.5567, 0.1585];
%! assert (q, qa, tol);

%!test
%! pct = 50;
%! tol = 0.0001;
%! x = [0.1126, 0.1148, 0.0521, 0.2364, 0.1393
%!      0.1718, 0.7273, 0.2041, 0.4531, 0.1585
%!      0.2795, 0.7978, 0.3296, 0.5567, 0.7307
%!      0.4288, 0.8753, 0.6477, 0.6287, 0.8165
%!      0.9331, 0.9312, 0.9635, 0.7796, 0.8461];
%! x(3,3) = Inf;
%! q = prctile (x, pct, 1);
%! qa = [0.2795, 0.7978, 0.6477, 0.5567, 0.7307];
%! assert (q, qa, tol);
%! q = prctile (x, pct, 2);
%! qa = [0.1148; 0.2041; 0.7307; 0.6477; 0.9312];
%! assert (q, qa, tol);

%!test
%! pct = 50;
%! tol = 0.0001;
%! x = [0.1126, 0.1148, 0.0521, 0.2364, 0.1393
%!      0.1718, 0.7273, 0.2041, 0.4531, 0.1585
%!      0.2795, 0.7978, 0.3296, 0.5567, 0.7307
%!      0.4288, 0.8753, 0.6477, 0.6287, 0.8165
%!      0.9331, 0.9312, 0.9635, 0.7796, 0.8461];
%! x(5,5) = NaN;
%! q = prctile (x, pct, 2);
%! qa = [0.1148; 0.2041; 0.5567; 0.6477; 0.9322];
%! assert (q, qa, tol);
%! x(1,1) = NaN;
%! q = prctile (x, pct, 2);
%! qa = [0.1270; 0.2041; 0.5567; 0.6477; 0.9322];
%! assert (q, qa, tol);
%! x(3,3) = NaN;
%! q = prctile (x, pct, 2);
%! qa = [0.1270; 0.2041; 0.6437; 0.6477; 0.9322];
%! assert (q, qa, tol);

%!assert (prctile ([1:10], 1, 3), [1:10])

## Test input validation
%!error <Invalid call> prctile ()
%!error prctile (['A'; 'B'], 10)
%!error prctile (1:10, [true, false])
%!error prctile (1:10, ones (2,2))
%!error prctile (1, 1, 1.5)
%!error prctile (1, 1, 0)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{q} =} quantile (@var{x})
## @deftypefnx {} {@var{q} =} quantile (@var{x}, @var{p})
## @deftypefnx {} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim})
## @deftypefnx {} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
## the cumulative probability values in @var{p}.  All non-numeric values (NaNs)
## of @var{x} are ignored.
##
## If @var{x} is a matrix, compute the quantiles for each column and
## return them in a matrix, such that the i-th row of @var{q} contains
## the @var{p}(i)th quantiles of each column of @var{x}.
##
## If @var{p} is unspecified, return the quantiles for
## @code{[0.00 0.25 0.50 0.75 1.00]}.
## The optional argument @var{dim} determines the dimension along which
## the quantiles are calculated.  If @var{dim} is omitted it defaults to
## the first non-singleton dimension.
##
## The methods available to calculate sample quantiles are the nine methods
## used by R (@url{https://www.r-project.org/}).  The default value is
## @w{@var{method} = 5}.
##
## Discontinuous sample quantile methods 1, 2, and 3
##
## @enumerate 1
## @item Method 1: Inverse of empirical distribution function.
##
## @item Method 2: Similar to method 1 but with averaging at discontinuities.
##
## @item Method 3: SAS definition: nearest even order statistic.
## @end enumerate
##
## Continuous sample quantile methods 4 through 9, where
## @tex
## $p(k)$
## @end tex
## @ifnottex
## @var{p}(k)
## @end ifnottex
## is the linear
## interpolation function respecting each method's representative cdf.
##
## @enumerate 4
## @item Method 4:
## @tex
## $p(k) = k / N$.
## @end tex
## @ifnottex
## @var{p}(k) = k / N.
## @end ifnottex
## That is, linear interpolation of the empirical cdf, where @math{N} is the
## length of @var{P}.
##
## @item Method 5:
## @tex
## $p(k) = (k - 0.5) / N$.
## @end tex
## @ifnottex
## @var{p}(k) = (k - 0.5) / N.
## @end ifnottex
## That is, a piecewise linear function where the knots are the values midway
## through the steps of the empirical cdf.
##
## @item Method 6:
## @tex
## $p(k) = k / (N + 1)$.
## @end tex
## @ifnottex
## @var{p}(k) = k / (N + 1).
## @end ifnottex
##
## @item Method 7:
## @tex
## $p(k) = (k - 1) / (N - 1)$.
## @end tex
## @ifnottex
## @var{p}(k) = (k - 1) / (N - 1).
## @end ifnottex
##
## @item Method 8:
## @tex
## $p(k) = (k - 1/3) / (N + 1/3)$.
## @end tex
## @ifnottex
## @var{p}(k) = (k - 1/3) / (N + 1/3).
## @end ifnottex
## The resulting quantile estimates are approximately median-unbiased
## regardless of the distribution of @var{x}.
##
## @item Method 9:
## @tex
## $p(k) = (k - 3/8) / (N + 1/4)$.
## @end tex
## @ifnottex
## @var{p}(k) = (k - 3/8) / (N + 1/4).
## @end ifnottex
## The resulting quantile estimates are approximately unbiased for the
## expected order statistics if @var{x} is normally distributed.
## @end enumerate
##
## @nospell{Hyndman and Fan} (1996) recommend method 8.  Maxima, S, and R
## (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS
## use method 6.  @sc{matlab} uses method 5.
##
## References:
##
## @itemize @bullet
## @item @nospell{Becker, R. A., Chambers, J. M. and Wilks, A. R.} (1988)
## The New S Language.  @nospell{Wadsworth & Brooks/Cole}.
##
## @item @nospell{Hyndman, R. J. and Fan, Y.} (1996) Sample quantiles in
## statistical packages, American Statistician, 50, 361--365.
##
## @item R: A Language and Environment for Statistical Computing;
## @url{https://cran.r-project.org/doc/manuals/fullrefman.pdf}.
## @end itemize
##
## Examples:
## @c Set example in small font to prevent overfull line
##
## @smallexample
## @group
## x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
## q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
## q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution
## @end group
## @end smallexample
## @seealso{prctile}
## @end deftypefn

function q = quantile (x, p = [], dim, method = 5)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)) || isempty (x))
    error ("quantile: X must be a non-empty numeric vector or matrix");
  endif

  if (isempty (p))
    p = [0.00 0.25, 0.50, 0.75, 1.00];
  endif

  if (! (isnumeric (p) && isvector (p)))
    error ("quantile: P must be a numeric vector");
  endif

  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (size (x) > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("quantile: DIM must be a positive integer");
    endif
  endif

  ## Set the permutation vector.
  perm = 1:(max (ndims (x), dim));
  perm(1) = dim;
  perm(dim) = 1;

  ## Permute dim to the 1st index.
  x = permute (x, perm);

  ## Save the size of the permuted x N-D array.
  sx = size (x);

  ## Reshape to a 2-D array.
  x = reshape (x, sx(1), []);

  ## Calculate the quantiles.
  q = __quantile__ (x, p, method);

  ## Return the shape to the original N-D array.
  q = reshape (q, [numel(p), sx(2:end)]);

  ## Permute the 1st index back to dim.
  q = ipermute (q, perm);

  ## For Matlab compatibility, return vectors with the same orientation as p
  if (isvector (q) && ! isscalar (q) && ! isscalar (p))
    if (isrow (p))
      q = reshape (q, 1, []);
    else
      q = reshape (q, [], 1);
    endif
  endif

endfunction


%!test
%! p = 0.50;
%! q = quantile (1:4, p);
%! qa = 2.5;
%! assert (q, qa);
%! q = quantile (1:4, p, 1);
%! qa = [1, 2, 3, 4];
%! assert (q, qa);
%! q = quantile (1:4, p, 2);
%! qa = 2.5;
%! assert (q, qa);

%!test
%! p = [0.50 0.75];
%! q = quantile (1:4, p);
%! qa = [2.5 3.5];
%! assert (q, qa);
%! q = quantile (1:4, p, 1);
%! qa = [1, 2, 3, 4; 1, 2, 3, 4];
%! assert (q, qa);
%! q = quantile (1:4, p, 2);
%! qa = [2.5 3.5];
%! assert (q, qa);

%!test
%! p = 0.5;
%! x = sort (rand (11));
%! q = quantile (x, p);
%! assert (q, x(6,:));
%! x = x.';
%! q = quantile (x, p, 2);
%! assert (q, x(:,6));

%!test
%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
%! x = [1; 2; 3; 4];
%! a = [1.0000   1.0000   2.0000   3.0000   4.0000
%!      1.0000   1.5000   2.5000   3.5000   4.0000
%!      1.0000   1.0000   2.0000   3.0000   4.0000
%!      1.0000   1.0000   2.0000   3.0000   4.0000
%!      1.0000   1.5000   2.5000   3.5000   4.0000
%!      1.0000   1.2500   2.5000   3.7500   4.0000
%!      1.0000   1.7500   2.5000   3.2500   4.0000
%!      1.0000   1.4167   2.5000   3.5833   4.0000
%!      1.0000   1.4375   2.5000   3.5625   4.0000];
%! for m = 1:9
%!   q = quantile (x, p, 1, m);
%!   assert (q, a(m,:), 0.0001);
%! endfor

%!test
%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
%! x = [1; 2; 3; 4; 5];
%! a = [1.0000   2.0000   3.0000   4.0000   5.0000
%!      1.0000   2.0000   3.0000   4.0000   5.0000
%!      1.0000   1.0000   2.0000   4.0000   5.0000
%!      1.0000   1.2500   2.5000   3.7500   5.0000
%!      1.0000   1.7500   3.0000   4.2500   5.0000
%!      1.0000   1.5000   3.0000   4.5000   5.0000
%!      1.0000   2.0000   3.0000   4.0000   5.0000
%!      1.0000   1.6667   3.0000   4.3333   5.0000
%!      1.0000   1.6875   3.0000   4.3125   5.0000];
%! for m = 1:9
%!   q = quantile (x, p, 1, m);
%!   assert (q, a(m,:), 0.0001);
%! endfor

%!test
%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
%! x = [1; 2; 5; 9];
%! a = [1.0000   1.0000   2.0000   5.0000   9.0000
%!      1.0000   1.5000   3.5000   7.0000   9.0000
%!      1.0000   1.0000   2.0000   5.0000   9.0000
%!      1.0000   1.0000   2.0000   5.0000   9.0000
%!      1.0000   1.5000   3.5000   7.0000   9.0000
%!      1.0000   1.2500   3.5000   8.0000   9.0000
%!      1.0000   1.7500   3.5000   6.0000   9.0000
%!      1.0000   1.4167   3.5000   7.3333   9.0000
%!      1.0000   1.4375   3.5000   7.2500   9.0000];
%! for m = 1:9
%!   q = quantile (x, p, 1, m);
%!   assert (q, a(m,:), 0.0001);
%! endfor

%!test
%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
%! x = [1; 2; 5; 9; 11];
%! a = [1.0000    2.0000    5.0000    9.0000   11.0000
%!      1.0000    2.0000    5.0000    9.0000   11.0000
%!      1.0000    1.0000    2.0000    9.0000   11.0000
%!      1.0000    1.2500    3.5000    8.0000   11.0000
%!      1.0000    1.7500    5.0000    9.5000   11.0000
%!      1.0000    1.5000    5.0000   10.0000   11.0000
%!      1.0000    2.0000    5.0000    9.0000   11.0000
%!      1.0000    1.6667    5.0000    9.6667   11.0000
%!      1.0000    1.6875    5.0000    9.6250   11.0000];
%! for m = 1:9
%!   q = quantile (x, p, 1, m);
%!   assert (q, a(m,:), 0.0001);
%! endfor

%!test
%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
%! x = [16; 11; 15; 12; 15;  8; 11; 12;  6; 10];
%! a = [6.0000   10.0000   11.0000   15.0000   16.0000
%!      6.0000   10.0000   11.5000   15.0000   16.0000
%!      6.0000    8.0000   11.0000   15.0000   16.0000
%!      6.0000    9.0000   11.0000   13.5000   16.0000
%!      6.0000   10.0000   11.5000   15.0000   16.0000
%!      6.0000    9.5000   11.5000   15.0000   16.0000
%!      6.0000   10.2500   11.5000   14.2500   16.0000
%!      6.0000    9.8333   11.5000   15.0000   16.0000
%!      6.0000    9.8750   11.5000   15.0000   16.0000];
%! for m = 1:9
%!   q = quantile (x, p, 1, m);
%!   assert (q, a(m,:), 0.0001);
%! endfor

%!test
%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
%! x = [-0.58851;  0.40048;  0.49527; -2.551500; -0.52057; ...
%!      -0.17841; 0.057322; -0.62523;  0.042906;  0.12337];
%! a = [-2.551474  -0.588505  -0.178409   0.123366   0.495271
%!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
%!      -2.551474  -0.625231  -0.178409   0.123366   0.495271
%!      -2.551474  -0.606868  -0.178409   0.090344   0.495271
%!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
%!      -2.551474  -0.597687  -0.067751   0.192645   0.495271
%!      -2.551474  -0.571522  -0.067751   0.106855   0.495271
%!      -2.551474  -0.591566  -0.067751   0.146459   0.495271
%!      -2.551474  -0.590801  -0.067751   0.140686   0.495271];
%! for m = 1:9
%!   q = quantile (x, p, 1, m);
%!   assert (q, a(m,:), 0.0001);
%! endfor

%!test
%! p = 0.5;
%! x = [0.112600, 0.114800, 0.052100, 0.236400, 0.139300
%!      0.171800, 0.727300, 0.204100, 0.453100, 0.158500
%!      0.279500, 0.797800, 0.329600, 0.556700, 0.730700
%!      0.428800, 0.875300, 0.647700, 0.628700, 0.816500
%!      0.933100, 0.931200, 0.963500, 0.779600, 0.846100];
%! tol = 0.00001;
%! x(5,5) = NaN;
%! assert (quantile (x, p, 1),
%!         [0.27950, 0.79780, 0.32960, 0.55670, 0.44460], tol);
%! x(1,1) = NaN;
%! assert (quantile (x, p, 1),
%!         [0.35415, 0.79780, 0.32960, 0.55670, 0.44460], tol);
%! x(3,3) = NaN;
%! assert (quantile (x, p, 1),
%!         [0.35415, 0.79780, 0.42590, 0.55670, 0.44460], tol);

%!test
%! sx = [2, 3, 4];
%! x = rand (sx);
%! dim = 2;
%! p = 0.5;
%! yobs = quantile (x, p, dim);
%! yexp = median (x, dim);
%! assert (yobs, yexp);

%!assert <*45455> (quantile ([1 3 2], 0.5, 1), [1 3 2])
%!assert <*54421> (quantile ([1:10], 0.5, 1), 1:10)
%!assert <*54421> (quantile ([1:10]', 0.5, 2), [1:10]')
%!assert <*54421> (quantile ([1:10], [0.25, 0.75]), [3, 8])
%!assert <*54421> (quantile ([1:10], [0.25, 0.75]'), [3; 8])
%!assert (quantile ([1:10], 1, 3), [1:10])

## Test input validation
%!error <Invalid call> quantile ()
%!error quantile (['A'; 'B'], 10)
%!error quantile (1:10, [true, false])
%!error quantile (1:10, ones (2,2))
%!error quantile (1, 1, 1.5)
%!error quantile (1, 1, 0)
%!error quantile ((1:5)', 0.5, 1, 0)
%!error quantile ((1:5)', 0.5, 1, 10)

## For the cumulative probability values in @var{p}, compute the
## quantiles, @var{q} (the inverse of the cdf), for the sample, @var{x}.
##
## The optional input, @var{method}, refers to nine methods available in R
## (https://www.r-project.org/).  The default is @var{method} = 7.
## @seealso{prctile, quantile, statistics}

## Description: Quantile function of empirical samples
function inv = __quantile__ (x, p, method = 5)

  if (nargin < 2)
    print_usage ("quantile");
  endif

  if (isinteger (x) || islogical (x))
    x = double (x);
  endif

  ## set shape of quantiles to column vector.
  p = p(:);

  ## Save length and set shape of samples.
  x = sort (x, 1);
  m = sum (! isnan (x));
  [xr, xc] = size (x);

  ## Initialize output values.
  inv = Inf (class (x)) * (-(p < 0) + (p > 1));
  inv = repmat (inv, 1, xc);

  ## Do the work.
  if (any (k = find ((p >= 0) & (p <= 1))))
    n = length (k);
    p = p(k);
    ## Special case of 1 row.
    if (xr == 1)
      inv(k,:) = repmat (x, n, 1);
      return;
    endif

    ## The column-distribution indices.
    pcd = kron (ones (n, 1), xr*(0:xc-1));
    mm = kron (ones (n, 1), m);
    switch (method)
      case {1, 2, 3}
        switch (method)
          case 1
            p = max (ceil (kron (p, m)), 1);
            inv(k,:) = x(p + pcd);

          case 2
            p = kron (p, m);
            p_lr = max (ceil (p), 1);
            p_rl = min (floor (p + 1), mm);
            inv(k,:) = (x(p_lr + pcd) + x(p_rl + pcd))/2;

          case 3
           ## Used by SAS, method PCTLDEF=2.
           ## http://support.sas.com/onlinedoc/913/getDoc/en/statug.hlp/stdize_sect14.htm
            t = max (kron (p, m), 1);
            t = roundb (t);
            inv(k,:) = x(t + pcd);
        endswitch

      otherwise
        switch (method)
          case 4
            p = kron (p, m);

          case 5
            ## Used by Matlab.
            p = kron (p, m) + 0.5;

          case 6
            ## Used by Minitab and SPSS.
            p = kron (p, m+1);

          case 7
            ## Used by S and R.
            p = kron (p, m-1) + 1;

          case 8
            ## Median unbiased.
            p = kron (p, m+1/3) + 1/3;

          case 9
            ## Approximately unbiased respecting order statistics.
            p = kron (p, m+0.25) + 0.375;

          otherwise
            error ("quantile: Unknown METHOD, '%d'", method);
        endswitch

        ## Duplicate single values.
        imm1 = (mm(1,:) == 1);
        x(2,imm1) = x(1,imm1);

        ## Interval indices.
        pi = max (min (floor (p), mm-1), 1);
        pr = max (min (p - pi, 1), 0);
        pi += pcd;
        inv(k,:) = (1-pr) .* x(pi) + pr .* x(pi+1);
    endswitch
  endif

endfunction
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} range (@var{x})
## @deftypefnx {} {} range (@var{x}, @var{dim})
## Return the range, i.e., the difference between the maximum and the minimum
## of the input data.
##
## If @var{x} is a vector, the range is calculated over the elements of
## @var{x}.  If @var{x} is a matrix, the range is calculated over each column
## of @var{x}.
##
## If the optional argument @var{dim} is given, operate along this dimension.
##
## The range is a quickly computed measure of the dispersion of a data set, but
## is less accurate than @code{iqr} if there are outlying data points.
## @seealso{bounds, iqr, mad, std}
## @end deftypefn

function y = range (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (nargin == 1)
    y = max (x) - min (x);
  else
    y = max (x, [], dim) - min (x, [], dim);
  endif

endfunction


%!assert (range (1:10), 9)
%!assert (range (single (1:10)), single (9))
%!assert (range (magic (3)), [5, 8, 5])
%!assert (range (magic (3), 2), [7; 4; 7])
%!assert (range (2), 0)

## Test input validation
%!error <Invalid call> range ()
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} ranks (@var{x})
## @deftypefnx {} {} ranks (@var{x}, @var{dim})
## @deftypefnx {} {} ranks (@var{x}, @var{dim}, @var{rtype})
## Return the ranks (in the sense of order statistics) of @var{x} along the
## first non-singleton dimension adjusted for ties.
##
## If the optional @var{dim} argument is given, operate along this dimension.
##
## The optional parameter @var{rtype} determines how ties are handled.  All
## examples below assume an input of @code{[ 1, 2, 2, 4 ]}.
##
## @table @asis
## @item 0 or @qcode{"fractional"} (default) for fractional ranking (1, 2.5,
## 2.5, 4);
##
## @item 1 or @qcode{"competition"} for competition ranking (1, 2, 2, 4);
##
## @item 2 or @qcode{"modified"} for modified competition ranking (1, 3, 3, 4);
##
## @item 3 or @qcode{"ordinal"} for ordinal ranking (1, 2, 3, 4);
##
## @item 4 or @qcode{"dense"} for dense ranking (1, 2, 2, 3).
## @end table
##
## @seealso{spearman, kendall}
## @end deftypefn

function y = ranks (x, dim, rtype = 0)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("ranks: X must be a numeric vector or matrix");
  endif

  nd = ndims (x);
  sz = size (x);

  if (nargin < 2 || isempty (dim))
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("ranks: DIM must be an integer and a valid dimension");
    endif
  endif

  if (sz(dim) == 1)
    y = ones (sz);  # dimension DIM is singleton, so all are ranked first.
  else
    ## The algorithm works only on dim = 1, so permute if necessary.
    ## FIXME: Most all functions now accept a dim argument.
    ##        Would it be faster not to permute and use the dim argument
    ##        to sort, find, cumsum, etc.?
    if (dim != 1)
      perm = [1 : nd];
      perm(1) = dim;
      perm(dim) = 1;
      x = permute (x, perm);
      sz = size (x);
    endif

    [sx, ids] = sort (x);  # sx is sorted x.
    lin = repmat ((1:rows (x))', [1, sz(2:end)]);  # linearly increasing array.

    switch (rtype)
      case {0, "fractional"};
        lin = (_competition (lin, sx, sz) + _modified (lin, sx, sz)) / 2;
      case {1, "competition"};
        lin = _competition (lin, sx, sz);
      case {2, "modified"};
        lin = _modified (lin, sx, sz);
      case {3, "ordinal"};
        ## no processing needed here.
      case {4, "dense"};
        lin = _dense (lin, sx, sz);
      otherwise
        if (! ischar (rtype))
          rtype = num2str (rtype);
        endif
        error ("ranks: unknown RTYPE '%s'", rtype);
    endswitch

    y = NaN (size (lin));

    ## Offsets to map indices into each column to indices into the linear array.
    ## FIXME: Would sub2ind be faster here?
    idf = zeros (sz);
    idf(1, :) = 0 : sz(1) : (numel (ids)-1);
    idf(:, :) = repmat (idf(1, :), [sz(1), ones(1,length(sz)-1)]);
    y(ids + idf) = lin;

    if (dim != 1)
      y = permute (y, perm);
    endif
  endif

endfunction

function linnew = _dense (lin, sx, sz)
  infvec = -Inf ([1, sz(2:end)]);
  fnewp = logical (diff ([infvec; sx]));
  linnew = cumsum (fnewp, 1);
endfunction

function linnew = _competition (lin, sx, sz)

  ## Stop increasing lin when sx does not increase.  Otherwise, same as before.
  infvec = -Inf ([1, sz(2:end)]);
  fnewp = find (diff ([infvec; sx]));
  linnew = zeros (size (lin));
  linnew(fnewp) = lin(fnewp);
  linnew = cummax (linnew, 1);

endfunction

function linnew = _modified (lin, sx, sz)

  ## Traverse lin backwards.  Stop decreasing it when sx doesn't decrease.
  infvec = Inf ([1, sz(2:end)]);
  fnewp = find (diff ([sx; infvec]));
  linnew = Inf (size (lin));
  linnew(fnewp) = lin(fnewp);
  linnew = flip (cummin (flip (linnew, 1)), 1);

endfunction


%!assert (ranks (1:2:10), 1:5)
%!assert (ranks (10:-2:1), 5:-1:1)
%!assert (ranks ([2, 1, 2, 4]), [2.5, 1, 2.5, 4])
%!assert (ranks (ones (1, 5)), 3*ones (1, 5))
%!assert (ranks (1e6*ones (1, 5)), 3*ones (1, 5))
%!assert (ranks (rand (1, 5), 1), ones (1, 5))

%!assert (ranks ([1, 2, 2, 4], [], "fractional"), [1, 2.5, 2.5, 4])
%!assert (ranks ([1, 2, 2, 4], [], "competition"), [1, 2, 2, 4])
%!assert (ranks ([1, 2, 2, 4], [], "modified"), [1, 3, 3, 4])
%!assert (ranks ([1, 2, 2, 4], [], "ordinal"), [1, 2, 3, 4])
%!assert (ranks ([1, 2, 2, 4], [], "dense"), [1, 2, 2, 3])

## Test input validation
%!error <Invalid call> ranks ()
%!error <X must be a numeric vector or matrix> ranks ({1, 2})
%!error <X must be a numeric vector or matrix> ranks (['A'; 'B'])
%!error <DIM must be an integer> ranks (1, 1.5)
%!error <DIM must be .* a valid dimension> ranks (1, 0)
%!error <unknown RTYPE 'foobar'> ranks (ones (2), 1, "foobar")
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} run_count (@var{x}, @var{n})
## @deftypefnx {} {} run_count (@var{x}, @var{n}, @var{dim})
## Count the upward runs along the first non-singleton dimension of @var{x}
## of length 1, 2, @dots{}, @var{n}-1 and greater than or equal to @var{n}.
##
## If the optional argument @var{dim} is given then operate along this
## dimension.
## @seealso{runlength}
## @end deftypefn

function retval = run_count (x, n, dim)

  if (nargin < 2)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("run_count: X must be a numeric vector or matrix");
  endif

  if (!(isscalar (n) && n == fix (n) && n > 0))
    error ("run_count: N must be a positive integer");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin != 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("run_count: DIM must be an integer and a valid dimension");
    endif
  endif

  ## Algorithm works on rows.  Permute array if necessary, ipermute back at end
  if (dim != 1)
    perm = [1 : nd];
    perm(1) = dim;
    perm(dim) = 1;
    x = permute (x, perm);
  endif

  sz = size (x);
  idx = cell ();
  for i = 1 : nd
    idx{i} = 1 : sz(i);
  endfor
  c = sz(1);
  tmp = zeros ([c + 1, sz(2 : end)]);
  infvec = Inf ([1, sz(2 : end)]);

  ind = find (diff ([infvec; x; -infvec]) < 0);
  tmp(ind(2:end) - 1) = diff (ind);
  tmp = tmp(idx{:});

  sz(1) = n;
  retval = zeros (sz);
  for k = 1 : (n-1)
    idx{1} = k;
    retval(idx{:}) = sum (tmp == k);
  endfor
  idx{1} = n;
  retval(idx{:}) = sum (tmp >= n);

  if (dim != 1)
    retval = ipermute (retval, perm);
  endif

endfunction


%!assert (run_count (magic (3), 4), [1,0,1;1,0,1;0,1,0;0,0,0])
%!assert (run_count (magic (3), 4, 2), [1,0,1;1,0,1;0,1,0;0,0,0]')
%!assert (run_count (5:-1:1, 5), [5, 0, 0, 0, 0])
%!assert (run_count (ones (3), 4), [0,0,0;0,0,0;1,1,1;0,0,0])

## Test input validation
%!error <Invalid call> run_count ()
%!error <Invalid call> run_count (1)
%!error run_count ({1, 2}, 3)
%!error run_count (['A'; 'A'; 'B'], 3)
%!error run_count (1:5, ones (2,2))
%!error run_count (1:5, 1.5)
%!error run_count (1:5, -2)
%!error run_count (1:5, 3, ones (2,2))
%!error run_count (1:5, 3, 1.5)
%!error run_count (1:5, 3, 0)
########################################################################
##
## Copyright (C) 2005-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {count =} runlength (@var{x})
## @deftypefnx {} {[count, value] =} runlength (@var{x})
## Find the lengths of all sequences of common values.
##
## @var{count} is a vector with the lengths of each repeated value.
##
## The optional output @var{value} contains the value that was repeated in
## the sequence.
##
## @example
## @group
## runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
## @result{}   2   1   3   1   4
## @end group
## @end example
## @seealso{run_count}
## @end deftypefn

function [count, value] = runlength (x)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)) || ! isvector (x))
    error ("runlength: X must be a numeric vector");
  endif

  if (iscolumn (x))
    x = x.';
  endif

  idx = [find(x(1:end-1) != x(2:end)), length(x)];
  count = diff ([0 idx]);
  if (nargout == 2)
    value = x(idx);
  endif

endfunction


%!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]), [2 1 3 1 4])
%!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]'), [2 1 3 1 4])
%!test
%! [c, v] = runlength ([2 2 0 4 4 4 0 1 1 1 1]);
%! assert (c, [2 1 3 1 4]);
%! assert (v, [2 0 4 0 1]);

## Test input validation
%!error <Invalid call> runlength ()
%!error runlength (['A'; 'B'])
%!error runlength (ones (2,2))
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} skewness (@var{x})
## @deftypefnx {} {} skewness (@var{x}, @var{flag})
## @deftypefnx {} {} skewness (@var{x}, @var{flag}, @var{dim})
## Compute the sample skewness of the elements of @var{x}.
##
## The sample skewness is defined as
## @tex
## $$
## {\rm skewness} (@var{x}) = {{{1\over N}\,
##          \sum_{i=1}^N (x_i - \bar{x})^3} \over \sigma^3},
## $$
## where $N$ is the length of @var{x}, $\bar{x}$ its mean and $\sigma$
## its (uncorrected) standard deviation.
## @end tex
## @ifnottex
##
## @example
## @group
##                mean ((@var{x} - mean (@var{x})).^3)
## skewness (@var{X}) = ------------------------.
##                       std (@var{x}).^3
## @end group
## @end example
##
## @end ifnottex
##
## @noindent
## The optional argument @var{flag} controls which normalization is used.
## If @var{flag} is equal to 1 (default value, used when @var{flag} is omitted
## or empty), return the sample skewness as defined above.  If @var{flag} is
## equal to 0, return the adjusted skewness coefficient instead:
## @tex
## $$
## {\rm skewness} (@var{x}) = {\sqrt{N (N - 1)} \over N - 2} \times \,
##   {{{1 \over N} \sum_{i=1}^N (x_i - \bar{x})^3} \over \sigma^3}
## $$
## @end tex
## @ifnottex
##
## @example
## @group
##                   sqrt (N*(N-1))   mean ((@var{x} - mean (@var{x})).^3)
## skewness (@var{X}, 0) = -------------- * ------------------------.
##                       (N - 2)             std (@var{x}).^3
## @end group
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} vector.
##
## @end ifnottex
## The adjusted skewness coefficient is obtained by replacing the sample second
## and third central moments by their bias-corrected versions.
##
## If @var{x} is a matrix, or more generally a multi-dimensional array, return
## the skewness along the first non-singleton dimension.  If the optional
## @var{dim} argument is given, operate along this dimension.
##
## @seealso{var, kurtosis, moment}
## @end deftypefn

function y = skewness (x, flag, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("skewness: X must be a numeric vector or matrix");
  endif

  if (nargin < 2 || isempty (flag))
    flag = 1;  # default: do not use the "bias corrected" version
  elseif (! isscalar (flag) || (flag != 0 && flag != 1))
    error ("skewness: FLAG must be 0 or 1");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      error ("skewness: DIM must be an integer and a valid dimension");
    endif
  endif

  n = size (x, dim);
  sz(dim) = 1;

  x = center (x, dim);   # center also promotes integer, logical to double
  s = std (x, 1, dim);   # Normalize with 1/N
  y = sum (x .^ 3, dim);
  idx = (s != 0);
  y(idx) ./= (n * s(idx) .^ 3);
  y(! idx) = NaN;

  ## Apply bias correction to the second and third central sample moment
  if (flag == 0)
    if (n > 2)
      y *= sqrt (n * (n - 1)) / (n - 2);
    else
      y(:) = NaN;
    endif
  endif

endfunction


%!assert (skewness ([-1, 0, 1]), 0)
%!assert (skewness ([-2, 0, 1]) < 0)
%!assert (skewness ([-1, 0, 2]) > 0)
%!assert (skewness ([-3, 0, 1]) == -1 * skewness ([-1, 0, 3]))
%!assert (skewness (ones (3, 5)), NaN (1, 5))
%!assert (skewness (1, [], 3), NaN)

%!test
%! x = [0; 0; 0; 1];
%! y = [x, 2*x];
%! assert (skewness (y), 1.154700538379251 * [1 1], 5*eps);

%!assert (skewness ([1:5 10; 1:5 10],  0, 2), 1.439590274527954 * [1; 1], eps)
%!assert (skewness ([1:5 10; 1:5 10],  1, 2), 1.051328089232020 * [1; 1], 2*eps)
%!assert (skewness ([1:5 10; 1:5 10], [], 2), 1.051328089232020 * [1; 1], 2*eps)

## Test behavior on single input
%!assert (skewness (single ([1:5 10])), single (1.0513283), eps ("single"))
%!assert (skewness (single ([1 2]), 0), single (NaN))

## Verify no warnings
%!test
%! lastwarn ("");  # clear last warning
%! skewness (1);
%! assert (lastwarn (), "");

## Test input validation
%!error <Invalid call> skewness ()
%!error <X must be a numeric vector or matrix> skewness (['A'; 'B'])
%!error <FLAG must be 0 or 1> skewness (1, 2)
%!error <FLAG must be 0 or 1> skewness (1, [1 0])
%!error <DIM must be an integer> skewness (1, [], ones (2,2))
%!error <DIM must be an integer> skewness (1, [], 1.5)
%!error <DIM must be .* a valid dimension> skewness (1, [], 0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} spearman (@var{x})
## @deftypefnx {} {} spearman (@var{x}, @var{y})
## @cindex Spearman's Rho
## Compute Spearman's rank correlation coefficient
## @tex
## $\rho$.
## @end tex
## @ifnottex
## @var{rho}.
## @end ifnottex
##
## For two data vectors @var{x} and @var{y}, Spearman's
## @tex
## $\rho$
## @end tex
## @ifnottex
## @var{rho}
## @end ifnottex
## is the correlation coefficient of the ranks of @var{x} and @var{y}.
##
## If @var{x} and @var{y} are drawn from independent distributions,
## @tex
## $\rho$
## @end tex
## @ifnottex
## @var{rho}
## @end ifnottex
## has zero mean and variance
## @tex
## $1 / (N - 1)$,
## @end tex
## @ifnottex
## @code{1 / (N - 1)},
## @end ifnottex
## where @math{N} is the length of the @var{x} and @var{y} vectors, and is
## asymptotically normally distributed.
##
## @code{spearman (@var{x})} is equivalent to
## @code{spearman (@var{x}, @var{x})}.
## @seealso{ranks, kendall}
## @end deftypefn

function rho = spearman (x, y = [])

  if (nargin < 1)
    print_usage ();
  endif

  if (   ! (isnumeric (x) || islogical (x))
      || ! (isnumeric (y) || islogical (y)))
    error ("spearman: X and Y must be numeric matrices or vectors");
  endif

  if (ndims (x) != 2 || ndims (y) != 2)
    error ("spearman: X and Y must be 2-D matrices or vectors");
  endif

  if (isrow (x))
    x = x.';
  endif

  if (nargin == 1)
    rho = corr (ranks (x));
  else
    if (isrow (y))
      y = y.';
    endif
    if (rows (x) != rows (y))
      error ("spearman: X and Y must have the same number of observations");
    endif
    rho = corr (ranks (x), ranks (y));
  endif

  ## Restore class cleared by ranks
  if (isa (x, "single") || isa (y, "single"))
    rho = single (rho);
  endif

endfunction


%!test
%! x = 1:10;
%! y = exp (x);
%! assert (spearman (x,y), 1, 5*eps);
%! assert (spearman (x,-y), -1, 5*eps);

%!assert (spearman ([1 2 3], [-1 1 -2]), -0.5, 5*eps)

## Test input validation
%!error <Invalid call> spearman ()
%!error spearman (['A'; 'B'])
%!error spearman (ones (1,2), {1, 2})
%!error spearman (ones (2,2,2))
%!error spearman (ones (2,2), ones (2,2,2))
%!error spearman (ones (2,2), ones (3,2))
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} statistics (@var{x})
## @deftypefnx {} {} statistics (@var{x}, @var{dim})
## Return a vector with the minimum, first quartile, median, third quartile,
## maximum, mean, standard deviation, skewness, and kurtosis of the elements of
## the vector @var{x}.
##
## If @var{x} is a matrix, calculate statistics over the first non-singleton
## dimension.
##
## If the optional argument @var{dim} is given, operate along this dimension.
## @seealso{min, max, median, mean, std, skewness, kurtosis}
## @end deftypefn

function stats = statistics (x, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("statistics: X must be a numeric vector or matrix");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin != 2)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("statistics: DIM must be an integer and a valid dimension");
    endif
  endif

  if (sz(dim) < 2)
    error ("statistics: dimension of X is too small (<2)");
  endif

  emp_inv = quantile (x, [0.25; 0.5; 0.75], dim, 7);

  stats = cat (dim, min (x, [], dim), emp_inv, max (x, [], dim), mean (x, dim),
               std (x, [], dim), skewness (x, [], dim), kurtosis (x, [], dim));

endfunction


%!test
%! x = rand (7,5);
%! s = statistics (x);
%! assert (min (x), s(1,:), eps);
%! assert (median (x), s(3,:), eps);
%! assert (max (x), s(5,:), eps);
%! assert (mean (x), s(6,:), eps);
%! assert (std (x), s(7,:), eps);
%! assert (skewness (x), s(8,:), eps);
%! assert (kurtosis (x), s(9,:), eps);

%! x = rand (7,5);
%! s = statistics (x, 2);
%! assert (min (x, [], 2), s(:,1), eps);
%! assert (median (x, 2), s(:,3), eps);
%! assert (max (x, [], 2), s(:,5), eps);
%! assert (mean (x, 2), s(:,6), eps);
%! assert (std (x, [], 2), s(:,7), eps);
%! assert (skewness (x, [], 2), s(:,8), eps);
%! assert (kurtosis (x, [], 2), s(:,9), eps);

## Test input validation
%!error <Invalid call> statistics ()
%!error statistics (['A'; 'B'])
%!error statistics (1, ones (2,2))
%!error statistics (1, 1.5)
%!error statistics (1, 0)
%!error statistics (1, 3)
%!error statistics (1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} std (@var{x})
## @deftypefnx {} {} std (@var{x}, @var{w})
## @deftypefnx {} {} std (@var{x}, @var{w}, @var{dim})
## @deftypefnx {} {} std (@var{x}, @var{w}, @qcode{"ALL"})
## Compute the standard deviation of the elements of the vector @var{x}.
##
## The standard deviation is defined as
## @tex
## $$
## {\rm std} (x) = \sigma = \sqrt{{\sum_{i=1}^N (x_i - \bar{x})^2 \over N - 1}}
## $$
## where $\bar{x}$ is the mean value of @var{x} and $N$ is the number of elements of @var{x}.
## @end tex
## @ifnottex
##
## @example
## @group
## std (@var{x}) = sqrt ( 1/(N-1) SUM_i (@var{x}(i) - mean(@var{x}))^2 )
## @end group
## @end example
##
## @noindent
## where @math{N} is the number of elements of the @var{x} vector.
## @end ifnottex
##
## If @var{x} is an array, compute the standard deviation for each column and
## return them in a row vector (or for an n-D array, the result is returned as
## an array of dimension 1 x n x m x @dots{}).
##
## The optional argument @var{w} determines the weighting scheme to use.  Valid
## values are:
##
## @table @asis
## @item 0 [default]:
## Normalize with @math{N-1}.  This provides the square root of the best
## unbiased estimator of the variance.
##
## @item 1:
## Normalize with @math{N}. This provides the square root of the second moment
## around the mean.
##
## @item a vector:
## Compute the weighted standard deviation with nonnegative scalar weights. The
## length of @var{w} must be equal to the size of @var{x} along dimension
## @var{dim}.
## @end table
##
## If @math{N} is equal to 1 the value of @var{W} is ignored and
## normalization by @math{N} is used.
##
## The optional variable @var{dim} forces @code{std} to operate over the
## specified dimension.  @var{dim} can either be a scalar dimension or a vector
## of non-repeating dimensions over which to operate.  Dimensions must be
## positive integers, and the standard deviation is calculated over the array
## slice defined by @var{dim}.
##
## Specifying dimension @qcode{"ALL"} will force @code{std} to operate on all
## elements of @var{x}, and is equivalent to @code{std (@var{x}(:))}.
##
## When @var{dim} is a vector or @qcode{"ALL"}, @var{w} must be either 0 or 1.
## @seealso{var, bounds, mad, range, iqr, mean, median}
## @end deftypefn

function retval = std (varargin)

  retval = sqrt (var (varargin{:}));

endfunction


%!test
%! x = ones (10, 2);
%! y = [1, 3];
%! assert (std (x), [0, 0]);
%! assert (std (y), sqrt (2), sqrt (eps));
%! assert (std (x, 0, 2), zeros (10, 1));

%!assert (std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2))
%!assert (std ([1 2], 0), sqrt (2)/2, 5*eps)
%!assert (std ([1 2], 1), 0.5, 5*eps)
%!assert (std (1), 0)
%!assert (std (single (1)), single (0))
%!assert (std ([1 2 3], [], 3), [0 0 0])

##Test empty inputs
%!assert (std ([]), NaN)
%!assert (std ([],[],1), NaN(1,0))
%!assert (std ([],[],2), NaN(0,1))
%!assert (std ([],[],3), [])
%!assert (std (ones (0,1)), NaN)
%!assert (std (ones (1,0)), NaN)
%!assert (std (ones (1,0), [], 1), NaN(1,0))
%!assert (std (ones (1,0), [], 2), NaN)
%!assert (std (ones (1,0), [], 3), NaN(1,0))
%!assert (std (ones (0,1)), NaN)
%!assert (std (ones (0,1), [], 1), NaN)
%!assert (std (ones (0,1), [], 2), NaN(0,1))
%!assert (std (ones (0,1), [], 3), NaN(0,1))
%!assert (std (ones (1,3,0,2)), NaN(1,1,0,2))
%!assert (std (ones (1,3,0,2), [], 1), NaN(1,3,0,2))
%!assert (std (ones (1,3,0,2), [], 2), NaN(1,1,0,2))
%!assert (std (ones (1,3,0,2), [], 3), NaN(1,3,1,2))
%!assert (std (ones (1,3,0,2), [], 4), NaN(1,3,0))


## Test input validation
%!error <Invalid call> std ()
%!error <X must be a numeric> std (['A'; 'B'])
%!error <W must be 0> std ([1 2], 2)
%!error <DIM must be a positive integer> std (1, [], ones (2,2))
%!error <DIM must be a positive integer> std (1, [], 1.5)
%!error <DIM must be a positive integer> std (1, [], 0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} var (@var{x})
## @deftypefnx {} {} var (@var{x}, @var{w})
## @deftypefnx {} {} var (@var{x}, @var{w}, @var{dim})
## @deftypefnx {} {} var (@var{x}, @var{w}, @qcode{"ALL"})
## Compute the variance of the elements of the vector @var{x}.
##
## The variance is defined as
## @tex
## $$
## {\rm var} (x) = \sigma^2 = {\sum_{i=1}^N (x_i - \bar{x})^2 \over N - 1}
## $$
## where $\bar{x}$ is the mean value of @var{x} and $N$ is the number of
## elements of @var{x}.
##
## @end tex
## @ifnottex
##
## @example
## @group
## var (@var{x}) = 1/(N-1) SUM_i (@var{x}(i) - mean(@var{x}))^2
## @end group
## @end example
##
## @noindent
## where @math{N} is the length of the @var{x} vector.
##
## @end ifnottex
## If @var{x} is an array, compute the variance for each column and return
## them in a row vector (or for an n-D array, the result is returned as
## an array of dimension 1 x n x m x @dots{}).
##
## The optional argument @var{w} determines the weighting scheme to use.  Valid
## values are
##
## @table @asis
## @item 0 [default]:
## Normalize with @math{N-1}.  This provides the square root of the best
## unbiased estimator of the variance.
##
## @item 1:
## Normalize with @math{N}, this provides the square root of the second moment
## around the mean
##
## @item a vector:
## Compute the weighted variance with nonnegative scalar weights.  The length of
## @var{w} must be equal to the size of @var{x} along dimension @var{dim}.
## @end table
##
## If @math{N} is equal to 1 the value of @var{W} is ignored and
## normalization by @math{N} is used.
##
## The optional variable @var{dim} forces @code{var} to operate over the
## specified dimension.  @var{dim} can either be a scalar dimension or a vector
## of non-repeating dimensions over which to operate.  Dimensions must be
## positive integers, and the variance is calculated over the array slice
## defined by @var{dim}.
##
## Specifying dimension @qcode{"ALL"} will force @code{var} to operate on all
## elements of @var{x}, and is equivalent to @code{var (@var{x}(:))}.
##
## When @var{dim} is a vector or @qcode{"ALL"}, @var{w} must be either 0 or 1.
## @seealso{cov, std, skewness, kurtosis, moment}
## @end deftypefn

function retval = var (x, w = 0, dim)

  if (nargin < 1)
    print_usage ();
  elseif (nargin < 3)
    dim = [];
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("var: X must be a numeric vector or matrix");
  endif

  nd = ndims (x);
  sz = size (x);
  emptydimflag = false;

  if (isempty (dim))
    emptydimflag = true;  ## Compatibliity hack for empty x, ndims==2
    ## Find the first non-singleton dimension.
   (dim = find (sz != 1, 1)) || (dim = 1);

  else
    if (! (isscalar (dim) && dim == fix (dim) && dim > 0))
      if (isvector (dim) &&
          isnumeric (dim) &&
          all (dim > 0) &&
          all (rem (dim, 1) == 0))
        if (dim != unique (dim, "stable"))
          error (["var: vector DIM must contain non-repeating positive"...
                  "integers"]);
        endif
        ## Check W
        if (! isscalar (w))
          error ("var: W must be either 0 or 1 when DIM is a vector");
        endif

        ## Reshape X to compute the variance over an array slice
        if (iscolumn (dim))
          dim = transpose (dim);
        endif

        collapsed_dims = dim;
        dim = dim(end);

        ## Permute X to cluster the dimensions to collapse
        highest_dim = max ([nd, collapsed_dims]);
        perm_start = perm_end = [1:highest_dim];
        perm_start(dim:end) = [];
        perm_start(ismember (perm_start, collapsed_dims)) = [];
        perm_end(1:dim) = [];
        perm_end(ismember (perm_end, collapsed_dims)) = [];
        perm = [perm_start, collapsed_dims, perm_end];

        x = permute (x, perm);

        ## Collapse the given dimensions
        newshape = ones (1, highest_dim);
        newshape(1:nd) = sz;
        newshape(collapsed_dims(1:(end - 1))) = 1;
        newshape(dim) = prod (sz(collapsed_dims));

        ## New X with collapsed dimensions
        x = reshape (x, newshape);
      elseif (ischar (dim) &&
              strcmp (tolower (dim), "all"))
        ## Check W
        if (! isscalar (w))
          error ("var: W must be either 0 or 1 when using 'ALL' as dimension");
        endif

        ## "ALL" equals to collapsing all elements to a single vector
        x = x(:);
        dim = 1;
        sz = size (x);
      else
        error ("var: DIM must be a positive integer scalar, vector, or 'all'");
      endif
    endif
  endif

  n = size (x, dim);
  if (isempty (w))
    w = 0;
  elseif (! isvector (w) ||
          ! isnumeric (w) ||
          (isvector (w) && any (w < 0)) ||
          (isscalar (w) && ((w != 0 && w != 1) && (n != 1))))
    error ("var: W must be 0, 1, or a vector of positive integers");
  endif

  if (isempty (x))
    if (emptydimflag && isequal (sz, [0 0]))
      retval = NaN;
    else
      output_size = sz;
      output_size(dim) = 1;
      retval = NaN(output_size);
    endif
  else
    if (n == 1)
      if (! isscalar (w))
        error (["var: the length of W must be equal to the size of X "...
                  "in the dimension along which variance is calculated"])
      else
        if (isa (x, "single"))
          retval = zeros (sz, "single");
        else
          retval = zeros (sz);
        endif
      endif
    else
      if (isscalar (w))
        retval = sumsq (center (x, dim), dim) / (n - 1 + w);
      else
        ## Weighted variance
        if (length (w) != n)
          error (["var: the length of W must be equal to the size of X "...
                  "in the dimension along which variance is calculated"]);
        else
          if ((dim == 1 && rows (w) == 1) ||
              (dim == 2 && columns (w) == 1))
            w = transpose (w);
          elseif (dim > 2)
            newdims = [(ones (1, (dim - 1))), (length (w))];
            w = reshape (w, newdims);
          endif
          den = sum (w);
          mu = sum (w .* x, dim) ./ sum (w);
          retval = sum (w .* ((x - mu) .^ 2), dim) / den;
        endif
      endif
    endif
  endif

endfunction

%!assert (var (13), 0)
%!assert (var (single (13)), single (0))
%!assert (var ([1,2,3]), 1)
%!assert (var ([1,2,3], 1), 2/3, eps)
%!assert (var ([1,2,3], [], 1), [0,0,0])
%!assert (var ([1,2,3], [], 3), [0,0,0])
%!assert (var (5, 99), 0)
%!assert (var (5, 99, 1), 0)
%!assert (var (5, 99, 2), 0)
%!assert (var ([1:7], [1:7]), 3)
%!assert (var ([eye(3)], [1:3]), [5/36, 2/9, 1/4], eps)
%!assert (var (ones (2,2,2), [1:2], 3), [(zeros (2,2))])
%!assert (var ([1 2; 3 4], 0, 'all'), var ([1:4]))
%!assert (var (reshape ([1:8], 2, 2, 2), 0, [1 3]), [17/3 17/3], eps)

##Test empty inputs
%!assert (var ([]), NaN)
%!assert (var ([],[],1), NaN(1,0))
%!assert (var ([],[],2), NaN(0,1))
%!assert (var ([],[],3), [])
%!assert (var (ones (0,1)), NaN)
%!assert (var (ones (1,0)), NaN)
%!assert (var (ones (1,0), [], 1), NaN(1,0))
%!assert (var (ones (1,0), [], 2), NaN)
%!assert (var (ones (1,0), [], 3), NaN(1,0))
%!assert (var (ones (0,1)), NaN)
%!assert (var (ones (0,1), [], 1), NaN)
%!assert (var (ones (0,1), [], 2), NaN(0,1))
%!assert (var (ones (0,1), [], 3), NaN(0,1))
%!assert (var (ones (1,3,0,2)), NaN(1,1,0,2))
%!assert (var (ones (1,3,0,2), [], 1), NaN(1,3,0,2))
%!assert (var (ones (1,3,0,2), [], 2), NaN(1,1,0,2))
%!assert (var (ones (1,3,0,2), [], 3), NaN(1,3,1,2))
%!assert (var (ones (1,3,0,2), [], 4), NaN(1,3,0))

## Test input validation
%!error <Invalid call> var ()
%!error <X must be a numeric> var (['A'; 'B'])
%!error <W must be 0> var ([1 2 3], 2)
%!error <W must be .* a vector of positive integers> var ([1 2], [-1 0])
%!error <W must be .* a vector of positive integers> var ([1 2], eye (2))
%!error <W must be either 0 or 1> var (ones (2, 2), [1 2], [1 2])
%!error <W must be either 0 or 1> var ([1 2], [1 2], 'all')
%!error <the length of W must be> var ([1 2], [1 2 3])
%!error <the length of W must be> var (1, [1 2])
%!error <the length of W must be> var ([1 2], [1 2], 1)
%!error <DIM must be a positive integer> var (1, [], ones (2,2))
%!error <DIM must be a positive integer> var (1, [], 1.5)
%!error <DIM must be a positive integer> var (1, [], 0)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{z} =} zscore (@var{x})
## @deftypefnx {} {@var{z} =} zscore (@var{x}, @var{opt})
## @deftypefnx {} {@var{z} =} zscore (@var{x}, @var{opt}, @var{dim})
## @deftypefnx {} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@dots{})
## Compute the Z score of @var{x}.
##
## If @var{x} is a vector, subtract its mean and divide by its standard
## deviation.  If the standard deviation is zero, divide by 1 instead.
##
## The optional parameter @var{opt} determines the normalization to use when
## computing the standard deviation and has the same definition as the
## corresponding parameter for @code{std}.
##
## If @var{x} is a matrix, calculate along the first non-singleton dimension.
## If the third optional argument @var{dim} is given, operate along this
## dimension.
##
## The optional outputs @var{mu} and @var{sigma} contain the mean and standard
## deviation.
##
## @seealso{mean, std, center}
## @end deftypefn

function [z, mu, sigma] = zscore (x, opt = 0, dim)

  if (nargin < 1)
    print_usage ();
  endif

  if (! (isnumeric (x) || islogical (x)))
    error ("zscore: X must be a numeric vector or matrix");
  endif

  if (isempty (opt))
    opt = 0;
  elseif (! isscalar (opt) || (opt != 0 && opt != 1))
    error ("zscore: normalization OPT must be empty, 0, or 1");
  endif

  nd = ndims (x);
  sz = size (x);
  if (nargin < 3)
    ## Find the first non-singleton dimension.
    (dim = find (sz > 1, 1)) || (dim = 1);
  else
    if (!(isscalar (dim) && dim == fix (dim))
        || !(1 <= dim && dim <= nd))
      error ("zscore: DIM must be an integer and a valid dimension");
    endif
  endif

  n = sz(dim);
  if (n == 0)
    z = x;
  else

    if (isinteger (x))
      x = double (x);
    endif

    mu = mean (x, dim);
    sigma = std (x, opt, dim);
    s = sigma;
    s(s==0) = 1;
    z = (x - mu) ./ s;
  endif

endfunction


%!assert (zscore ([1,2,3]), [-1,0,1])
%!assert (zscore (single ([1,2,3])), single ([-1,0,1]))
%!assert (zscore (int8 ([1,2,3])), [-1,0,1])
%!assert (zscore (ones (3,2,2,2)), zeros (3,2,2,2))
%!assert (zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
%!assert <*54531> (zscore ([1,2,3], [], 2), [-1,0,1])

## Test input validation
%!error <Invalid call> zscore ()
%!error zscore (1, 2, 3)
%!error <X must be a numeric> zscore (['A'; 'B'])
%!error <OPT must be empty, 0, or 1> zscore (1, ones (2,2))
%!error <OPT must be empty, 0, or 1> zscore (1, 1.5)
%!error <DIM must be an integer> zscore (1, [], ones (2,2))
%!error <DIM must be an integer> zscore (1, [], 1.5)
%!error <DIM must be .* a valid dimension> zscore (1, [], 0)
encoding=utf-8
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} base2dec (@var{s}, @var{base})
## Convert @var{s} from a string of digits in base @var{base} to a decimal
## integer (base 10).
##
## @example
## @group
## base2dec ("11120", 3)
##    @result{} 123
## @end group
## @end example
##
## If @var{s} is a string matrix, return a column vector with one value per
## row of @var{s}.  If a row contains invalid symbols then the corresponding
## value will be NaN@.
##
## If @var{s} is a cell array of strings, return a column vector with one
## value per cell element in @var{s}.
##
## If @var{base} is a string, the characters of @var{base} are used as the
## symbols for the digits of @var{s}.  Space (' ') may not be used as a symbol.
##
## @example
## @group
## base2dec ("yyyzx", "xyz")
##    @result{} 123
## @end group
## @end example
## @seealso{dec2base, bin2dec, hex2dec}
## @end deftypefn

function out = base2dec (s, base)

  if (nargin != 2)
    print_usage ();
  endif

  if (iscellstr (s))
    s = char (s);
  elseif (! ischar (s))
    error ("base2dec: S must be a string or cellstring");
  endif

  symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if (ischar (base))
    symbols = base;
    base = length (symbols);
    if (length (unique (symbols)) != base)
      error ("base2dec: symbols representing digits must be unique");
    endif
    if (any (isspace (symbols)))
      error ("base2dec: whitespace characters are not valid symbols");
    endif
  elseif (! isscalar (base))
    error ("base2dec: cannot convert from several bases at once");
  elseif (! (base >= 2 && base <= length (symbols)))
    error ("base2dec: BASE must be between 2 and 36, or a string of symbols");
  else
    s = toupper (s);
  endif

  ## Right justify the values and squeeze out any spaces.
  ## This looks complicated, but indexing solution is very fast
  ## compared to alternatives which use cellstr or cellfun or looping.
  [nr, nc] = size (s);
  if (nc > 1)   # Bug #35621
    s = s.';
    nonbl = s != " ";
    num_nonbl = sum (nonbl);
    nc = max (num_nonbl);
    num_blank = nc - num_nonbl;
    R = repmat ([1 2; 0 0], 1, nr);
    R(2, 1:2:2*nr) = num_blank;
    R(2, 2:2:2*nr) = num_nonbl;
    idx = repelems ([false, true], R);
    idx = reshape (idx, nc, nr);

    ## Create a blank matrix and position the nonblank characters.
    s2 = repmat (" ", nc, nr);
    s2(idx) = s(nonbl);
    s = s2.';
  endif

  ## Lookup value of symbols in symbol table, with invalid symbols
  ## evaluating to NaN and space evaluating to 0.
  table = NaN (1, 256);
  table(double (symbols(1:base))) = 0 : base-1;
  table(double (" ")) = 0;
  s = reshape (table(double (s)), size (s));

  ## Multiply the resulting digits by the appropriate power
  ## and sum the rows.
  out = s * (base .^ (columns (s)-1 : -1 : 0)');

endfunction


%!assert (base2dec ("11120", 3), 123)
%!assert (base2dec ("yyyzx", "xyz"), 123)
%!assert (base2dec ("-1", 2), NaN)
%!assert (base2dec ({"A1", "1A"}, 16), [161; 26])

%!assert <*35621> (base2dec (["0"; "1"], 2), [0; 1])

## Test input validation
%!error <Invalid call> base2dec ()
%!error base2dec ("11120")
%!error base2dec ("11120", 3, 4)
%!error <symbols .* must be unique> base2dec ("11120", "1231")
%!error <whitespace characters are not valid> base2dec ("11120", "12 3")
%!error <cannot convert from several bases> base2dec ("11120", ones (2))
%!error <BASE must be between 2 and 36> base2dec ("11120", 1)
%!error <BASE must be between 2 and 36> base2dec ("11120", 37)
%!error <BASE must be between 2 and 36> base2dec ("11120", NaN)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} bin2dec (@var{s})
## Return the decimal number corresponding to the binary number represented
## by the string @var{s}.
##
## For example:
##
## @example
## @group
## bin2dec ("1110")
##      @result{} 14
## @end group
## @end example
##
## Spaces are ignored during conversion and may be used to make the binary
## number more readable.
##
## @example
## @group
## bin2dec ("1000 0001")
##      @result{} 129
## @end group
## @end example
##
## If @var{s} is a string matrix, return a column vector with one converted
## number per row of @var{s}; Invalid rows evaluate to NaN@.
##
## If @var{s} is a cell array of strings, return a column vector with one
## converted number per cell element in @var{s}.
## @seealso{dec2bin, base2dec, hex2dec}
## @end deftypefn

function d = bin2dec (s)

  if (nargin < 1)
    print_usage ();
  endif

  d = base2dec (s, 2);

endfunction


%!assert (bin2dec ("0000"), 0)
%!assert (bin2dec ("1110"), 14)
%!assert (bin2dec ("11111111111111111111111111111111111111111111111111111"),
%!        2^53-1)
%!assert (bin2dec ({"1110", "1111"}), [14; 15])
%!assert (bin2dec ("1 0 1"), 5)
%!assert (bin2dec (char ("1 0 1", "   1111")), [5; 15])

## Test input validation
%!error <Invalid call> bin2dec ()
%!error <S must be a string> bin2dec (1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} blanks (@var{n})
## Return a string of @var{n} blanks.
##
## For example:
##
## @example
## @group
## blanks (10);
## whos ans
##      @result{}
##       Attr Name        Size                     Bytes  Class
##       ==== ====        ====                     =====  =====
##            ans         1x10                        10  char
## @end group
## @end example
## @seealso{repmat}
## @end deftypefn

function s = blanks (n)

  if (nargin < 1)
    print_usage ();
  elseif (! (isscalar (n) && n == fix (n) && n >= 0))
    error ("blanks: N must be a non-negative integer");
  endif

  ## If 1:n is empty, the following expression will create an empty
  ## character string.  Otherwise, it will create a row vector.
  s(1:n) = " ";

endfunction


## There really isn't that much to test here
%!assert (blanks (0), "")
%!assert (blanks (5), "     ")
%!assert (blanks (10), "          ")

## Test input validation
%!error <Invalid call> blanks ()
%!error blanks (ones (2))
%!error blanks (2.1)
%!error blanks (-2)
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} cstrcat (@var{s1}, @var{s2}, @dots{})
## Return a string containing all the arguments concatenated horizontally
## with trailing white space preserved.
##
## For example:
##
## @example
## @group
## cstrcat ("ab   ", "cd")
##       @result{} "ab   cd"
## @end group
## @end example
##
## @example
## @group
## s = [ "ab"; "cde" ];
## cstrcat (s, s, s)
##       @result{} "ab ab ab "
##          "cdecdecde"
## @end group
## @end example
## @seealso{strcat, char, strvcat}
## @end deftypefn

function st = cstrcat (varargin)

  if (nargin == 0)
    ## Special because if varargin is empty, iscellstr still returns
    ## true but then "[varargin{:}]" would be of class double.
    st = "";
  elseif (iscellstr (varargin))
    st = [varargin{:}];
  else
    error ("cstrcat: arguments must be character strings");
  endif

endfunction


## Test the dimensionality
## 1d
%!assert (cstrcat ("ab ", "ab "), "ab ab ")
## 2d
%!assert (cstrcat (["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])

%!assert (cstrcat ("foo", "bar"), "foobar")
%!assert (cstrcat (["a "; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])

%!assert (cstrcat (), "")

## Test input validation
%!error cstrcat (1, 2)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} deblank (@var{s})
## Remove trailing whitespace and nulls from @var{s}.
##
## If @var{s} is a matrix, @var{deblank} trims each row to the length of
## longest string.  If @var{s} is a cell array of strings, operate
## recursively on each string element.
##
## Examples:
##
## @example
## @group
## deblank ("    abc  ")
##      @result{}  "    abc"
##
## deblank ([" abc   "; "   def   "])
##      @result{}  [" abc  " ; "   def"]
## @end group
## @end example
## @seealso{strtrim}
## @end deftypefn

function s = deblank (s)

  if (nargin < 1)
    print_usage ();
  endif

  if (isempty (s))

    ## Return empty objects unchanged (Matlab compatibility)

  elseif (ischar (s))

    ## Find indices of non-whitespace characters.  If s is a
    ## char matrix, the indices are in column major order.
    k = find (! isspace (s) & s != "\0");
    if (isempty (k))
      ## Even if s was a char matrix! (Matlab compatibility)
      s = "";
    else
      s = s(:,1:ceil (max (k) / rows (s)));
    endif

  elseif (iscell (s))

    char_idx = cellfun ("isclass", s, "char");
    cell_idx = cellfun ("isclass", s, "cell");
    empty_idx = cellfun ("isempty", s);
    if (! all (char_idx | cell_idx | empty_idx))
      error ("deblank: S argument must be a string or cellstring");
    endif

    ## Divide work load.  Recursive cellfun deblank call is slow
    ## and avoided where possible.
    s(char_idx) = regexprep (s(char_idx), "[\\s\v\\0]+$", '');
    s(cell_idx) = cellfun ("deblank", s(cell_idx), "UniformOutput", false);

  else
    error ("deblank: S argument must be a string or cellstring");
  endif

endfunction


%!assert (deblank (" f o o \0"), " f o o")
%!assert (deblank (" \t f o o \t \0"), " \t f o o")
%!assert (deblank (char (" abc   ", "   def   ")), [" abc  " ; "   def"])
%!assert (deblank (["   "; "   "]), "")
%!assert (deblank ('   '), '')
%!assert (deblank ("   "), "")
%!assert (deblank (""), "")
%!assert (deblank ([]), [])
%!assert (deblank ({}), {})
%!assert (deblank ({[]}), {[]})
%!assert (deblank ({[], []}), {[], []})
%!assert (deblank ({" abc   ", {"   def   "}}), {" abc", {"   def"}})

%!error <Invalid call to deblank> deblank ()
%!error <called with too many inputs> deblank ("foo", "bar")
%!error <argument must be a string> deblank (1)
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dec2base (@var{d}, @var{base})
## @deftypefnx {} {} dec2base (@var{d}, @var{base}, @var{len})
## Return a string of symbols in base @var{base} corresponding to the
## non-negative integer @var{d}.
##
## @example
## @group
## dec2base (123, 3)
##    @result{} "11120"
## @end group
## @end example
##
## If @var{d} is a matrix or cell array, return a string matrix with one row
## per element in @var{d}, padded with leading zeros to the width of the
## largest value.
##
## If @var{base} is a string then the characters of @var{base} are used as
## the symbols for the digits of @var{d}.  Whitespace (spaces, tabs, newlines,
##, etc.@:) may not be used as a symbol.
##
## @example
## @group
## dec2base (123, "aei")
##    @result{} "eeeia"
## @end group
## @end example
##
## The optional third argument, @var{len}, specifies the minimum number of
## digits in the result.
## @seealso{base2dec, dec2bin, dec2hex}
## @end deftypefn

function retval = dec2base (d, base, len)

  if (nargin < 2)
    print_usage ();
  endif

  if (iscell (d))
    d = cell2mat (d);
  endif

  ## Create column vector for algorithm
  d = d(:);

  ## Treat logical as numeric for compatibility with ML
  if (islogical (d))
    d = double (d);
  elseif (! isnumeric (d) || iscomplex (d) || any (d < 0 | d != fix (d)))
    error ("dec2base: input must be real non-negative integers");
  endif

  symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if (ischar (base))
    symbols = base(:).';  # force a row vector
    base = numel (symbols);
    if (numel (unique (symbols)) != base)
      error ("dec2base: symbols representing digits must be unique");
    elseif (any (isspace (symbols)))
      error ("dec2base: whitespace characters are not valid symbols");
    endif
  elseif (! isscalar (base) || ! isreal (base) || fix (base) != base
          || base < 2 || base > 36)
    error ("dec2base: BASE must be an integer between 2 and 36, or a string of symbols");
  endif

  ## determine number of digits required to handle all numbers, can overflow
  ## by 1 digit
  max_len = round (log (max (max (d), 1)) / log (base)) + 1;

  if (nargin == 3)
    if (! (isscalar (len) && isreal (len) && len >= 0 && len == fix (len)))
      error ("dec2base: LEN must be a non-negative integer");
    endif
    max_len = max (max_len, len);
  endif

  ## determine digits for each number
  digits = zeros (length (d), max_len);
  for k = max_len:-1:1
    digits(:,k) = mod (d, base);
    d = round ((d - digits(:,k)) / base);
  endfor

  ## convert digits to symbols
  retval = reshape (symbols(digits+1), size (digits));

  ## Check if the first element is the zero symbol.  It seems possible
  ## that LEN is provided, and is less than the computed MAX_LEN and
  ## MAX_LEN is computed to be one larger than necessary, so we would
  ## have a leading zero to remove.  But if LEN >= MAX_LEN, we should
  ## not remove any leading zeros.
  if ((nargin == 2 || (nargin == 3 && max_len > len))
      && columns (retval) != 1 && ! any (retval(:,1) != symbols(1)))
    retval = retval(:,2:end);
  endif

endfunction


%!test
%! s0 = "";
%! for n = 1:13
%!   for b = 2:16
%!     pp = dec2base (b^n+1, b);
%!     assert (dec2base (b^n, b), ['1',s0,'0']);
%!     assert (dec2base (b^n+1, b), ['1',s0,'1']);
%!   endfor
%!   s0 = [s0,'0'];
%! endfor

%!test
%! digits = "0123456789ABCDEF";
%! for n = 1:13
%!   for b = 2:16
%!     pm = dec2base (b^n-1, b);
%!     assert (length (pm), n);
%!     assert (all (pm == digits(b)));
%!   endfor
%! endfor

%!test
%! for b = 2:16
%!   assert (dec2base (0, b), '0');
%! endfor

%!assert (dec2base (0, 2, 4), "0000")
%!assert (dec2base (2^51-1, 2), ...
%!        "111111111111111111111111111111111111111111111111111")
%!assert (dec2base (uint64 (2)^63-1, 16), "7FFFFFFFFFFFFFFF")
%!assert (dec2base ([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"])
%!assert (dec2base ({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"])

%!test
%! a = 0:3;
%! assert (dec2base (! a, 2, 1), ["1"; "0"; "0"; "0"]);

%!assert <*56005> (dec2base ([0, 0], 16), ["0"; "0"])

## Test input validation
%!error <Invalid call> dec2base ()
%!error <Invalid call> dec2base (1)
%!error <input must be real non-negative integers> dec2base ("A", 10)
%!error <input must be real non-negative integers> dec2base (2i, 10)
%!error <input must be real non-negative integers> dec2base (-1, 10)
%!error <input must be real non-negative integers> dec2base (1.1, 10)
%!error <symbols representing digits must be unique> dec2base (1, "ABA")
%!error <whitespace characters are not valid symbols> dec2base (1, "A B")
%!error <BASE must be an integer> dec2base (1, ones (2))
%!error <BASE must be an integer> dec2base (1, 2i)
%!error <BASE must be an integer> dec2base (1, 2.5)
%!error <BASE must be .* between 2 and 36> dec2base (1, 1)
%!error <BASE must be .* between 2 and 36> dec2base (1, 37)
%!error <LEN must be a non-negative integer> dec2base (1, 2, ones (2))
%!error <LEN must be a non-negative integer> dec2base (1, 2, 2i)
%!error <LEN must be a non-negative integer> dec2base (1, 2, -1)
%!error <LEN must be a non-negative integer> dec2base (1, 2, 2.5)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dec2bin (@var{d})
## @deftypefnx {} {} dec2bin (@var{d}, @var{len})
## Return a string of ones and zeros representing the conversion of the integer
## @var{d} to a binary number.
##
## If @var{d} is negative, return the two's complement binary value of @var{d}.
## If @var{d} is a matrix or cell array, return a string matrix with one row
## for each element in @var{d}, padded with leading zeros to the width of the
## largest value.
##
## The optional second argument, @var{len}, specifies the minimum number of
## digits in the result.
##
## Examples:
##
## @example
## @group
## dec2bin (14)
##      @result{} "1110"
##
## dec2bin (-14)
##      @result{} "11110010"
## @end group
## @end example
##
## Programming Notes: The largest negative value that can be converted into
## two's complement is @code{- (flintmax () / 2)}.
##
## Known @sc{matlab} Incompatibility: @sc{matlab}'s @code{dec2bin} allows
## non-integer values for @var{d}, truncating the value using the equivalent
## of @code{fix (@var{d})} for positive values, but, as of R2020b and in
## conflict with published documentation, appears to use
## @code{round (@var{d})} for negative values.  To be consistent with
## @code{dec2hex} and @code{dec2base}, Octave produces an error for non-integer
## valued inputs for @var{d}.  Users wanting compatible code for non-integer
## valued inputs should make use of @code{fix} or @code{round} as appropriate.
## @seealso{bin2dec, dec2base, dec2hex}
## @end deftypefn

function b = dec2bin (d, len)

  if (nargin == 0)
    print_usage ();
  endif

  if (iscell (d))
    d = cell2mat (d);
  endif
  ## Create column vector for algorithm (output is always col. vector anyways)
  d = d(:);

  lt_zero_idx = (d < 0);
  if (any (lt_zero_idx))
    ## FIXME: Need an algorithm that works with larger values such as int64.
    if (any (d(lt_zero_idx) < -2^52))
      error ("dec2bin: negative inputs cannot be less than -flintmax () / 2");
    elseif (any (d(lt_zero_idx) < intmin ("int32")))
      d(lt_zero_idx) += flintmax ();
    elseif (any (d < intmin ("int16")))
      d(lt_zero_idx) += double (intmax ("uint32")) + 1;
    elseif (any (d < intmin ("int8")))
      d(lt_zero_idx) += double (intmax ("uint16"))+ 1;
    else
      d(lt_zero_idx) += double (intmax ("uint8")) + 1;
    endif
  endif

  if (nargin == 1)
    b = dec2base (d, 2);
  else
    b = dec2base (d, 2, len);
  endif

endfunction


%!assert (dec2bin (3), "11")
%!assert (dec2bin (14), "1110")
%!assert (dec2bin (14, 6), "001110")
%!assert (dec2bin ([1, 2; 3, 4]), ["001"; "011"; "010"; "100"])
%!assert (dec2bin ({1, 2; 3, 4}), ["001"; "011"; "010"; "100"])
%!assert (dec2bin ({1, 2; 3, 4}, 4), ["0001"; "0011"; "0010"; "0100"])

## Test negative inputs
%!assert (dec2bin (-3), "11111101")
%!assert (dec2bin (-3, 3), "11111101")
%!assert (dec2bin (-3, 9), "011111101")
%!assert (dec2bin (-2^7 -1), "1111111101111111")
%!assert (dec2bin (-2^15 -1), "11111111111111110111111111111111")
## FIXME: Matlab generates a string that is 64 characters long
%!assert (dec2bin (-2^31 -1),
%!        "11111111111111111111101111111111111111111111111111111")
%!assert (dec2bin (-2^52),
%!        "10000000000000000000000000000000000000000000000000000")
## FIXME: Uncomment when support for int64 is added
%!#assert (dec2bin (-2^63),
%!        "1000000000000000000000000000000000000000000000000000000000000000")
%!#test
%! assert (dec2bin (int64 (-2^63)),
%!        "1000000000000000000000000000000000000000000000000000000000000000");
%!#test
%! assert (dec2bin (int64 (-2^63) -1),
%!        "1000000000000000000000000000000000000000000000000000000000000000");
%!#test
%! assert (dec2bin (int64 (-2^63) +1),
%!        "1000000000000000000000000000000000000000000000000000000000000001");
%!assert (dec2bin ([-1, -2; -3, -4]),
%!        ["11111111"; "11111101"; "11111110"; "11111100"])
%!assert (dec2bin ([1, 2; 3, -4]),
%!        ["00000001"; "00000011"; "00000010"; "11111100"])
%!assert (dec2bin ({1, 2; 3, -4}),
%!        ["00000001"; "00000011"; "00000010"; "11111100"])

## Test input validation
%!error <Invalid call> dec2bin ()
%!error <negative inputs cannot be less than> dec2bin (- flintmax ())
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} dec2hex (@var{d})
## @deftypefnx {} {} dec2hex (@var{d}, @var{len})
## Return a string representing the conversion of the integer @var{d} to a
## hexadecimal (base16) number.
##
## If @var{d} is negative, return the hexadecimal equivalent of the two's
## complement binary value of @var{d}.
## If @var{d} is a matrix or cell array, return a string matrix with one row
## for each element in @var{d}, padded with leading zeros to the width of the
## largest value.
##
## The optional second argument, @var{len}, specifies the minimum number of
## digits in the result.
##
## Examples:
##
## @example
## @group
## dec2hex (2748)
##      @result{} "ABC"
##
## dec2hex (-2)
##      @result{} "FE"
## @end group
## @end example
##
## @seealso{hex2dec, dec2base, dec2bin}
## @end deftypefn

function h = dec2hex (d, len)

  if (nargin == 0)
    print_usage ();
  endif

  if (iscell (d))
    d = cell2mat (d);
  endif
  ## Create column vector for algorithm (output is always col. vector anyways)
  d = d(:);

  lt_zero_idx = (d < 0);
  if (any (lt_zero_idx))
    ## FIXME: Need an algorithm that works with larger values such as int64.
    if (any (d(lt_zero_idx) < -2^52))
      error ("dec2hex: negative inputs cannot be less than -flintmax () / 2");
    elseif (any (d(lt_zero_idx) < intmin ("int32")))
      d(lt_zero_idx) += flintmax ();
    elseif (any (d < intmin ("int16")))
      d(lt_zero_idx) += double (intmax ("uint32")) + 1;
    elseif (any (d < intmin ("int8")))
      d(lt_zero_idx) += double (intmax ("uint16"))+ 1;
    else
      d(lt_zero_idx) += double (intmax ("uint8")) + 1;
    endif
  endif

  if (nargin == 1)
    h = dec2base (d, 16);
  else
    h = dec2base (d, 16, len);
  endif

endfunction


%!assert (dec2hex (2748), "ABC")
%!assert (dec2hex (2748, 5), "00ABC")
%!assert (dec2hex ([2748, 2746]), ["ABC"; "ABA"])
%!assert (dec2hex ({2748, 2746}), ["ABC"; "ABA"])
%!assert (dec2hex ({2748, 2746}, 4), ["0ABC"; "0ABA"])

## Test negative inputs
%!assert (dec2hex (-3), "FD")
%!assert (dec2hex (-3, 1), "FD")
%!assert (dec2hex (-3, 3), "0FD")
%!assert (dec2hex (-2^7 -1), "FF7F")
%!assert (dec2hex (-2^15 -1), "FFFF7FFF")
## FIXME: Matlab returns longer string that begins with 'F'
%!assert (dec2hex (-2^31 -1), "1FFFFF7FFFFFFF")
## FIXME: Matlab returns longer string that begins with 'FFF'
%!assert (dec2hex (-2^52), "10000000000000")
## FIXME: Uncomment when support for int64 is added
%!#assert (dec2hex (-2^63),
%!        "1000000000000000000000000000000000000000000000000000000000000000")
%!#test
%! assert (dec2hex (int64 (-2^63)),
%!        "1000000000000000000000000000000000000000000000000000000000000000");
%!#test
%! assert (dec2hex (int64 (-2^63) -1),
%!        "1000000000000000000000000000000000000000000000000000000000000000");
%!#test
%! assert (dec2hex (int64 (-2^63) +1),
%!        "1000000000000000000000000000000000000000000000000000000000000001");
%!assert (dec2hex ([-1, -2; -3, -4]), ["FF"; "FD"; "FE"; "FC"])
%!assert (dec2hex ([1, 2; 3, -4]), ["01"; "03"; "02"; "FC"])
%!assert (dec2hex ({1, 2; 3, -4}), ["01"; "03"; "02"; "FC"])

## Test input validation
%!error <Invalid call> dec2hex ()
%!error <negative inputs cannot be less than> dec2hex (- flintmax ())
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{retval} =} endsWith (@var{str}, @var{pattern})
## @deftypefnx {} {@var{retval} =} endsWith (@var{str}, @var{pattern}, "IgnoreCase", @var{ignore_case})
## Check whether string(s) end with pattern(s).
##
## Return an array of logical values that indicates which string(s) in the
## input @var{str} (a single string or cell array of strings) end with
## the input @var{pattern} (a single string or cell array of strings).
##
## If the value of the parameter @qcode{"IgnoreCase"} is true, then the
## function will ignore the letter case of @var{str} and @var{pattern}.  By
## default, the comparison is case sensitive.
##
## Examples:
##
## @example
## @group
## ## one string and one pattern while considering case
## endsWith ("hello", "lo")
##       @result{}  1
## @end group
##
## @group
## ## one string and one pattern while ignoring case
## endsWith ("hello", "LO", "IgnoreCase", true)
##       @result{}  1
## @end group
##
## @group
## ## multiple strings and multiple patterns while considering case
## endsWith (@{"tests.txt", "mydoc.odt", "myFunc.m", "results.pptx"@},
##           @{".docx", ".odt", ".txt"@})
##       @result{}  1  1  0  0
## @end group
##
## @group
## ## multiple strings and one pattern while considering case
## endsWith (@{"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"@},
##           ".txt", "IgnoreCase", false)
##       @result{}  0  0  1  0
## @end group
##
## @group
## ## multiple strings and one pattern while ignoring case
## endsWith (@{"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"@},
##           ".txt", "IgnoreCase", true)
##       @result{}  1  0  1  0
## @end group
## @end example
##
## @seealso{startsWith, regexp, strncmp, strncmpi}
## @end deftypefn

function retval = endsWith (str, pattern, IgnoreCase, ignore_case)

  if (nargin != 2 && nargin != 4)
    print_usage ();
  endif

  ## Validate input str and pattern
  if (! (iscellstr (str) || ischar (str)))
    error ("endsWith: STR must be a string or cell array of strings");
  endif
  if (! (iscellstr (pattern) || ischar (pattern)))
    error ("endsWith: PATTERN must be a string or cell array of strings");
  endif

  ## reverse str and pattern
  str = cellfun (@flip, cellstr (str), "UniformOutput", false);
  pattern = cellfun (@flip, cellstr (pattern), "UniformOutput", false);

  if (nargin == 2)
    ignore_case = false;
  else
    ## For Matlab compatibility accept any abbreviation of 3rd argument
    if (! ischar (IgnoreCase) || isempty (IgnoreCase)
        || ! strncmpi (IgnoreCase, "IgnoreCase", length (IgnoreCase)))
      error ('endsWith: third input must be "IgnoreCase"');
    endif

    if (! isscalar (ignore_case) || ! isreal (ignore_case))
      error ('endsWith: "IgnoreCase" value must be a logical scalar');
    endif
    ignore_case = logical (ignore_case);
  endif

  retval = false (size (str));
  if (ignore_case)
    for j = 1:numel (pattern)
      retval |= strncmpi (str, pattern{j}, length (pattern{j}));
    endfor
  else
    for j = 1:numel (pattern)
      retval |= strncmp (str, pattern{j}, length (pattern{j}));
    endfor
  endif

endfunction


## Test simple use with one string and one pattern
%!assert (endsWith ("hello", "lo"))
%!assert (! endsWith ("hello", "LO"))
%!assert (endsWith ("hello", "LO", "i", 5))
%!assert (! endsWith ("hello", "no"))

## Test multiple strings with a single pattern
%!test
%! str = {"myFile.odt", "results.ppt", "myCode.m"; ...
%!        "data-analysis.ppt", "foundations.txt", "data.odt"};
%! pattern = ".odt";
%! expected = [true, false, false; false, false, true];
%! assert (endsWith (str, pattern), expected);

## Test multiple strings with multiple patterns
%!test
%! str = {"tests.txt", "mydoc.odt", "myFunc.m", "results.pptx"};
%! pattern = {".docx", ".odt", ".txt"};
%! expected = [true, true, false, false];
%! assert (endsWith (str, pattern), expected);

## Test IgnoreCase
%!test
%! str = {"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"};
%! pattern = ".txt";
%! expected_ignore = [true, false, true, false];
%! expected_wo_ignore = [false, false, true, false];
%! assert (endsWith (str, pattern, "IgnoreCase", true), expected_ignore);
%! assert (endsWith (str, pattern, "IgnoreCase", false), expected_wo_ignore);
%! assert (endsWith (str, pattern, "I", 500), expected_ignore);
%! assert (endsWith (str, pattern, "iG", 0), expected_wo_ignore);

## Test input validation
%!error <Invalid call> endsWith ()
%!error endsWith ("A")
%!error endsWith ("A", "B", "C")
%!error endsWith ("A", "B", "C", "D", "E")
%!error <STR must be a string> endsWith (152, "hi")
%!error <STR must be a .* cell array of strings> endsWith ({152}, "hi")
%!error <PATTERN must be a string> endsWith ("hi", 152)
%!error <PATTERN must be a .* cell array of strings> endsWith ("hi", {152})
%!error <third input must be "IgnoreCase"> endsWith ("hello", "lo", 1, 1)
%!error <third input must be "IgnoreCase"> endsWith ("hello", "lo", "", 1)
%!error <third input must be "IgnoreCase"> endsWith ("hello", "lo", "foo", 1)
%!error <"IgnoreCase" value must be a logical scalar>
%! endsWith ("hello", "hi", "i", "true");
%!error <"IgnoreCase" value must be a logical scalar>
%! endsWith ("hello", "hi", "i", {true});
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{newstr} =} erase (@var{str}, @var{ptn})
## Delete all occurrences of @var{ptn} within @var{str}.
##
## @var{str} and @var{ptn} can be ordinary strings, cell array of strings, or
## character arrays.
##
## Examples
##
## @example
## @group
## ## string, single pattern
## erase ("Hello World!", " World")
##     @result{} "Hello!"
##
## ## cellstr, single pattern
## erase (@{"Hello", "World!"@}, "World")
##     @result{} @{"Hello", "!"@}
##
## ## string, multiple patterns
## erase ("The Octave interpreter is fabulous", ...
##        @{"interpreter ", "The "@})
##     @result{} "Octave is fabulous"
##
## ## cellstr, multiple patterns
## erase (@{"The ", "Octave interpreter ", "is fabulous"@}, ...
##        @{"interpreter ", "The "@})
##     @result{} @{"", "Octave ", "is fabulous"@}
## @end group
## @end example
##
## Programming Note: @code{erase} deletes the first instance of a pattern in a
## string when there are overlapping occurrences.  For example:
##
## @example
## @group
## erase ("abababa", "aba")
##     @result{} "b"
## @end group
## @end example
##
## For processing overlaps, @pxref{XREFstrrep,,@code{strrep}}.
##
## @seealso{strrep, regexprep}
## @end deftypefn


function newstr = erase (str, ptn)

  if (nargin != 2)
    print_usage ();
  endif

  ischarmatrix = false;
  if (ischar (str))
    if (rows (str) > 1)
      ## Convert to cell.  Can't use cellstr which trims spaces.
      str = mat2cell (str, ones (1, rows (str)));
      ischarmatrix = true;
    endif
  elseif (! iscellstr (str))
    error ("erase: STR must be a string or cell array of strings");
  endif

  if (ischar (ptn))
    if (rows (ptn) > 1)
      warning ("Octave:erase:chararray",
               "erase: using character array for PTN is not recommended, consider cell array of strings instead");
      ## Convert to cell.  Can't use cellstr which trims spaces.
      ptn = mat2cell (ptn, ones (1, rows (ptn)));
    endif
  elseif (! iscellstr (ptn))
    error ("erase: PTN must be a string or cell array of strings");
  endif

  nptn = ifelse (ischar (ptn), 1, numel (ptn));
  if (nptn == 1)
    newstr = strrep (str, ptn, "", "overlaps", false);
  else
    ptn = regexptranslate ("escape", ptn(:).');
    ptn = strjoin (ptn, '|');
    newstr = regexprep (str, ptn, "");
  endif

  if (ischarmatrix)
    newstr = char (newstr);
  endif

endfunction


%!assert (erase ("Hello World!", " World"), "Hello!")
%!assert (erase ({"Hello World!"}, " World"), {"Hello!"})
%!assert (erase (char ("Hello", "World!"), "World"), char ("Hello ", "!"))
%!assert (erase ({"Hello", "World!"}, "World"), {"Hello", "!"})
%!assert (erase ("Hello World!", {"o"; "World"; " "}), "Hell!")

## Test overlaps
## from https://savannah.gnu.org/bugs/?52647#comment5
%!assert (erase ('ababa', 'aba'), 'ba')
%!assert (erase ('abababa', 'aba'), 'b')
%!assert (erase ('ababababa', 'aba'), 'bba')
%!assert (erase ('ababababa', {'aba', 'bba'}), 'bba')
%!assert (erase ('ababababa ', {'aba', 'bba'}), 'bba ')
%!assert (erase ({' ababababa '}, {'aba', 'bba'}), {' bba '})
%!assert (erase (' ababa ', {'aba', 'baba'}), ' ba ')
%!assert (erase (' Hello World t ', {'t';'llo'}), ' He World  ')
%!assert (erase ({' Hello World t '}, [ 'o ']), {' HellWorld t '})
%!assert (erase ( 'Hello World t ', {'ld '; 'o '}), 'HellWort ')
%!assert (erase ('aba', 'aba'), '')
%!assert (erase ({'aba'}, 'aba'), ({""}))
%!assert (erase ('', 'aba'), '')
%!assert (erase ({'abbabbabba'},{'abba'}), {'bb'})
%!assert (erase ({'ababababa';'abbabbabba'}, 'aba'), {'bba';'abbabbabba'})
%!assert (erase ({''}, {''}), {''})
%!assert (erase ({'pppppppp'}, 'p'), {''})
%!assert (erase ('Hello World t ', {'ld '; 'o '}), 'HellWort ')
%!assert (erase ({'Hello World t '}, {'ld '; 'o '}), {'HellWort '})

## Test input validation
%!error <Invalid call> erase ()
%!error erase ("a")
%!error erase ("a", "b", "c")
%!error <STR must be a string> erase ([1], "foo")
%!error <PTN must be a string> erase ("foo", [1])
%!warning <using character array for PTN is not recommended>
%! erase ("a", ["a";"b"]);
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} hex2dec (@var{s})
## Return the integer corresponding to the hexadecimal number represented by
## the string @var{s}.
##
## For example:
##
## @example
## @group
## hex2dec ("12B")
##       @result{} 299
## hex2dec ("12b")
##       @result{} 299
## @end group
## @end example
##
## If @var{s} is a string matrix, return a column vector with one converted
## number per row of @var{s}; Invalid rows evaluate to NaN@.
##
## If @var{s} is a cell array of strings, return a column vector with one
## converted number per cell element in @var{s}.
##
## @seealso{dec2hex, base2dec, bin2dec}
## @end deftypefn

function d = hex2dec (s)

  if (nargin < 1)
    print_usage ();
  endif

  d = base2dec (s, 16);

endfunction


%!assert (hex2dec ("0000"), 0)
%!assert (hex2dec ("1FFFFFFFFFFFFF"), 2^53-1)
%!assert (hex2dec (["12b"; "12B"]), [299; 299])
%!assert (hex2dec ({"A1", "1A"}), [161; 26])

## Test input validation
%!error <Invalid call> hex2dec ()
%!error <S must be a string> hex2dec (1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} index (@var{s}, @var{t})
## @deftypefnx {} {} index (@var{s}, @var{t}, @var{direction})
## Return the position of the first occurrence of the string @var{t} in the
## string @var{s}, or 0 if no occurrence is found.
##
## @var{s} may also be a string array or cell array of strings.
##
## For example:
##
## @example
## @group
## index ("Teststring", "t")
##     @result{} 4
## @end group
## @end example
##
## If @var{direction} is @qcode{"first"}, return the first element found.
## If @var{direction} is @qcode{"last"}, return the last element found.
##
## @seealso{find, rindex}
## @end deftypefn

function n = index (s, t, direction = "first")

  if (nargin < 2)
    print_usage ();
  endif

  if (ischar (s))
    if (! isrow (s))
      s = cellstr (s);  # Handle string arrays by conversion to cellstr
    endif
  elseif (! iscellstr (s))
    error ("index: S must be a string, string array, or cellstr");
  endif

  f = strfind (s, t);
  if (isempty (f))
    f = 0;
  elseif (iscell (f))
    f(cellfun ("isempty", f)) = {0};
  endif

  direction = tolower (direction);

  if (strcmp (direction, "first"))
    if (iscell (f))
      n = cellfun ("min", f);
    else
      n = f(1);
    endif
  elseif (strcmp (direction, "last"))
    if (iscell (f))
      n = cellfun ("max", f);
    else
      n = f(end);
    endif
  else
    error ('index: DIRECTION must be either "first" or "last"');
  endif

endfunction


%!assert (index ("foobarbaz", "b"), 4)
%!assert (index ("foobarbaz", "z"), 9)

%!assert (index ("astringbstringcstring", "s"), 2)
%!assert (index ("astringbstringcstring", "st"), 2)
%!assert (index ("astringbstringcstring", "str"), 2)
%!assert (index ("astringbstringcstring", "string"), 2)
%!assert (index ("abc---", "abc+++"), 0)

## test everything out in reverse
%!assert (index ("astringbstringcstring", "s", "last"), 16)
%!assert (index ("astringbstringcstring", "st", "last"), 16)
%!assert (index ("astringbstringcstring", "str", "last"), 16)
%!assert (index ("astringbstringcstring", "string", "last"), 16)
%!assert (index ("abc---", "abc+++", "last"), 0)

%!test
%! str = char ("Hello", "World", "Goodbye", "World");
%! assert (index (str, "o"), [5; 2; 2; 2]);
%! assert (index (str, "o", "last"), [5; 2; 3; 2]);
%! str = cellstr (str);
%! assert (index (str, "o"), [5; 2; 2; 2]);
%! assert (index (str, "o", "last"), [5; 2; 3; 2]);

## Test input validation
%!error <Invalid call> index ()
%!error index ("a")
%!error index ("a", "b", "first", "d")
%!error index (1, "bar")
%!error index ("foo", "bar", 3)
########################################################################
##
## Copyright (C) 1998-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isletter (@var{s})
## Return a logical array which is true where the elements of @var{s}
## are letters and false where they are not.
##
## This is an alias for the @code{isalpha} function.
## @seealso{isalpha, isdigit, ispunct, isspace, iscntrl, isalnum}
## @end deftypefn

function retval = isletter (s)

  if (nargin < 1)
    print_usage ();
  endif

  retval = isalpha (s);

endfunction


%!error <Invalid call> isletter ()
%!error isletter ("a", "b")
########################################################################
##
## Copyright (C) 2017-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isstring (@var{s})
## Return true if @var{s} is a string array.
##
## A string array is a data type that stores strings (row vectors of
## characters) at each element in the array.  It is distinct from character
## arrays which are N-dimensional arrays where each element is a single 1x1
## character.  It is also distinct from cell arrays of strings which store
## strings at each element, but use cell indexing @samp{@{@}} to access
## elements rather than string arrays which use ordinary array indexing
## @samp{()}.
##
## Programming Note: Octave does not yet implement string arrays so this
## function will always return false.
## @seealso{ischar, iscellstr, isfloat, isinteger, islogical, isnumeric, isa}
## @end deftypefn

function retval = isstring (s)

  if (nargin < 1)
    print_usage ();
  endif

  retval = false;

endfunction


%!assert (isstring ([]), false)
%!assert (isstring (1), false)
%!assert (isstring ('a'), false)
## FIXME: when string arrays are implemented, this should return true.
#%!assert (isstring ("b"), true)
%!assert (isstring ({'a'}), false)
%!assert (isstring ({"b"}), false)

%!error <Invalid call> isstring ()
%!error isstring ("a", "b")
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} isstrprop (@var{str}, @var{prop})
## Test character string properties.
##
## For example:
##
## @example
## @group
## isstrprop ("abc123", "alpha")
## @result{} [1, 1, 1, 0, 0, 0]
## @end group
## @end example
##
## If @var{str} is a cell array, @code{isstrpop} is applied recursively to
## each element of the cell array.
##
## Numeric arrays are converted to character strings.
##
## The second argument @var{prop} must be one of
##
## @table @asis
## @item @qcode{"alpha"}
## True for characters that are alphabetic (letters).
##
## @item  @nospell{@qcode{"alnum"}}
## @itemx @nospell{@qcode{"alphanum"}}
## True for characters that are alphabetic or digits.
##
## @item @qcode{"lower"}
## True for lowercase letters.
##
## @item @qcode{"upper"}
## True for uppercase letters.
##
## @item @qcode{"digit"}
## True for decimal digits (0-9).
##
## @item @nospell{@qcode{"xdigit"}}
## True for hexadecimal digits (@nospell{a-fA-F0-9}).
##
## @item  @qcode{"space"}
## @itemx @nospell{@qcode{"wspace"}}
## True for whitespace characters (space, formfeed, newline, carriage return,
## tab, vertical tab).
##
## @item @nospell{@qcode{"punct"}}
## True for punctuation characters (printing characters except space or
## letter or digit).
##
## @item @nospell{@qcode{"cntrl"}}
## True for control characters.
##
## @item  @qcode{"graph"}
## @itemx @qcode{"graphic"}
## True for printing characters except space.
##
## @item @qcode{"print"}
## True for printing characters including space.
##
## @item @qcode{"ascii"}
## True for characters that are in the range of ASCII encoding.
##
## @end table
##
## @seealso{isalpha, isalnum, islower, isupper, isdigit, isxdigit,
## isspace, ispunct, iscntrl, isgraph, isprint, isascii}
## @end deftypefn

function retval = isstrprop (str, prop)

  if (nargin != 2)
    print_usage ();
  endif

  switch (prop)
    case "alpha"
      retval = isalpha (str);
    case {"alnum", "alphanum"}
      retval = isalnum (str);
    case "ascii"
      retval = isascii (str);
    case "cntrl"
      retval = iscntrl (str);
    case "digit"
      retval = isdigit (str);
    case {"graph", "graphic"}
      retval = isgraph (str);
    case "lower"
      retval = islower (str);
    case "print"
      retval = isprint (str);
    case "punct"
      retval = ispunct (str);
    case {"space", "wspace"}
      retval = isspace (str);
    case "upper"
      retval = isupper (str);
    case "xdigit"
      retval = isxdigit (str);
    otherwise
      error ("isstrprop: invalid string property");
  endswitch

endfunction


%!assert (isstrprop ("abc123", "alpha"), logical ([1, 1, 1, 0, 0, 0]))
%!assert (isstrprop ("abc123", "digit"), logical ([0, 0, 0, 1, 1, 1]))
%!assert (isstrprop ("Hello World", "wspace"), isspace ("Hello World"))
%!assert (isstrprop ("Hello World", "graphic"), isgraph ("Hello World"))
%!assert (isstrprop (char ("AbC", "123"), "upper"), logical ([1 0 1; 0 0 0]))
%!assert (isstrprop ({"AbC", "123"}, "lower"),
%!        {logical([0 1 0]), logical([0 0 0])})

## Test input validation
%!error <Invalid call> isstrprop ()
%!error isstrprop ("abc123")
%!error isstrprop ("abc123", "alpha", "alpha")
%!error <invalid string property> isstrprop ("abc123", "foo")
########################################################################
##
## Copyright (C) 2002-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{s} =} mat2str (@var{x}, @var{n})
## @deftypefnx {} {@var{s} =} mat2str (@var{x}, @var{n}, "class")
## Format real, complex, and logical matrices as strings.
##
## The returned string may be used to reconstruct the original matrix by using
## the @code{eval} function.
##
## The precision of the values is given by @var{n}.  If @var{n} is a scalar
## then both real and imaginary parts of the matrix are printed to the same
## precision.  Otherwise @code{@var{n}(1)} defines the precision of the real
## part and @code{@var{n}(2)} defines the precision of the imaginary part.
## The default for @var{n} is 15.
##
## If the argument @qcode{"class"} is given then the class of @var{x} is
## included in the string in such a way that @code{eval} will result in the
## construction of a matrix of the same class.
##
## @example
## @group
## mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
##      @result{} "[-0.3333+0.14i;0.3333-0.14i]"
##
## mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
##      @result{} "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]"
##
## mat2str (int16 ([1 -1]), "class")
##      @result{} "int16([1 -1])"
##
## mat2str (logical (eye (2)))
##      @result{} "[true false;false true]"
##
## isequal (x, eval (mat2str (x)))
##      @result{} 1
## @end group
## @end example
##
## @seealso{sprintf, num2str, int2str}
## @end deftypefn

function s = mat2str (x, n = 15, cls = "")

  if (nargin < 1 || ! (isnumeric (x) || islogical (x)))
    print_usage ();
  elseif (ndims (x) > 2)
    error ("mat2str: X must be two dimensional");
  endif

  if (nargin == 2 && ischar (n))
    cls = n;
    n = 15;
  elseif (isempty (n))
    n = 15;   # Default precision
  elseif (numel (n) > 2)
    error ("mat2str: N must have only 1 or 2 elements");
  else
    n = fix (n);
  endif

  x_islogical = islogical (x);
  x_iscomplex = iscomplex (x);

  if (x_iscomplex)
    if (isscalar (n))
      n = [n, n];
    endif
    fmt = sprintf ("%%.%dg%%+.%dgi", n(1), n(2));
  elseif (x_islogical)
    v = {"false", "true"};
    fmt = "%s";
  else
    fmt = sprintf ("%%.%dg", n(1));
  endif

  nel = numel (x);

  if (nel == 0)
    ## Empty, only print brackets
    s = "[]";
  elseif (nel == 1)
    ## Scalar X, don't print brackets
    if (x_iscomplex)
      s = sprintf (fmt, real (x), imag (x));
    elseif (x_islogical)
      s = v{x+1};
    else
      s = sprintf (fmt, x);
    endif
  else
    ## Non-scalar X, print brackets
    fmt = [fmt " "];
    if (x_iscomplex)
      t = x.';
      s = sprintf (fmt, [real(t(:))'; imag(t(:))']);
    elseif (x_islogical)
      t = v(x.'+1);
      s = cstrcat (sprintf (fmt, t{:}));
    else
      s = sprintf (fmt, x.');
    endif

    s = ["[" s];
    s(end) = "]";
    idx = strfind (s, " ");
    nc = columns (x);
    s(idx(nc:nc:end)) = ";";
  endif

  if (strcmp ("class", cls))
    s = [class(x) "(" s ")"];
  endif

endfunction


%!assert (mat2str (0.7), "0.7")
%!assert (mat2str (pi), "3.14159265358979")
%!assert (mat2str (pi, 5), "3.1416")
%!assert (mat2str (single (pi), 5, "class"), "single(3.1416)")
%!assert (mat2str ([-1/3 + i/7; 1/3 - i/7], [4 2]),
%!        "[-0.3333+0.14i;0.3333-0.14i]")
%!assert (mat2str ([-1/3 +i/7; 1/3 -i/7], [4 2]),
%!        "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]")
%!assert (mat2str (int16 ([1 -1]), "class"), "int16([1 -1])")
%!assert (mat2str (true), "true")
%!assert (mat2str (false), "false")
%!assert (mat2str (logical (eye (2))), "[true false;false true]")
%!assert (mat2str (logical ([0 1; 0 0])), "[false true;false false]")

## Test input validation
%!error <Invalid call> mat2str ()
%!error mat2str (["Hello"])
%!error <X must be two dimensional> mat2str (ones (3,3,2))
%!error <N must have only 1 or 2 elements> mat2str (ones (3,3), [1 2 3])
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{utf8_str} =} native2unicode (@var{native_bytes}, @var{codepage})
## @deftypefnx {} {@var{utf8_str} =} native2unicode (@var{native_bytes})
## Convert byte stream @var{native_bytes} to UTF-8 using @var{codepage}.
##
## The numbers in the vector @var{native_bytes} are rounded and clipped to
## integers between 0 and 255.  This byte stream is then mapped into the
## code page given by the string @var{codepage} and returned in the string
## @var{utf8_str}.  Octave uses UTF-8 as its internal encoding.  The string
## @var{codepage} must be an identifier of a valid code page.  Examples for
## valid code pages are @qcode{"ISO-8859-1"}, @qcode{"Shift-JIS"}, or
## @qcode{"UTF-16"}.  For a list of supported code pages, see
## @url{https://www.gnu.org/software/libiconv}.  If @var{codepage} is omitted
## or empty, the system default codepage is used.
##
## If @var{native_bytes} is a string vector, it is returned as is.
##
## @seealso{unicode2native}
## @end deftypefn

function utf8_str = native2unicode (native_bytes, codepage = "")

  if (nargin < 1)
    print_usage ();
  endif

  if (ischar (native_bytes))
    utf8_str = native_bytes;
    return;
  endif

  if (! isnumeric (native_bytes) || ! isvector (native_bytes))
    error ("native2unicode: NATIVE_BYTES must be a numeric vector");
  endif

  if (nargin == 2 && ! (ischar (codepage) && isrow (codepage)))
    error ("native2unicode: CODEPAGE must be a string");
  endif

  ## Convert to uint8 which rounds and clips values to range [0, 255]3
  native_bytes = uint8 (native_bytes);

  utf8_str = __native2unicode__ (native_bytes, codepage);

  if (! isrow (native_bytes))
    utf8_str = utf8_str.';
  endif

endfunction


## ""
%!testif HAVE_ICONV
%! assert (double (native2unicode (164:170, 'ISO-8859-5')),
%!         [208 132 208 133 208 134 208 135 208 136 208 137 208 138]);
## ["" 0 ""]
%!testif HAVE_ICONV
%! assert (double (native2unicode ([164:166 0 167:170], 'ISO-8859-5')),
%!         [208 132 208 133 208 134 0 208 135 208 136 208 137 208 138]);

%!assert (native2unicode ("foobar"), "foobar")
%!assert <*54384> (double (native2unicode ([0 0 120.3 0 0 122.6 0 0])),
%!                 [0 0 120 0 0 123 0 0])

%!error <Invalid call> native2unicode ()
%!error <called with too many inputs> native2unicode (1, 'ISO-8859-1', 'test')
%!error <NATIVE_BYTES must be a numeric vector> native2unicode ([1 2; 3 4])
%!error <NATIVE_BYTES must be a numeric vector> native2unicode ({1 2 3 4})
%!error <CODEPAGE must be a string> native2unicode (164:170, 123)
%!error <CODEPAGE must be a string> native2unicode (164:170, ['ISO-8859-1']')
%!testif HAVE_ICONV
%! fail ("native2unicode (234, 'foo')",
%!       "converting from codepage 'foo' to UTF-8");
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{cstr}] =} ostrsplit (@var{s}, @var{sep})
## @deftypefnx {} {[@var{cstr}] =} ostrsplit (@var{s}, @var{sep}, @var{strip_empty})
## Split the string @var{s} using one or more separators @var{sep} and return
## a cell array of strings.
##
## Consecutive separators and separators at boundaries result in empty
## strings, unless @var{strip_empty} is true.  The default value of
## @var{strip_empty} is false.
##
## 2-D character arrays are split at separators and at the original column
## boundaries.
##
## Example:
##
## @example
## @group
## ostrsplit ("a,b,c", ",")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = c
##           @}
##
## ostrsplit (["a,b" ; "cde"], ",")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = cde
##           @}
## @end group
## @end example
## @seealso{strsplit, strtok}
## @end deftypefn

function cstr = ostrsplit (s, sep, strip_empty = false)

  if (nargin < 2)
    print_usage ();
  elseif (! ischar (s) || ! ischar (sep))
    error ("ostrsplit: S and SEP must be string values");
  elseif (! isscalar (strip_empty))
    error ("ostrsplit: STRIP_EMPTY must be a scalar value");
  endif

  if (isempty (s))
    cstr = cell (size (s));
  else
    if (rows (s) > 1)
      ## For 2-D arrays, add separator character at line boundaries
      ## and transform to single string
      s(:, end+1) = sep(1);
      s = reshape (s.', 1, numel (s));
      s(end) = [];
    endif

    ## Split s according to delimiter
    if (isscalar (sep))
      ## Single separator
      idx = find (s == sep);
    else
      ## Multiple separators
      idx = strchr (s, sep);
    endif

    ## Get substring lengths.
    if (isempty (idx))
      strlens = length (s);
    else
      strlens = [idx(1)-1, diff(idx)-1, numel(s)-idx(end)];
    endif
    ## Remove separators.
    s(idx) = [];
    if (strip_empty)
      ## Omit zero lengths.
      strlens = strlens(strlens != 0);
    endif

    ## Convert!
    cstr = mat2cell (s, 1, strlens);
  endif

endfunction


%!assert (ostrsplit ("road to hell", " "), {"road", "to", "hell"})
%!assert (ostrsplit ("road to^hell", " ^"), {"road", "to", "hell"})
%!assert (ostrsplit ("road   to--hell", " -", true), {"road", "to", "hell"})
%!assert (ostrsplit (char ("a,bc", ",de"), ","),
%!        {"a", "bc", char(ones(1,0)), "de "})
%!assert (ostrsplit (char ("a,bc", ",de"), ",", true), {"a", "bc", "de "})
%!assert (ostrsplit (char ("a,bc", ",de"), ", ", true), {"a", "bc", "de"})

## Test input validation
%!error <Invalid call> ostrsplit ()
%!error ostrsplit ("abc")
%!error ostrsplit ("abc", "b", true, 4)
%!error <S and SEP must be string values> ostrsplit (123, "b")
%!error <S and SEP must be string values> ostrsplit ("abc", 1)
%!error <STRIP_EMPTY must be a scalar value> ostrsplit ("abc", "def", ones (3,3))
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} regexptranslate (@var{op}, @var{s})
## Translate a string for use in a regular expression.
##
## This may include either wildcard replacement or special character escaping.
##
## The behavior is controlled by @var{op} which can take the following
## values
##
## @table @asis
## @item @qcode{"wildcard"}
## The wildcard characters @code{.}, @code{*}, and @code{?} are replaced with
## wildcards that are appropriate for a regular expression.  For example:
##
## @example
## @group
## regexptranslate ("wildcard", "*.m")
##      @result{} '.*\.m'
## @end group
## @end example
##
## @item @qcode{"escape"}
## The characters @code{$.?[]}, that have special meaning for regular
## expressions are escaped so that they are treated literally.  For example:
##
## @example
## @group
## regexptranslate ("escape", "12.5")
##      @result{} '12\.5'
## @end group
## @end example
##
## @end table
## @seealso{regexp, regexpi, regexprep}
## @end deftypefn

function y = regexptranslate (op, s)

  if (nargin != 2)
    print_usage ();
  endif

  if (! ischar (op))
    error ("regexptranslate: operation OP must be a string");
  endif

  op = tolower (op);
  if (strcmp ("wildcard", op))
    y = strrep (strrep (strrep (s, '.', '\.'),
                                   '*', '.*'),
                                   '?', '.');
  elseif (strcmp ("escape", op))
    y = regexprep (s, '([][(){}.*+?^$|\\])', '\\$1');
  else
    error ("regexptranslate: invalid operation OP");
  endif

endfunction


%!assert (regexptranslate ("wildcard", "/a*b?c."), "/a.*b.c\\.")
%!assert (regexptranslate ("escape", '^.?[abc]$'), '\^\.\?\[abc\]\$')

## Test input validation
%!error <Invalid call to regexptranslate> regexptranslate ()
%!error <Invalid call to regexptranslate> regexptranslate ("wildcard")
%!error <called with too many inputs> regexptranslate ("a", "b", "c")
%!error <invalid operation> regexptranslate ("foo", "abc")
%!error <operation OP must be a string> regexptranslate (10, "abc")
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} rindex (@var{s}, @var{t})
## Return the position of the last occurrence of the character string
## @var{t} in the character string @var{s}, or 0 if no occurrence is
## found.
##
## @var{s} may also be a string array or cell array of strings.
##
## For example:
##
## @example
## @group
## rindex ("Teststring", "t")
##      @result{} 6
## @end group
## @end example
##
## The @code{rindex} function is equivalent to @code{index} with
## @var{direction} set to @qcode{"last"}.
##
## @seealso{find, index}
## @end deftypefn

function n = rindex (s, t)

  if (nargin != 2)
    print_usage ();
  endif

  n = index (s, t, "last");

endfunction


%!assert (rindex ("foobarbaz", "b"), 7)
%!assert (rindex ("foobarbaz", "o"), 3)

%!test
%! str = char ("Hello", "World", "Goodbye", "World");
%! assert (rindex (str, "o"), [5; 2; 3; 2]);
%! str = cellstr (str);
%! assert (rindex (str, "o"), [5; 2; 3; 2]);

## Test input validation
%!error <Invalid call> rindex ()
%!error rindex ("foo")
%!error rindex ("foo", "bar", "last")
########################################################################
##
## Copyright (C) 2020-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{retval} =} startsWith (@var{str}, @var{pattern})
## @deftypefnx {} {@var{retval} =} startsWith (@var{str}, @var{pattern}, "IgnoreCase", @var{ignore_case})
## Check whether string(s) start with pattern(s).
##
## Return an array of logical values that indicates which string(s) in the
## input @var{str} (a single string or cell array of strings) begin with
## the input @var{pattern} (a single string or cell array of strings).
##
## If the value of the parameter @qcode{"IgnoreCase"} is true, then the
## function will ignore the letter case of @var{str} and @var{pattern}.  By
## default, the comparison is case sensitive.
##
## Examples:
##
## @example
## @group
## ## one string and one pattern while considering case
## startsWith ("hello", "he")
##       @result{}  1
## @end group
##
## @group
## ## one string and one pattern while ignoring case
## startsWith ("hello", "HE", "IgnoreCase", true)
##       @result{}  1
## @end group
##
## @group
## ## multiple strings and multiple patterns while considering case
## startsWith (@{"lab work.pptx", "data.txt", "foundations.ppt"@},
##             @{"lab", "data"@})
##       @result{}  1  1  0
## @end group
##
## @group
## ## multiple strings and one pattern while considering case
## startsWith (@{"DATASHEET.ods", "data.txt", "foundations.ppt"@},
##             "data", "IgnoreCase", false)
##       @result{}  0  1  0
## @end group
##
## @group
## ## multiple strings and one pattern while ignoring case
## startsWith (@{"DATASHEET.ods", "data.txt", "foundations.ppt"@},
##             "data", "IgnoreCase", true)
##       @result{}  1  1  0
## @end group
## @end example
##
## @seealso{endsWith, regexp, strncmp, strncmpi}
## @end deftypefn

function retval = startsWith (str, pattern, IgnoreCase, ignore_case)

  if (nargin != 2 && nargin != 4)
    print_usage ();
  endif

  ## Validate input str and pattern
  if (! (iscellstr (str) || ischar (str)))
    error ("startsWith: STR must be a string or cell array of strings");
  endif
  if (! (iscellstr (pattern) || ischar (pattern)))
    error ("startsWith: PATTERN must be a string or cell array of strings");
  endif

  str = cellstr (str);
  pattern = cellstr (pattern);

  if (nargin == 2)
    ignore_case = false;
  else
    ## For Matlab compatibility accept any abbreviation of 3rd argument
    if (! ischar (IgnoreCase) || isempty (IgnoreCase)
        || ! strncmpi (IgnoreCase, "IgnoreCase", length (IgnoreCase)))
      error ('startsWith: third input must be "IgnoreCase"');
    endif

    if (! isscalar (ignore_case) || ! isreal (ignore_case))
      error ('startsWith: "IgnoreCase" value must be a logical scalar');
    endif
    ignore_case = logical (ignore_case);
  endif

  retval = false (size (str));
  if (ignore_case)
    for j = 1:numel (pattern)
      retval |= strncmpi (str, pattern{j}, length (pattern{j}));
    endfor
  else
    for j = 1:numel (pattern)
      retval |= strncmp (str, pattern{j}, length (pattern{j}));
    endfor
  endif

endfunction


## Test simple use with one string and one pattern
%!assert (startsWith ("hello", "he"))
%!assert (! startsWith ("hello", "HE"))
%!assert (startsWith ("hello", "HE", "i", 5))
%!assert (! startsWith ("hello", "no"))

## Test multiple strings with a single pattern
%!test
%! str = {"data science", "dataSheet.ods", "myFunc.m"; "foundations.ppt", ...
%!        "results.txt", "myFile.odt"};
%! pattern = "data";
%! expected = [true, true, false; false, false, false];
%! assert (startsWith (str, pattern), expected);

## Test multiple strings with multiple patterns
%!test
%! str = {"lab work.pptx", "myFile.odt", "data.txt", "foundations.ppt"};
%! pattern = {"lab", "data"};
%! expected = [true, false, true, false];
%! assert (startsWith (str, pattern), expected);

## Test IgnoreCase
%!test
%! str = {"DATASHEET.ods", "myFile.odt", "data.txt", "foundations.ppt"};
%! pattern = "data";
%! expected_ignore = [true, false, true, false];
%! expected_wo_ignore = [false, false, true, false];
%! assert (startsWith (str, pattern, "IgnoreCase", true), expected_ignore);
%! assert (startsWith (str, pattern, "IgnoreCase", false), expected_wo_ignore);
%! assert (startsWith (str, pattern, "I", 500), expected_ignore);
%! assert (startsWith (str, pattern, "iG", 0), expected_wo_ignore);

## Test input validation
%!error <Invalid call> startsWith ()
%!error startsWith ("A")
%!error startsWith ("A", "B", "C")
%!error startsWith ("A", "B", "C", "D", "E")
%!error <STR must be a string> startsWith (152, "hi")
%!error <STR must be a .* cell array of strings> startsWith ({152}, "hi")
%!error <PATTERN must be a string> startsWith ("hi", 152)
%!error <PATTERN must be a .* cell array of strings> startsWith ("hi", {152})
%!error <third input must be "IgnoreCase"> startsWith ("hello", "he", 1, 1)
%!error <third input must be "IgnoreCase"> startsWith ("hello", "he", "", 1)
%!error <third input must be "IgnoreCase"> startsWith ("hello", "he", "foo", 1)
%!error <"IgnoreCase" value must be a logical scalar>
%! startsWith ("hello", "hi", "i", "true");
%!error <"IgnoreCase" value must be a logical scalar>
%! startsWith ("hello", "hi", "i", {true});
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{x} =} str2num (@var{s})
## @deftypefnx {} {[@var{x}, @var{state}] =} str2num (@var{s})
## Convert the string (or character array) @var{s} to a number (or an array).
##
## Examples:
##
## @example
## @group
## str2num ("3.141596")
##       @result{} 3.141596
##
## str2num (["1, 2, 3"; "4, 5, 6"])
##       @result{} 1  2  3
##          4  5  6
## @end group
## @end example
##
## The optional second output, @var{state}, is logically true when the
## conversion is successful.  If the conversion fails the numeric output,
## @var{x}, is empty and @var{state} is false.
##
## @strong{Caution:} As @code{str2num} uses the @code{eval} function to do the
## conversion, @code{str2num} will execute any code contained in the string
## @var{s}.  Use @code{str2double} for a safer and faster conversion.
##
## For cell array of strings use @code{str2double}.
## @seealso{str2double, eval}
## @end deftypefn

function [m, state] = str2num (s)

  if (nargin < 1)
    print_usage ();
  elseif (! ischar (s))
    error ("str2num: S must be a string or string array");
  endif

  s(:, end+1) = ";";
  s = sprintf ("m = [%s];", reshape (s', 1, numel (s)));
  state = true;
  ## Swallow any errors from eval (bug #55939).
  try
    eval (s);
  catch
    m = [];
    state = false;
  end_try_catch

  if (ischar (m))
    m = [];
    state = false;
  endif

endfunction


%!assert (str2num ("-1.3e2"), -130)
%!assert (str2num ("[1, 2; 3, 4]"), [1, 2; 3, 4])

%!test
%! [x, state] = str2num ("pi");
%! assert (state);
%! [x, state] = str2num ("Hello World");
%! assert (! state);

## Test input validation
%!error <Invalid call> str2num ()
%!error <S must be a string> str2num ({"string"})
########################################################################
##
## Copyright (C) 1994-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} strcat (@var{s1}, @var{s2}, @dots{})
## Return a string containing all the arguments concatenated
## horizontally.
##
## If the arguments are cell strings, @code{strcat} returns a cell string
## with the individual cells concatenated.  For numerical input, each element
## is converted to the corresponding ASCII character.  Trailing white space
## for any character string input is eliminated before the strings are
## concatenated.  Note that cell string values do @strong{not} have
## whitespace trimmed.
##
## For example:
##
## @example
## @group
## strcat ("|", " leading space is preserved", "|")
##     @result{} | leading space is preserved|
## @end group
## @end example
##
## @example
## @group
## strcat ("|", "trailing space is eliminated ", "|")
##     @result{} |trailing space is eliminated|
## @end group
## @end example
##
## @example
## @group
## strcat ("homogeneous space |", "  ", "| is also eliminated")
##     @result{} homogeneous space || is also eliminated
## @end group
## @end example
##
## @example
## @group
## s = [ "ab"; "cde" ];
## strcat (s, s, s)
##     @result{}
##         "ababab   "
##         "cdecdecde"
## @end group
## @end example
##
## @example
## @group
## s = @{ "ab"; "cd " @};
## strcat (s, s, s)
##     @result{}
##         @{
##           [1,1] = ababab
##           [2,1] = cd cd cd
##         @}
## @end group
## @end example
##
## @seealso{cstrcat, char, strvcat}
## @end deftypefn

function st = strcat (varargin)

  if (nargin == 0)
    st = "";
  elseif (nargin == 1)
    if (iscellstr (varargin{1}))
      st = varargin{1};
    elseif (isreal (varargin{1}) || ischar (varargin{1}))
      st = char (cellstr (varargin{1}));
    else
      error ("strcat: inputs must be strings or cells of strings");
    endif
  else
    ## Convert to cells of strings
    uo = "uniformoutput";
    reals = cellfun ("isreal", varargin);
    if (any (reals))
      varargin(reals) = cellfun ("char", varargin(reals), uo, false);
    endif
    chars = cellfun ("isclass", varargin, "char");
    allchar = all (chars);
    varargin(chars) = cellfun ("cellstr", varargin(chars), uo, false);
    if (! all (cellfun ("isclass", varargin, "cell")))
      error ("strcat: inputs must be strings or cells of strings");
    endif

    ## We don't actually need to bring all cells to common size, because
    ## cellfun can now expand scalar cells.
    err = common_size (varargin{:});

    if (err)
      error ("strcat: arguments must be the same size, or be scalars");
    endif

    ## Cellfun handles everything for us.
    st = cellfun ("horzcat", varargin{:}, uo, false);

    if (allchar)
      ## If all inputs were strings, return strings.
      st = char (st);
    endif
  endif

endfunction


## test the dimensionality
## 1d
%!assert (strcat ("ab ", "ab "), "abab")
%!assert (strcat ({"ab "}, "ab "), {"ab ab"})
%!assert (strcat ("ab ", {"ab "}), {"abab "})
%!assert (strcat ({"ab "}, {"ab "}), {"ab ab "})
%!assert (strcat ("", "ab"), "ab")
%!assert (strcat ("", {"ab"}, {""}), {"ab"})
## 2d
%!assert (strcat (["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])

## test for deblanking implied trailing spaces of character input
%!assert (strcat ("foo", "bar"), "foobar")
%!assert (strcat (["a "; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])

## test for mixing character and cell inputs
%!assert (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})

## test for scalar strings with vector strings
%!assert (strcat (["a"; "b"], "c"), ["ac"; "bc"])

## test with cells with strings of differing lengths
%!assert (all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
%!assert (all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))

## test with a single string or cell input
%!assert <*49094> (strcat ("foo    "), "foo")
%!assert <*49094> (strcat ({"foo"}), {"foo"})

%!assert (strcat (1), char (1))
%!assert (strcat (1, 2), strcat (char (1), char (2)))
%!assert (strcat ("", 2), strcat ([], char (2)))

%!assert (strcat (), "")
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{idx} =} strchr (@var{str}, @var{chars})
## @deftypefnx {} {@var{idx} =} strchr (@var{str}, @var{chars}, @var{n})
## @deftypefnx {} {@var{idx} =} strchr (@var{str}, @var{chars}, @var{n}, @var{direction})
## @deftypefnx {} {[@var{i}, @var{j}] =} strchr (@dots{})
## Search through the string @var{str} for occurrences of characters from the
## set @var{chars}.
##
## The return value(s), as well as the @var{n} and @var{direction} arguments
## behave identically as in @code{find}.
##
## This will be faster than using @code{regexp} in most cases.
##
## @seealso{find}
## @end deftypefn

function varargout = strchr (str, chars, varargin)

  if (nargin < 2 || nargin > 4)
    print_usage ();
  elseif (! ischar (str))
    error ("strchr: STR argument must be a string or string array");
  elseif (! ischar (chars))
    error ("strchr: CHARS argument must be a string");
  endif

  if (isempty (chars))
    mask = false (size (str));
  elseif (length (chars) <= 4)
    ## With a few characters, it pays off to build the mask incrementally.
    ## We do it via a for loop to save memory.
    mask = str == chars(1);
    for i = 2:length (chars)
      mask |= str == chars(i);
    endfor
  else
    ## Index the str into a mask of valid values.
    ## This is slower than it could be because of the +1 issue.
    f = false (256, 1);
    f(uint8 (chars) + 1) = true;
    ## Default goes via double -- unnecessarily long.
    si = uint32 (str);
    ## in-place is faster than str+1
    ++si;
    mask = reshape (f(si), size (str));
  endif

  varargout = cell (1, nargout);
  varargout{1} = [];
  [varargout{:}] = find (mask, varargin{:});

endfunction


%!assert (strchr ("Octave is the best software", ""), zeros (1,0))
%!assert (strchr ("Octave is the best software", "best"),
%!        [3, 6, 9, 11, 13, 15, 16, 17, 18, 20, 23, 27])
%!assert (strchr ("Octave is the best software", "software"),
%!        [3, 4, 6, 9, 11, 13, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27])

## Test input validation
%!error <Invalid call> strchr ()
%!error <Invalid call> strchr (1)
%!error <Invalid call> strchr ("s", "a", 1, "last", 5)
%!error <STR argument must be a string> strchr (1, "aeiou")
%!error <CHARS argument must be a string> strchr ("aeiou", 1)
########################################################################
##
## Copyright (C) 2007-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{str} =} strjoin (@var{cstr})
## @deftypefnx {} {@var{str} =} strjoin (@var{cstr}, @var{delimiter})
## Join the elements of the cell string array, @var{cstr}, into a single
## string.
##
## If no @var{delimiter} is specified, the elements of @var{cstr} are
## separated by a space.
##
## If @var{delimiter} is specified as a string, the cell string array is
## joined using the string.  Escape sequences are supported.
##
## If @var{delimiter} is a cell string array whose length is one less than
## @var{cstr}, then the elements of @var{cstr} are joined by interleaving the
## cell string elements of @var{delimiter}.  Escape sequences are not
## supported.
##
## @example
## @group
## strjoin (@{'Octave','Scilab','Lush','Yorick'@}, '*')
##       @result{} 'Octave*Scilab*Lush*Yorick'
## @end group
## @end example
## @seealso{strsplit}
## @end deftypefn

function rval = strjoin (cstr, delimiter = " ")

  if (nargin < 1)
    print_usage ();
  elseif (! (iscellstr (cstr) && (ischar (delimiter) || iscellstr (delimiter))))
    print_usage ();
  endif

  if (numel (cstr) == 1)
    rval = cstr{1};
    return;
  endif

  if (ischar (delimiter))
    delimiter = do_string_escapes (delimiter);
    delimiter = {delimiter};
  endif

  num = numel (cstr);
  if (numel (delimiter) == 1 && num > 1)
    delimiter = repmat (delimiter, 1, num);
    delimiter(end) = {""};
  elseif (num > 0 && numel (delimiter) != num - 1)
    error ("Octave:strjoin:cellstring_delimiter_mismatch",
      "strjoin: the number of delimiters does not match the number of strings");
  else
    delimiter(end+1) = {""};
  endif

  if (num == 0)
    rval = "";
  else
    rval = [[cstr(:).'; delimiter(:).']{:}];
  endif

endfunction


%!assert (strjoin ({"hello"}, "-"), "hello")
%!assert (strjoin ({"hello", "world"}), "hello world")
%!assert (strjoin ({"Octave", "Scilab", "Lush", "Yorick"}, "*"),
%!  "Octave*Scilab*Lush*Yorick")
%!assert (strjoin ({"space", "comma", "dash", "semicolon", "done"},
%!  {" ", ",", "-", ";"}), "space comma,dash-semicolon;done")
%!assert (strjoin ({'Octave','Scilab'},'\n'), "Octave\nScilab")
%!assert (strjoin ({'Octave','Scilab'},{'\n'}), "Octave\\nScilab")
%!assert (strjoin ({},'foo'), "")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} strjust (@var{s})
## @deftypefnx {} {} strjust (@var{s}, @var{pos})
## Return the text, @var{s}, justified according to @var{pos}, which may
## be @qcode{"left"}, @qcode{"center"}, or @qcode{"right"}.
##
## If @var{pos} is omitted it defaults to @qcode{"right"}.
##
## Null characters are replaced by spaces.  All other character data are
## treated as non-white space.
##
## Example:
##
## @example
## @group
## strjust (["a"; "ab"; "abc"; "abcd"])
##      @result{}
##         "   a"
##         "  ab"
##         " abc"
##         "abcd"
## @end group
## @end example
## @seealso{deblank, strrep, strtrim, untabify}
## @end deftypefn

function y = strjust (s, pos = "right")

  if (nargin < 1)
    print_usage ();
  elseif (! ischar (s) || ndims (s) > 2)
    error ("strjust: S must be a string or 2-D character matrix");
  endif

  if (isempty (s))
    y = s;
    return;
  endif

  ## Apparently, Matlab considers nulls to be blanks as well; however, does
  ## not preserve the nulls, but rather converts them to blanks.  That's a
  ## bit unexpected, but it allows simpler processing, because we can move
  ## just the nonblank characters.  So we'll do the same here.

  [nr, nc] = size (s);
  ## Find the indices of all nonblanks.
  nonbl = s != " " & s != "\0";
  [idx, jdx] = find (nonbl);

  if (strcmpi (pos, "right"))
    ## We wish to find the maximum column index for each row.  Because jdx is
    ## sorted, we can take advantage of the fact that assignment is processed
    ## sequentially and for duplicate indices the last value will remain.
    maxs = repmat (nc, [nr, 1]);
    maxs(idx) = jdx;
    shift = nc - maxs;
  elseif (strcmpi (pos, "left"))
    ## See above for explanation.
    mins = ones (nr, 1);
    mins(flipud (idx(:))) = flipud (jdx(:));
    shift = 1 - mins;
  else
    ## Use both of the above to achieve centering.
    mins = ones (nr, 1);
    mins(flipud (idx(:))) = flipud (jdx(:));
    maxs = repmat (nc, [nr, 1]);
    maxs(idx) = jdx;
    shift = floor ((nc + 1 - maxs - mins) / 2);
  endif

  ## Adjust the column indices.
  jdx += shift (idx);

  ## Create a blank matrix and position the nonblank characters.
  y = repmat (" ", nr, nc);
  y(sub2ind ([nr, nc], idx, jdx)) = s(nonbl);

endfunction


%!assert (strjust (char ("a", "ab", "abc", "abcd")),
%!        ["   a";"  ab"; " abc"; "abcd"])
%!assert (strjust (char (" a", "  ab", "abc", "abcd"), "left"),
%!        ["a   "; "ab  "; "abc "; "abcd"])
%!assert (strjust (char ("a", "ab", "abc", "abcd"), "CENTER"),
%!        [" a  "; " ab "; "abc "; "abcd"])
%!assert (strjust (["";""]), "")

## Test input validation
%!error <Invalid call to strjust> strjust ()
%!error <called with too many inputs> strjust (["a";"ab"], "center", 1)
%!error <S must be a string> strjust (ones (3,3))
%!error <S must be a string> strjust (char (ones (3,3,3)))
########################################################################
##
## Copyright (C) 2009-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{cstr}] =} strsplit (@var{str})
## @deftypefnx {} {[@var{cstr}] =} strsplit (@var{str}, @var{del})
## @deftypefnx {} {[@var{cstr}] =} strsplit (@dots{}, @var{name}, @var{value})
## @deftypefnx {} {[@var{cstr}, @var{matches}] =} strsplit (@dots{})
## Split the string @var{str} using the delimiters specified by @var{del} and
## return a cell string array of substrings.
##
## If a delimiter is not specified the string is split at whitespace
## @code{@{" ", "\f", "\n", "\r", "\t", "\v"@}}.  Otherwise, the delimiter,
## @var{del} must be a string or cell array of strings.  By default,
## consecutive delimiters in the input string @var{s} are collapsed into one
## resulting in a single split.
##
## Supported @var{name}/@var{value} pair arguments are:
##
## @itemize
## @item @var{collapsedelimiters} which may take the value of @code{true}
## (default) or @code{false}.
##
## @item @var{delimitertype} which may take the value of @qcode{"simple"}
## (default) or @nospell{@qcode{"regularexpression"}}.  A simple delimiter
## matches the text exactly as written.  Otherwise, the syntax for regular
## expressions outlined in @code{regexp} is used.
## @end itemize
##
## The optional second output, @var{matches}, returns the delimiters which were
## matched in the original string.
##
## Examples with simple delimiters:
##
## @example
## strsplit ("a b c")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = c
##           @}
##
## strsplit ("a,b,c", ",")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = c
##           @}
##
## strsplit ("a foo b,bar c", @{" ", ",", "foo", "bar"@})
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = c
##           @}
##
## strsplit ("a,,b, c", @{",", " "@}, "collapsedelimiters", false)
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] =
##             [1,3] = b
##             [1,4] =
##             [1,5] = c
##           @}
##
## @end example
##
## Examples with @nospell{regularexpression} delimiters:
##
## @smallexample
## strsplit ("a foo b,bar c", ',|\s|foo|bar', ...
##           "delimitertype", "regularexpression")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = c
##           @}
##
## strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, ...
##           "delimitertype", "regularexpression")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] =
##             [1,3] = b
##             [1,4] =
##             [1,5] = c
##           @}
##
## strsplit ("a,\t,b, c", @{',', '\s'@}, "delimitertype", "regularexpression")
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] = b
##             [1,3] = c
##           @}
##
## strsplit ("a,\t,b, c", @{',', ' ', '\t'@}, "collapsedelimiters", false)
##       @result{}
##           @{
##             [1,1] = a
##             [1,2] =
##             [1,3] =
##             [1,4] = b
##             [1,5] =
##             [1,6] = c
##           @}
## @end smallexample
##
## @seealso{ostrsplit, strjoin, strtok, regexp}
## @end deftypefn

function [cstr, matches] = strsplit (str, del, varargin)

  args.collapsedelimiters = true;
  args.delimitertype = "simple";

  [reg, params] = parseparams (varargin);

  if (nargin < 1)
    print_usage ();
  elseif (numel (reg) > 1)
    print_usage ();
  elseif (numel (reg) == 1)
    ## This is undocumented behavior to accept a logical 3rd arg.
    if (islogical (reg{1}))
      args.collapsedelimiters = reg{1};
    else
      print_usage ();
    endif
  endif
  fields = fieldnames (args);
  for n = 1:2:numel (params)
    if (any (strcmpi (params{n}, fields)))
      args.(tolower (params{n})) = params{n+1};
    elseif (ischar (varargin{n}))
      error ("Octave:strsplit:invalid_parameter_name",
             "strsplit: invalid parameter name, '%s'", varargin{n});
    else
      print_usage ();
    endif
  endfor

  ## Save the length of the "delimitertype" parameter
  length_deltype = length (args.delimitertype);

  if (nargin == 1 || (nargin > 1 && islogical (del)))
    if (nargin > 1)
      ## Second input is the "collapsedelimiters" parameter
      args.collapsedelimiters = del;
    endif
    ## Set proper default for the delimiter type
    if (strncmpi (args.delimitertype, "simple", length_deltype))
      del = {" ", "\f", "\n", "\r", "\t", "\v"};
    else
      del = '\s';
    endif
  endif

  if (! ischar (str) || (! ischar (del) && ! iscellstr (del)))
    error ("strsplit: S and DEL must be string values");
  elseif (! isempty (str) && ! isrow (str))
    error ("strsplit: S must be a char row vector");
  elseif (! isscalar (args.collapsedelimiters))
    error ("strsplit: COLLAPSEDELIMITERS must be a scalar value");
  endif

  if (strncmpi (args.delimitertype, "simple", length_deltype))
    is_simple = true;
  elseif (strncmpi (args.delimitertype, "regularexpression", length_deltype))
    is_simple = false;
  else
    error ("Octave:strsplit:invalid_delimitertype", "strsplit: Invalid DELIMITERTYPE");
  endif

  if (is_simple)
    if (iscellstr (del))
      del = cellfun (@do_string_escapes, del, "uniformoutput", false);
    else
      del = do_string_escapes (del);
    endif
    ## Escape characters which have a special meaning in regexp.
    del = regexprep (del, '([{}()[\]^$.*?+|\\])', '\\$1');
  endif

  if (isempty (str))
    cstr = {str};
  else
    if (iscellstr (del))
      del = sprintf ("%s|", del{:});
      del(end) = [];
    endif
    if (args.collapsedelimiters)
      del = [ "(" del ")+" ];
    endif
    [cstr, matches] = regexp (str, del, "split", "match");
  endif

endfunction


%!shared str
%! str = "The rain in Spain stays mainly in the plain.";

## Split on all whitespace.
%!assert (strsplit (str), {"The", "rain", "in", "Spain", "stays", ...
%!                         "mainly", "in", "the", "plain."})
## Split on "ain".
%!assert (strsplit (str, "ain"), {"The r", " in Sp", " stays m", ...
%!                                "ly in the pl", "."})
## Split on " " and "ain" (treating multiple delimiters as one).
%!test
%! s = strsplit (str, '\s|ain', true, "delimitertype", "r");
%! assert (s, {"The", "r", "in", "Sp", "stays", ...
%!             "m", "ly", "in", "the", "pl", "."});
%!test
%! s = strsplit (str, '\s|ain', true, "delimitertype", "r");
%! assert (s, {"The", "r", "in", "Sp", "stays", ...
%!             "m", "ly", "in", "the", "pl", "."});
%!test
%! [s, m] = strsplit (str, {'\s', 'ain'}, true, "delimitertype", "r");
%! assert (s, {"The", "r", "in", "Sp", "stays", ...
%!             "m", "ly", "in", "the", "pl", "."});
%! assert (m, {" ", "ain ", " ", "ain ", " ", "ain", " ", " ", " ", "ain"});
## Split on " " and "ain", and treat multiple delimiters separately.
%!test
%! [s, m] = strsplit (str, {" ", "ain"}, "collapsedelimiters", false);
%! assert (s, {"The", "r", "", "in", "Sp", "", "stays", ...
%!             "m", "ly", "in", "the", "pl", "."});
%! assert (m, {" ", "ain", " ", " ", "ain", " ", " ", "ain", ...
%!             " ", " ", " ", "ain"});

%!assert (strsplit ("road to hell"), {"road", "to", "hell"})
%!assert (strsplit ("road to hell", " "), {"road", "to", "hell"})
%!assert (strsplit ("road to^hell", {" ","^"}), {"road", "to", "hell"})
%!assert (strsplit ("road   to--hell", {" ","-"}, true), {"road", "to", "hell"})
%!assert (strsplit (["a,bc,,de"], ",", false, "delimitertype", "s"),
%!        {"a", "bc", "", "de"})
%!assert (strsplit (["a,bc,,de"], ",", false), {"a", "bc", "", "de"})
%!assert (strsplit (["a,bc,de"], ",", true), {"a", "bc", "de"})
%!assert (strsplit (["a,bc,de"], {","," "}, true), {"a", "bc", "de"})

%!assert (strsplit ("road to hell", " ", "delimitertype", "r"),
%!        {"road", "to", "hell"})
%!assert (strsplit ("road to^hell", '\^| ', "delimitertype", "r"),
%!        {"road", "to", "hell"})
%!assert (strsplit ("road to^hell", "[ ^]", "delimitertype", "r"),
%!        {"road", "to", "hell"})
%!assert (strsplit ("road   to--hell", "[ -]", false, "delimitertype", "r"),
%!        {"road", "", "", "to", "", "hell"})
%!assert (strsplit (["a,bc,de"], ",", "delimitertype", "r"), {"a", "bc", "de"})
%!assert (strsplit (["a,bc,,de"], ",", false, "delimitertype", "r"),
%!        {"a", "bc", "", "de"})
%!assert (strsplit (["a,bc,de"], ",", true, "delimitertype", "r"),
%!        {"a", "bc", "de"})
%!assert (strsplit (["a,bc,de"], "[, ]", true, "delimitertype", "r"),
%!        {"a", "bc", "de"})
%!assert (strsplit ("hello \t world", true, "delimitertype", "r"),
%!        {"hello", "world"})

%!assert (strsplit ("foo\tbar", '\t', "delimitertype", "r"), {"foo", "bar"})
%!assert (strsplit ("foo\tbar", '\t', "delimitertype", "s"), {"foo", "bar"})

## Test "match" for consecutive delmiters
%!test
%! [a, m] = strsplit ("a\t \nb", '\s', "delimitertype", "regularexpression",
%!   "collapsedelimiters", false);
%! assert (a, {"a", "", "", "b"});
%! assert (m, {"\t", " ", "\n"});
%!test
%! [a, m] = strsplit ("a\t \nb", '\s', false, "delimitertype", "regularexpression");
%! assert (a, {"a", "", "", "b"});
%! assert (m, {"\t", " ", "\n"});
%!test
%! [a, m] = strsplit ("a\t \nb", '\s', "delimitertype", "regularexpression");
%! assert (a, {"a", "b"});
%! assert (m, {"\t \n"});
%!test
%! [a, m] = strsplit ("a\t \nb", {"\t", " ", "\n"}, "delimitertype", "simple");
%! assert (a, {"a", "b"});
%! assert (m, {"\t \n"});
%!test
%! [s, m] = strsplit ("hello \t world", true);
%! assert (s, {"hello", "world"});
%! assert (m, {" \t "});

## Compatibility
%! assert (strsplit ("", "a"), {""});
%! assert (strsplit ("a", "a"), {"", ""});
%! assert (strsplit ("aa", "a"), {"", ""});
%! assert (strsplit ("aaa", "a"), {"", ""});

%!assert <*44641> (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
%!assert <*44641> (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})

%!assert <*47403> (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})

## Test input validation
%!error <Invalid call> strsplit ()
%!error strsplit ("abc", "b", true, 4)
%!error <invalid parameter name, 'foo'> strsplit ("abc", "b", "foo", "true")
%!error <S and DEL must be string values> strsplit (123, "b")
%!error <S must be a char row vector> strsplit (["abc"; "xyz"])
%!error <S must be a char row vector> strsplit (reshape ("axbycz", [1 3 2]))
%!error <COLLAPSEDELIMITERS must be a scalar value> strsplit ("abc", "def", "collapsedelimiters", ones (3,3))
%!error <Invalid DELIMITERTYPE> strsplit ("abc", "b", "delimitertype", "foobar")
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{tok}, @var{rem}] =} strtok (@var{str})
## @deftypefnx {} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
##
## Find all characters in the string @var{str} up to, but not including, the
## first character which is in the string @var{delim}.
##
## @var{str} may also be a cell array of strings in which case the function
## executes on every individual string and returns a cell array of tokens and
## remainders.
##
## Leading delimiters are ignored.  If @var{delim} is not specified,
## whitespace is assumed.
##
## If @var{rem} is requested, it contains the remainder of the string, starting
## at the first delimiter.
##
## Examples:
##
## @example
## @group
## strtok ("this is the life")
##      @result{} "this"
##
## [tok, rem] = strtok ("14*27+31", "+-*/")
##      @result{}
##         tok = 14
##         rem = *27+31
## @end group
## @end example
## @seealso{index, strsplit, strchr, isspace}
## @end deftypefn

function [tok, rem] = strtok (str, delim)

  if (nargin < 1)
    print_usage ();
  elseif (! (ischar (str) || iscellstr (str)))
    error ("strtok: STR must be a string or cell array of strings");
  elseif (ischar (str) && ! isvector (str) &&! isempty (str))
    error ("strtok: STR cannot be a 2-D character array");
  endif

  if (nargin < 2 || isempty (delim))
    ws_delim = true;
  else
    ws_delim = false;
  endif

  if (isempty (str))
    tok = rem = "";
  elseif (ischar (str))
    if (ws_delim)
      idx = isspace (str);
    elseif (length (delim) <= 7)
      ## Build index of delimiters incrementally for low N.
      idx = str == delim(1);
      for i = 2:length (delim)
        idx |= str == delim(i);
      endfor
    else
      ## Index the str into a mask of valid values.  Faster for large N.
      f = false (256, 1);
      ## This is slower than it could be because of the +1 issue.
      f(uint8 (delim)+1) = true;
      ## Default goes via double -- unnecessarily long.
      si = uint32 (str);
      ## in-place is faster than str+1
      ++si;
      idx = f(si);
    endif

    idx_dlim = find (idx, 1);
    idx_nodlim = find (! idx, 1);
    if (isempty (idx_dlim))
      ## No delimiter.  Return whole string.
      tok = str;
      rem = "";
    elseif (idx_dlim > idx_nodlim)
      ## Normal case.  No leading delimiters and at least 1 delimiter in STR.
      tok = str(1:idx_dlim-1);
      rem = str(idx_dlim:end);
    else
      ## Leading delimiter found.
      idx_dlim = find (idx(idx_nodlim+1:end), 1);
      if (isempty (idx_dlim))
        ## No further delimiters.  Return STR stripped of delimiter prefix.
        tok = str(idx_nodlim:end);
        rem = "";
      else
        ## Strip delimiter prefix.  Return STR up to 1st delimiter
        tok = str(idx_nodlim:(idx_dlim + idx_nodlim -1));
        rem = str((idx_dlim + idx_nodlim):end);
      endif
    endif
  else    # Cell array of strings
    if (ws_delim)
      delim = '\s';
    endif
    ptn = [ '^[' delim ']*','([^' delim ']+)','([' delim '].*)$' ];
    matches = regexp (str, ptn, "tokens");
    eidx = cellfun ("isempty", matches);
    midx = ! eidx;
    tok = cell (size (str));
    tok(eidx) = regexprep (str(eidx), [ '^[' delim ']+' ], '');
    ## Unwrap doubly nested cell array from regexp
    tmp = [matches{midx}];
    if (! isempty (tmp))
      tmp = [tmp{:}];
    endif
    tok(midx) = tmp(1:2:end);
    if (isargout (2))
      rem = cell (size (str));
      rem(eidx) = {""};
      rem (midx) = tmp(2:2:end);
    endif
  endif

endfunction


%!demo
%! strtok ("this is the life")
%! # split at the first space, returning "this"

%!demo
%! s = "14*27+31"
%! while (1)
%!   [t, s] = strtok (s, "+-*/");
%!   printf ("<%s>", t);
%!   if (isempty (s))
%!     break;
%!   endif
%!   printf ("<%s>", s(1));
%! endwhile
%! printf ("\n");
%! % ----------------------------------------------------
%! % Demonstrates processing of an entire string split on
%! % a variety of delimiters.  Tokens and delimiters are
%! % printed one after another in angle brackets.

## Test the tokens for all cases
%!assert (strtok (""), "");             # no string
%!assert (strtok ("this"), "this");     # no delimiter in string
%!assert (strtok ("this "), "this");    # delimiter at end
%!assert (strtok ("this is"), "this");  # delimiter in middle
%!assert (strtok (" this"), "this");    # delimiter at start
%!assert (strtok (" this "), "this");   # delimiter at start and end
%!assert (strtok (" "), ""(1:0));       # delimiter only

## Test the remainder for all cases
%!test [t,r] = strtok (""); assert (r, "");
%!test [t,r] = strtok ("this"); assert (r, "");
%!test [t,r] = strtok ("this "); assert (r, " ");
%!test [t,r] = strtok ("this is"); assert (r, " is");
%!test [t,r] = strtok (" this"); assert (r, "");
%!test [t,r] = strtok (" this "); assert (r, " ");
%!test [t,r] = strtok (" "); assert (r, "");

## Test all tokens and remainders with cell array input
%!test
%! str = {"", "this", "this ", "this is", " this", " this ", " "};
%! [t, r] = strtok (str);
%! assert (t{1}, "");
%! assert (r{1}, "");
%! assert (t{2}, "this");
%! assert (r{2}, "");
%! assert (t{3}, "this");
%! assert (r{3}, " ");
%! assert (t{4}, "this");
%! assert (r{4}, " is");
%! assert (t{5}, "this");
%! assert (r{5}, "");
%! assert (t{6}, "this");
%! assert (r{6}, " ");
%! assert (t{7}, "");
%! assert (r{7}, "");

## Simple check for 2, 3, and 4 delimiters
%!assert (strtok ("this is", "i "), "th")
%!assert (strtok ("this is", "ij "), "th")
%!assert (strtok ("this is", "ijk "), "th")

## Test all cases for 8 delimiters since a different
%!# algorithm is used when more than 7 delimiters
%!assert (strtok ("","jklmnop "), "")
%!assert (strtok ("this","jklmnop "), "this")
%!assert (strtok ("this ","jklmnop "), "this")
%!assert (strtok ("this is","jklmnop "), "this")
%!assert (strtok (" this","jklmnop "), "this")
%!assert (strtok (" this ","jklmnop "), "this")
%!assert (strtok (" ","jklmnop "), ""(1:0))

## Test 'bad' string orientations
%!assert (strtok (" this ".'), "this".');   # delimiter at start and end
%!assert (strtok (" this ".',"jkl "), "this".')

## Test with TAB, LF, VT, FF, and CR
%!test
%! for ch = "\t\n\v\f\r"
%!   [t, r] = strtok (["beg", ch, "end"]);
%!   assert (t, "beg");
%!   assert (r, [ch, "end"]);
%! endfor

## Test input validation
%!error <Invalid call> strtok ()
%!error <STR must be a string> strtok (1, "b")
%!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} strtrim (@var{s})
## Remove leading and trailing whitespace from @var{s}.
##
## If @var{s} is a matrix, @var{strtrim} trims each row to the length of
## longest string.  If @var{s} is a cell array of strings, operate recursively
## on each string element.
##
## For example:
##
## @example
## @group
## strtrim ("    abc  ")
##      @result{}  "abc"
##
## strtrim ([" abc   "; "   def   "])
##      @result{}  ["abc  "  ; "  def"]
## @end group
## @end example
## @seealso{deblank}
## @end deftypefn

## This function was derived from deblank.

function s = strtrim (s)

  if (nargin < 1)
    print_usage ();
  endif

  if (ischar (s))

    k = find (! isspace (s));
    if (isempty (s) || isempty (k))
      s = "";
    else
      s = s(:, ceil (min (k) / rows (s)):ceil (max (k) / rows (s)));
    endif

  elseif (iscell (s))

    char_idx = cellfun ("isclass", s, "char");
    cell_idx = cellfun ("isclass", s, "cell");
    if (! all (char_idx | cell_idx))
      error ("strtrim: S argument must be a string or cellstring");
    endif

    ## Divide work load.  Recursive cellfun strtrim call is slow
    ## and avoided where possible.
    s(char_idx) = regexprep (s(char_idx), "^[\\s\v]+|[\\s\v]+$", '');
    s(cell_idx) = cellfun ("strtrim", s(cell_idx), "UniformOutput", false);

  else
    error ("strtrim: S argument must be a string or cellstring");
  endif

endfunction


%!assert (strtrim ("    abc  "), "abc")
%!assert (strtrim ("  "), "")
%!assert (strtrim ("abc"), "abc")
%!assert (strtrim (char (" abc   ", "   def   ")), ["abc  "; "  def"])
%!assert (strtrim ({" abc   "; "   def   "}), {"abc"; "def"})
%!assert (strtrim ({" abc   ", {"   def   "}}), {"abc", {"def"}})

%!error <Invalid call to strtrim> strtrim ()
%!error <called with too many inputs> strtrim ("abc", "def")
%!error <argument must be a string> strtrim (1)
%!error <argument must be a string> strtrim ({[]})
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} strtrunc (@var{s}, @var{n})
## Truncate the character string @var{s} to length @var{n}.
##
## If @var{s} is a character matrix, then the number of columns is adjusted.
##
## If @var{s} is a cell array of strings, then the operation is performed
## on each cell element and the new cell array is returned.
## @end deftypefn

function s = strtrunc (s, n)

  if (nargin != 2)
    print_usage ();
  endif

  n = fix (n);
  if (! isscalar (n) || n < 0)
    error ("strtrunc: length N must be a positive integer (N >= 0)");
  endif

  if (ischar (s))
    if (n < columns (s))
      s = s(:, 1:n);
    endif
  elseif (iscellstr (s))
    ## Convoluted approach converts cellstr to char matrix, trims the character
    ## matrix using indexing, and then converts back to cellstr with mat2cell.
    ## This approach is 24X faster than using cellfun with call to strtrunc
    idx = cellfun ("size", s, 2) > n;
    rows = cellfun ("size", s(idx), 1);
    if (! isempty (rows))
      s(idx) = mat2cell (char (s(idx))(:, 1:n), rows);
    endif
  else
    error ("strtrunc: S must be a character string or a cell array of strings");
  endif

endfunction


%!assert (strtrunc ("abcdefg", 4), "abcd")
%!assert (strtrunc ("abcdefg", 10), "abcdefg")
%!assert (strtrunc (char ("abcdef", "fedcba"), 3), ["abc"; "fed"])
%!assert (strtrunc ({"abcdef", "fedcba"}, 3), {"abc", "fed"})
%!assert (strtrunc ({"", "1", "21", "321"}, 1), {"", "1", "2", "3"})
%!assert (strtrunc ({"1", "", "2"}, 1), {"1", "", "2"})
%!test
%! cstr = {"line1"; ["line2"; "line3"]; "line4"};
%! y = strtrunc (cstr, 4);
%! assert (size (y), [3, 1]);
%! assert (size (y{2}), [2, 4]);
%! assert (y{2}, repmat ("line", 2, 1));

## Test input validation
%!error <Invalid call> strtrunc ()
%!error strtrunc ("abcd")
%!error strtrunc ("abcd", 4, 5)
%!error <N must be a positive integer> strtrunc ("abcd", ones (2,2))
%!error <N must be a positive integer> strtrunc ("abcd", -1)
%!error <S must be a character string or a cell array of strings> strtrunc (1, 1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} substr (@var{s}, @var{offset})
## @deftypefnx {} {} substr (@var{s}, @var{offset}, @var{len})
## Return the substring of @var{s} which starts at character number
## @var{offset} and is @var{len} characters long.
##
## Position numbering for offsets begins with 1.  If @var{offset} is negative,
## extraction starts that far from the end of the string.
##
## If @var{len} is omitted, the substring extends to the end of @var{s}.  A
## negative value for @var{len} extracts to within @var{len} characters of
## the end of the string
##
## Examples:
##
## @example
## @group
## substr ("This is a test string", 6, 9)
##      @result{} "is a test"
## substr ("This is a test string", -11)
##      @result{} "test string"
## substr ("This is a test string", -11, -7)
##      @result{} "test"
## @end group
## @end example
##
## This function is patterned after the equivalent function in Perl.
## @end deftypefn

function t = substr (s, offset, len)

  if (nargin < 2)
    print_usage ();
  endif

  if (! ischar (s))
    error ("substr: S must be a string or string array");
  elseif (! isscalar (offset) || (nargin == 3 && ! isscalar (len)))
    error ("substr: OFFSET and LEN must be scalar integers");
  endif

  offset = fix (offset);
  nc = columns (s);
  if (abs (offset) > nc || offset == 0)
    error ("substr: OFFSET = %d out of range", offset);
  endif

  if (offset <= 0)
    offset += nc + 1;
  endif

  if (nargin == 2)
    eos = nc;
  else
    len = fix (len);
    if (len < 0)
      eos = nc + len;
    else
      eos = offset + len - 1;
    endif
  endif

  if (eos > nc)
    error ("substr: length LEN = %d out of range", len);
  elseif (offset > eos && len != 0)
    error ("substr: No overlap with chosen values of OFFSET and LEN");
  endif

  t = s(:, offset:eos);

endfunction


%!assert (substr ("This is a test string", 6, 9), "is a test")
%!assert (substr ("This is a test string", -11), "test string")
%!assert (substr ("This is a test string", -11, 4), "test")
%!assert (substr ("This is a test string", -11, -7), "test")
%!assert (substr ("This is a test string", 1, -7), "This is a test")
%!assert (isempty (substr ("This is a test string", 1, 0)))

## Test input validation
%!error <Invalid call> substr ()
%!error substr ("foo", 2, 3, 4)
%!error substr (ones (5, 1), 1, 1)
%!error substr ("foo", ones (2,2))
%!error substr ("foo", 1, ones (2,2))
%!error substr ("foo", 0)
%!error substr ("foo", 5)
%!error substr ("foo", 1, 5)
%!error substr ("foo", -1, 5)
%!error substr ("foo", 2, -5)
########################################################################
##
## Copyright (C) 2016-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{native_bytes} =} unicode2native (@var{utf8_str}, @var{codepage})
## @deftypefnx {} {@var{native_bytes} =} unicode2native (@var{utf8_str})
## Convert UTF-8 string @var{utf8_str} to byte stream using @var{codepage}.
##
## The character vector @var{utf8_str} is converted to a byte stream
## @var{native_bytes} using the code page given by @var{codepage}.  The
## string @var{codepage} must be an identifier of a valid code page.
## Examples for valid code pages are @qcode{"ISO-8859-1"},
## @qcode{"Shift-JIS"}, or @qcode{"UTF-16"}.  For a list of supported code
## pages, see @url{https://www.gnu.org/software/libiconv}.  If @var{codepage}
## is omitted or empty, the system default codepage is used.
##
## If any of the characters cannot be mapped into the codepage @var{codepage},
## they are replaced with the appropriate substitution sequence for that
## codepage.
##
## @seealso{native2unicode}
## @end deftypefn

function native_bytes = unicode2native (utf8_str, codepage = "")

  if (nargin < 1)
    print_usage ();
  endif

  ## For Matlab compatibility, return empty output for empty input.
  if (isempty (utf8_str))
    native_bytes = uint8 ([]);
    return;
  endif

  if (! ischar (utf8_str) || ! isvector (utf8_str))
    error ("unicode2native: UTF8_STR must be a character vector");
  endif

  if (! (ischar (codepage) && isrow (codepage)))
    error ("unicode2native: CODEPAGE must be a string");
  endif

  native_bytes = __unicode2native__ (utf8_str, codepage);

  if (iscolumn (utf8_str))
    native_bytes = native_bytes.';
  endif

endfunction


%!testif HAVE_ICONV
%! assert (unicode2native ("", "ISO-8859-5"), uint8 (164:170));
%!testif HAVE_ICONV
%! assert (unicode2native (["" "\0" ""], "ISO-8859-5"),
%!         uint8 ([164:166 0 167:170]));
%!assert <*60480> (unicode2native (''), uint8 ([]))

%!error <Invalid call> unicode2native ()
%!error <called with too many inputs> unicode2native ('a', 'ISO-8859-1', 'test')
%!error <UTF8_STR must be a character vector> unicode2native (['ab'; 'cd'])
%!error <UTF8_STR must be a character vector> unicode2native ({1 2 3 4})
%!error <CODEPAGE must be a string> unicode2native ('', 123)
%!error <CODEPAGE must be a string> unicode2native ('', ['ISO-8859-1']')
%!testif HAVE_ICONV
%! fail ("unicode2native ('a', 'foo')",
%!       "converting from UTF-8 to codepage 'foo'");
########################################################################
##
## Copyright (C) 2010-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} untabify (@var{t})
## @deftypefnx {} {} untabify (@var{t}, @var{tw})
## @deftypefnx {} {} untabify (@var{t}, @var{tw}, @var{deblank})
## Replace TAB characters in @var{t} with spaces.
##
## The input, @var{t}, may be either a 2-D character array, or a cell array of
## character strings.  The output is the same class as the input.
##
## The tab width is specified by @var{tw}, and defaults to eight.
##
## If the optional argument @var{deblank} is true, then the spaces will be
## removed from the end of the character data.
##
## The following example reads a file and writes an untabified version of the
## same file with trailing spaces stripped.
##
## @example
## @group
## fid = fopen ("tabbed_script.m");
## text = char (fread (fid, "uchar")');
## fclose (fid);
## fid = fopen ("untabified_script.m", "w");
## text = untabify (strsplit (text, "\n"), 8, true);
## fprintf (fid, "%s\n", text@{:@});
## fclose (fid);
## @end group
## @end example
##
## @seealso{strjust, strsplit, deblank}
## @end deftypefn

function s = untabify (t, tw = 8, deblank_arg = false)

  if (nargin < 1)
    print_usage ();
  elseif (! (ischar (t) || iscellstr (t)))
    error ("untabify: T must be a string or cellstring");
  endif

  if (ischar (t))
    s = replace_tabs (t, tw);
  else
    s = cellfun (@replace_tabs, t, {tw}, "uniformoutput", false);
  endif

  if (deblank_arg)
    s = deblank (s);
  endif

endfunction

function s = replace_tabs (t, tw)

  if (ndims (t) != 2)
    error ("untabify: character strings to untabify must have 2 dimensions");
  endif

  if (isempty (t))
    s = t;
  else
    nr = rows (t);
    sc = cell (nr, 1);
    for j = 1:nr
      n = 1:numel (t(j,:));
      m = find (t(j,:) == "\t");
      t(j,m) = " ";
      for i = 1:numel (m)
        k = tw * ceil (n(m(i)) / tw);
        dn = k - n(m(i));
        n(m(i):end) += dn;
      endfor
      sc{j} = blanks (n(end));
      sc{j}(n) = t(j,:);
    endfor
    s = char (sc);
  endif

endfunction


%!test
%! s = untabify ("\thello\t");
%! assert (s, [blanks(8) "hello" blanks(3)]);

%!test
%! s = untabify ("\thello\t", 2);
%! assert (s, [blanks(2) "hello" blanks(1)]);

%!test
%! s = untabify ("\thello\t", 4, true);
%! assert (s, [blanks(4) "hello"]);

%!assert (isempty (untabify ("")))

%!test
%! s = char (randi ([97 97+25], 3, 3));
%! assert (untabify (s), char (untabify (cellstr (s))));

## Test input validation
%!error <Invalid call> untabify ()
%!error <must be a string> untabify (1)
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{validstr} =} validatestring (@var{str}, @var{strarray})
## @deftypefnx {} {@var{validstr} =} validatestring (@var{str}, @var{strarray}, @var{funcname})
## @deftypefnx {} {@var{validstr} =} validatestring (@var{str}, @var{strarray}, @var{funcname}, @var{varname})
## @deftypefnx {} {@var{validstr} =} validatestring (@dots{}, @var{position})
## Verify that @var{str} is an element, or substring of an element, in
## @var{strarray}.
##
## When @var{str} is a character string to be tested, and @var{strarray} is a
## cell array of strings of valid values, then @var{validstr} will be the
## validated form of @var{str} where validation is defined as @var{str} being
## a member or substring of @var{validstr}.  This is useful for both verifying
## and expanding short options, such as @qcode{"r"}, to their longer forms,
## such as @qcode{"red"}.  If @var{str} is a substring of @var{validstr},
## and there are multiple matches, the shortest match will be returned if
## all matches are substrings of each other.  Otherwise, an error will be
## raised because the expansion of @var{str} is ambiguous.  All comparisons
## are case insensitive.
##
## The additional inputs @var{funcname}, @var{varname}, and @var{position}
## are optional and will make any generated validation error message more
## specific.
##
## Examples:
## @c Set example in small font to prevent overfull line
##
## @smallexample
## @group
## validatestring ("r", @{"red", "green", "blue"@})
## @result{} "red"
##
## validatestring ("b", @{"red", "green", "blue", "black"@})
## @result{} error: validatestring: multiple unique matches were found for 'b':
##    blue, black
## @end group
## @end smallexample
##
## @seealso{strcmp, strcmpi, validateattributes, inputParser}
## @end deftypefn

function str = validatestring (str, strarray, varargin)

  if (nargin < 2 || nargin > 5)
    print_usage ();
  endif

  ## Process input arguments
  position = 0;
  if (! isempty (varargin) && isnumeric (varargin{end}))
    position = fix (varargin{end});
    varargin(end) = [];
    if (position < 1)
      error ("validatestring: POSITION must be >= 1");
    endif
  endif

  funcname = varname = "";
  char_idx = cellfun ("isclass", varargin, "char");
  n_chararg = sum (char_idx);
  if (n_chararg > 2)
    error ("validatestring: invalid number of character inputs (> 3)");
  elseif (n_chararg == 2)
    [funcname, varname] = deal (varargin{char_idx});
  elseif (n_chararg == 1)
    funcname = varargin{char_idx};
  endif

  ## Validate the inputs
  if (! (ischar (str) && isrow (str)))
    error ("validatestring: STR must be a single character string");
  elseif (! iscellstr (strarray))
    error ("validatestring: STRARRAY must be a cellstr");
  elseif (! isempty (funcname) && ! isrow (funcname))
    error ("validatestring: FUNCNAME must be a single character string");
  elseif (! isempty (varname) && ! isrow (varname))
    error ("validatestring: VARNAME must be a single character string");
  endif

  ## Make static part of error string that uses funcname, varname, and position
  if (isempty (funcname))
    funcname = "validatestring";
  endif
  errstr = [funcname ": '" str "' "];
  if (! isempty (varname))
    if (position > 0)
      errstr = sprintf ("%s(variable %s, argument #%i) ", ...
                        errstr, varname, position);
    else
      errstr = sprintf ("%s(variable %s) ", errstr, varname);
    endif
  else
    if (position > 0)
      errstr = sprintf ("%s(argument #%i) ", errstr, position);
    endif
  endif

  matches = strncmpi (str, strarray(:), numel (str));
  nmatches = sum (matches);
  if (nmatches == 0)
    error ("%sdoes not match any of\n%s", errstr,
           sprintf ("'%s', ", strarray{:})(1:end-2));
  elseif (nmatches == 1)
    str = strarray{matches};
  else
    ## Are the matches substrings of each other?
    ## If true, choose the shortest.  If not, raise an error.
    match_idx = find (matches);
    match_len = cellfun ("length", strarray(match_idx));
    [min_len, min_idx] = min (match_len);
    short_str = strarray{match_idx(min_idx)};
    submatch = strncmpi (short_str, strarray(match_idx), min_len);
    if (all (submatch))
      str = short_str;
    else
      error ("%smatches multiple possible values:\n%s", errstr,
             sprintf ("'%s', ", strarray{match_idx})(1:end-2));
    endif
  endif

endfunction


%!shared strarray
%! strarray = {"octave" "Oct" "octopus" "octaves"};
%!assert (validatestring ("octave", strarray), "octave")
%!assert (validatestring ("oct", strarray), "Oct")
%!assert (validatestring ("octa", strarray), "octave")
%! strarray = {"abc1" "def" "abc2"};
%!assert (validatestring ("d", strarray), "def")

%!error <'xyz' does not match any> validatestring ("xyz", strarray)
%!error <DUMMY_TEST: 'xyz' does not match any>
%! validatestring ("xyz", strarray, "DUMMY_TEST")
%!error <DUMMY_TEST: 'xyz' \(variable DUMMY_VAR\) does not match>
%! validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR")
%!error <DUMMY_TEST: 'xyz' \(variable DUMMY_VAR, argument #5\) does>
%! validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR", 5)
%!error <'abc' matches multiple possible values:> validatestring ("abc", strarray)

## Test input validation
%!error <Invalid call> validatestring ("xyz")
%!error <Invalid call> validatestring ("xyz", {"xyz"}, "3", "4", 5, 6)
%!error <POSITION must be .= 1> validatestring ("xyz", {"xyz"}, "3", "4", -5)
%!error <invalid number of character inputs>
%! validatestring ("xyz", {"xyz"}, "3", "4", "5")
%!error <STR must be a single character string>
%! validatestring (1, {"xyz"}, "3", "4", 5)
%!error <STR must be a single character string>
%! validatestring (['xyz';'def'], {"xyz"}, "3", "4", 5)
%!error <STRARRAY must be a cellstr> validatestring ("xyz", "xyz", "3", "4", 5)
%!error <FUNCNAME must be a single character string>
%! validatestring ("xyz", {"xyz"}, ["3";"3"], "4", 5)
%!error <VARNAME must be a single character string>
%! validatestring ("xyz", {"xyz"}, "3", ["4";"4"], 5)
encoding=utf-8
########################################################################
##
## Copyright (C) 2008-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{d} =} addtodate (@var{d}, @var{q}, @var{f})
## Add @var{q} amount of time (with units @var{f}) to the serial datenum,
## @var{d}.
##
## @var{f} must be one of @qcode{"year"}, @qcode{"month"}, @qcode{"day"},
## @qcode{"hour"}, @qcode{"minute"}, @qcode{"second"}, or
## @qcode{"millisecond"}.
## @seealso{datenum, datevec, etime}
## @end deftypefn

function d = addtodate (d, q, f)

  persistent mult = struct ("day", 1, "hour", 1/24, "minute", 1/1440, ...
                            "second", 1/86400, "millisecond", 1/86400000);

  if (nargin != 3)
    print_usage ();
  elseif (! (ischar (f) && isrow (f)))
    error ("addtodate: F must be a single character string");
  endif

  if (isscalar (d) && ! isscalar (q))
    ## expand d to size of q to make later addition easier.
    d = repmat (d, size (q));
  endif

  ## in case the user gives f as a plural, remove the 's'
  if ("s" == f(end))
    f(end) = [];
  endif

  if (any (strcmpi ({"year" "month"}, f)))
    dtmp = datevec (d);
    if (strcmpi ("year", f))
      dtmp(:,1) += q(:);
    elseif (strcmpi ("month", f))
      dtmp(:,2) += q(:);
      ## adjust the years and months if the date rolls over a year
      dtmp(:,1) += floor ((dtmp(:,2)-1)/12);
      dtmp(:,2) = mod (dtmp(:,2)-1, 12) + 1;
    endif
    dnew = datenum (dtmp);
    ## make the output the right shape
    if (numel (d) == numel (dnew))
      d = reshape (dnew, size (d));
    else
      d = reshape (dnew, size (q));
    endif
  elseif (any (strcmpi ({"day" "hour" "minute" "second", "millisecond"}, f)))
    d += q .* mult.(f);
  else
    error ("addtodate: Invalid time unit: %s", f);
  endif

endfunction


## tests
%!shared d
%! d = datenum (2008, 1, 1);
## Identity
%!assert (addtodate (d, 0, "year"), d)
%!assert (addtodate (d, 0, "month"), d)
%!assert (addtodate (d, 0, "day"), d)
%!assert (addtodate (d, 0, "hour"), d)
%!assert (addtodate (d, 0, "minute"), d)
%!assert (addtodate (d, 0, "second"), d)
%!assert (addtodate (d, 0, "millisecond"), d)
## Add one of each
## leap year
%!assert (addtodate (d, 1, "year"), d+366)
%!assert (addtodate (d, 1, "month"), d+31)
%!assert (addtodate (d, 1, "day"), d+1)
%!assert (addtodate (d, 1, "hour"), d+1/24)
%!assert (addtodate (d, 1, "minute"), d+1/1440)
%!assert (addtodate (d, 1, "second"), d+1/86400)
%!assert (addtodate (d, 1, "millisecond"), d+1/86400000)
## subtract one of each
%!assert (addtodate (d, -1, "year"), d-365)
%!assert (addtodate (d, -1, "month"), d-31)
%!assert (addtodate (d, -1, "day"), d-1)
%!assert (addtodate (d, -1, "hour"), d-1/24)
%!assert (addtodate (d, -1, "minute"), d-1/1440)
%!assert (addtodate (d, -1, "second"), d-1/86400)
%!assert (addtodate (d, -1, "millisecond"), d-1/86400000)
## rollover
%!assert (addtodate (d, 12, "month"), d+366)
%!assert (addtodate (d, 13, "month"), d+366+31)
## multiple inputs and output orientation
%!assert (addtodate ([d d], [1 13], "month"), [d+31 d+366+31])
%!assert (addtodate ([d;d], [1;13], "month"), [d+31;d+366+31])
%!assert (addtodate (d, [1;13], "month"), [d+31;d+366+31])
%!assert (addtodate (d, [1 13], "month"), [d+31 d+366+31])
%!assert (addtodate ([d;d+1], 1, "month"), [d+31;d+1+31])
%!assert (addtodate ([d d+1], 1, "month"), [d+31 d+1+31])

## Test input validation
%!error <Invalid call> addtodate ()
%!error <Invalid call> addtodate (1)
%!error <Invalid call> addtodate (1,2)
%!error <F must be a single character string> addtodate (1,2,3)
%!error <F must be a single character string> addtodate (1,2,"month"')
%!error <Invalid time unit> addtodate (1,2,"abc")
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} asctime (@var{tm_struct})
## Convert a time structure to a string using the following
## format: @qcode{"ddd mmm mm HH:MM:SS yyyy@backslashchar{}n"}.
##
## For example:
##
## @example
## @group
## asctime (localtime (time ()))
##      @result{} "Mon Feb 17 01:15:06 1997@backslashchar{}n"
## @end group
## @end example
##
## This is equivalent to @code{ctime (time ())}.
## @seealso{ctime, localtime, time}
## @end deftypefn

function retval = asctime (tm_struct)

  if (nargin < 1)
    print_usage ();
  endif

  retval = strftime ("%a %b %d %H:%M:%S %Y\n", tm_struct);

endfunction


%!test
%! t = time ();
%! assert (strcmp (asctime (localtime (t)), ctime (t)));

%!assert (asctime (localtime (time ()))(end), "\n")

%!error <Invalid call> asctime ()
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{c} =} calendar ()
## @deftypefnx {} {@var{c} =} calendar (@var{d})
## @deftypefnx {} {@var{c} =} calendar (@var{y}, @var{m})
## @deftypefnx {} {} calendar (@dots{})
## Return the current monthly calendar in a 6x7 matrix.
##
## If @var{d} is specified, return the calendar for the month containing the
## date @var{d}, which must be a serial date number or a date string.
##
## If @var{y} and @var{m} are specified, return the calendar for year @var{y}
## and month @var{m}.
##
## If no output arguments are specified, print the calendar on the screen
## instead of returning a matrix.
## @seealso{datenum, datestr}
## @end deftypefn

function varargout = calendar (varargin)

  switch (nargin)
    case 0
      v = clock ();
      y = v(1);
      m = v(2);
      d = v(3);
    case 1
      v = datevec (varargin{1});
      y = v(1);
      m = v(2);
      d = v(3);
    case 2
      y = varargin{1};
      m = varargin{2};
      d = [];
    otherwise
      print_usage ();
  endswitch

  c = zeros (7, 6);
  dayone = datenum (y, m, 1);
  ndays = eomday (y, m);
  c(weekday (dayone) - 1 + [1:ndays]) = 1:ndays;

  if (nargout > 0)
    varargout{1} = c';
  else
    ## Layout the calendar days, 6 columns per day, 7 days per row.
    str = sprintf ("    %2d    %2d    %2d    %2d    %2d    %2d    %2d\n", c);

    ## Print an asterisk before the specified date
    if (! isempty (d))
      pos = weekday (dayone) + d - 1;
      idx = 6*pos + fix (pos / 7.1) - ifelse (d < 10, 1, 2);
      str(idx) = "*";
    endif

    ## Display the calendar.
    s.year = y - 1900;
    s.mon = m - 1;
    puts (strftime ("                    %b %Y\n", s));
    puts ("     S     M    Tu     W    Th     F     S\n");
    puts (str);
  endif

endfunction


%!demo
%! ## Calendar for current month
%! calendar ()

%!demo
%! ## Calendar for October, 1957
%! calendar (1957, 10)

%!assert ((calendar(2000,2))'(2:31), [0:29])
%!assert ((calendar(1957,10))'(2:33), [0:31])

## Test input validation
%!error calendar (1,2,3)
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} clock ()
## Return the current local date and time as a date vector.
##
## The date vector contains the following fields: current year, month (1-12),
## day (1-31), hour (0-23), minute (0-59), and second (0-61).  The seconds
## field has a fractional part after the decimal point for extended accuracy.
##
## For example:
##
## @example
## @group
## fix (clock ())
##   @result{}   1993      8     20      4     56      1
## @end group
## @end example
##
## @code{clock} is more accurate on systems that have the @code{gettimeofday}
## function.
## @seealso{now, date, datevec}
## @end deftypefn

function retval = clock ()

  tm = localtime (time ());

  retval = zeros (1, 6);

  retval(1) = tm.year + 1900;
  retval(2) = tm.mon + 1;
  retval(3) = tm.mday;
  retval(4) = tm.hour;
  retval(5) = tm.min;
  retval(6) = tm.sec + tm.usec / 1e6;

endfunction


%!test
%! t1 = clock ();
%! t2 = str2num (strftime ("[%Y, %m, %d, %H, %M, %S]", localtime (time ())));
%! assert (etime (t1, t2) < 1);
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} ctime (@var{t})
## Convert a value returned from @code{time} (or any other non-negative
## integer), to the local time and return a string of the same form as
## @code{asctime}.
##
## The function @code{ctime (time)} is equivalent to
## @code{asctime (localtime (time))}.  For example:
##
## @example
## @group
## ctime (time ())
##    @result{} "Mon Feb 17 01:15:06 1997@backslashchar{}n"
## @end group
## @end example
## @seealso{asctime, time, localtime}
## @end deftypefn

function retval = ctime (t)

  if (nargin < 1)
    print_usage ();
  endif

  retval = asctime (localtime (t));

endfunction


%!test
%! t = time ();
%! assert (strcmp (asctime (localtime (t)), ctime (t)));

%!assert (ctime (time ())(end), "\n")

%!error <Invalid call> ctime ()
########################################################################
##
## Copyright (C) 1995-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} date ()
## Return the current date as a character string in the form DD-MMM-YYYY@.
##
## For example:
##
## @example
## @group
## date ()
##   @result{} 20-Aug-1993
## @end group
## @end example
## @seealso{now, clock, datestr, localtime}
## @end deftypefn

function retval = date ()

  retval = strftime ("%d-%b-%Y", localtime (time ()));

endfunction


%!assert (strcmp (date (), strftime ("%d-%b-%Y", localtime (time ()))))
########################################################################
##
## Copyright (C) 2006-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{days} =} datenum (@var{datevec})
## @deftypefnx {} {@var{days} =} datenum (@var{year}, @var{month}, @var{day})
## @deftypefnx {} {@var{days} =} datenum (@var{year}, @var{month}, @var{day}, @var{hour})
## @deftypefnx {} {@var{days} =} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute})
## @deftypefnx {} {@var{days} =} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute}, @var{second})
## @deftypefnx {} {@var{days} =} datenum ("datestr")
## @deftypefnx {} {@var{days} =} datenum ("datestr", @var{f})
## @deftypefnx {} {@var{days} =} datenum ("datestr", @var{p})
## @deftypefnx {} {[@var{days}, @var{secs}] =} datenum (@dots{})
## Return the date/time input as a serial day number, with Jan 1, 0000
## defined as day 1.
##
## The integer part, @code{floor (@var{days})} counts the number of
## complete days in the date input.
##
## The fractional part, @code{rem (@var{days}, 1)} corresponds to the time
## on the given day.
##
## The input may be a date vector (@pxref{XREFdatevec,,@code{datevec}}),
## date string (@pxref{XREFdatestr,,@code{datestr}}), or directly specified
## as input.
##
## When processing input datestrings, @var{f} is the format string used to
## interpret date strings (@pxref{XREFdatestr,,@code{datestr}}).  If no
## format @var{f} is specified, then a relatively slow search is performed
## through various formats.  It is always preferable to specify the format
## string @var{f} if it is known.  Formats which do not specify a particular
## time component will have the value set to zero.  Formats which do not
## specify a date will default to January 1st of the current year.
##
## @var{p} is the year at the start of the century to which two-digit years
## will be referenced.  If not specified, it defaults to the current year
## minus 50.
##
## The optional output @var{secs} holds the time on the specified day with
## greater precision than @var{days}.
##
## Notes:
##
## @itemize
## @item
## Years can be negative and/or fractional.
##
## @item
## Months below 1 are considered to be January.
##
## @item
## Days of the month start at 1.
##
## @item
## Days beyond the end of the month go into subsequent months.
##
## @item
## Days before the beginning of the month go to the previous month.
##
## @item
## Days can be fractional.
## @end itemize
##
## @strong{Caution:} datenums represent a specific time for the Earth as a
## whole.  They do not take in to account time zones (shifts in time based
## on location), nor seasonal changes due to Daylight Savings Time (shifts in
## time based on local regulation).  Be aware that it is possible to create
## datenums that, when interpreted by a function which accounts for time zone
## and DST shifts such as @code{datestr}, are nonexistent or ambiguous.
##
## @strong{Caution:} this function does not attempt to handle Julian calendars
## so dates before October 15, 1582 are wrong by as much as eleven days.  Also,
## be aware that only Roman Catholic countries adopted the calendar in 1582.
## It took until 1924 for it to be adopted everywhere.  See the Wikipedia entry
## on the Gregorian calendar for more details.
##
## @strong{Warning:} leap seconds are ignored.  A table of leap seconds is
## available on the Wikipedia entry for leap seconds.
##
## @seealso{datestr, datevec, now, clock, date}
## @end deftypefn

## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)

function [days, secs] = datenum (year, month = [], day = [], hour = 0, minute = 0, second = 0)

  ## Days until start of month assuming year starts March 1.
  persistent monthstart = [306; 337; 0; 31; 61; 92; 122; 153; 184; 214; 245; 275];
  persistent monthlength = [31; 28; 31; 30; 31; 30; 31; 31; 30; 31; 30; 31];

  if (nargin == 0 || (nargin > 2 && (ischar (year) || iscellstr (year))))
    print_usage ();
  endif

  do_reshape = false;
  if (ischar (year) || iscellstr (year))
    [year, month, day, hour, minute, second] = datevec (year, month);
  else
    if (nargin == 1)
      nc = columns (year);
      if (nc > 6 || nc < 3)
        error ("datenum: expected date vector containing [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]");
      endif
      if (nc >= 6) second = year(:,6); endif
      if (nc >= 5) minute = year(:,5); endif
      if (nc >= 4) hour   = year(:,4); endif
      day   = year(:,3);
      month = year(:,2);
      year  = year(:,1);
    else
      [err, year, month, day] = common_size (year, month, day);
      if (err)
        error ("datenum: incompatible sizes for YEAR, MONTH, DAY");
      endif
      ## Preserve shape if necessary, and work with column vectors
      ## for the remainder of the function.
      do_reshape = ! iscolumn (day);
      if (do_reshape)
        sz_reshape = size (day);
        year = year(:);
        month = month(:);
        day = day(:);
      endif
    endif
  endif

  if (! (isa (year, "double") && isa (month, "double")
         && isa (day, "double") && isa (hour, "double")
         && isa (minute, "double") && isa (second, "double")))
    error ("datenum: all inputs must be of class double");
  endif

  ## For Matlab compatibility.  Otherwise, could allow negative months.
  month(month < 1) = 1;

  ## Treat fractional months, by converting the fraction to days
  if (any (month != fix (month)))
    fracmonth = month - floor (month);
    month = floor (month);
    ## Separate regular months from leap months
    idx = mod (month-1,12) + 1 != 2 | ! is_leap_year (floor (year));
    day(idx) += fracmonth(idx) .* monthlength(mod (month(idx)-1,12) + 1);
    day(! idx) += fracmonth(! idx) * 29;
  endif

  ## Set start of year to March by moving Jan. and Feb. to previous year.
  ## Correct for months > 12 by moving to subsequent years.
  year += ceil ((month-14)/12);

  ## Lookup number of days since start of the current year.
  day += monthstart(mod (month-1,12) + 1) + 60;

  ## Treat fractional years, by converting the fraction to days
  if (any (year != fix (year)))
    fracyear = year - floor (year);
    year = floor (year);
    day += fracyear .* (365 + is_leap_year (year+1));
  endif

  ## Add number of days to the start of the current year.  Correct
  ## for leap year every 4 years except centuries not divisible by 400.
  day += 365*year + floor (year/4) - floor (year/100) + floor (year/400);

  if (do_reshape)
    day = reshape (day, sz_reshape);
  endif

  ## Add fraction representing current second of the day.
  days = day + (hour + (minute + second/60)/60)/24;

  ## Output seconds if asked so that etime can be more accurate
  if (isargout (2))
    secs = day*86400 + hour*3600 + minute*60 + second;
  endif

endfunction


%!shared part
%! part = 0.514623842592593;
%!assert (datenum (2001,5,19), 730990)
%!assert (datenum ([1417,6,12]), 517712)
%!assert (datenum ([2001,5,19;1417,6,12]), [730990;517712])
%!assert (datenum (2001,5,19,12,21,3.5), 730990+part, eps)
%!assert (datenum ([1417,6,12,12,21,3.5]), 517712+part, eps)

## Test vector inputs
%!test
%! t = [2001,5,19,12,21,3.5; 1417,6,12,12,21,3.5];
%! n = [730990; 517712] + part;
%! assert (datenum (t), n, 2*eps);
%! ## Check that vectors can have either orientation
%! t = t';
%! n = n';
%! assert (datenum (t(1,:), t(2,:), t(3,:), t(4,:), t(5,:), t(6,:)), n, 2*eps);

%!assert (size (datenum (2000, 1, ones(1, 1, 3))), [1 1 3])

## Test fractional years including leap years
%!assert (fix (datenum ([2001.999 1 1; 2001.999 2 1])), [731216; 731247])
%!assert (fix (datenum ([2004.999 1 1; 2004.999 2 1])), [732312; 732343])

## Test fractional months including leap months
%!assert (fix (datenum ([2001 1.999 1; 2001 2.999 1])), [730882; 730910])
%!assert (fix (datenum ([2004 1.999 1; 2004 2.999 1])), [731977; 732006])


## Test mixed vectors and scalars
%!assert (datenum ([2008;2009],1,1), [datenum(2008,1,1);datenum(2009,1,1)])
%!assert (datenum (2008, [1;2], 1), [datenum(2008,1,1);datenum(2008,2,1)])
%!assert (datenum (2008, 1, [1;2]), [datenum(2008,1,1);datenum(2008,1,2)])
%!assert (datenum ([2008;2009], [1;2], 1),
%!        [datenum(2008,1,1);datenum(2009,2,1)])
%!assert (datenum ([2008;2009], 1, [1;2]),
%!        [datenum(2008,1,1);datenum(2009,1,2)])
%!assert (datenum (2008, [1;2], [1;2]), [datenum(2008,1,1);datenum(2008,2,2)])
## And the other orientation
%!assert (datenum ([2008 2009], 1, 1), [datenum(2008,1,1) datenum(2009,1,1)])
%!assert (datenum (2008, [1 2], 1), [datenum(2008,1,1) datenum(2008,2,1)])
%!assert (datenum (2008, 1, [1 2]), [datenum(2008,1,1) datenum(2008,1,2)])
%!assert (datenum ([2008 2009], [1 2], 1),
%!        [datenum(2008,1,1) datenum(2009,2,1)])
%!assert (datenum ([2008 2009], 1, [1 2]),
%!        [datenum(2008,1,1) datenum(2009,1,2)])
%!assert (datenum (2008, [1 2], [1 2]), [datenum(2008,1,1) datenum(2008,2,2)])

## Test string and cellstr inputs
%!assert (datenum ("5/19/2001"), 730990)
%!assert (datenum ({"5/19/2001"}), 730990)
%!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
%!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])

## Test string input with format string
%!assert (datenum ("5-19, 2001", "mm-dd, yyyy"), 730990)

## Test input validation
%!error <Invalid call> datenum ()
%!error <expected date vector containing> datenum ([1, 2])
%!error <expected date vector containing> datenum ([1,2,3,4,5,6,7])
%!error <all inputs must be of class double> datenum (int32 (2000), int32 (1), int32 (1))
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{str} =} datestr (@var{date})
## @deftypefnx {} {@var{str} =} datestr (@var{date}, @var{f})
## @deftypefnx {} {@var{str} =} datestr (@var{date}, @var{f}, @var{p})
## Format the given date/time according to the format @var{f} and return
## the result in @var{str}.
##
## @var{date} is a serial date number (@pxref{XREFdatenum,,@code{datenum}}), a
## date vector (@pxref{XREFdatevec,,@code{datevec}}), or a string or cell array
## of strings.  In the latter case, it is passed to @code{datevec} to guess the
## input date format.
##
## @var{f} can be an integer which corresponds to one of the codes in the table
## below, or a date format string.
##
## @var{p} is the year at the start of the century in which two-digit years are
## to be interpreted in.  If not specified, it defaults to the current year
## minus 50.
##
## For example, the date 730736.65149 (2000-09-07 15:38:09.0934) would be
## formatted as follows:
##
## @multitable @columnfractions 0.1 0.45 0.35
## @headitem Code @tab Format @tab Example
## @item 0 @tab dd-mmm-yyyy HH:MM:SS    @tab 07-Sep-2000 15:38:09
## @item 1 @tab dd-mmm-yyyy             @tab 07-Sep-2000
## @item 2 @tab mm/dd/yy                @tab 09/07/00
## @item 3 @tab mmm                     @tab Sep
## @item 4 @tab m                       @tab S
## @item 5 @tab mm                      @tab 09
## @item 6 @tab mm/dd                   @tab 09/07
## @item 7 @tab dd                      @tab 07
## @item 8 @tab ddd                     @tab Thu
## @item 9 @tab d                       @tab T
## @item 10 @tab yyyy                   @tab 2000
## @item 11 @tab yy                     @tab 00
## @item 12 @tab mmmyy                  @tab Sep00
## @item 13 @tab HH:MM:SS               @tab 15:38:09
## @item 14 @tab HH:MM:SS PM            @tab  3:38:09 PM
## @item 15 @tab HH:MM                  @tab 15:38
## @item 16 @tab HH:MM PM               @tab  3:38 PM
## @item 17 @tab QQ-YY                  @tab Q3-00
## @item 18 @tab QQ                     @tab Q3
## @item 19 @tab dd/mm                  @tab 07/09
## @item 20 @tab dd/mm/yy               @tab 07/09/00
## @item 21 @tab mmm.dd,yyyy HH:MM:SS   @tab Sep.07,2000 15:38:08
## @item 22 @tab mmm.dd,yyyy            @tab Sep.07,2000
## @item 23 @tab mm/dd/yyyy             @tab 09/07/2000
## @item 24 @tab dd/mm/yyyy             @tab 07/09/2000
## @item 25 @tab yy/mm/dd               @tab 00/09/07
## @item 26 @tab yyyy/mm/dd             @tab 2000/09/07
## @item 27 @tab QQ-YYYY                @tab Q3-2000
## @item 28 @tab mmmyyyy                @tab Sep2000
## @item 29 @tab yyyy-mm-dd             @tab 2000-09-07
## @item 30 @tab yyyymmddTHHMMSS        @tab 20000907T153808
## @item 31 @tab yyyy-mm-dd HH:MM:SS    @tab 2000-09-07 15:38:08
## @end multitable
##
## If @var{f} is a format string, the following symbols are recognized:
##
## @multitable @columnfractions 0.1 0.7 0.2
## @headitem Symbol @tab Meaning @tab Example
## @item yyyy @tab Full year                                    @tab 2005
## @item yy   @tab Two-digit year                               @tab 05
## @item mmmm @tab Full month name                              @tab December
## @item mmm  @tab Abbreviated month name                       @tab Dec
## @item mm   @tab Numeric month number (padded with zeros)     @tab 01, 08, 12
## @item m    @tab First letter of month name (capitalized)     @tab D
## @item dddd @tab Full weekday name                            @tab Sunday
## @item ddd  @tab Abbreviated weekday name                     @tab Sun
## @item dd   @tab Numeric day of month (padded with zeros)     @tab 11
## @item d    @tab First letter of weekday name (capitalized)   @tab S
## @item HH   @tab Hour of day, padded with zeros,              @tab 09:00
## @item      @tab or padded with spaces if PM is set           @tab  9:00 AM
## @item MM   @tab Minute of hour (padded with zeros)           @tab 10:05
## @item SS   @tab Second of minute (padded with zeros)         @tab 10:05:03
## @item FFF  @tab Milliseconds of second (padded with zeros)   @tab 10:05:03.012
## @item AM   @tab Use 12-hour time format                      @tab 11:30 AM
## @item PM   @tab Use 12-hour time format                      @tab 11:30 PM
## @end multitable
##
## If @var{f} is not specified or is @code{-1}, then use 0, 1 or 16, depending
## on whether the date portion or the time portion of @var{date} is empty.
##
## If @var{p} is not specified, it defaults to the current year minus 50.
##
## If a matrix or cell array of dates is given, a column vector of date strings
## is returned.
##
## @seealso{datenum, datevec, date, now, clock}
## @end deftypefn

## FIXME: parse arbitrary code strings.
## e.g., for Wednesday 2001-03-05 09:04:06 AM, use
##     yy    01
##     yyyy  2001
##     m     M
##     mm    03
##     mmm   Mar
##     d     W
##     dd    05
##     ddd   Wed
##     HH    09
##     MM    04
##     SS    06
##     PM    AM
## FIXME: Vectorize.  It is particularly easy since all the codes are
##    fixed width.  Just generate the parts in separate arrays and
##    concatenate.

function retval = datestr (date, f = [], p = [])

  persistent dateform names_mmmm names_m names_d;

  if (isempty (dateform))
    dateform = cell (32, 1);
    dateform{1}  = "dd-mmm-yyyy HH:MM:SS";
    dateform{2}  = "dd-mmm-yyyy";
    dateform{3}  = "mm/dd/yy";
    dateform{4}  = "mmm";
    dateform{5}  = "m";
    dateform{6}  = "mm";
    dateform{7}  = "mm/dd";
    dateform{8}  = "dd";
    dateform{9}  = "ddd";
    dateform{10} = "d";
    dateform{11} = "yyyy";
    dateform{12} = "yy";
    dateform{13} = "mmmyy";
    dateform{14} = "HH:MM:SS";
    dateform{15} = "HH:MM:SS PM";
    dateform{16} = "HH:MM";
    dateform{17} = "HH:MM PM";
    dateform{18} = "QQ-YY";
    dateform{19} = "QQ";
    dateform{20} = "dd/mm";
    dateform{21} = "dd/mm/yy";
    dateform{22} = "mmm.dd,yyyy HH:MM:SS";
    dateform{23} = "mmm.dd,yyyy";
    dateform{24} = "mm/dd/yyyy";
    dateform{25} = "dd/mm/yyyy";
    dateform{26} = "yy/mm/dd";
    dateform{27} = "yyyy/mm/dd";
    dateform{28} = "QQ-YYYY";
    dateform{29} = "mmmyyyy";
    dateform{30} = "yyyy-mm-dd";
    dateform{31} = "yyyymmddTHHMMSS";
    dateform{32} = "yyyy-mm-dd HH:MM:SS";

    names_m = {"J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"};
    names_d = {"S", "M", "T", "W", "T", "F", "S"};
  endif

  if (nargin < 1)
    print_usage ();
  endif

  ## Guess input type.  We might be wrong.
  if (ischar (date) || iscellstr (date) || columns (date) != 6)
    v = datevec (date, p);
  else
    v = [];
    if (columns (date) == 6)
      ## Make sure that the input really is a datevec.
      maxdatevec = [Inf, 12, 31, 23, 59, 60];
      if (any (max (date, 1) > maxdatevec)
          || any (date(:,1:5) != floor (date(:,1:5))))
        v = datevec (date, p);
      endif
    endif
    if (isempty (v))
      v = date;
    endif
  endif

  ## Round fractional seconds >= 0.9995 s to next full second.
  idx = v(:,6) - fix (v(:,6)) >= 0.9995;
  if (any (idx))
    v(idx,6) = fix (v(idx,6)) + 1;
    v(idx,:) = datevec (datenum (v(idx,:)));
  endif

  ## Automatic format selection
  if (isempty (f))
    if (v(:,4:6) == 0)
      f = 1;
    elseif (v(:,1:3) == [-1, 12, 31])
      f = 16;
    else
      f = 0;
    endif
  endif

  retval = "";
  for i = 1 : rows (v)

    if (isnumeric (f))
      df = dateform{f + 1};
    else
      df = f;
    endif

    df_orig = df;
    df = strrep (df, "AM", "%p");
    df = strrep (df, "PM", "%p");
    if (strcmp (df, df_orig))
      ## PM not set.
      df = strrep (df, "HH", "%H");
    else
      hr = mod (v(i,4), 12);
      if (hr == 0)
        hr = 12;
      endif
      df = strrep (df, "HH", sprintf ("%2d", hr));
    endif

    df = regexprep (df, "[Yy][Yy][Yy][Yy]", "%Y");

    df = regexprep (df, "[Yy][Yy]", "%y");

    df = regexprep (df, "[Dd][Dd][Dd][Dd]", "%A");

    df = regexprep (df, "[Dd][Dd][Dd]", "%a");

    df = regexprep (df, "[Dd][Dd]", "%d");

    wday = weekday (datenum (v(i,1), v(i,2), v(i,3)));
    tmp = names_d{wday};
    df = regexprep (df, "([^%])[Dd]", sprintf ("$1%s", tmp));
    df = regexprep (df, "^[Dd]", sprintf ("%s", tmp));

    df = strrep (df, "mmmm", "%B");

    df = strrep (df, "mmm", "%b");

    df = strrep (df, "mm", "%m");

    tmp = names_m{v(i,2)};
    pos = regexp (df, "[^%]m") + 1;
    df(pos) = tmp;
    df = regexprep (df, "^m", tmp);

    df = strrep (df, "MM", "%M");

    df = regexprep (df, "[Ss][Ss]", "%S");

    df = strrep (df, "FFF", sprintf ("%03d",
                                     round (1000 * (v(i,6) - fix (v(i,6))))));

    df = strrep (df, "QQ", sprintf ("Q%d", fix ((v(i,2) + 2) / 3)));

    vi = v(i,:);
    tm.year = vi(1) - 1900;
    tm.mon = vi(2) - 1;
    tm.mday = vi(3);
    tm.hour = vi(4);
    tm.min = vi(5);
    sec = vi(6);
    tm.sec = fix (sec);
    tm.usec = fix ((sec - tm.sec) * 1e6);
    tm.wday = wday - 1;
    ## FIXME: Do we need YDAY and DST?  How should they be computed?
    ## We don't want to use "localtime (mktime (tm))" because that
    ## doesn't correctly handle dates before 1970-01-01 on some systems.
    ## tm.yday = ?;
    ## tm.isdst = ?;

    str = strftime (df, tm);

    retval = [retval; str];

  endfor

endfunction


%!demo
%! ## Current date and time in default format
%! datestr (now ())

%!demo
%! ## Current date (integer portion of datenum)
%! datestr (fix (now ()))

%!demo
%! ## Current time (fractional portion of datenum)
%! datestr (rem (now (), 1))

%!shared testtime
%! testtime = [2005.0000, 12.0000, 18.0000, 2.0000, 33.0000, 17.3822];
%!assert (datestr (testtime,0), "18-Dec-2005 02:33:17")
%!assert (datestr (testtime,1), "18-Dec-2005")
%!assert (datestr (testtime,2), "12/18/05")
%!assert (datestr (testtime,3), "Dec")
%!assert (datestr (testtime,4), "D")
%!assert (datestr (testtime,5), "12")
%!assert (datestr (testtime,6), "12/18")
%!assert (datestr (testtime,7), "18")
%!assert (datestr (testtime,8), "Sun")
%!assert (datestr (testtime,9), "S")
%!assert (datestr (testtime,10), "2005")
%!assert (datestr (testtime,11), "05")
%!assert (datestr (testtime,12), "Dec05")
%!assert (datestr (testtime,13), "02:33:17")
## Mac OS X interprets %p parameter to strftime as lower case am/pm indicator.
## Accommodate this, although no other UNIX-based OS does this.
%!test
%! obs = toupper (datestr (testtime,14));
%! assert (obs, " 2:33:17 AM");
%!assert (datestr (testtime,15), "02:33")
%!test
%! obs = toupper (datestr (testtime,16));
%! assert (obs, " 2:33 AM");
%!test <*48071>
%! testtime2 = testtime;
%! testtime2(4) = 15;
%! obs = toupper (datestr (testtime2,16));
%! assert (obs, " 3:33 PM");
%!assert (datestr (testtime,17), "Q4-05")
%!assert (datestr (testtime,18), "Q4")
%!assert (datestr (testtime,19), "18/12")
%!assert (datestr (testtime,20), "18/12/05")
%!assert (datestr (testtime,21), "Dec.18,2005 02:33:17")
%!assert (datestr (testtime,22), "Dec.18,2005")
%!assert (datestr (testtime,23), "12/18/2005")
%!assert (datestr (testtime,24), "18/12/2005")
%!assert (datestr (testtime,25), "05/12/18")
%!assert (datestr (testtime,26), "2005/12/18")
%!assert (datestr (testtime,27), "Q4-2005")
%!assert (datestr (testtime,28), "Dec2005")
%!assert (datestr (testtime,29), "2005-12-18")
%!assert (datestr (testtime,30), "20051218T023317")
%!assert (datestr (testtime,31), "2005-12-18 02:33:17")
%!assert (datestr (testtime+[0 0 3 0 0 0], "dddd"), "Wednesday")
## Test possible bug where input is a vector of datenums that is exactly 6 wide
%!assert (datestr ([1944, 6, 6, 6, 30, 0], 0), "06-Jun-1944 06:30:00")
## Test fractional millisecond time extension
%!assert (datestr (testtime, "HH:MM:SS:FFF"), "02:33:17:382")
## Test automatic format detection over vectors
%!assert (datestr ([2017 03 16 0 0 0; 2017 03 16 0 0 1]),
%!        char ("16-Mar-2017 00:00:00", "16-Mar-2017 00:00:01"))
## Test for correct millisecond rounding
%!assert (datestr (datenum ("1:00") - datenum ("0:55"), "HH:MM:SS.FFF"),
%!                 "00:05:00.000")

## Test input validation
%!error <Invalid call> datestr ()
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {@var{v} =} datevec (@var{date})
## @deftypefnx {} {@var{v} =} datevec (@var{date}, @var{f})
## @deftypefnx {} {@var{v} =} datevec (@var{date}, @var{p})
## @deftypefnx {} {@var{v} =} datevec (@var{date}, @var{f}, @var{p})
## @deftypefnx {} {[@var{y}, @var{m}, @var{d}, @var{h}, @var{mi}, @var{s}] =} datevec (@dots{})
## Convert a serial date number (@pxref{XREFdatenum,,@code{datenum}}) or date
## string (@pxref{XREFdatestr,,@code{datestr}}) into a date vector.
##
## A date vector is a row vector with six members, representing the year,
## month, day, hour, minute, and seconds respectively.
##
## @var{f} is the format string used to interpret date strings
## (@pxref{XREFdatestr,,@code{datestr}}).  If @var{date} is a string, but no
## format is specified, then a relatively slow search is performed through
## various formats.  It is always preferable to specify the format string
## @var{f} if it is known.  Formats which do not specify a particular time
## component will have the value set to zero.  Formats which do not specify a
## date will default to January 1st of the current year.
##
## @var{p} is the year at the start of the century to which two-digit years
## will be referenced.  If not specified, it defaults to the current year minus
## 50.
## @seealso{datenum, datestr, clock, now, date}
## @end deftypefn

## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)

## The function __date_str2vec__ is based on datesplit by Bill Denney.

function [y, m, d, h, mi, s] = datevec (date, f = [], p = [])

  persistent std_formats nfmt;

  if (isempty (std_formats))
    std_formats = cell ();
    nfmt = 0;
    ## These formats are specified by Matlab documentation to be parsed
    ## The '# XX' refers to the datestr numerical format code
    std_formats{++nfmt} = "dd-mmm-yyyy HH:MM:SS";   # 0
    std_formats{++nfmt} = "dd-mmm-yyyy";            # 1
    std_formats{++nfmt} = "mm/dd/yy";               # 2
    std_formats{++nfmt} = "mm/dd";                  # 6
    std_formats{++nfmt} = "HH:MM:SS";               # 13
    std_formats{++nfmt} = "HH:MM:SS PM";            # 14
    std_formats{++nfmt} = "HH:MM";                  # 15
    std_formats{++nfmt} = "HH:MM PM";               # 16
    std_formats{++nfmt} = "mm/dd/yyyy";             # 23

    ## These formats are undocumented but parsed by Matlab
    std_formats{++nfmt} = "mmmyy";                  # 12
    std_formats{++nfmt} = "mmm.dd,yyyy HH:MM:SS";   # 21
    std_formats{++nfmt} = "mmm.dd,yyyy";            # 22
    std_formats{++nfmt} = "yyyy/mm/dd";             # 26
    std_formats{++nfmt} = "yyyy-mm-dd";             # 29
    std_formats{++nfmt} = "yyyy-mm-dd HH:MM:SS";    # 31

    ## These are other formats that Octave tries
    std_formats{++nfmt} = "mmm-dd-yyyy HH:MM:SS";
    std_formats{++nfmt} = "mmm-dd-yyyy";
    std_formats{++nfmt} = "dd mmm yyyy HH:MM:SS";
    std_formats{++nfmt} = "dd mmm yyyy";
    std_formats{++nfmt} = "mmm dd yyyy HH:MM:SS";
    std_formats{++nfmt} = "mmm dd yyyy";
    std_formats{++nfmt} = "dd.mmm.yyyy HH:MM:SS";
    std_formats{++nfmt} = "dd.mmm.yyyy";
    std_formats{++nfmt} = "mmm.dd.yyyy HH:MM:SS";
    std_formats{++nfmt} = "mmm.dd.yyyy";
    std_formats{++nfmt} = "mm/dd/yyyy HH:MM";
  endif

  if (nargin < 1)
    print_usage ();
  endif

  if (ischar (date))
    date = cellstr (date);
  endif

  if (isnumeric (f))
    p = f;
    f = [];
  endif

  if (isempty (f))
    f = -1;
  endif

  if (isempty (p))
    p = (localtime (time ())).year + 1900 - 50;
  endif

  do_resize = false;

  if (iscell (date))

    nd = numel (date);

    y = m = d = h = mi = s = zeros (nd, 1);

    if (f == -1)
      for k = 1:nd
        found = false;
        for l = 1:nfmt
          [f, rY, ry, fy, fm, fd, fh, fmi, fs] = ...
            __date_vfmt2sfmt__ (std_formats{l});
          [found y(k) m(k) d(k) h(k) mi(k) s(k)] = ...
            __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
          if (found)
            break;
          endif
        endfor
        if (! found)
          error ("datevec: none of the standard formats match the DATE string");
        endif
      endfor
    else
      ## Decipher the format string just once for speed.
      [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f);
      for k = 1:nd
        [found y(k) m(k) d(k) h(k) mi(k) s(k)] = ...
          __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
        if (! found)
          error ("datevec: DATE not parsed correctly with given format");
        endif
      endfor
    endif

  else   # datenum input

    if (! iscolumn (date))
      date_sz = size (date);
      do_resize = true;
    endif
    date = date(:);

    ## Move day 0 from midnight -0001-12-31 to midnight 0000-3-1
    z = double (floor (date) - 60);
    ## Calculate number of centuries; K1 = 0.25 is to avoid rounding problems.
    a = floor ((z - 0.25) / 36524.25);
    ## Days within century; K2 = 0.25 is to avoid rounding problems.
    b = z - 0.25 + a - floor (a / 4);
    ## Calculate the year (year starts on March 1).
    y = floor (b / 365.25);
    ## Calculate day in year.
    c = fix (b - floor (365.25 * y)) + 1;
    ## Calculate month in year.
    m = fix ((5 * c + 456) / 153);
    d = c - fix ((153 * m - 457) / 5);
    ## Move to Jan 1 as start of year.
    ++y(m > 12);
    m(m > 12) -= 12;

    ## Convert hour-minute-seconds.  Attempt to account for precision of
    ## datenum format.

    fracd = date - floor (date);
    tmps = abs (eps*86400*date);
    tmps(tmps == 0) = 1;
    srnd = 2 .^ floor (- log2 (tmps));
    s = round (86400 * fracd .* srnd) ./ srnd;
    h = floor (s / 3600);
    s -= 3600 * h;
    mi = floor (s / 60);
    s -= 60 * mi;

  endif

  if (nargout <= 1)
    y = [y, m, d, h, mi, s];
  elseif (do_resize)
    y = reshape (y, date_sz);
    m = reshape (m, date_sz);
    d = reshape (d, date_sz);
    h = reshape (h, date_sz);
    mi = reshape (mi, date_sz);
    s = reshape (s, date_sz);
  endif

endfunction

function [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f)

  original_f = f;   # Store for error messages.

  ## Play safe with percent signs.
  f = strrep (f, "%", "%%");

  if (! isempty (strfind (f, "PM")) || ! isempty (strfind (f, "AM")))
    ampm = true;
  else
    ampm = false;
  endif

  ## Date part.
  f = regexprep (f, '[Yy][Yy][Yy][Yy]', "%Y");
  f = regexprep (f, '[Yy][Yy]', "%y");
  f = strrep (f, "mmmm", "%B");
  f = strrep (f, "mmm", "%b");
  f = strrep (f, "mm", "%m");
  f = regexprep (f, '[Dd][Dd][Dd][Dd]', "%A");
  f = regexprep (f, '[Dd][Dd][Dd]', "%a");
  f = regexprep (f, '[Dd][Dd]', "%d");

  ## Time part.
  if (ampm)
    f = strrep (f, "HH", "%I");
    f = strrep (f, "PM", "%p");
    f = strrep (f, "AM", "%p");
  else
    f = strrep (f, "HH", "%H");
  endif
  f = strrep (f, "MM", "%M");
  f = regexprep (f, '[Ss][Ss]', "%S");

  ## Check for conflicting or repeated fields.
  ## Only warn, not error, if we may be confused by an original '%'s.
  if (index (original_f, "%"))
    err_or_warn = @warning;
  else
    err_or_warn = @error;
  endif

  if (numel (strfind (f, "%Y")) + numel (strfind (f, "%y")) > 1)
    err_or_warn ("datevec: multiple year specifiers in %s", original_f);
  elseif (numel (strfind (f, "%m")) + numel (strfind (f, "%b"))
          + numel (strfind (f, "%B")) > 1)
    err_or_warn ("datevec: multiple month specifiers in %s", original_f);
  elseif (numel (strfind (f, "%d")) > 1)
    err_or_warn ("datevec: multiple day specifiers in %s", original_f);
  elseif (numel (strfind (f, "%a"))+ numel (strfind (f, "%A")) > 1)
    err_or_warn ("datevec: multiple day of week specifiers in %s", original_f);
  elseif (numel (strfind (f, "%H")) + numel (strfind (f, "%I")) > 1)
    err_or_warn ("datevec: multiple hour specifiers in %s", original_f);
  elseif (numel (strfind (f, "%M")) > 1)
    err_or_warn ("datevec: multiple minute specifiers in %s", original_f);
  elseif (numel (strfind (f, "%S")) > 1)
    err_or_warn ("datevec: multiple second specifiers in %s", original_f);
  endif

  rY = rindex (f, "%Y");
  ry = rindex (f, "%y");

  ## Check whether we need to give default values.
  ## Possible error when string contains "%%".
  fy = rY || ry;
  fm = index (f, "%m") || index (f, "%b") || index (f, "%B");
  fd = index (f, "%d") || index (f, "%a") || index (f, "%A");
  fh = index (f, "%H") || index (f, "%I");
  fmi = index (f, "%M");
  fs = index (f, "%S");

endfunction

function [found, y, m, d, h, mi, s] = __date_str2vec__ (ds, p, f, rY, ry, fy, fm, fd, fh, fmi, fs)

  ## Local time zone is irrelevant, and potentially dangerous, when using
  ## strptime to simply convert a string into a broken down struct tm.
  ## Set and restore TZ so time is parsed exactly as-is. See bug #36954.
  TZ_orig = getenv ("TZ");
  unwind_protect
    setenv ("TZ", "UTC0");

    idx = strfind (f, "FFF");
    if (! isempty (idx))
      ## Kludge to handle FFF millisecond format since strptime does not.

      ## Find location of FFF in ds.
      ## Might not match idx because of things like yyyy -> %y.
      [~, nc] = strptime (ds, f(1:idx-1));

      msec = ds(nc:min (nc+2,end)); # pull 3-digit fractional seconds.
      msec_idx = find (! isdigit (msec), 1);

      if (! isempty (msec_idx))  # non-digits in msec
        msec = msec(1:msec_idx-1);
        msec(end+1:3) = "0";     # pad msec with trailing zeros
        ds = [ds(1:(nc-1)), msec, ds((nc-1)+msec_idx:end)];  # zero pad ds
      elseif (numel (msec) < 3)  # less than three digits in msec
        m_len = numel (msec);
        msec(end+1:3) = "0";     # pad msec with trailing zeros
        ds = [ds(1:(nc-1)), msec, ds(nc+m_len:end)];  # zero pad ds as well
      endif

      ## replace FFF with digits to guarantee match in strptime.
      f(idx:idx+2) = msec;

      if (nc > 0)
        [tm, nc] = strptime (ds, f);
        tm.usec = 1000 * str2double (msec);
      endif

    else
      [tm, nc] = strptime (ds, f);
    endif
  unwind_protect_cleanup
    if (isempty (TZ_orig))
      unsetenv ("TZ");
    else
      setenv ("TZ", TZ_orig);
    endif
  end_unwind_protect

  if (nc == columns (ds) + 1)
    found = true;
    y = tm.year + 1900; m = tm.mon + 1; d = tm.mday;
    h = tm.hour; mi = tm.min; s = tm.sec + tm.usec / 1e6;
    if (rY < ry)
      if (y > 1999)
        y -= 2000;
      else
        y -= 1900;
      endif
      y += p - mod (p, 100);
      if (y < p)
        y += 100;
      endif
    endif
    if (! fy && ! fm && ! fd)
      tmp = localtime (time ());
      ## default is January 1st of current year
      y = tmp.year + 1900;
      m = 1;
      d = 1;
    elseif (! fy && fm && fd)
      tmp = localtime (time ());
      y = tmp.year + 1900;
    elseif (fy && fm && ! fd)
      d = 1;
    endif
    if (! fh && ! fmi && ! fs)
      h = mi = s = 0;
    elseif (fh && fmi && ! fs)
      s = 0;
    endif
  else
    y = m = d = h = mi = s = 0;
    found = false;
  endif

endfunction


%!demo
%! ## Current date and time
%! datevec (now ())

%!shared yr
%! yr = datevec (now)(1);  # Some tests could fail around midnight!
## tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
%!assert (datevec ("07-Sep-2000 15:38:09"), [2000,9,7,15,38,9])
%!assert (datevec ("07-Sep-2000"), [2000,9,7,0,0,0])
%!assert (datevec ("09/07/00"), [2000,9,7,0,0,0])
%!assert (datevec ("09/13"), [yr,9,13,0,0,0])
%!assert (datevec ("15:38:09"), [yr,1,1,15,38,9])
%!assert (datevec ("3:38:09 PM"), [yr,1,1,15,38,9])
%!assert (datevec ("15:38"), [yr,1,1,15,38,0])
%!assert (datevec ("03:38 PM"), [yr,1,1,15,38,0])
%!assert (datevec ("03/13/1962"), [1962,3,13,0,0,0])

## Test millisecond format FFF
%!assert (datevec ("15:38:21.2", "HH:MM:SS.FFF"), [yr,1,1,15,38,21.2])
%!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [yr,1,1,15,38,21.25])
%!assert (datevec ("15:38:21.251", "HH:MM:SS.FFF"), [yr,1,1,15,38,21.251])

## Test millisecond format FFF with AM/PM, and 1,2, or 3 FFF digits
%!assert (datevec ("06/01/2015 3:07:12.102 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,15,7,12.102])
%!assert (datevec ("06/01/2015 11:07:12.102 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,23,7,12.102])
%!assert (datevec ("06/01/2015 3:07:12.102 AM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,3,7,12.102])
%!assert (datevec ("06/01/2015 11:07:12.102 AM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,11,7,12.102])
%!assert (datevec ("06/01/2015 3:07:12.1 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,15,7,12.1])
%!assert (datevec ("06/01/2015 3:07:12.12 AM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,3,7,12.12])
%!assert (datevec ("06/01/2015 3:07:12.12 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
%!        [2015,6,1,15,7,12.12])

## Test structure of return value
%!test <*42334>
%! [~, ~, d] = datevec ([1 2; 3 4]);
%! assert (d, [1 2; 3 4]);

## Other tests
%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
%!test
%! t = linspace (-2e5, 2e5, 10993);
%! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
%!assert (double (datevec (int64 (datenum ([2014 6 1])))),
%!        datevec (datenum ([2014 6 1])))
%!assert (double (datevec (int64 (datenum ([2014 6 18])))),
%!        datevec (datenum ([2014 6 18])))

## Test parsing of date strings that fall within daylight saving transition
%!testif ; isunix () <*36954>
%! zones = { "UTC0"                                 ...
%!           "EST+5EDT,M3.2.0/2,M11.1.0/2"          ... America/New_York
%!           "CET-1CEST,M3.5.0/2,M10.5.0/2"         ... Europe/Berlin
%!           "CLT+4CLST,M8.2.0/0,M5.2.0/0"          ... America/Santiago
%!           "LHST-10:30LHDT-11,M10.1.0/2,M4.1.0/2" ... Australia/Lord_Howe
%!           ":America/Caracas"                     ...
%!         };
%! TZ_orig = getenv ("TZ");
%! unwind_protect
%!   for i = 1:numel (zones)
%!     setenv ("TZ", zones{i});
%!     ## These specific times were chosen to test conversion during the loss
%!     ## of some amount of local time at the start of daylight saving time in
%!     ## each of the zones listed above.  We test all in each time zone to be
%!     ## exhaustive, even though each is problematic for only one of the zones.
%!     assert (datevec ("2017-03-12 02:15:00"), [2017  3 12 2 15 0]);
%!     assert (datevec ("2017-03-26 02:15:00"), [2017  3 26 2 15 0]);
%!     assert (datevec ("2017-08-13 00:15:00"), [2017  8 13 0 15 0]);
%!     assert (datevec ("2017-10-01 02:15:00"), [2017 10  1 2 15 0]);
%!     ## This tests a one-time loss of 30 minutes in Venezuela's local time
%!     assert (datevec ("2016-05-01 02:40:00"), [2016  5  1 2 40 0]);
%!   endfor
%! unwind_protect_cleanup
%!   if (isempty (TZ_orig))
%!     unsetenv ("TZ");
%!   else
%!     setenv ("TZ", TZ_orig);
%!   endif
%! end_unwind_protect

## Test input validation
%!error <Invalid call> datevec ()
%!error <none of the standard formats match> datevec ("foobar")
%!error <DATE not parsed correctly with given format> datevec ("foobar", "%d")
%!error <multiple year specifiers> datevec ("1/2/30", "mm/yy/yy")
%!error <multiple month specifiers> datevec ("1/2/30", "mm/mm/yy")
%!error <multiple day specifiers> datevec ("1/2/30", "mm/dd/dd")
%!error <multiple hour specifiers> datevec ("15:38:21.251", "HH:HH:SS")
%!error <multiple minute specifiers> datevec ("15:38:21.251", "MM:MM:SS")
%!error <multiple second specifiers> datevec ("15:38:21.251", "HH:SS:SS")
########################################################################
##
## Copyright (C) 2004-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {@var{e} =} eomday (@var{y}, @var{m})
## Return the last day of the month @var{m} for the year @var{y}.
## @seealso{weekday, datenum, datevec, is_leap_year, calendar}
## @end deftypefn

function e = eomday (y, m)

  if (nargin != 2)
    print_usage ();
  endif

  eom = [31, 28, 31, 30 ,31, 30, 31, 31, 30, 31, 30, 31];
  e = reshape (eom(m), size (m));
  e += (m == 2) & (mod (y, 4) == 0 & (mod (y, 100) != 0 | mod (y, 400) == 0));

endfunction


%!demo
%! ## Find leap years in the 20th century
%! y = 1900:1999;
%! e = eomday (y, repmat (2, [1, 100]));
%! y(find (e == 29))

%!assert (eomday ([-4:4],2), [29,28,28,28,29,28,28,28,29])
%!assert (eomday ([-901,901],2), [28,28])
%!assert (eomday ([-100,100],2), [28,28])
%!assert (eomday ([-900,900],2), [28,28])
%!assert (eomday ([-400,400],2), [29,29])
%!assert (eomday ([-800,800],2), [29,29])
%!assert (eomday (2001,1:12), [31,28,31,30,31,30,31,31,30,31,30,31])
%!assert (eomday (1:3,1:3), [31,28,31])
%!assert (eomday (1:2000,2)', datevec (datenum (1:2000,3,0))(:,3))
%!assert ([1900:1999](find (eomday (1900:1999,2*ones(1,100))==29)),
%!        [1904,1908,1912,1916,1920,1924,1928,1932,1936,1940,1944,1948,1952,1956,1960,1964,1968,1972,1976,1980,1984,1988,1992,1996])
%!assert (eomday ([2004;2005], [2;2]), [29;28])

## Test input validation
%!error <Invalid call> eomday ()
%!error <Invalid call> eomday (1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {} etime (@var{t2}, @var{t1})
## Return the difference in seconds between two time values returned from
## @code{clock} (@math{@var{t2} - @var{t1}}).
##
## For example:
##
## @example
## @group
## t0 = clock ();
## # many computations later@dots{}
## elapsed_time = etime (clock (), t0);
## @end group
## @end example
##
## @noindent
## will set the variable @code{elapsed_time} to the number of seconds since the
## variable @code{t0} was set.
## @seealso{tic, toc, clock, cputime, addtodate}
## @end deftypefn

function secs = etime (t2, t1)

  if (nargin != 2)
    print_usage ();
  endif

  [~, s2] = datenum (t2);
  [~, s1] = datenum (t1);

  secs = s2 - s1;

endfunction


%!assert (etime ([1900,12,31,23,59,59], [1901,1,1,0,0,0]), -1)
%!assert (etime ([1900,2,28,23,59,59], [1900,3,1,0,0,0]), -1)
%!assert (etime ([2000,2,28,23,59,59], [2000,3,1,0,0,0]), -86401)
%!assert (etime ([1996,2,28,23,59,59], [1996,3,1,0,0,0]), -86401)
%!test
%! t1 = [1900,12,31,23,59,59; 1900,2,28,23,59,59];
%! t2 = [1901,1,1,0,0,0; 1900,3,1,0,0,0];
%! assert (etime (t2, t1), [1;1]);

%!test
%! t1 = [1993, 8, 20, 4, 56, 1];
%! t2 = [1993, 8, 21, 4, 56, 1];
%! t3 = [1993, 8, 20, 5, 56, 1];
%! t4 = [1993, 8, 20, 4, 57, 1];
%! t5 = [1993, 8, 20, 4, 56, 14];
%!
%! assert (etime (t2, t1), 86400);
%! assert (etime (t3, t1), 3600);
%! assert (etime (t4, t1), 60);
%! assert (etime (t5, t1), 13);

## Test input validation
%!error <Invalid call> etime ()
%!error <Invalid call> etime (1)
########################################################################
##
## Copyright (C) 1996-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {} is_leap_year ()
## @deftypefnx {} {} is_leap_year (@var{year})
## Return true if @var{year} is a leap year and false otherwise.
##
## If no year is specified, @code{is_leap_year} uses the current year.
##
## For example:
##
## @example
## @group
## is_leap_year (2000)
##    @result{} 1
## @end group
## @end example
## @seealso{weekday, eomday, calendar}
## @end deftypefn

function retval = is_leap_year (year)

  if (nargin == 0)
    t = clock ();
    year = t(1);
  endif

  retval = (rem (year, 4) == 0 & rem (year, 100) != 0) | (rem (year, 400) == 0);

endfunction


%!assert (is_leap_year (2000), true)
%!assert (is_leap_year (1976), true)
%!assert (is_leap_year (1000), false)
%!assert (is_leap_year (1800), false)
%!assert (is_leap_year (1600), true)

########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn {} {t =} now ()
## Return the current local date/time as a serial day number
## (@pxref{XREFdatenum,,@code{datenum}}).
##
## The integral part, @code{floor (now)} corresponds to the number of days
## between today and Jan 1, 0000.
##
## The fractional part, @code{rem (now, 1)} corresponds to the current time.
## @seealso{clock, date, datenum}
## @end deftypefn

function t = now ()

  t = datenum (clock ());

  ## The following doesn't work (e.g., one hour off on 2005-10-04):
  ##
  ##   seconds since 1970-1-1 corrected by seconds from GMT to local time
  ##   divided by 86400 sec/day plus day num for 1970-1-1
  ##   t = (time - mktime(gmtime(0)))/86400 + 719529;
  ##
  ## mktime (gmtime (0)) does indeed return the offset from Greenwich to the
  ## local time zone, but we need to account for daylight saving time
  ## changing by an hour the offset from CUT for part of the year.

endfunction


%!assert (isnumeric (now ()))
%!assert (now () > 0)
%!assert (now () <= now ())
########################################################################
##
## Copyright (C) 2000-2022 The Octave Project Developers
##
## See the file COPYRIGHT.md in the top-level directory of this
## distribution or <https://octave.org/copyright/>.
##
## This file is part of Octave.
##
## Octave is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Octave is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <https://www.gnu.org/licenses/>.
##
########################################################################

## -*- texinfo -*-
## @deftypefn  {} {[@var{n}, @var{s}] =} weekday (@var{d})
## @deftypefnx {} {[@var{n}, @var{s}] =} weekday (@var{d}, @var{format})
## Return the day of the week as a number in @var{n} and as a string in
## @var{s}.
##
## The days of the week are numbered 1--7 with the first day being Sunday.
##
## @var{d} is a serial date number or a date string.
##
## If the string @var{format} is not present or is equal to @qcode{"short"}
## then @var{s} will contain the abbreviated name of the weekday.  If
## @var{format} is @qcode{"long"} then @var{s} will contain the full name.
##
## Table of return values based on @var{format}:
##
## @multitable @columnfractions .06 .13 .16
## @headitem @var{n} @tab @qcode{"short"} @tab @qcode{"long"}
## @item 1 @tab Sun @tab Sunday
## @item 2 @tab Mon @tab Monday
## @item 3 @tab Tue @tab Tuesday
## @item 4 @tab Wed @tab Wednesday
## @item 5 @tab Thu @tab Thursday
## @item 6 @tab Fri @tab Friday
## @item 7 @tab Sat @tab Saturday
## @end multitable
##
## @seealso{eomday, is_leap_year, calendar, datenum, datevec}
## @end deftypefn

function [d, s] = weekday (d, format = "short")

  if (nargin < 1)
    print_usage ();
  endif

  if (iscellstr (d) || isnumeric (d))
    endsize = size (d);
  elseif (ischar (d))
    endsize = [rows(d), 1];
  endif
  if (ischar (d) || iscellstr (d))
    ## Make sure the date is numeric
    d = datenum (d);
  endif
  ## Find the offset from a known Sunday (2008-Jan-6), mod 7.
  d = floor (reshape (mod (d - 733048, 7), endsize));
  ## Make Saturdays a 7 and not a 0.
  d(! d) = 7;

  if (isargout (2))
    if (strcmpi (format, "long"))
      names = {"Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" ...
               "Friday" "Saturday"};
    else
      names = {"Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"};
    endif
    s = strvcat (names(d));
  endif

endfunction


%!demo
%! ## Current weekday
%! [n, s] = weekday (now ())

%!demo
%! ## Weekday from datenum input
%! [n, s] = weekday (728647)

%!demo
%! ## Weekday of new millennium from datestr input
%! [n, s] = weekday ("1-Jan-2000")

%!assert (weekday (728647), 2)
## Test vector inputs for both directions
%!assert (weekday ([728647 728648]), [2 3])
%!assert (weekday ([728647;728648]), [2;3])
## Test a full week before our reference day
%!assert (weekday ("19-Dec-1994"), 2)
%!assert (weekday ("20-Dec-1994"), 3)
%!assert (weekday ("21-Dec-1994"), 4)
%!assert (weekday ("22-Dec-1994"), 5)
%!assert (weekday ("23-Dec-1994"), 6)
%!assert (weekday ("24-Dec-1994"), 7)
%!assert (weekday ("25-Dec-1994"), 1)
## Test our reference day
%!assert (weekday ("6-Jan-2008"), 1)
## Test a full week after our reference day
%!assert (weekday ("1-Feb-2008"), 6)
%!assert (weekday ("2-Feb-2008"), 7)
%!assert (weekday ("3-Feb-2008"), 1)
%!assert (weekday ("4-Feb-2008"), 2)
%!assert (weekday ("5-Feb-2008"), 3)
%!assert (weekday ("6-Feb-2008"), 4)
%!assert (weekday ("7-Feb-2008"), 5)
## Test fractional dates
%!assert (weekday (728647.1), 2)
## Test "long" option
%!test
%! [n, s] = weekday ("25-Dec-1994", "long");
%! assert (n, 1);
%! assert (s, "Sunday");
