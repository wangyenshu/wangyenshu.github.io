/***
|Name|TiddlerToCPlugin|
|Description|Tiddler Table of Contents generator|
|Author|Julien Coloos|
|Version|1.1.0|
|Date|2011-06-12|
|Status|stable|
|Source|http://julien.coloos.free.fr/TiddlyWiki-dev/#TiddlerToCPlugin|
|License|[img[CC BY-SA 3.0|http://i.creativecommons.org/l/by-sa/3.0/80x15.png][http://creativecommons.org/licenses/by-sa/3.0/]]|
|CoreVersion|2.6|
|Documentation|http://julien.coloos.free.fr/TiddlyWiki-dev/#TiddlerToCPlugin|

{{tw_ttoc{}}}
!Description
This plugin adds the {{{TiddlerToC}}} macro to generate a ~ToC inside a tiddler.
The generated ~ToC entries list the visible headings found in the tidder, each entry being preceded by a number representing its level and index (e.g.: //1.2.1//). Those numbers link to the corresponding heading.
Found headings are also altered to display a link back to the ~ToC.

The ~ToC does not reference tiddlers embedded using the {{{tiddler}}}, {{{slider}}} or {{{tabs}}} macro.

The ~ToC is either generated at a given target, or at the beginning of the place it was dropped in. If there are less headings than a given minimum (default being 2), the ~ToC is not displayed.
The ~ToC title can be clicked to hide/display the ~ToC content.


!Notes
The {{{TiddlerToC}}} macro searches for the HTML headings ({{{h1}}} to {{{h6}}} tags) in the place where it is inserted. Each heading is then converted to a ~ToC entry, preserving inner text format.
The macro thus has to be inserted at the end of the tiddler: content has been generated and the ~ToC can be populated.


!Usage
The {{{TiddlerToC}}} macro is intended to be inserted at the end of a tiddler.

By default the ~ToC is generated at the beginning of the place the macro was inserted in.
However a target can be used: if the place contains an element which class is {{{tw_ttoc}}}, this element will be replaced by the ~ToC.
Such an element can be generated by dropping one of the following inside the tiddler:
* using a ~TiddlyWiki macro
{{{
{{tw_ttoc{}}}
}}}
* inserting an explicit HTML tag; the advantage here is that attributes can be specified
{{{
<html><div class="tw_ttoc" min-entries="3"/></html>
}}}


The macro and/or target element can also be used in [[ViewTemplate]] to be applied to all tiddlers:
{{{
...
<!-- Wikified tiddler content -->
<div class='viewer' macro='view text wikified'>
	<!-- Insert ToC right before tiddler content -->
	<div class='tw_ttoc'></div>
</div>
<!-- ToC generator, to use at the end of the tiddler -->
<div macro='TiddlerToC min-entries:3'></div>
}}}

!!Parameters
The following parameters are available:
* {{{min-entries}}} (optional)
** minimum number of entries needed to display the ~ToC
** can be specified as macro parameter, and can be overridden in the target tag (needs explicit HTML tag; see before)
** default value is {{{2}}}

!!Examples
Without target:
{{{
Tiddler content.
...

<<TiddlerToC min-entries:3>>
}}}

With a target:
{{{
Beginning of the tiddler.
...

Where to generate the ToC:
{{tw_ttoc{}}}
Or, with a minimum number of entries specified:
<html><div class="tw_ttoc" min-entries="3"/></html>

Tiddler continues ...

<<TiddlerToC min-entries:3>>
}}}


!Styling
~ToC content uses some classes which style can be overriden using CSS. Those classes are:
* {{{tw_ttoc}}}: ~ToC
* {{{tw_ttoc_title}}}: title ({{{Table of Contents}}})
* {{{tw_ttoc_level}}}: sub-level entry indentation
* {{{tw_ttoc_entry}}}: entry
* {{{tw_ttoc_id}}}: entry number
* {{{tw_ttoc_top}}}: heading link back to the ~ToC

Default style can be found in the code below, and can be overridden in the [[StyleSheet]] tiddler.


!Revision History
!!v1.1.0 (2011-06-12)
Changes:
* by default, ~ToC is now displayed only if it contains more than one entry

Enhancements:
* added a macro parameter to give the minimum number of entries needed to display the ~ToC
** the parameter can be overridden in the ~ToC target

Fixes:
* do not list headings that are not //displayed//

!!v1.0.1 (2011-05-29)
Changes:
* if there is none, adds a {{{br}}} tag after the ~ToC

!!v1.0.0 (2011-05-28)
Initial release.


!Code
***/
//{{{
if (!config.macros.TiddlerToC) {(function($) {

version.extensions.TiddlerToCPlugin = {major: 1, minor: 1, revision: 0, date: new Date(2011, 6, 12)};

var hTag = /^h([1-6])$/i;

setStylesheet(".tw_ttoc {background-color: #F8F8F8; padding: 10px; border: 1px #CCCCCC solid;} .tw_ttoc_title {text-align:center; font-weight: bold; margin: 5px 0px 20px 0px;} .tw_ttoc_level {padding-left: 20px;} .tw_ttoc_id {margin-right: 6px;} .tw_ttoc_top {float: right; font-size: 0.5em;}", "TiddlerToCPlugin");

function cloneNodeWithEvents(node) {
	var clone = node.cloneNode(true);
	var n1 = [node].concat(Array.prototype.slice.call(node.getElementsByTagName('*')));
	var n2 = [clone].concat(Array.prototype.slice.call(clone.getElementsByTagName('*')));

	for (var i=0 ; i<n1.length ; i++) {
		for (var j in n1[i]) {
			if (j.substr(0,2) != "on") continue;
			n2[i][j] = n1[i][j];
		}
	}

	return clone;
}

var pl = config.macros.TiddlerToC = {
handler: function(place, macroName, params, wikifier, paramString, tiddler) {
	var namedParams = paramString.parseParams(null, null, true), paramMinEntries = getParam(namedParams, "min-entries"), minEntries = paramMinEntries ? parseInt(paramMinEntries) : 2;

	if ($(place).hasClass("viewer") || $(place).parents(".viewer").size()) pl.generate(place, minEntries);
	else {
		/* the macro is not used inside a tiddler content but probably in a template */
		var t = story.findContainingTiddler(place);
		if (!t) return;
		pl.generate(t, minEntries);
	}
},
getElements: function(place) {
	var els = $();

	$(place).children().each(function(i, n) {
		/* exclude embedded tiddlers */
		if ($(n).attr("tiddler") || $(n).hasClass("sliderPanel") || $(n).hasClass("tabsetWrapper")) return;
		/* include headings and ToC target */
		if (hTag.test(n.tagName) || $(n).is(".tw_ttoc")) els = els.add(n);
		/* recurse */
		els = els.add(pl.getElements(n));
	});

	return els;
},
generate: function(place, minEntries) {
	var els = pl.getElements(place);

	/* get ToC target, or insert it as first element */
	var toc = els.filter(".tw_ttoc");
	if (toc.size()) {
		if (toc.size() > 1) {
			/* More than one target; happens when using ViewTemplate while
			 * tiddler already contains a ToC target. In any case, it is best
			 * to keep the last one and remove others.
			 */
			toc.not(toc.last()).remove();
			toc = toc.last();
		}
		/* check the ToC was not already generated */
		if (toc[0].toc && toc[0].toc.generated) return;
		/* check if the minimum number of entries is overridden */
		if (toc.attr("min-entries")) minEntries = parseInt(toc.attr("min-entries"));
		/* rebuild target tag */
		toc = toc.empty().wrapInner("<div class='tw_ttoc'/>").children("div").unwrap();
	}
	else toc = $("<div class='tw_ttoc'/>").prependTo(place);

	var hLevelCurrent = 0, hLevel;
	var tocInner = $("<div/>"), listCurrent = tocInner[0], listId = "1";
	toc.hide().append($("<div class='tw_ttoc_title'><a href='javascript:;'>Table of Contents</a></div>"), tocInner);
	$(".tw_ttoc_title a", toc).click(function() {
		if (tocInner.is(":visible")) tocInner.hide("fast");
		else tocInner.show("fast");
	});

	var headings = $();
	els.each(function(i, c) {
		/* check we got a visible heading */
		var match = hTag.exec(c.tagName);
		if (!match || !$(c).is(":visible")) return;
		hLevel = parseInt(match[1]);

		/* check the heading level */
		if (!hLevelCurrent) hLevelCurrent = hLevel;
		if (hLevel < hLevelCurrent) {
			/* have to go up */
			while ((hLevel <= --hLevelCurrent) && listCurrent.parentNode) {
				listCurrent = listCurrent.parentNode.parentNode;
				ids = listId.split(".");
				ids.pop();
				listId = ids.join(".");
			}
		}
		else if (hLevel > hLevelCurrent) {
			/* have to go down */
			while (hLevel >= ++hLevelCurrent) {
				$(listCurrent.lastChild).append(listCurrent = $("<div class='tw_ttoc_level'/>")[0]);
				ids = listId.split(".");
				ids.push(1);
				listId = ids.join(".");
			}
		}
		/* determine this heading index */
		ids = listId.split(".");
		ids[ids.length-1] = $(listCurrent).children("div.tw_ttoc_entry").size() + 1;
		listId = ids.join(".");

		/* clone the heading content to insert it in the ToC */
		$(cloneNodeWithEvents(c)).wrapInner("<div class='tw_ttoc_entry'/>").children("div").unwrap().prepend($("<a class='tw_ttoc_id' href='javascript:;'/>").html(listId).click({target: c}, function(ev){window.scrollTo(0,findPosY(ev.data.target))})).appendTo(listCurrent);

		headings = headings.add(c);

		hLevelCurrent = hLevel;
	});
	toc[0].toc = {generated: true};

	if (headings.size() >= minEntries) {
		/* display ToC */
		/* Note: jQuery 'next' does not take into account text nodes */
		var sibling = toc.show()[0].nextSibling;
		if (sibling && (sibling.nodeName != "BR")) toc.after("<br/>");

		/* insert a 'ToC' link in the headings */
		headings.append($("<span class='tw_ttoc_top'><a href='javascript:;' title='Go to Table of Contents'>[ToC]</a></span>")).find(".tw_ttoc_top a").click(function() {window.scrollTo(0,findPosY(toc[0]))});
	}
}
};

})(jQuery);}
//}}}
/***
<<TiddlerToC>>
***/
