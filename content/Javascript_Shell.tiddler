<div title="Javascript Shell" modifier="Wang Yanshu" created="202407251506" creator="Wang Yanshu">
<pre>/%

Derived from http://www.squarefree.com/shell/?ignoreReferrerFrom=shell1.4

%/<html><div class="shell"><div id="output"></div><input type=text
		onkeydown="jsshell.inputKeydown(event)"
		id="input" class="input" wrap="off" autocomplete="off"
		title="TAB=auto-complete property names, Ctrl+Up/Down=history"
		style="width:100%;margin-top:.2em;border:1px solid;color:#000;background:#fff;"><span style="float:right">height: <input type="text" name="height" value="20em" size="2" style="width:3em;padding:0;margin:0;" onchange="document.getElementById('output').style.height=this.value"> <input type="button" onclick="jsshell.go('clear()')"value="clear"></span><!--
	--><div>enter a javascript expression or shell function:
	ans, load(URL), scope(obj), <!--
	--><a accesskey="M" href="javascript:jsshell.go('scope(Math); mathHelp();');">Math</a>, <!--
	--><a accesskey="P" href="javascript:jsshell.go('props(ans)')">props(obj)</a>, <!--
	--><a accesskey="B" href="javascript:jsshell.go('blink(ans)')">blink(node)</a>, <!--
	--><a href="javascript:jsshell.go('wikify(ans)')">wikify(text)</a>, <!--
	--><a href="javascript:jsshell.go('print(ans)')">print(text)</a></div></div></html><script>

var shellstyles="";
shellstyles+=".shell #output { height:20em;width:100%;white-space:normal;overflow:auto; }";
shellstyles+=".shell #output { border:1px solid #999;background:#000 !important; }";
shellstyles+=".shell #output .input { color:#fff !important; }"; // white
shellstyles+=".shell #output .error { color:#f00 !important; }"; // red
shellstyles+=".shell #output .normalOutput { color:#0c0 !important; }"; // green
shellstyles+=".shell #output .propList { color:#0c0 !important; }"; // green
shellstyles+=".shell #output .print { color:#ccc !important; }"; // gray
shellstyles+=".shell #output .tabcomplete { color:#ff0 !important; }"; // yellow
shellstyles+=".shell #output .message { color:#0ff !important; }"; // cyan
setStylesheet(shellstyles,"JavascriptShellStyles");

window.jsshell = {}; // Put our functions in the global namespace.

window.jsshell.refocus = function()
{
  jsshell._in.blur(); // Needed for Mozilla to scroll correctly.
  jsshell._in.focus();
}

window.jsshell.initTarget = function()
{
  window.print = jsshell.shellCommands.print;
}

// Unless the user is selected something, refocus the textbox.
// (requested by caillon, brendan, asa)
window.jsshell.keepFocusInTextbox = function(e) 
{
  var g = e.srcElement ? e.srcElement : e.target; // IE vs. standard
  
  while (!g.tagName)
    g = g.parentNode;
  var t = g.tagName.toUpperCase();
  if (t=="A" || t=="INPUT")
    return;
    
  if (window.getSelection) {
    // Mozilla
    if (String(window.getSelection()))
      return;
  }
  else if (document.getSelection) {
    // Opera? Netscape 4?
    if (document.getSelection())
      return;
  }
  else {
    // IE
    if ( document.selection.createRange().text )
      return;
  }
  
  jsshell.refocus();
}

//function inputKeydown(e) {
window.jsshell.inputKeydown = function(e) {
  // Use onkeydown because IE doesn't support onkeypress for arrow keys

  //alert(e.keyCode + " ^ " + e.keycode);

  if (e.shiftKey && e.keyCode == 13) { // shift-enter
    // don't do anything; allow the shift-enter to insert a line break as normal
  } else if (e.keyCode == 13) { // enter
    // execute the input on enter
    try { jsshell.go(); } catch(er) { alert(er); };
    setTimeout(function() { jsshell._in.value = ""; }, 0); // can't preventDefault on input, so clear it later
  } else if (e.keyCode == 38) { // up
    // go up in history if at top or ctrl-up
    if (e.ctrlKey || jsshell.caretInFirstLine(jsshell._in))
      jsshell.hist(true);
  } else if (e.keyCode == 40) { // down
    // go down in history if at end or ctrl-down
    if (e.ctrlKey || jsshell.caretInLastLine(jsshell._in))
      jsshell.hist(false);
  } else if (e.keyCode == 9) { // tab
    jsshell.tabcomplete();
    setTimeout(function() { jsshell.refocus(); }, 0); // refocus because tab was hit
  } else { }

  setTimeout(jsshell.recalculateInputHeight, 0);
  
  //return true;
};

window.jsshell.caretInFirstLine = function(textbox)
{
  // IE doesn't support selectionStart/selectionEnd
  if (textbox.selectionStart == undefined)
    return true;

  var firstLineBreak = textbox.value.indexOf("\n");

  return ((firstLineBreak == -1) || (textbox.selectionStart <= firstLineBreak));
}

window.jsshell.caretInLastLine = function(textbox)
{
  // IE doesn't support selectionStart/selectionEnd
  if (textbox.selectionEnd == undefined)
    return true;

  var lastLineBreak = textbox.value.lastIndexOf("\n");
  
  return (textbox.selectionEnd > lastLineBreak);
}

window.jsshell.recalculateInputHeight = function()
{
  var rows = jsshell._in.value.split(/\n/).length
    + 1 // prevent scrollbar flickering in Mozilla
    + (window.opera ? 1 : 0); // leave room for scrollbar in Opera

  if (jsshell._in.rows != rows) // without this check, it is impossible to select text in Opera 7.60 or Opera 8.0.
    jsshell._in.rows = rows;
}

window.jsshell.println = function(s, type)
{
  if((s=String(s)))
  {
    var newdiv = document.createElement("div");
    newdiv.appendChild(document.createTextNode(s));
    newdiv.className = type;
    jsshell._out.appendChild(newdiv);
    jsshell._out.scrollTop=jsshell._out.scrollHeight-jsshell._out.clientHeight; // ELS: scroll output into view
    return newdiv;
  }
}

window.jsshell.printWithRunin = function(h, s, type)
{
  var div = jsshell.println(s, type);
  var head = document.createElement("strong");
  head.appendChild(document.createTextNode(h + ": "));
  div.insertBefore(head, div.firstChild);
}

window.jsshell.shellCommands = 
{
load : function load(url)
{
  var s = document.createElement("script");
  s.type = "text/javascript";
  s.src = url;
  document.getElementsByTagName("head")[0].appendChild(s);
  jsshell.println("Loading " + url + "...", "message");
},

clear : function clear()
{
    jsshell._out.innerHTML = "";
},

wikify : function wikify(text)
{
    window.wikify(text, jsshell._out);
},

print : function print(s) { jsshell.println(s, "print"); },

// the normal function, "print", shouldn't return a value
// (suggested by brendan; later noticed it was a problem when showing others)
pr : function pr(s) 
{ 
  jsshell.shellCommands.print(s); // need to specify shellCommands so it doesn't try window.print()!
  return s;
},

props : function props(e, onePerLine)
{
  if (e === null) {
    jsshell.println("props called with null argument", "error");
    return;
  }

  if (e === undefined) {
    jsshell.println("props called with undefined argument", "error");
    return;
  }

  var ns = ["Methods", "Fields", "Unreachables"];
  var as = [[], [], []]; // array of (empty) arrays of arrays!
  var p, j, i; // loop variables, several used multiple times

  var protoLevels = 0;

  for (p = e; p; p = p.__proto__)
  {
    for (i=0; i<ns.length; ++i)
      as[i][protoLevels] = [];
    ++protoLevels;
  }

  for(var a in e)
  {
    // Shortcoming: doesn't check that VALUES are the same in object and prototype.

    var protoLevel = -1;
    try
    {
      for (p = e; p && (a in p); p = p.__proto__)
        ++protoLevel;
    }
    catch(er) { protoLevel = 0; } // "in" operator throws when param to props() is a string

    var type = 1;
    try
    {
      if ((typeof e[a]) == "function")
        type = 0;
    }
    catch (er) { type = 2; }

    as[type][protoLevel].push(a);
  }

  function times(s, n) { return n ? s + times(s, n-1) : ""; }

  for (j=0; j<protoLevels; ++j)
    for (i=0;i<ns.length;++i)
      if (as[i][j].length) 
        jsshell.printWithRunin(
          ns[i] + times(" of prototype", j), 
          (onePerLine ? "\n\n" : "") + as[i][j].sort().join(onePerLine ? "\n" : ", ") + (onePerLine ? "\n\n" : ""), 
          "propList"
        );
},

blink : function blink(node)
{
  if (!node)                     throw("blink: argument is null or undefined.");
  if (node.nodeType == null)     throw("blink: argument must be a node.");
  if (node.nodeType == 3)        throw("blink: argument must not be a text node");
  if (node.documentElement)      throw("blink: argument must not be the document object");

  function setOutline(o) { 
    return function() {
      if (node.style.outline != node.style.bogusProperty) {
        // browser supports outline (Firefox 1.1 and newer, CSS3, Opera 8).
        node.style.outline = o;
      }
      else if (node.style.MozOutline != node.style.bogusProperty) {
        // browser supports MozOutline (Firefox 1.0.x and older)
        node.style.MozOutline = o;
      }
      else {
        // browser only supports border (IE). border is a fallback because it moves things around.
        node.style.border = o;
      }
    }
  } 
  
  function focusIt(a) {
    return function() {
      a.focus(); 
    }
  }

  if (node.ownerDocument) {
    var windowToFocusNow = (node.ownerDocument.defaultView || node.ownerDocument.parentWindow); // Moz vs. IE
    if (windowToFocusNow)
      setTimeout(focusIt(windowToFocusNow.top), 0);
  }

  for(var i=1;i<7;++i)
    setTimeout(setOutline((i%2)?'3px solid red':'none'), i*100);

  setTimeout(focusIt(window), 800);
  setTimeout(focusIt(jsshell._in), 810);
},

scope : function scope(sc)
{
  if (!sc) sc = {};
  jsshell._scope = sc;
  jsshell.println("Scope is now " + sc + ".  If a variable is not found in this scope, window will also be searched.  New variables will still go on window.", "message");
},

mathHelp : function mathHelp()
{
  jsshell.printWithRunin("Math constants", "E, LN2, LN10, LOG2E, LOG10E, PI, SQRT1_2, SQRT2", "propList");
  jsshell.printWithRunin("Math methods", "abs, acos, asin, atan, atan2, ceil, cos, exp, floor, log, max, min, pow, random, round, sin, sqrt, tan", "propList");
},

ans : undefined
};


window.jsshell.hist = function(up)
{
  // histList[0] = first command entered, [1] = second, etc.
  // type something, press up --> thing typed is now in "limbo"
  // (last item in histList) and should be reachable by pressing 
  // down again.

  var L = jsshell.histList.length;

  if (L == 1)
    return;

  if (up)
  {
    if (jsshell.histPos == L-1)
    {
      // Save this entry in case the user hits the down key.
      jsshell.histList[jsshell.histPos] = jsshell._in.value;
    }

    if (jsshell.histPos > 0)
    {
      jsshell.histPos--;
      // Use a timeout to prevent up from moving cursor within new text
      // Set to nothing first for the same reason
      setTimeout(
        function() {
          jsshell._in.value = ''; 
          jsshell._in.value = jsshell.histList[jsshell.histPos];
          var caretPos = jsshell._in.value.length;
          if (jsshell._in.setSelectionRange) 
            jsshell._in.setSelectionRange(caretPos, caretPos);
        },
        0
      );
    }
  } 
  else // down
  {
    if (jsshell.histPos < L-1)
    {
      jsshell.histPos++;
      jsshell._in.value = jsshell.histList[jsshell.histPos];
    }
    else if (jsshell.histPos == L-1)
    {
      // Already on the current entry: clear but save
      if (jsshell._in.value)
      {
        jsshell.histList[jsshell.histPos] = jsshell._in.value;
        ++jsshell.histPos;
        jsshell._in.value = "";
      }
    }
  }
}

window.jsshell.tabcomplete = function()
{
  /*
   * Working backwards from s[from], find the spot
   * where this expression starts.  It will scan
   * until it hits a mismatched ( or a space,
   * but it skips over quoted strings.
   * If stopAtDot is true, stop at a '.'
   */
  function findbeginning(s, from, stopAtDot)
  {
    /*
     *  Complicated function.
     *
     *  Return true if s[i] == q BUT ONLY IF
     *  s[i-1] is not a backslash.
     */
    function equalButNotEscaped(s,i,q)
    {
      if(s.charAt(i) != q) // not equal go no further
        return false;

      if(i==0) // beginning of string
        return true;

      if(s.charAt(i-1) == '\\') // escaped?
        return false;

      return true;
    }

    var nparens = 0;
    var i;
    for(i=from; i>=0; i--)
    {
      if(s.charAt(i) == ' ')
        break;

      if(stopAtDot && s.charAt(i) == '.')
        break;
        
      if(s.charAt(i) == ')')
        nparens++;
      else if(s.charAt(i) == '(')
        nparens--;

      if(nparens < 0)
        break;

      // skip quoted strings
      if(s.charAt(i) == '\'' || s.charAt(i) == '\"')
      {
        //dump("skipping quoted chars: ");
        var quot = s.charAt(i);
        i--;
        while(i >= 0 && !equalButNotEscaped(s,i,quot)) {
          //dump(s.charAt(i));
          i--;
        }
        //dump("\n");
      }
    }
    return i;
  }

  // XXX should be used more consistently (instead of using selectionStart/selectionEnd throughout code)
  // XXX doesn't work in IE, even though it contains IE-specific code
  function getcaretpos(inp)
  {
    if(inp.selectionEnd != null)
      return inp.selectionEnd;
      
    if(inp.createTextRange)
    {
      var docrange = document.selection.createRange();
      var inprange = inp.createTextRange();
      if (inprange.setEndPoint)
      {
        inprange.setEndPoint('EndToStart', docrange);
        return inprange.text.length;
      }
    }

    return inp.value.length; // sucks, punt
  }

  function setselectionto(inp,pos)
  {
    if(inp.selectionStart) {
      inp.selectionStart = inp.selectionEnd = pos;
    }
    else if(inp.createTextRange) {
      var docrange = document.selection.createRange();
      var inprange = inp.createTextRange();
      inprange.move('character',pos);
      inprange.select();
    }
    else { // err...
    /*
      inp.select();
      if(document.getSelection())
        document.getSelection() = "";
        */
    }
  }
    // get position of cursor within the input box
    var caret = getcaretpos(jsshell._in);

    if(caret) {
      //dump("----\n");
      var dotpos, spacepos, complete, obj;
      //dump("caret pos: " + caret + "\n");
      // see if there's a dot before here
      dotpos = findbeginning(jsshell._in.value, caret-1, true);
      //dump("dot pos: " + dotpos + "\n");
      if(dotpos == -1 || jsshell._in.value.charAt(dotpos) != '.') {
        dotpos = caret;
//dump("changed dot pos: " + dotpos + "\n");
      }

      // look backwards for a non-variable-name character
      spacepos = findbeginning(jsshell._in.value, dotpos-1, false);
      //dump("space pos: " + spacepos + "\n");
      // get the object we're trying to complete on
      if(spacepos == dotpos || spacepos+1 == dotpos || dotpos == caret)
      {
        // try completing function args
        if(jsshell._in.value.charAt(dotpos) == '(' ||
 (jsshell._in.value.charAt(spacepos) == '(' && (spacepos+1) == dotpos))
        {
          var fn,fname;
  var from = (jsshell._in.value.charAt(dotpos) == '(') ? dotpos : spacepos;
          spacepos = findbeginning(jsshell._in.value, from-1, false);

          fname = jsshell._in.value.substr(spacepos+1,from-(spacepos+1));
  //dump("fname: " + fname + "\n");
          try {
            with(window)
              with(jsshell._scope)
                with(jsshell.shellCommands)
                  fn = eval(fname);
          }
          catch(er) {
            //dump('fn is not a valid object\n');
            return;
          }
          if(fn == undefined) {
             //dump('fn is undefined');
             return;
          }
          if(fn instanceof Function)
          {
            // Print function definition, including argument names, but not function body
            if(!fn.toString().match(/function .+?\(\) +\{\n +\[native code\]\n\}/))
              jsshell.println(fn.toString().match(/function .+?\(.*?\)/), "tabcomplete");
          }

          return;
        }
        else
          obj = window;
      }
      else
      {
        var objname = jsshell._in.value.substr(spacepos+1,dotpos-(spacepos+1));
        //dump("objname: |" + objname + "|\n");
        try {
          with(jsshell._scope)
            with(window)
                obj = eval(objname);
        }
        catch(er) {
          jsshell.printError(er); 
          return;
        }
        if(obj == undefined) {
          // sometimes this is tabcomplete's fault, so don't print it :(
          // e.g. completing from "print(document.getElements"
          // jsshell.println("Can't complete from null or undefined expression " + objname, "error");
          return;
        }
      }
      //dump("obj: " + obj + "\n");
      // get the thing we're trying to complete
      if(dotpos == caret)
      {
        if(spacepos+1 == dotpos || spacepos == dotpos)
        {
          // nothing to complete
          //dump("nothing to complete\n");
          return;
        }

        complete = jsshell._in.value.substr(spacepos+1,dotpos-(spacepos+1));
      }
      else {
        complete = jsshell._in.value.substr(dotpos+1,caret-(dotpos+1));
      }
      //dump("complete: " + complete + "\n");
      // ok, now look at all the props/methods of this obj
      // and find ones starting with 'complete'
      var matches = [];
      var bestmatch = null;
      for(var a in obj)
      {
        //a = a.toString();
        //XXX: making it lowercase could help some cases,
        // but screws up my general logic.
        if(a.substr(0,complete.length) == complete) {
          matches.push(a);
          ////dump("match: " + a + "\n");
          // if no best match, this is the best match
          if(bestmatch == null)
          {
            bestmatch = a;
          }
          else {
            // the best match is the longest common string
            function min(a,b){ return ((a<b)?a:b); }
            var i;
            for(i=0; i< min(bestmatch.length, a.length); i++)
            {
              if(bestmatch.charAt(i) != a.charAt(i))
                break;
            }
            bestmatch = bestmatch.substr(0,i);
            ////dump("bestmatch len: " + i + "\n");
          }
          ////dump("bestmatch: " + bestmatch + "\n");
        }
      }
      bestmatch = (bestmatch || "");
      ////dump("matches: " + matches + "\n");
      var objAndComplete = (objname || obj) + "." + bestmatch;
      //dump("matches.length: " + matches.length + ", jsshell.tooManyMatches: " + jsshell.tooManyMatches + ", objAndComplete: " + objAndComplete + "\n");
      if(matches.length > 1 && (jsshell.tooManyMatches == objAndComplete || matches.length <= 10)) {

        jsshell.printWithRunin("Matches: ", matches.join(', '), "tabcomplete");
        jsshell.tooManyMatches = null;
      }
      else if(matches.length > 10)
      {
        jsshell.println(matches.length + " matches.  Press tab again to see them all", "tabcomplete");
        jsshell.tooManyMatches = objAndComplete;
      }
      else {
        jsshell.tooManyMatches = null;
      }
      if(bestmatch != "")
      {
        var sstart;
        if(dotpos == caret) {
          sstart = spacepos+1;
        }
        else {
          sstart = dotpos+1;
        }
        jsshell._in.value = jsshell._in.value.substr(0, sstart)
                  + bestmatch
                  + jsshell._in.value.substr(caret);
        setselectionto(jsshell._in,caret + (bestmatch.length - complete.length));
      }
    }
}

window.jsshell.printQuestion = function(q)
{
  jsshell.println(q, "input");
}

window.jsshell.printAnswer = function(a)
{
  if (a !== undefined) {
    jsshell.println(a, "normalOutput");
    jsshell.shellCommands.ans = a;
  }
}

window.jsshell.printError = function(er)
{ 
  var lineNumberString;

  lastError = er; // for debugging the shell
  if (er.name)
  {
    // lineNumberString should not be "", to avoid a very wacky bug in IE 6.
    lineNumberString = (er.lineNumber != undefined) ? (" on line " + er.lineNumber + ": ") : ": ";
    jsshell.println(er.name + lineNumberString + er.message, "error"); // Because IE doesn't have error.toString.
  }
  else
    jsshell.println(er, "error"); // Because security errors in Moz /only/ have toString.
}

window.jsshell.go = function(s)
{
  jsshell._in.value = jsshell.question = s ? s : jsshell._in.value;

  if (jsshell.question == "")
    return;

  jsshell.histList[jsshell.histList.length-1] = jsshell.question;
  jsshell.histList[jsshell.histList.length] = "";
  jsshell.histPos = jsshell.histList.length - 1;
  
  // Unfortunately, this has to happen *before* the JavaScript is run, so that 
  // print() output will go in the right place.
  jsshell._in.value='';
  jsshell.recalculateInputHeight();
  jsshell.printQuestion(jsshell.question);

  if (window.closed) {
    jsshell.printError("Target window has been closed.");
    return;
  }
  
  try { ("jsshell" in window) }
  catch(er) {
    jsshell.printError("The JavaScript Shell cannot access variables in the target window.  The most likely reason is that the target window now has a different page loaded and that page has a different hostname than the original page.");
    return;
  }

  if (!("jsshell" in window))
    initTarget(); // silent

  // Evaluate Shell.question using _win's eval (this is why eval isn't in the |with|, IIRC).
//  window.location.href = "javascript:try{ jsshell.printAnswer(eval('with(jsshell._scope) with(jsshell.shellCommands) {' + jsshell.question + String.fromCharCode(10) + '}')); } catch(er) { jsshell.printError(er); }; setTimeout(jsshell.refocus, 0); void 0";
  try { 
      jsshell.printAnswer(eval(
          'with(jsshell._scope) with(jsshell.shellCommands) {' 
              + jsshell.question + String.fromCharCode(10) + 
          '}')); 
  } catch(er) { 
      jsshell.printError(er); 
  }; 
  setTimeout(jsshell.refocus, 0);
}

window.jsshell.histList = [""]; 
window.jsshell.histPos = 0; 
window.jsshell._scope = {}; 
window.jsshell.question;
window.jsshell._in;
window.jsshell._out;
window.jsshell.tooManyMatches = null;
window.jsshell.lastError = null;

jsshell._in = document.getElementById("input");
jsshell._out = document.getElementById("output");

jsshell.initTarget();

jsshell.recalculateInputHeight();
jsshell.refocus();

</script></pre>
</div>
